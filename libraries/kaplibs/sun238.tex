\documentstyle[11pt]{article}
\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun\stardocnumber}
\newcommand{\stardocnumber}    {238.6}
\newcommand{\stardocauthors}   {D.S. Berry \\Malcolm J. Currie}
\newcommand{\stardocdate}      {9th March 2009}
\newcommand{\stardoctitle}     {KAPLIBS -- Internal subroutines used within
                                the KAPPA package.}
\newcommand{\stardocversion}   {Version 3.0}
\newcommand{\stardocmanual}    {Programmer's Reference}
\newcommand{\stardocabstract}  {KAPLIBS is a package of Fortran subroutine
libraries which were originally written as part of the KAPPA package (a
package of general-purpose image-processing and visualization tools).
KAPLIBS provides software developers with access to many of the internal
KAPPA routines, so that KAPPA-like applications can be written and built
independently of KAPPA.}

% ? End of document identification

% -----------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by
%  star2html to signify raw TeX that latex2html cannot process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newenvironment{latexonly}{}{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\html}[1]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{{\bf LaTeX}{2}{\tt{HTML}}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\newcommand{\latex}[1]{#1}
\newcommand{\setunderscore}{\renewcommand{\_}{{\tt\symbol{95}}}}
\latex{\setunderscore}

%  Redefine the \tableofcontents command. This procrastination is necessary
%  to stop the automatic creation of a second table of contents page
%  by latex2html.
\newcommand{\latexonlytoc}[0]{\tableofcontents}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
\newcommand{\latexonlysection}[1]{\section{#1}}
\newcommand{\latexonlysubsection}[1]{\subsection{#1}}
\newcommand{\latexonlysubsubsection}[1]{\subsubsection{#1}}
\begin{htmlonly}
   \newcommand{\latexonlysection}[1]{#1}
   \newcommand{\latexonlysubsection}[1]{#1}
   \newcommand{\latexonlysubsubsection}[1]{#1}
\end{htmlonly}
\newcommand{\st}[1]{{\em{#1}}}
\newcommand{\hi}[1]{{\tt{#1}}}
\newcommand{\latexelsehtml}[2]{#1}
\begin{htmlonly}
  \newcommand{\latexelsehtml}[2]{#2}
\end{htmlonly}

% Command for displaying routines in routine lists:
% =================================================

\newcommand{\noteroutine}[2]{{\small{\bf{#1}}}\nopagebreak\\
                             \hspace*{3em}\st{#2}\\[1.5ex]}
\begin{htmlonly}
   \newcommand{\noteroutine}[2]{{\small{\bf{#1}}}\\
                                  --- \st{#2}\\[1.0ex]}
\end{htmlonly}

%+
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2html. The contents of this file should be included in the
%     source prior to any statements that make of the sst commnds.

%  Notes:
%     The commands defined in the style file html.sty provided with LaTeX2html
%     are used. These should either be made available by using the appropriate
%     sun.tex (with hypertext extensions) or by putting the file html.sty
%     on your TEXINPUTS path (and including the name as part of the
%     documentstyle declaration).

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)
%     MJC: Malcolm J. Currie (STARLINK)
%     DSB: David Berry (STARLINK)
%     TIMJ: Tim Jenness (JAC)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     1995 October 4 (MJC):
%        Added goodbreaks and pagebreak[3] in various places to improve
%        pages breaking before headings, not immediately after.
%        Corrected banner width.
%     1996 March 7 (MJC):
%        Mark document name on both sides of an sstroutine.
%     2-DEC-1998 (DSB):
%        Added sstattributetype (copied from sun210.tex).
%     2004 August 6 (MJC):
%        Added sstattribute.
%     21-JUL-2009 (TIMJ):
%        Added \sstdiylist{}{} as used when a Parameters section is located that
%        is not "ADAM Parameters".
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\latex{\newfont{\ssttt}{cmtt10 scaled 1095}}
\html{\newcommand{\ssttt}{\tt}}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \markboth{{\stardocname}~ --- #1}{{\stardocname}~ --- #1}
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

% Frame attributes fount.  Need to find a way for these to stand out.
% San serif doesn't work by default.  Also without the \rm the
% san serif continues after \sstatt hyperlinks.  Extra braces
% failed to prevent \sstattribute from using roman fount for its
% headings.  The current lash up appears to work, but needs further
% investigation or a TeX wizard.
\newcommand{\sstatt}[1]{\sf #1}
\begin{htmlonly}
  \newcommand{\sstatt}[1]{\large{\tt #1}}
\end{htmlonly}

%  Define a command to produce an attribute header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstattribute}[3]{
   \goodbreak
   \markboth{{\stardocname}~ --- #1}{{\stardocname}~ --- #1}
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\sstatt #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.9pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\sstatt #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\sstatt #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\goodbreak \item[Usage:] \mbox{}
\\[1.3ex]{\raggedright \ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the attribute data type section.
\newcommand{\sstattributetype}[1]{
   \item[Type:] \mbox{} \\
      #1
}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \goodbreak
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the applicability section.
\newcommand{\sstapplicability}[1]{
   \item[Class Applicability:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \goodbreak
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy
\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \vspace{1.0ex}
\\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\goodbreak \item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}]
\mbox{} \\[1.3ex] #2}

%  Format the a generic section as a list
\newcommand{\sstdiylist}[2]{
   \item[#1:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #2
   \end{description}
}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  sstroutine.
   \newcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  sstattribute. Note the further level of subsectioning.
   \newcommand{\sstattribute}[3]{
      \subsubsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
      \\
   }

%  sstdescription
   \newcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstusage
   \newcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstinvocation
   \newcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstarguments
   \newcommand{\sstarguments}[1]{
      \item[Arguments:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstreturnedvalue
   \newcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstparameters
   \newcommand{\sstparameters}[1]{
      \item[Parameters:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstapplicability
   \newcommand{\sstapplicability}[1]{%
      \item[Class Applicability:]
       \begin{description}
         #1
      \end{description}
      \\
   }

%  sstexamples
   \newcommand{\sstexamples}[1]{
      \item[Examples:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstsubsection
   \newcommand{\sstsubsection}[1]{\item[{#1}]}

%  sstexamplesubsection
   \newcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] #2\\}

%  sstnotes
   \newcommand{\sstnotes}[1]{\item[Notes:] #1 }

%  sstdiytopic
   \newcommand{\sstdiytopic}[2]{\item[{#1}] #2 }

%  sstimplementationstatus
   \newcommand{\sstimplementationstatus}[1]{
      \item[Implementation Status:] #1
   }

%  sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
      \\
   }
%  sstitem
   \newcommand{\sstitem}{\item}

\end{htmlonly}

%  End of sst.tex layout definitions.
%.


% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / {\sc Rutherford Appleton Laboratory} \hfill {\bf \stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\bf  \stardoctitle \\ [2.5ex]}
   {\LARGE\bf \stardocversion \\ [4ex]}
   {\Huge\bf  \stardocmanual}
   \end{center}
   \vspace{5mm}

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\bf Abstract}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> \end{rawhtml}

% ? Add picture here if required.
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC}{http://www.cclrc.ac.uk} /
      \htmladdnormallink{Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk/ral} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents.
%  ================================
%  Add table of contents header and a navigation button to return to this
%  point in the document (this should always go before the abstract \section).
  \label{stardoccontents}
  \begin{rawhtml}
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \renewcommand{\latexonlytoc}[0]{}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
 \newpage
 \begin{latexonly}
   \setlength{\parskip}{0mm}
   \latexonlytoc
   \setlength{\parskip}{\medskipamount}
   \markright{\stardocname}
 \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\section {Introduction}

KAPPA is package of general-purpose astronomical image-processing and
visualization commands. It is documented in \xref{SUN/95}{sun95}{}. Over
the long history of the KAPPA package, many internal Fortran subroutines
have been written to provide facilities within KAPPA which have
subsequently proved to be of more-general use outside KAPPA. In order to
gain the benefit of these internal KAPPA facilities, software developers
have in the past taken copies of the relevant routines and included them
in their own projects. The disadvantages of this are obvious---it is easy
to end up with many, potentially different, copies of the same routines
within a large software suite such as the Starlink Software Collection,
and bug fixes need to be implemented in many different places, rather
than a in single master copy.

Another way of using the internal KAPPA routines is to link your
applications directly against the libraries in the KAPPA package, but
this requires the KAPPA package to be installed anywhere where your
software is to be built, which is not always convenient.

To get round these problems, the KAPLIBS package was created to
contain the internal routines from KAPPA which are deemed to be
``generally useful''. Now, you only need to have KAPLIBS installed to
build your software, not the much larger KAPPA.

There are a large number of routines in KAPLIBS, making it potentially
difficult to find the routines you want. To ease this problem, a search
tool is provided which allows the contents of this document to be
searched (see \hyperref{here}{Section~}{}{SEC:SEARCH}).

\subsection{Stability of the KAPLIBS Interface}
KAPLIBS was created as a pragmatic solution to the problem of
proliferation of KAPPA source code in several other packages. One of the
reasons for previously keeping these routines hidden away within KAPPA was
so that changes could be made to the argument lists or functionality
of these routines without breaking software within other packages. In
practice, it has hardly ever been necessary to change the interface to
routines after an initial development period, but the possibility still
exists that this may be necessary. For this reason, users of KAPLIBS
should be aware that \emph{it may occasionally be necessary to change the
interface to KAPLIBS routines}. Such changes will be listed within
this document at each release. To aid developers decisions over which
routines to use, routines which are deemed to have a significant chance
of being changed within the foreseeable future are highlighted later in
this document. This class of routine will normally just include routines
which have only recently been written.

\subsection{The Scope of this Document}
The purpose of this document is to give reference information about the
argument lists and functionality of the internal KAPPA routines which are
contained within KAPLIBS. It does not give a detailed explanation of how
these routines should be used within a real application. Developers
should usually study examples of existing code within KAPPA for this
purpose. The source code for KAPPA is available from the Starlink
Software Librarian, {\tt ussc@star.rl.ac.uk}.

Applications within KAPPA are split up into several groups (called
``monoliths'), with names such as {\tt kapview}, {\tt ndfpack} and
(rather confusingly but at one time the only KAPPA monolith)
{\tt kappa}. The top-level routines for the
applications in monolith {\tt xyz} are in the tar file {\tt
\$KAPPA\_DIR/xyz\_sub.tar}. Each application may use some
application-specific subroutines (\emph{i.e.} subroutines which are so
closely related to the purpose of a single application that they are not
deemed as ``generally useful''). These will be denoted by subroutines
names with prefix ``{\tt KPS1\_}'' and will be contained within the tar
file {\tt \$KAPPA\_DIR/kapsub\_sub.tar}.

\section{Naming Conventions}
Each subroutine within KAPLIBS has a name of the form {\tt <prefix>\_<name>}
where {\tt <prefix>} is a prefix indicating which KAPPA library the
routine belongs to, and {\tt <name>} is a unique name for the routine.
The prefix associated with each KAPPA library indicates something of the
purpose of that library. The following prefixes are currently included
within KAPLIBS:

\begin{description}

\item [AIF\_] These are old routines which were used to access parameter
values or temporary work space. They are gradually being replaced within
KAPPA by more modern routines provided by the PAR and PSX libraries.

\item [FTS1\_] These are routines used to access FITS files and headers -
KAPPA's own {\tt fitsio}.

\item [IRA\_] These routines were initially part of the IRAS90 Astrometry
library (hence the IRA acronym). They are used to gain access to WCS
information stored within NDFs in the form of IRAS90 Astrometry extension.
This form of WCS is now deprecated in favour of the NDF WCS component,
accessed through the \xref{AST}{sun210}{} library.

\item [KPG1\_] These are other general-purpose routines which do not fall
into such obvious groups.  Even within this library, though, there are
loose associations of routines, usually indicated by some common element
within the routine name. The following are some of the more significant
associations:

\begin{itemize}
\item Routines associated with use of the PGPLOT graphics package usually
have names which start ``{\tt KPG1\_PG}''.
\item Routines associated with use of the AGI graphics database usually
have names which start ``{\tt KPG1\_GD}''.
\item Routines associated with accessing or using WCS information usually
have names which start ``{\tt KPG1\_AS}''.
\end{itemize}

\end{description}

Within all these groups, some routines have different versions for
processing data with different numerical types. The names of such
routines are identical except for the trailing one or two characters
which indicate the data type processed. These one- or two-character
codes are:

\begin{description}
\item [d] - Double-precision floating point
\item [r] - Single-precision floating point
\item [c] - Character
\item [i] - Single-precision integer
\item [w] - Word (usually two-byte integers)
\item [uw] - Unsigned word (usually two-byte unsigned integers)
\item [bw] - Byte (usually one-byte integers)
\item [ub] - Unsigned byte (usually one-byte unsigned integers)
\item [l] - Logical
\end{description}

Sometimes, routine names are documented as ending with a lower-case
``x''. This indicates that routines exist for various of the above
numerical types. The \emph{actual} routines names will not include the trailing
``x'', but will have one of the above codes in place of the ``x''.

\section{Compiling and Linking}
To compile and link an application with the KAPLIBS package, the following
commands should be used (see \xref{SUN/144}{sun144}{}):

\small
\begin{verbatim}
      % alink adamprog.f `kaplibs_link_adam`
\end{verbatim}
\normalsize

Note the use of {\em opening} apostrophes (`) rather than the more common
closing apostrophe (')\footnote{Currently, the parameter handling
routines within KAPLIBS have not been separated out, and so it is not
currently possible to link stand-alone (\emph{i.e.} ``non-Adam'')
applications against KAPLIBS.}.

This produces an executable image called {\bf prog}. The
\verb+kaplibs_dev+ command creates soft links within the current
directory to the various include files provided by KAPLIBS. These are
removed by the \verb+kaplibs_dev remove+ command.

\subsection{Linking with Native PGPLOT}
The commands described above will link the application with the Starlink
GKS version of the \xref{PGPLOT graphics library}{sun15}{}. If you wish
to link with the {\em native} version of PGPLOT, then include the switch
``-nogks'' as follows:

\small
\begin{verbatim}
      % alink adamprog.f `kaplibs_link_adam -nogks`
\end{verbatim}
\normalsize

This will include native PGPLOT in the link list, and cause all GKS and IDI
related items to be removed.

\newpage
\appendix

\section{Changes in Version 3.1}
\begin{itemize}
\item Remove FTS1\_TREAD since the MAG library has now been removed
      from the main Starlink source tree.
\item New C function kpg1Config gets a KeyMap containing configuration
      parameters from the user, with name checking and default values
      supplied.
\item KPG\_OSTAx added.  It uses recurrence formulae to calculate
      simple statistics robustly.  It also extends KPG1\_STATx by
      deriving the skewness and kurtosis.
\item The MODE argument of KPG1\_PLTLN has an additional option of
      {\tt "Gapped"} that is the same as {\tt "Histogram"} except
      bad values are not flanked by vertical lines, leaving a gap.
\item KPG1\_STDSx and KPG1\_STFLx can respectively report or log the
      skewness and kurtosis via two additional arguments.  Users of
      these routines will need to modify calling routines accordingly;
      without skewness or kurtosis values to document supply
      VAL\_\_BADD for each undefined statistic.
\end{itemize}

\section{Changes in Version 3.0}
\begin{itemize}
\item \xref{CTG}{sun262}{}, \xref{IRQ}{sun261}{}, and \xref{LPG}{sun263}{}
      libraries are no longer in KAPLIBS.  They are autonomous
      libraries each with its own documentation and link scripts.
\item KPG1\_MVBDx added. It modifies an array index (such as produced by
      \xref{PDA\_QSIAx}{sun194}{PDA_QSIAx}) to exclude indices that refer
      to bad data values.
\item KPG\_STOSx added.  It calculates accurate order statistics by
      sorting an array by means of an index, returning the median and
      optionally percentiles.
\end{itemize}

\section{Changes in Version 2.8}
\begin{itemize}

\item KPG1\_BADBX added. It returns an NDF identifier for the smallest section
      of a supplied NDF that encloses all the good data values in the NDF.
\item KPG1\_BBOX$<$T$>$ added. It obtains the pixel bounding box of a given
     value within an $N$-dimensional data array.
\item KPG1\_LIKE added. It obtains a section of an NDF that matches either
      the pixel or WCS shape of a given template NDF.
\item KPG1\_KYMAP can read vectors as well as scalars from a GRP
      group into an AST keyMap.
\item {\tt kaplibs\_link} script now works without attempting to load ADAM
      symbols.
\item Can now be built as a shared library.
\item Added KPG1\_ASTCMN to provide access to KPG\_AST private common block
\item The \xref{HLP}{sun124}{} helper routines are no longer part of kaplibs.
      Use the SHL library instead.
\item KPG1\_SCRSZ is no longer present. Please use
      \xref{ONE\_SCRSZ}{sun234}{ONE\_SCRSZ} instead.
\item Now released under the GPL.
\item kpgGtfts and kpgPtfts can now be used to read and write
      AST FitsChan objects from/to an NDF.
\item KAPLIBS no longer links against Tk (the one Tk routine has been
      removed from KAPLIBS).
\item KAPLIBS now has a public C interface (but not for all routines).
\item Added KPG1\_CGET, which returns the value of an NDF character
      component removing any AST or PGPLOT escape sequences.
\item Added KPG1\_MXMNX, which provides a single interface to the
      existing generic KPG1\_MXMNx routines.
\item Added KPG1\_SCALX, which provides a single interface to the
      new doubly generic KPG1\_SCLxx routines, for scaling
      and shifting data values.
\end{itemize}

\section{Changes in Version 2.7}
\begin{itemize}
\item A new routine LPG\_REPLA has been added. It controls a new option
      which allows a single NDF to be used as both input and output for an
      ADAM task.  The default is for this option to be disabled.
\end{itemize}

\section{Changes in Version 2.6}
\begin{itemize}
\item The GRF module (grf\_kaplibs.c) has been upgraded to include the
      extra functions needed by AST V3.2.
\end{itemize}

\section{Changes in Version 2.5}
\begin{itemize}
\item The KPG1\_FFT... routines have been made significantly faster (at
      the expense of using slightly more memory). For instance, a speed gain
      of a factor 10 is typical for an array of 150000 points.
\end{itemize}

\section{Changes in Version 2.4}
\begin{itemize}
\item The KPG1\_WRLST routine now normalises the supplied positions (using
      \xref{AST\_NORM}{sun210}{AST_NORM}) before writing them to the output
      catalogue.
\end{itemize}

\section{Changes in Version 2.3}
\begin{itemize}
\item The routine GETHLP has been moved from KAPPA to the KAPLIBS:KAPGEN library.
\end{itemize}

\section{Changes in Version 2.2}
\begin{itemize}
\item Script \verb+kaplibs_link+ has been added to enable linking of standalone
      applications.
\item The routine KPG1\_DSFRM has been modified to include details of AST
      SpecFrames. \emph{The argument list has also been changed.}
\item The routine KPG1\_ASMRG has been modified to attempt alignment in
      Domain SPECTRAL.
\end{itemize}

\section{Changes in Version 2.1}
\begin{itemize}
\item The KPG1\_CPSTY routine has been added to copy AST Plotting styles
      from one graphical element to another.
\end{itemize}

\section{Changes in Version 2.0}
\begin{itemize}
\item The ``-nogks'' switch has been added to the
      \verb#kaplibs_link_adam# command, allowing applications to be linked with
      native PGPLOT instead of the Starlink GKS-based PGPLOT.
\item The routine KPG1\_WRLST now allows the user to choose the
      co-ordinate system in which the positions are stored in the catalogue
      columns. This is done using two ADAM parameters called COLFRAME and
      COLEPOCH (these names are hard-wired into the routine to encourage
      conformity). Consequently, applications which use this routine should add
      definitions for these two parameters to their IFL files.
\item The routine KPG1\_RDLST can now read positions from catalogues which
      do not contain a WCS FrameSet, in certain special cases. That is, if the
      catalogue contains columsn called RA and DEC, or X and Y.
\item The IRAS90 IRQ library has been included. IRQ is used to manage
      textual representations of NDF Quality bits.
\end{itemize}

\begin{latexonly}
  \newpage
  \latexonlysection{Alphabetical List of Routines}
  \small






  \normalsize
\end{latexonly}

\newpage
\section{\xlabel{ro_full}Routine Descriptions\label{ro:full}}

\small

\sstroutine{
   AIF\_ANTMP
}{
   Annul a locator to a temporary object, thereby erasing the object
}{
   \sstdescription{
      The routine annuls a locator to a temporary object created by
      AIF\_TEMP, thereby causing the associated object to be erased and
      the file space associated with it to be released. If data are
      mapped to the object via HDS, then they are first unmapped.
   }
   \sstinvocation{
      CALL AIF\_ANTMP( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         HDS locator to the temporary object to be annulled. The
         character variable supplied is reset to a blank string by this
         routine.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set on
         entry. However, no additional error report is made if it
         subsequently fails under these circumstances.
      }
   }
}
\sstroutine{
   AIF\_ASFIO
}{
   Opens a sequential file via a parameter
}{
   \sstdescription{
      This routine opens a sequential file via FIO\_ASSOC.  Up to four
      attempts may be made to open the file.  If a null response is
      supplied the file is not opened, and the flag returned indicates
      this fact.
   }
   \sstinvocation{
      CALL AIF\_ASFIO( PNFILE, ACMODE, FORM, RECSZ, FD, OPEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNFILE = CHARACTER$*$($*$)
      }{
         Parameter name by which file is to be opened
      }
      \sstsubsection{
         ACMODE = CHARACTER$*$($*$)
      }{
         Expression giving the required access mode.
           Valid modes are: {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '}, {\tt '}UPDATE{\tt '} and {\tt '}APPEND{\tt '}.
           For details, see FIO\_OPEN.
      }
      \sstsubsection{
         FORM = CHARACTER$*$($*$)( READ )
      }{
         Expression giving the required formatting of the file.
           Valid formats are: {\tt '}FORTRAN{\tt '}, {\tt '}LIST{\tt '}, {\tt '}NONE{\tt '} and
           {\tt '}UNFORMATTED{\tt '}. For details, see FIO\_OPEN.
      }
      \sstsubsection{
         RECSZ = INTEGER( READ )
      }{
         Expression giving the maximum record size in bytes.
           Set it to zero if the Fortran default is required.
      }
      \sstsubsection{
         FD = INTEGER( WRITE )
      }{
         Variable to contain the file descriptor.
      }
      \sstsubsection{
         OPEN = LOGICAL( WRITE )
      }{
         If true the file has been opened.
      }
      \sstsubsection{
         STATUS = INTEGER( READ, WRITE )
      }{
         Global status value
      }
   }
   \sstdiytopic{
      Method
   }{
      Check for error on entry - return if not o.k.
      Initialise looping flag
      Do while no error obtaining the name and opening the output file
        and maximum number of attempts not exceeded
         Get file name and open file
         If null returned then
            Set flag so that a log file will not be created
            Annul the error
            Exit from the loop
         Else if error occurred then
            If abort requested, do so
            Increment loop counter
            If maximum number of attempts not exceeded then
               Report error
            Else
               Set looping flag to exit
            Endif
              Cancel parameter used to get filename
         Else
            Set flag to indicate that the file has been opened
            Set looping flag to false
         Endif
      Enddo
      If error then
         Report and abort
      Endif
      Return
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   AIF\_FLNAM
}{
   Returns the name of a file as a character string given its
   parameter name
}{
   \sstdescription{
      Normally, the handles to HDS data files are locators and files
      are obtained via the parameter system.  The name of a data
      file itself is not available to applications via the user-level
      parameter-system library, and so applications cannot place the
      file name in log files or use the it to generate compound names.
      This routine provides that functionality by calling internal
      parameter-system routines to obtain the name.  This routine also
      works for Fortran files associated via an ADAM parameter.
   }
   \sstinvocation{
      CALL AIF\_FLNAM( PARNAM, FILNAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name associated with the data object whose name is
         required.
      }
      \sstsubsection{
         FILNAM = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the file.  If \%FILNAM is not long enough a bad
         status is returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This cannot be used to obtain the names of objects within
            an HDS file.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         Must have obtained the file via the input parameter.
      }
   }
}
\sstroutine{
   AIF\_GETVM
}{
   Obtains a pointer and a locator to mapped HDS workspace
}{
   \sstdescription{
      This routine obtains and file maps a temporary array of a given
      data type and dimensions via HDS.  A pointer to the mapped work
      array is returned, as is a locator so that the temporary array
      may be annulled when no longer required.
   }
   \sstinvocation{
      CALL AIF\_GETVM( TYPE, NDIM, DIMS, PNTR, WKLOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The HDS data type of the temporary array.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions of the work array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the temporary array.
      }
      \sstsubsection{
         PNTR = INTEGER (Returned)
      }{
         The pointer to the mapped temporary array.
      }
      \sstsubsection{
         WKLOC = CHARACTER $*$ ( DAT\_\_SZLOC )(Returned)
      }{
         The HDS locator to the temporary array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The current HDS tuning parameter MAP is stored, so that the
      temporary array may be accessed via file mapping, and upon exit
      restored to its former value.
   }
}
\sstroutine{
   AIF\_OPFIO
}{
   Opens a Fortran sequential file by name
}{
   \sstdescription{
      This routine opens a sequential file via FIO\_OPEN.  Up to four
      attempts may be made to open the file.  If a null response is
      supplied the file is not opened, and the flag returned indicates
      this fact.
   }
   \sstinvocation{
      CALL AIF\_OPFIO( FILNAM, ACMODE, FORM, RECSZ, FD, OPEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILNAM = CHARACTER$*$($*$)
      }{
         The name of the file to be opened.
      }
      \sstsubsection{
         ACMODE = CHARACTER$*$($*$)
      }{
         Expression giving the required access mode.
           Valid modes are: {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '}, {\tt '}UPDATE{\tt '} and {\tt '}APPEND{\tt '}.
           For details, see FIO\_OPEN.
      }
      \sstsubsection{
         FORM = CHARACTER$*$($*$)( READ )
      }{
         Expression giving the required formatting of the file.
           Valid formats are: {\tt '}FORTRAN{\tt '}, {\tt '}LIST{\tt '}, {\tt '}NONE{\tt '} and
           {\tt '}UNFORMATTED{\tt '}. For details, see FIO\_OPEN.
      }
      \sstsubsection{
         RECSZ = INTEGER( READ )
      }{
         Expression giving the maximum record size in bytes.
           Set it to zero if the Fortran default is required.
      }
      \sstsubsection{
         FD = INTEGER( WRITE )
      }{
         Variable to contain the file descriptor.
      }
      \sstsubsection{
         OPEN = LOGICAL( WRITE )
      }{
         If true the file has been opened.
      }
      \sstsubsection{
         STATUS = INTEGER( READ, WRITE )
      }{
         Global status value
      }
   }
   \sstdiytopic{
      Method
   }{
      Check for error on entry - return if not o.k.
      Initialise looping flag
      Do while no error obtaining the name and opening the output file
        and maximum number of attempts not exceeded
         Get file name and open file
         If error occurred then
            If abort requested, do so
            Increment loop counter
            If maximum number of attempts not exceeded then
               Report error
            Else
               Set looping flag to exit
            Endif
         Else
            Set flag to indicate that the file has been opened
            Set looping flag to false
         Endif
      Enddo
      If error then
         Report and abort
      Endif
      Return
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   AIF\_PTFNM
}{
   Writes the name of an HDS file to a parameter
}{
   \sstdescription{
      Normally, the handles to HDS data files are locators and files
      are obtained via the parameter system.  However, some
      applications can generate sensible names, especially when dealing
      a long series of files that are to be created without manual
      intervention.  There is no direct mechanism in the user-level
      parameter-system library to put a name into the associated
      parameter.  This routine provides that functionality.
   }
   \sstinvocation{
      CALL AIF\_PTFNM( PARNAM, FILNAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name associated with the data object whose name is
         to be written.
      }
      \sstsubsection{
         FILNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This cannot be used to obtain the names of objects within
            an HDS file.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         Must have obtained the file via the input parameter.
      }
   }
}
\sstroutine{
   AIF\_TEMP
}{
   Create a temporary HDS object
}{
   \sstdescription{
      The routine creates a temporary HDS object with the specified
      type and shape. On the first invocation a temporary structure is
      created to contain such objects. Subsequently, temporary objects
      are created within this enclosing structure.
   }
   \sstinvocation{
      CALL AIF\_TEMP( TYPE, NDIM, DIM, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         HDS type of object to be created.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of object dimensions.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Locator to temporary object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A blank string will be returned for the LOC argument if this
         routine is called with STATUS set, although no further processing
         will occur. The same value will also be returned if the routine
         should fail for any reason.

         \sstitem
         This routine is a work-around to avoid the problems associated
         with calling DAT\_TEMP if the objects created must subsequently be
         erased.
      }
   }
}
\sstroutine{
   CCG\_ORVAR
}{
   Returns the variances and covariances of the order statistics
   from n to 1, assuming an initially normal distribution
}{
   \sstdescription{
      The routine returns the variances and covariances of the order
      statistics, assuming an initial (pre-ordered) normal distribution
      of mean 0 and standard deviation 1. The routine returns all
      variance/covariances in an array with the terms vectorised - that
      is following on after each row. This uses the symmetric nature of
      the matrix to compress the data storage, but remember to double
      the covariance components if summing in quadrature. The variances
      \sstitemlist{

         \sstitem
         covariances are returned for all statistics from n to 1. The
         special case of n = 1 returns the variance of 2/pi (median).
      }
   }
   \sstinvocation{
      CALL CCG\_ORVAR( EL, NBIG, PP, VEC, MATRIX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of members in ordered set.
      }
      \sstsubsection{
         NBIG = INTEGER (Given)
      }{
         Maximum number of entries in covariance array row.
         equal to EL$*$(EL$+$1)/2).
      }
      \sstsubsection{
         PP( EL ) = DOUBLE PRECISION (Given)
      }{
         Workspace for storing expected values of order statistics.
      }
      \sstsubsection{
         VEC( NBIG, EL ) = DOUBLE PRECISION (Returned)
      }{
         The upper triangles of the nset by nset variance-covariance
         matrix packed by columns.  Each triangle is packed into a
         single row.  For each row element Vij is stored in
         VEC(i$+$j$*$(j-1)/2), for 1 $<$= i $<$= j $<$= nset.
      }
      \sstsubsection{
         MATRIX( EL, EL ) = DOUBLE PRECISION (Returned)
      }{
         Work space.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Data are returned as above to save on repeated calls (which are
         too slow).  To obtain the actual variance of the data of order n
         you need to sum all the variances and twice the covariances and
         use these to modify the actual variance of the (unordered) data.
      }
   }
}
\sstroutine{
   CCG1\_AD1x
}{
   Combines data lines using absolute deviations from an unweighted
   mean
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data. The data values in the lines are then
      combined to form an unweighted mean, and then the absolute mean
      deviation from the mean.  The output means are returned in the
      array RESULT.  The output variances are standard-error values and
      are returned in RESVAR.
   }
   \sstinvocation{
      CALL CCG1\_AD1x( NPIX, NLINES, STACK, MINPIX,
                      RESULT, RESVAR, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output RESULT array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CCG\_AD3x
}{
   Combines data lines using absolute deviations from an unweighted
   mean
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data.  The data values in the lines are then
      combined to form an unweighted mean, and then the absolute mean
      deviation from the mean.  The output means are returned in the
      array RESULT.
   }
   \sstinvocation{
      CALL CCG\_AD3x( NPIX, NLINES, STACK, MINPIX,
                     RESULT, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output RESULT array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CCG\_BM1x
}{
   Combines data lines using a broadened median
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then combined to
      form an broadened medium line.  The broadened median is similar to
      a trimmed mean, except that the trimming fraction changes with
      the number of values (and is equivalent to a median for fewer than
      five values).  The output means are returned in the array RESULT.
      The variances are propagation through the combination process and
      returned in the RESVAR array.
   }
   \sstinvocation{
      CALL CCG\_BM1x( NPIX, NLINES, STACK, VARS, MINPIX, NMAT, COVEC,
                     RESULT, RESVAR, WRK1, POINT, USED, NCON, NBAD,
                     STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The variances of the data.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NMAT = INTEGER (Given)
      }{
         Size of the first dimension of COVEC.
      }
      \sstsubsection{
         COVEC( NMAT, NLINES ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of sizes up to NLINES, produced by
         CCG\_ORVAR.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, RESVAR, and WRK1 arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_BM3x
}{
   Combines data lines using a broadened median
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then combined to
      form an broadened medium line.  The broadened median is similar to
      a trimmed mean, except that the trimming fraction changes with
      the number of values (and is equivalent to a median for fewer than
      five values).  The output means are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_BM3x( NPIX, NLINES, STACK, MINPIX, RESULT,
                     WRK1, POINT, USED, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, RESULT,
         and WRK1 arguments supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   CCG\_CLIPx
}{
   Sets any data outside a given value range BAD
}{
   \sstdescription{
      This generic routine loops over all entries in RA. If any values
      are outside the range RMIN to VMAX then they are set BAD.
   }
   \sstinvocation{
      CALL CCG\_CLIPR( VMIN, VMAX, EL, ARRAY, NGOOD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VMIN = ? (Given)
      }{
         The minimum allowed value.  All values below this are set BAD.
      }
      \sstsubsection{
         VMAX = ? (Given)
      }{
         The maximum allowed value.  All values above this are set BAD.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of entries in ARRAY.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The list of values to be clipped within the given range.  On
         output this contains the clipped list.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         The number of values left after rejection.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The ARRAY, VMIN,
         and VMAX arguments supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   CCG\_COMB1x
}{
   Combines a stack of array lines into one line, using a variety of
   methods
}{
   \sstdescription{
      The routine works along each line of the input stack of lines,
      combining the data.  This variant uses a complete variance array
      propagates them.

      The array NCON holds the actual numbers of pixels that were used
      in deriving the output value plus any values already present in
      the array; thus a cumulative sum of contributing pixel numbers may
      be kept.
   }
   \sstinvocation{
      CALL CCG\_COMB1x( NPIX, NLINES, STACK, VARS, COORDS, IMETH, MINPIX,
                       NITER, NSIGMA, ALPHA, RMIN, RMAX, NMAT, RESULT,
                       RESVAR, WIDTHS, COIND, WRK1, WRK2, PP, COVEC,
                       POINT, USED, NCON, NFLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         COORDS( NPIX, NLINES ) = ? (Given)
      }{
         The co-ordinates along the collapse axis for each pixel.
         It is accessed only for IMETH = 22, 23, 33, 34.
      }
      \sstsubsection{
         IMETH = INTEGER (Given)
      }{
         The method to use in combining the lines.  It has a code of 1
         to 300 which represent the following statistics.
         1  = Mean
         2  = Weighted mean
         3  = Median
         4  = Trimmed mean
         5  = Mode
         6  = Sigma-clipped mean
         7  = Threshold exclusion mean
         8  = Minmax mean
         9  = Broadened median
         10 = Sigma-clipped median
         11 = Fast median
         12 = Sum
         13 = Standard deviation about the mean
         14 = Sigma-clipped standard deviation about the mean
         21 = Integrated value (sum of pixel co-ordinate width times
              value)
         22 = Intensity-weighted co-ordinate
         23 = Intensity-weighted dispersion of the co-ordinate
         24 = Root mean square
         25 = Absolute mean deviation
         31 = Maximum
         32 = Minimum
         33 = Co-ordinate of maximum
         34 = Co-ordinate of minimum
         300 = Median, but estimating variance from mean variance
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations (IMETH = 5).
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The number of sigmas to clip the data at (IMETH = 5 and 6).
      }
      \sstsubsection{
         ALPHA = REAL (Given)
      }{
         The fraction of data values to remove from data (IMETH = 4).
      }
      \sstsubsection{
         RMIN = REAL (Given)
      }{
         The minimum allowed data value (IMETH = 7).
      }
      \sstsubsection{
         RMAX = REAL (Given)
      }{
         The maximum allowed data value (IMETH = 7).
      }
      \sstsubsection{
         NMAT = INTEGER (Given)
      }{
         Number of columns in covariance matrix.   It should be at
         least NLINES $*$ ( NLINES $+$ 1 )/ 2.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         WIDTHS( NPIX, NLINES ) = ? (Returned)
      }{
         The widths along the collapse axis for each pixel.  It is
         calculated only for IMETH = 21.
      }
      \sstsubsection{
         COIND( NPIX ) = INTEGER (Returned)
      }{
         Workspace to hold co-ordinate indices.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         PP( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         Workspace for order statistics calculations.
      }
      \sstsubsection{
         COVEC( NMAT, NLINES ) = DOUBLE PRECISION (Returned)
      }{
         Workspace for storing ordered statistics variance-covariance
         matrix.  Used for IMETHs 3 to 11, and 14.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NFLAG = INTEGER (Returned)
      }{
         Number of output pixels set to bad because insufficient pixels
         were present to form the statistic for the collapsed axis,
         provided the minimum number of contributing data values is one.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         COORDS, RESULT, RESVAR, WIDTHS, WRK1, and WRK2 arguments supplied
         to the routine must have the data type specified.

         \sstitem
         Various of the options are simply variations on a theme.  The
         Broadened median is just a trimmed mean with a variable trimming
         fraction. The Mode is an iteratively carried out version of the
         sigma clipping (or more precisely the reverse).  The minmax and
         threshold mean are also just trimmed means, but require their own
         mechanisms.

         \sstitem
         The {\tt '}propagation{\tt '} of the input variances assumes that the input
         data are fairly represented by a normal distribution.  This fact
         is used together with the {\tt '}order statistics{\tt '} of a normal
         population to form a new variance estimate.  The order statistics
         are not independent so have non-zero covariances (off diagonal
         components of the variance-covariance matrix).  All {\tt '}trimmed
         means{\tt '} of any description use the order of the values to
         estimate which values are corrupt.  This applies to all the
         methods supported here except the mean which rejects no data. The
         variance used to represent the input normal population is the
         reciprocal of the sum of the reciprocal variances.  We have no
         other estimate of this value except from the population itself.

         \sstitem
         Calculations are performed in double precision.
      }
   }
}
\sstroutine{
   CCG\_COMB3x
}{
   Combines a stack of array lines into one line, using a variety
   of methods
}{
   \sstdescription{
      The routine works along each line of the input stack of lines,
      combining the data.  This variant uses a single variance for each
      line and and does NOT propagate it.

      The array NCON holds the actual numbers of pixels which were used
      in deriving the output value plus any values already present in
      the array; thus a cumulative sum of contributing pixel numbers may
      be kept.
   }
   \sstinvocation{
      CALL CCG\_COMB3x( NPIX, NLINES, STACK, VARS, COORDS, IMETH, MINPIX,
                       NITER, NSIGMA, ALPHA, RMIN, RMAX, RESULT, WIDTHS,
                       COIND, WRK1, WRK2, POINT, USED, NCON, NFLAG,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NLINES ) = ? (Given)
      }{
         The variance to to used for each line of data.
      }
      \sstsubsection{
         COORDS( NPIX, NLINES ) = ? (Given)
      }{
         The co-ordinates along the collapse axis for each pixel.
         It is accessed only for IMETH = 22, 23, 33, 34.
      }
      \sstsubsection{
         IMETH = INTEGER (Given)
      }{
         The method to use in combining the lines.  It has a code of 1
         to 300 which represent the following statistics.
         1  = Mean
         2  = Weighted mean
         3  = Median
         4  = Trimmed mean
         5  = Mode
         6  = Sigma-clipped mean
         7  = Threshold exclusion mean
         8  = Minmax mean
         9  = Broadened median
         10 = Sigma-clipped median
         11 = Fast median
         12 = Sum
         13 = Standard deviation about the mean
         14 = Sigma-clipped standard deviation about the mean
         21 = Integrated value (sum of pixel co-ordinate width times
              value)
         22 = Intensity-weighted co-ordinate
         23 = Intensity-weighted dispersion of the co-ordinate
         24 = Root mean square
         25 = Absolute mean deviation
         31 = Maximum
         32 = Minimum
         33 = Co-ordinate of maximum
         34 = Co-ordinate of minimum
         300 = Median, but estimating variance from mean variance
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations (IMETH = 5).
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The number of sigmas to clip the data at (IMETH = 5 and 6).
      }
      \sstsubsection{
         ALPHA = REAL (Given)
      }{
         The fraction of data values to remove from data (IMETH = 4).
      }
      \sstsubsection{
         RMIN = REAL (Given)
      }{
         The minimum allowed data value (IMETH = 7).
      }
      \sstsubsection{
         RMAX = REAL (Given)
      }{
         The maximum allowed data value (IMETH = 7).
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         WIDTHS( NPIX, NLINES ) = ? (Returned)
      }{
         The widths along the collapse axis for each pixel.  It is
         calculated only for IMETH = 21.
      }
      \sstsubsection{
         COIND( NPIX ) = INTEGER (Returned)
      }{
         Workspace to hold co-ordinate indices.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NFLAG = INTEGER (Returned)
      }{
         Number of output pixels set to bad because insufficient pixels
         were present to form the statistic for the collapsed axis,
         provided the minimum number of contributing data values is one.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         COORDS, RESULT, WIDTHS, WRK1, and WRK2 arguments supplied to the
         routine must have the data type specified.

         \sstitem
         Various of the options are simply variations on a theme.  The
         Broadened median is just a trimmed mean with a variable trimming
         fraction.  The Mode is an iteratively carried out version of the
         sigma clipping (or more precisely the reverse).  The minmax and
         threshold mean are also just trimmed means, but require their own
         mechanisms.

         \sstitem
         No propagation of variances is performed using this routine.

         \sstitem
         Calculations are performed in double precision.
      }
   }
}
\sstroutine{
   CCG\_CS1x
}{
   Combines data lines using a sigma-clipped standard deviation
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The weighted mean and standard deviation of each
      input column in STACK is then used to estimate the range of
      values which represent the required sigma clipping.  Values
      outside of this range are then rejected and the resulting output
      standard deviations are returned in the array RESULT.  The
      variances are propagated through the combination process and
      returned in the RESVAR array.
   }
   \sstinvocation{
      CALL CCG\_CS1x( NSIGMA, NPIX, NLINES, STACK, VARS, MINPIX, NMAT,
                      COVEC, RESULT, RESVAR, WRK1, WRK2, POINT, USED,
                      NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The number of sigma at which to reject data values.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NMAT = INTEGER (Given)
      }{
         Size of the first dimension of COVEC.
      }
      \sstsubsection{
         COVEC( NMAT, NLINES ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of sizes up to NLINES, produced by
         CCG\_ORVAR.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data, i.e. the clipped standard deviations.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances of the clipped standard deviations.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, RESVAR, WRK1, and WRK2 arguments supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_CS3x
}{
   Combines data lines using a sigma-clipped standard deviation
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The weighted mean and standard deviation of each
      input column in STACK is then used to estimate the range of values
      that represent the required sigma clipping.  The standard
      deviation is derived from the population of values at each
      position along the lines (cf. each image pixel).  Values outside
      of this range are then rejected and the resulting output
      standard-deviation values are returned in the array RESULT.

      Note that clipping will not be used when only two or three
      values are available (unless in the case of three values NSIGMA
      is less than 1.0).
   }
   \sstinvocation{
      CALL CCG\_CS3x( NSIGMA, NPIX, NLINES, STACK, VARS, MINPIX,
                     RESULT, WRK1, WRK2, POINT, USED, NCON, NBAD,
                     STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The number of sigma at which to reject data values.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NLINES ) = ? (Given)
      }{
         The variance to to used for each line of data. These are
         used as inverse weights when forming the mean and do not
         need to be real variances, as they are not propagated.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of clipped standard deviations.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, WRK1, and WRK2 arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_FLX1x
}{
   Combines data lines using the integrated value
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data.  It forms the sum of the data values
      multiplied by its pixel width lines are then summed, i.e a flux.
      The output integrated values are returned in the array RESULT.
      The output variances are estimated from the VARS values and are
      returned in RESVAR; this assumes no errors in the widths.
   }
   \sstinvocation{
      CALL CCG\_FLX1x( NPIX, NLINES, STACK, VARS, WIDTHS, MINPIX,
                       RESULT, RESVAR, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         WIDTHS( NPIX, NLINES ) = ? (Given)
      }{
         The pixel widths in world co-ordinates.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = $<$TYPE$>$ (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = $<$TYPE$>$ (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output RESULT array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, and RESVAR arguments supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   CCG\_FLX3x
}{
   Combines data lines using the integrated value
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data.  It forms the sum of the data values
      multiplied by its pixel width lines are then summed, i.e a flux.
      The output integrated values are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_FLX3x( NPIX, NLINES, STACK, WIDTHS, MINPIX, RESULT,
                      NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         WIDTHS( NPIX, NLINES ) = ? (Given)
      }{
         The pixel widths in world co-ordinates.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The STACK and RESULT
         arguments supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   CCG\_FM1x
}{
   Combines data lines using a fast median
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then combined to
      form a (fast) median line.  This method uses no weights and
      returns the estimated variances based on order stats for the
      population sizes used at each output pixel.

      The method used is based on Wirth{\tt '}s algorithm for selecting the
      Kth value, which is very fast compared to a full sort.

      The output medians are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_FM1x( NPIX, NLINES, STACK, VARS, MINPIX, NMAT, COVEC,
                     RESULT, RESVAR, WRK1, WRK2, POINT, NCON, NBAD,
                     STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NMAT = INTEGER (Given)
      }{
         Size of the first dimension of COVEC.
      }
      \sstsubsection{
         COVEC( NMAT, NLINES ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of sizes up to NLINES, produced by
         CCG\_ORVAR. This is only used when median is derived from
         the central-2 values.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variance.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, RESVAR, WRK1, and WRK2 arguments supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_FM3x
}{
   Combines data lines using a fast median
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data. The data values in the lines are then combined to
      form a (fast) median line.  This method uses no weights and
      returns no variances.

      The method used is based on Wirth{\tt '}s algorithm for selecting the
      Kth value, which is very fast compared to a full sort.

      The output medians are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_FM3x( NPIX, NLINES, STACK, MINPIX, RESULT, WRK1, NCON,
                     POINT, USED, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, RESULT,
         and WRK1 arguments supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   CCG\_I2WCx
}{
   Assigns world co-ordinates to an output array from an input list
   of indices
}{
   \sstdescription{
      This routine assigns world co-ordinates to an output vector
      from an input two-dimensional array, corresponding to a
      a vector for each output element.  The world co-ordinates are
      selected using a list of indices in each world-co-ordinate
      vector, there being one index per output value.  A bad value or
      a value outside the bounds of the array in the list of indices
      causes a bad value to be assigned to the output array.
   }
   \sstinvocation{
      CALL CCG\_I2WCx( NPIX, NLINES, INDICE, COORDS, RESULT, NBAD,
                     STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data.
      }
      \sstsubsection{
         INDICE( NPIX ) = INTEGER (Given)
      }{
         The indices in the input array that point to the values to be
         assigned to the output vector.
      }
      \sstsubsection{
         COORDS( NPIX, NLINES ) = ? (Given)
      }{
         The world co-ordinates.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The vector containing values copied from the input COORDS
         array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The COORDS and
         RESULT supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_IS2x
}{
   Sorts a list of data into increasing order, and applies the
   corresponding shuffle to an ancillary list
}{
   \sstdescription{
      The routine uses an insert-sort method.  This has proven itself
      the quickest for sorting small sets of data lots of times, as in
      image stacking using ordered statistics.  The method looks at the
      second value, compares this with the first if swaps if necessary,
      then it looks at the third, looks at the previous values swaps
      with the lowest (or not at all) and so on until all values have
      been passed.  It is fast (for the case above) simply because of
      the very few lines of operation.  The sort is extended to the
      ancillary data ANCDAT, this maintains its correspondence with the
      ORDDAT dataset on exit.
   }
   \sstinvocation{
      CALL CCG\_IS2x( EL, ORDDAT, ANCDAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of entries in ORDDAT.
      }
      \sstsubsection{
         ORDDAT( EL ) = ? (Given and Returned)
      }{
         The data to order. On output it contains the data in increasing
         order.
      }
      \sstsubsection{
         ANCDAT( EL ) = INTEGER (Given and Returned)
      }{
         A list of data associated with ORDDAT which needs to retain its
         correspondence with the items in ORDDAT (probably pointers).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The ORDDAT
         argument supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   CCG\_IS3x
}{
   Sorts a list of data into increasing order, and applies the
   corresponding shuffle to two ancillary lists
}{
   \sstdescription{
      The routine uses an insert sort method.  This has proven itself
      the quickest for sorting small sets of data lots of times, as in
      image stacking using ordered statistics.  The method looks at the
      second value, compares this with the first if swaps if necessary,
      then it looks at the third, looks at the previous values swaps
      with the lowest (or not at all) and so on until all values have
      been passed. It is fast (for the case above ) simply because of
      the very few lines of operation.  The sort is extended to the
      ancillary data RDAT and PDAT that maintain their correspondence
      with the ORDDAT dataset on exit.
   }
   \sstinvocation{
      CALL CCG\_IS3x( EL, ORDDAT, RDAT, PDAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of entries in ORDDAT.
      }
      \sstsubsection{
         ORDDAT( EL ) = ? (Given and Returned)
      }{
         The data to order. On output it contains the data in increasing
         order.
      }
      \sstsubsection{
         RDAT( EL ) = ? (Given and Returned)
      }{
         A list of data associated with ORDDAT which needs to retain its
         correspondence with the items in ORDDAT.
      }
      \sstsubsection{
         PDAT( EL ) = INTEGER (Given and Returned)
      }{
         A list of data associated with ORDDAT which needs to retain its
         correspondence with the items in ORDDAT (probably pointers).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The ORDDAT and RDAT
         arguments supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   CCG\_IWC1$<$T$>$
}{
   Combines data lines using the intensity-weighted co-ordinate
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data and their co-ordinates.  For each
      pixel the subroutine forms a weighted mean co-ordinate and
      variance along a line of data.  The weights are the product of
      the data values and their inverse variance.  The output weighted
      co-ordinates are returned in the array RESULT.  The output
      weighted variances are returned in RESVAR; this assumes no
      errors in the co-ordinates.
   }
   \sstinvocation{
      CALL CCG\_IWC1x( NPIX, NLINES, STACK, VARS, COORDS, MINPIX,
                       RESULT, RESVAR, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         COORDS( NPIX, NLINES ) = ? (Given)
      }{
         The world co-ordinates.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output RESULT array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The STACK, VARS,
         COORDS, RESULT, and RESVAR arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_IWC3x
}{
   Combines data lines using the intensity-weighted co-ordinate
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data and their co-ordinates.  For each
      pixel the subroutine forms a weighted mean co-ordinate along a
      line of data.  The weights are the data values.  The output
      weighted co-ordinates are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_IWC3x( NPIX, NLINES, STACK, COORDS, MINPIX,
                       RESULT, NCON, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         COORDS( NPIX, NLINES ) = ? (Given)
      }{
         The world co-ordinates.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The STACK, COORDS, and
         RESULT arguments supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   CCG\_IWD1x
}{
   Combines data lines using the dispersion of the intensity-weighted
   co-ordinate
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data and their co-ordinates.  For each
      pixel the subroutine forms the weighted dispersion of the
      co-ordinate and an estimated variance along a line of data.  The
      weights are the data values and their inverse variances.  The
      output co-ordinate dispersions are returned in the array RESULT.
      The output variances in RESVAR are the standard error of RESULT.
   }
   \sstinvocation{
      CALL CCG\_IWD1x( NPIX, NLINES, STACK, VARS, COORDS, MINPIX,
                       RESULT, RESVAR, NCON, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         COORDS( NPIX, NLINES ) = ? (Given)
      }{
         The world co-ordinates.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output RESULT array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The STACK, VARS,
         COORDS, RESULT, and RESVAR arguments supplied to the routine must
         have the data type specified.

         \sstitem
         It uses the corrected two-pass algorithm of Chan, T.F.,
         Golub, G.H., \& LeVeque, R.J. (1983). {\tt "}Algorithms for computing the
         sample variance: Analysis and recommendations{\tt "}, American
         Statistician, 37(3), 242-247.
      }
   }
}
\sstroutine{
   CCG\_IWD3x
}{
   Combines data lines using the dispersion of the intensity-weighted
   co-ordinate
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data and their co-ordinates.  For each
      pixel the subroutine forms the weighted dispersion of the
      co-ordinate along a line of data.  The weights are the data
      values.  The output co-ordinate dispersions are returned in the
      array RESULT.
   }
   \sstinvocation{
      CALL CCG\_IWD3x( NPIX, NLINES, STACK, COORDS, MINPIX,
                       RESULT, RESVAR, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         COORDS( NPIX, NLINES ) = ? (Given)
      }{
         The world co-ordinates.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output RESULT array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The STACK, COORDS,
         and RESULT arguments supplied to the routine must have the data
         type specified.

         \sstitem
         It uses the corrected two-pass algorithm of Chan, T.F.,
         Golub, G.H., \& LeVeque, R.J. (1983). {\tt "}Algorithms for computing the
         sample variance: Analysis and recommendations{\tt "}, American
         Statistician, 37(3), 242--247.
      }
   }
}
\sstroutine{
   CCG\_KTHx
}{
   Returns the Kth smallest value in an array
}{
   \sstdescription{
      This routine returns the value of the Kth smallest element in the
      given array.  It is an implementation of an algorithm of Niklaus
      Wirth from the book {\tt "}Algorithms $+$ data structures = programs{\tt "}.
   }
   \sstinvocation{
      CALL CCG\_KTHx( EL, K, ARRAY, ANCDAT, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the input array.
      }
      \sstsubsection{
         K = INTEGER (Given and Returned)
      }{
         On entry the ordered value to be returned, on exit index of
         ARRAY that contain the Kth smallest value.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The array of values to be processed. Note this is modified on
         exit.
      }
      \sstsubsection{
         ANCDAT( EL ) = INTEGER (Given and Returned)
      }{
         Array of data whose association with ARRAY is to be preserved
         (such as a list of pointers to the original positions within
         ARRAY).
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The Kth smallest value in the input array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CCG\_MD1x
}{
   Combines data lines using a weighted median
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then combined to
      form a weighted median line.  The weights used are one-per-line
      and are the reciprocal of values given in the array VARS.  The
      output means are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_MD1x( CALCMV, NPIX, NLINES, STACK, VARS, MINPIX,
                     NMAT, COVEC, RESULT, RESVAR, WRK1, WRK2,
                     POINT, USED, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CALCMV = LOGICAL (Given)
      }{
         If .FALSE. then the output variances are estimated by scaling
         the variance on the weighted mean (rather than the weighted
         median) by Pi/2.  Otherwise, the output variances are
         calculated using the COVEC array.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NMAT = INTEGER (Given)
      }{
         Size of the first dimension of COVEC.
      }
      \sstsubsection{
         COVEC( NMAT, NLINES ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of sizes up to NLINES, produced by
         CCG\_ORVAR. Not used if CALCMV is .FALSE.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variance.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, RESVAR, WRK1, and WRK2 arguments supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_MDR3x
}{
   Combines data lines using a weighted median
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data. The data values in the lines are then combined to
      form a weighted median line.  The weights used are one-per-line
      and are the reciprocal of values given in the array VARS.  The
      output medians are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_MD3x( NPIX, NLINES, STACK, VARS, MINPIX, RESULT,
                      WRK1, WRK2, POINT, USED, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NLINES ) = ? (Given)
      }{
         The variance to to used for each line of data.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, WRK1, and WRK2 arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_ME1x
}{
   Combines data lines using a weighted mean
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data.  The data values in the lines are then
      combined to form a weighted mean. The weights used are are the
      reciprocal of values given in the array VARS.  The output means
      are returned in the array RESULT.  The output variances are
      estimated from the VARS values and are returned in RESVAR.
   }
   \sstinvocation{
      CALL CCG\_ME1x( NPIX, NLINES, STACK, VARS, MINPIX,
                     RESULT, RESVAR, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, and RESVAR arguments supplied to the routine must have
         the data type specified.

         \sstitem
         This routine performs its work in double precision.
      }
   }
}
\sstroutine{
   CCG\_ME3x
}{
   Combines data lines using a weighted mean
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then combined to
      form a weighted mean.  The weights used are one-per-line and are
      the reciprocal of values given in the array VARS.  The output
      means are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_ME3x( NPIX, NLINES, STACK, VARS, MINPIX, RESULT, NCON,
                    NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NLINES ) = ? (Given)
      }{
         The variance to to used for each line of data.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         and RESULT arguments supplied to the routine must have the data
         type specified.

         \sstitem
         This routine performs its work in double precision.
      }
   }
}
\sstroutine{
   CCG\_MM1x
}{
   Combines data lines using a min-max exclusion trimmed mean
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then combined to
      form an trimmed mean in which the minimum and maximum values are
      excluded.  The output means are returned in the array RESULT.  The
      output variances are propagated from the inverse weights given in
      array VARS and are returned in the array RESVAR.
   }
   \sstinvocation{
      CALL CCG\_MM1x( NPIX, NLINES, STACK, VARS, MINPIX, NMAT, COVEC,
                     RESULT, RESVAR, WRK1, POINT, USED, NCON, NBAD,
                     STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NMAT = INTEGER (Given)
      }{
         Size of the first dimension of COVEC.
      }
      \sstsubsection{
         COVEC( NMAT, NLINES ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of sizes up to NLINES, produced by
         CCG\_ORVAR.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, RESVAR, and WRK1 arguments supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_MM3x
}{
   Combines data lines using a min-max exclusion trimmed mean
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then combined to
      form an trimmed mean in which the minimum and maximum values are
      excluded. The output means are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_MM3x( NPIX, NLINES, STACK, MINPIX, RESULT,
                     WRK1, POINT, USED, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, RESVAR, WRK1, and WRK2 arguments supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_MN1x
}{
   Combines data lines using the minimum value
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then collapsed
      to the minimum value in each line.  The output minima are
      returned in the array RESULT.  Each output variance value is the
      corresponding variance of the minimum data value, propagated from
      the input variances given in array VARNCE and are returned in the
      array RESVAR.  The vectorised pixel indices corresponding to the
      minima are also returned in POSIND.
   }
   \sstinvocation{
      CALL CCG\_MN1x( BAD, NPIX, NLINES, STACK, VARNCE, RESULT, RESVAR,
                     POSIND, WRK1, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true, there may be bad pixels present in the array.  If
         false, it is safe not to check for bad values.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARNCE( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         POSIND( NPIX ) = INTEGER (Returned)
      }{
         The pixel indices of the minima in each output pixel.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         STACK, VARNCE, RESULT, RESVAR, and WRK1 arguments supplied to the
         routine must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_MN3x
}{
   Combines data lines using the minimum value
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then collapsed
      to the minimum value in each line.  The output minima are
      returned in the array RESULT.  The vectorised pixel indices
      corresponding to the minima are also returned in POSIND.
   }
   \sstinvocation{
      CALL CCG\_MN3x( BAD, NPIX, NLINES, STACK, RESULT,
                     POSIND, WRK1, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true, there may be bad pixels present in the array.  If
         false, it is safe not to check for bad values.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         RESULT( NPIX ) = $<$TYPE$>$ (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         POSIND( NPIX ) = INTEGER (Returned)
      }{
         The pixel indices of the minima in each output pixel.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         STACK, RESULT, and WRK1 arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_MO1x
}{
   Combines data lines using a mode
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then combined to
      form an output mode line.  The output modal values are returned in
      the array RESULT. The variances are propagated through the
      combination process and returned in RESVAR.
   }
   \sstinvocation{
      CALL CCG\_MO1x( NSIGMA, NITER, NPIX, NLINES, STACK, VARS, MINPIX,
                     NMAT, COVEC, RESULT, RESVAR, WRK1, WRK2, POINT,
                     USED, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The number of sigma at which to reject data values.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         Maximum number of refining iterations.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NMAT = INTEGER (Given)
      }{
         Size of the first dimension of COVEC.
      }
      \sstsubsection{
         COVEC( NMAT, NLINES ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of sizes up to NLINES, produced by
         CCG\_ORVAR.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, RESVAR, WRK1, and WRK2 arguments supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_MOR3x
}{
   Combines data lines using a mode
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data. The data values in the lines are then combined to
      form an output mode line. The output modal values are returned in
      the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_MOR3x( NSIGMA, NITER, NPIX, NLINES, STACK, VARS, MINPIX,
                       RESULT, WRK1, WRK2, POINT, USED, NCON, NBAD,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The number of sigma at which to reject data values.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         Maximum number of refining iterations.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NLINES ) = ? (Given)
      }{
         The variance to to used for each line of data.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, WRK1, and WRK2 arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_MX1x
}{
   Combines data lines using the maximum value
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then collapsed
      to the maximum value in each line.  The output maxima are
      returned in the array RESULT.  Each output variance value is the
      corresponding variance of the maximum data value, propagated from
      the input variances given in array VARNCE and are returned in the
      array RESVAR.  The vectorised pixel indices corresponding to the
      maxima are also returned in POSIND.
   }
   \sstinvocation{
      CALL CCG\_MX1x( BAD, NPIX, NLINES, STACK, VARNCE, RESULT, RESVAR,
                     POSIND, WRK1, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true, there may be bad pixels present in the array.  If
         false, it is safe not to check for bad values.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARNCE( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         POSIND( NPIX ) = INTEGER (Returned)
      }{
         The pixel indices of the maxima in each output pixel.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output RESULT array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         STACK, VARNCE, RESULT, RESVAR, and WRK1 arguments supplied to the
         routine must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_MX3x
}{
   Combines data lines using the maximum value
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then collapsed
      to the maximum value in each line.  The output maxima are
      returned in the array RESULT.  The vectorised pixel indices
      corresponding to the maxima are also returned in POSIND.
   }
   \sstinvocation{
      CALL CCG\_MX3x( BAD, NPIX, NLINES, STACK, RESULT, POSIND, WRK1,
                     NBAD, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true, there may be bad pixels present in the array.  If
         false, it is safe not to check for bad values.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         POSIND( NPIX ) = INTEGER (Returned)
      }{
         The pixel indices of the maxima in each output pixel.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         STACK, RESULT, and WRK1 arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_RMS1x
}{
   Combines data lines using the root mean square
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in each lines are then combined to
      form the roor mean square of the values.  The output rot mean
      squares are returned in the array RESULT.  The squared
      standard error of the variance is returned in RESVAR.
   }
   \sstinvocation{
      CALL CCG\_RMS1x( NPIX, NLINES, STACK, MINPIX, RESULT, RESVAR,
                      NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine performs its work in double precision.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         STACK, RESULT, and RESVAR arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_RMS3x
}{
   Combines data lines using the root mean square
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in each lines are then combined to
      form the roor mean square of the values.  The output rot mean
      squares are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_RMS3x( NPIX, NLINES, STACK, MINPIX, RESULT, RESVAR,
                      NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine performs its work in double precision.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         STACK and RESULT arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_SCR1
}{
   Combines data lines using a sigma-clipped mean
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The weighted mean and standard deviation of each
      input column in STACK is then used to estimate the range of
      values which represent the required sigma clipping.  Values
      outside of this range are then rejected and  the resulting output
      mean values are returned in the array RESULT.  The variances are
      propagated through the combination process and returned in the
      RESVAR array, and include a covariance correction.
   }
   \sstinvocation{
      CALL CCG\_SCR1( NSIGMA, NPIX, NLINES, STACK, VARS, MINPIX, NMAT,
                     COVEC, RESULT, RESVAR, WRK1, WRK2, POINT, USED,
                     NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The number of sigma at which to reject data values.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NMAT = INTEGER (Given)
      }{
         Size of the first dimension of COVEC.
      }
      \sstsubsection{
         COVEC( NMAT, NLINES ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of sizes up to NLINES, produced by
         CCG\_ORVAR.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output population variances.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, RESVAR, WRK1, and WRK2 arguments supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_SC3x
}{
   Combines data lines using a sigma clipped mean
}{
   \sstdescription{
      This routine accepts an array consisting a series of
      (vectorised) lines of data.  The weighted mean and standard
      deviation of each input column in STACK is then used to estimate
      the range of values which represent the required sigma
      clipping.  The standard deviation is derived from the population
      of values at each position along the lines (cf. each image
      pixel).  Values outside of this range are then rejected and the
      resulting output mean values are returned in the array RESULT.

      Note that clipping will not be used when only two or three
      values are available (unless in the case of three values NSIGMA
      is less than 1.0).
   }
   \sstinvocation{
      CALL CCG\_SC3x( NSIGMA, NPIX, NLINES, STACK, VARS, MINPIX, RESULT,
                     WRK1, WRK2, POINT, USED, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The number of sigma at which to reject data values.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NLINES ) = ? (Given)
      }{
         The variance to to used for each line of data. These are
         used as inverse weights when forming the mean and do not
         need to be real variances, as they are not propagated.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, WRK1, and WRK2 arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_SD1x
}{
   Combines data lines using an unweighted standard deviation
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in each lines are then combined to
      form an unweighted standard deviation.  The output standard
      deviations are returned in the array RESULT.  The squared
      standard error of the variance is returned in RESVAR.
   }
   \sstinvocation{
      CALL CCG\_SD1x( NPIX, NLINES, STACK, MINPIX, RESULT, RESVAR,
                     NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
         to the output line.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         STACK, RESULT, and RESVAR arguments supplied to the routine must
         have the data type specified.

         \sstitem
         This routine performs its work in double precision.
      }
   }
}
\sstroutine{
   CCG\_SD3x
}{
   Combines data lines using an unweighted standard deviation
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in each lines are then combined to
      form an unweighted standard deviation.  The output standard
      deviations are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_SD3x( NPIX, NLINES, STACK, MINPIX, RESULT, NCON,
                     NBAD, NCON, NBAD, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
         to the output line.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine performs its work in double precision.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         STACK and RESULT arguments supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   CCG\_SM1x
}{
   Combines data lines using a sigma-clipped median
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The weighted mean and standard deviation of each
      input column in STACK is then used to estimate the range of
      values which represent the required sigma clipping.  Values
      outside of this range are then rejected and then the median
      of the remaining values is returned in the array RESULT.  The
      variances are propagated through the combination processand
      returned in the RESVAR array.
   }
   \sstinvocation{
      CALL CCG\_SM1x( NSIGMA, NPIX, NLINES, STACK, VARS, MINPIX, COVEC,
                     NMAT, RESULT, RESVAR, WRK1, WRK2, POINT, USED,
                     NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The number of sigma at which to reject data values.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NMAT = INTEGER (Given)
      }{
         Size of the first dimension of COVEC.
      }
      \sstsubsection{
         COVEC( NMAT, NLINES ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of sizes up to NLINES, produced by
         CCG\_ORVAR.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Given and Returned)
      }{
         The actual number of contributing pixels.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, RESVAR, WRK1, and WRK2 arguments supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_SM3x
}{
   Combines data lines using a sigma clipped median
}{
   \sstdescription{
      This routine accepts an array consisting a series of
      (vectorised) lines of data.  The weighted mean and standard
      deviation of each input column in STACK is then used to estimate
      the range of values which represent the required sigma
      clipping.  The standard deviation is derived from the population
      of values at each position along the lines (cf. each image
      pixel).  Values outside of this range are then rejected and the
      resulting output mean values are returned in the array RESULT.

      Note that clipping will not be used when only two or three
      values are available (unless in the case of 3 values NSIGMA
      is less than 1.0).
   }
   \sstinvocation{
      CALL CCG\_SM3x( NSIGMA, NPIX, NLINES, STACK, VARS, MINPIX,
                      RESULT, WRK1, WRK2, POINT, USED, NCON, NBAD,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The number of sigma at which to reject data values.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NLINES ) = ? (Given)
      }{
         The variance to to used for each line of data. These are
         used as inverse weights when forming the mean and do not
         need to be real variances, as they are not propagated.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, WRK1, and WRK2 arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_SUM1x
}{
   Combines data lines using the sum of values
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data.  The data values in the lines are then
      summed.  The output sums are returned in the array RESULT.  The
      output variances are estimated from the VARS values and are
      returned in RESVAR.
   }
   \sstinvocation{
      CALL CCG\_SUM1x( NPIX, NLINES, STACK, VARS, MINPIX,
                       RESULT, RESVAR, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output RESULT array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         STACK, VARS, RESULT, and RESVAR arguments supplied to the
         routine must have the data type specified.  It is not wise to
         choose an integer type as the chances of overflow are high.
      }
   }
}
\sstroutine{
   CCG\_SUM3x
}{
   Combines data lines using the sum of values
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data.  The data values in the lines are then
      summed.  The output sums are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_SUM3x( NPIX, NLINES, STACK, MINPIX,
                      RESULT, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         STACK and RESULT arguments supplied to the routine must have the
         data type specified.  It is not wise to choose an integer type
         as the chances of overflow are high.
      }
   }
}
\sstroutine{
   CCG\_TC1x
}{
   Combines data lines using a threshold clipped mean
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data. All values outside of the range VMIN to VMAX are
      rejected before a estimate of the (weighted) mean is made. The
      output mean values are returned in the array RESULT.  The
      variances are propagation through the combination process and
      returned in the RESVAR array.
   }
   \sstinvocation{
      CALL CCG\_TC1x( VMIN, VMAX, NPIX, NLINES, STACK, VARS, MINPIX,
                     COVEC, NMAT, RESULT, RESVAR, WRK1, WRK2, POINT,
                     USED, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VMIN = ? (Given)
      }{
         Minimum allowed value.
      }
      \sstsubsection{
         VMAX = ? (Given)
      }{
         Maximum allowed value.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NMAT = INTEGER (Given)
      }{
         Size of the first dimension of COVEC.
      }
      \sstsubsection{
         COVEC( NMAT, NLINES ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of sizes up to NLINES, produced by
         CCD1\_ORVAR.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variance.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The VMIN, VMAX,
         STACK, VARS, RESULT, RESVAR, WRK1, and WRK2 arguments supplied to
         the routine must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_TCR3x
}{
   Combines data lines using a threshold clipped mean
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  All values outside of the range VMIN to VMAX are
      rejected before a estimate of the (weighted) mean is made.  The
      output mean values are returned in the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_TCR3x( VMIN, VMAX, NPIX, NLINES, STACK, VARS, MINPIX,
                      RESULT, WRK1, WRK2, POINT, USED, NCON, NBAD,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VMIN = ? (Given)
      }{
         Minimum allowed value.
      }
      \sstsubsection{
         VMAX = ? (Given)
      }{
         Maximum allowed value.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NLINES ) = ? (Given)
      }{
         The variance to to used for each line of data.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         WRK2( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The VMIN, VMAX,
         STACK, VARS, RESULT, WRK1, and WRK2 arguments supplied to the
         routine must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_TM1x
}{
   Combines data lines using a trimmed mean
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then combined to
      form an alpha trimmed mean line.  The output means are returned in
      the array RESULT.  The variances are propagated through the
      combination process and returned in the RESVAR array.
   }
   \sstinvocation{
      CALL CCG\_TM1x( ALPHA, NPIX, NLINES, STACK, VARS, MINPIX, NMAT,
                     COVEC, RESULT, RESVAR, WRK1, POINT, USED,
                     NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ALPHA = REAL (Given)
      }{
         The fraction of data to trim from upper and lower orders.
         It must be greater than 0.0 and less than 0.5.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         NMAT = INTEGER (Given)
      }{
         Size of the first dimension of COVEC.
      }
      \sstsubsection{
         COVEC( NMAT, NLINES ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of sizes up to NLINES, produced by
         CCG\_ORVAR.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variance.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, RESVAR, WRK1, and WRK2 arguments supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   CCG\_TM3x
}{
   Combines data lines using a trimmed mean
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then combined to
      form an alpha trimmed mean line.  The output means are returned in
      the array RESULT.
   }
   \sstinvocation{
      CALL CCG\_TM3x( ALPHA, NPIX, NLINES, STACK, MINPIX, RESULT,
                     WRK1, POINT, USED, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ALPHA = REAL (Given)
      }{
         The fraction of data to trim from upper and lower orders.
         It must be greater than 0.0 and less 0.5.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         WRK1( NLINES ) = ? (Returned)
      }{
         Workspace for calculations.
      }
      \sstsubsection{
         POINT( NLINES ) = INTEGER (Returned)
      }{
         Workspace to hold pointers to the original positions of the
         data before extraction and conversion in to the WRK1 array.
      }
      \sstsubsection{
         USED( NLINES ) = LOGICAL (Returned)
      }{
         Workspace used to indicate which values have been used in
         estimating a resultant value.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, RESULT,
         and WRK1 arguments supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   CCG\_TMN2x
}{
   Forms the n-trimmed mean of the given set of ordered data
}{
   \sstdescription{
      The routine forms the trimmed mean of the given dataset. The
      IGNORE upper and lower ordered values are removed from
      consideration.  Then the remaining values are added and averaged.
      The SVAR value is a (given) best estimate of the original
      un-ordered population variance. The variance of the output value
      is formed assuming that the original dataset was normal in
      distribution, and is now fairly represented by the ordered
      statistics variances-covariances supplied in packed form in
      COVAR. The values not rejected are indicated by setting the flags
      in array used.
   }
   \sstinvocation{
      CALL CCG\_TMN2x( IGNORE, ORDDAT, ORDVAR, EL, USED, COVAR, TMEAN,
                      TVAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGNORE = INTEGER (Given)
      }{
         The number of values to ignore from the upper and lower orders.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of entries in ORDDAT.
      }
      \sstsubsection{
         ORDDAT( EL ) = ? (Given)
      }{
         The set of ordered data for which a trimmed mean is required.
      }
      \sstsubsection{
         SVAR = DOUBLE PRECISION (Given)
      }{
         The variance of the unordered sample now ordered in ORDDAT.
      }
      \sstsubsection{
         USED( EL ) = LOGICAL (Returned)
      }{
         Flags showing which values have not been rejected.
      }
      \sstsubsection{
         COVAR( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of size EL.
      }
      \sstsubsection{
         TMEAN = DOUBLE PRECISION (Returned)
      }{
         The trimmed mean.
      }
      \sstsubsection{
         TVAR = DOUBLE PRECISION (Returned)
      }{
         A variance estimate of the trimmed mean.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The ORDDAT
         argument supplied to the routine must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The variance-covariance array must have been generated in a
         fashion similar to that of ORDVAR.
      }
   }
}
\sstroutine{
   CCG\_TMN3x
}{
   Forms the n-trimmed mean of the given set of ordered data.
   This variant does not process variances
}{
   \sstdescription{
      The routine forms the trimmed mean of the given dataset.  The
      IGNORE upper and lower ordered values are removed from
      consideration.  Then the remaining values are added and averaged.
      The values not rejected are indicated by setting the flags
      in array used.
   }
   \sstinvocation{
      CALL CCG1\_TMN3x( IGNORE, EL, ORDDAT, USED, TMEAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of entries in ORDDAT.
      }
      \sstsubsection{
         IGNORE = INTEGER (Given)
      }{
         The number of values to ignore from the upper and lower orders.
      }
      \sstsubsection{
         ORDDAT( EL ) = ? (Given)
      }{
         The set of ordered data for which a trimmed mean is required.
      }
      \sstsubsection{
         USED( EL ) = LOGICAL (Returned)
      }{
         Flags showing which values have not been rejected.
      }
      \sstsubsection{
         TMEAN = DOUBLE PRECISION (Returned)
      }{
         The trimmed mean.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The ORDDAT
         argument supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   CCG\_TRM2x
}{
   Forms the trimmed mean of the given set of ordered data,
   returning flags showing which values are used
}{
   \sstdescription{
      The routine forms the trimmed mean of the given dataset. The
      alpha (as a fraction) upper and lower ordered values are removed
      from consideration.  Then the remaining values are added and
      averaged. The SVAR value is a (given) best estimate of the
      original un-ordered population variance. The variance of the
      output value is formed assuming that the original dataset was
      normal in distribution, and is now fairly represented by the
      ordered statistics variances-covariances supplied in packed form
      in COVAR. The elements of the input array which actually
      contribute to the final value are flagged in the used array.
   }
   \sstinvocation{
      CALL CCG\_TRM2x( ALPHA, EL, ORDDAT, ORDVAR, USED, COVAR,
                      TMEAN, TVAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ALPHA = REAL (Given)
      }{
         The fraction of data to trim from upper and lower orders.
         (MUST BE GREATER THAN 0.0 AND LESS 0.5)
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of entries in ORDDAT.
      }
      \sstsubsection{
         ORDDAT( EL ) = ? (Given)
      }{
         The set of ordered data for which a trimmed mean is required.
      }
      \sstsubsection{
         SVAR = DOUBLE PRECISION (Given)
      }{
         The variance of the unordered sample now ordered in ORDDAT.
      }
      \sstsubsection{
         USED( EL ) = LOGICAL (Returned)
      }{
         If the corresponding value in ORDDAT contributes to the final
         value then this is set true.
      }
      \sstsubsection{
         COVAR( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of size EL.
      }
      \sstsubsection{
         TMEAN = DOUBLE PRECISION (Returned)
      }{
         The trimmed mean.
      }
      \sstsubsection{
         TVAR = DOUBLE PRECISION (Returned)
      }{
         A variance estimate of the trimmed mean.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The variance-covariance array must have been generated in a
         fashion similar to that of ORDVAR.
      }
   }
}
\sstroutine{
   CCG\_TRM3x
}{
   To form the trimmed mean of the given set of ordered data,
   returning flags showing which values are used. This variant does
   not process variances
}{
   \sstdescription{
      The routine forms the trimmed mean of the given dataset. The
      alpha (as a fraction) upper and lower ordered values are removed
      from consideration.  Then the remaining values are added and
      averaged. The elements of the input array which actually
      contribute to the final value are flagged in the used array.
   }
   \sstinvocation{
      CALL CCG\_TRM3x( ALPHA, EL, ORDDAT, USED, TMEAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ALPHA = REAL (Given)
      }{
         The fraction of data to trim from upper and lower orders.
         It must be greater than 0.0 and less than 0.5.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of entries in ORDDAT.
      }
      \sstsubsection{
         ORDDAT( EL ) = ? (Given)
      }{
         The set of ordered data for which a trimmed mean is required.
      }
      \sstsubsection{
         USED( EL ) = LOGICAL (Returned)
      }{
         If the corresponding value in ORDDAT contributes to the final
         value then this is set true.
      }
      \sstsubsection{
         TMEAN = DOUBLE PRECISION (Returned)
      }{
         The trimmed mean.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CCG\_UM1x
}{
   Combines data lines using an unweighted mean
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of data.  The data values in the lines are then
      combined to form an unweighted mean.  The output means
      are returned in the array RESULT.  The output variances are
      estimated from the VARS values and are returned in RESVAR.
   }
   \sstinvocation{
      CALL CCG\_UM1x( NPIX, NLINES, STACK, VARS, MINPIX,
                     RESULT, RESVAR, NCON, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         VARS( NPIX, NLINES ) = ? (Given)
      }{
         The data variances.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel or variance.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
      }
      \sstsubsection{
         RESVAR( NPIX ) = ? (Returned)
      }{
         The output variances.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         RESULT, and RESVAR arguments supplied to the routine must have the
         data type specified.

         \sstitem
         This routine performs its work in double precision.
      }
   }
}
\sstroutine{
   CCG\_UM3x
}{
   Combines data lines using an unweighted mean
}{
   \sstdescription{
      This routine accepts an array consisting a series of (vectorised)
      lines of data.  The data values in the lines are then combined to
      form an unweighted mean.  The output means are returned in the
      array RESULT.
   }
   \sstinvocation{
      CALL CCG\_UM3x( NPIX, NLINES, STACK, MINPIX, RESULT, NCON,
                     NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         STACK( NPIX, NLINES ) = ? (Given)
      }{
         The array of lines which are to be combined into a single line.
      }
      \sstsubsection{
         MINPIX = INTEGER (Given)
      }{
         The minimum number of pixels required to contribute to an
         output pixel.
      }
      \sstsubsection{
         RESULT( NPIX ) = ? (Returned)
      }{
         The output line of data.
         to the output line.
      }
      \sstsubsection{
         NCON( NLINES ) = DOUBLE PRECISION (Returned)
      }{
         The actual number of contributing pixels from each input line
         to the output line.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array created while
         forming the statistics.  It excludes those bad values whose
         corresponding values along the collapse axis are all bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The STACK, VARS,
         and RESULT arguments supplied to the routine must have the data
         type specified.

         \sstitem
         This routine performs its work in double precision.
      }
   }
}
\sstroutine{
   CCG\_WCWIx
}{
   Creates a channel-width array from the channel co-ordinates
}{
   \sstdescription{
      This routine accepts an array consisting of a series of
      (vectorised) lines of co-ordinates.  For each pixel the
      subroutine forms a channel width by halving the difference
      of neighbouring co-ordinates along a line of data, i.e.
      it assumes that therre are no gaps.  The widths for first and
      last pixels are the difference with its interior neighbour.
   }
   \sstinvocation{
      CALL CCG\_WCWIx( NPIX, NLINES, COORDS, WIDTHS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in a line of data.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of lines of data in the stack.
      }
      \sstsubsection{
         COORDS( NPIX, NLINES ) = ? (Given)
      }{
         The world co-ordinates.
      }
      \sstsubsection{
         WIDTHS( NPIX, NLINES ) = ? (Given)
      }{
         The chanel widths.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The COORDS and WIDTHS
         arguments supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   CCG\_WMD2x
}{
   Estimates the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      Not available. Remember to look in EDRS.
   }
   \sstinvocation{
      CALL CCG\_WMD2x( EL, X, W, PBAD, NITER, TOLL, NSIGMA, XMODE,
                      SIGMA, USED, NUSED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         X( EL ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         W( EL ) = ? (Given)
      }{
         An array of data weights for each data value.  The weights are
         inversely proportional to the square of the relative errors on
         each data point.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The sigma level to reject data values at.
      }
      \sstsubsection{
         XMODE = DOUBLE PRECISION (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = DOUBLE PRECISION (Returned)
      }{
         An estimate of the uncorrupted normalised standard deviation of
         the data points.  An estimate of the standard deviation of any
         one point is:  SIGMA / SQRT( W ) where W is its weight.
      }
      \sstsubsection{
         USED( EL ) = LOGICAL (Returned)
      }{
         If a value is not rejected then its corresponding used element
         will be set true.
      }
      \sstsubsection{
         NUSED = INTEGER (Returned)
      }{
         Number of the input data values which are actually used.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The X and W
         arguments supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   CCG\_WMD3x
}{
   Estimates the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      This routine is based on maximising the likelyhood function for
      a statistical model in which any of the data points has a
      constant probability of being corrupt. A weighted mean is formed
      with weights chosen according to the deviation of each data
      point from the current estimate of the mean. The weights are
      derived from the relative probability of being invalid or
      corrupt. A sequence of these iterations converges to a
      stationary point in the likelyhood function. The routine
      approximates to a k-sigma clipping algorithm for a large number
      of points and to a mode estimating algorithm for fewer data
      points.  Different weighting for each data point are allowed to
      accomodate known different intrinsic errors in the input data.

      The variance of the input population is determined from the
      whole population and a new variance is computed, after the
      rejection passes, using the order statistics of a trimmed sample
      with the derived weights and initial numbers. Thus the input data
      should be ordered (either increasing or decreasing) so that means
      which are outliers (due to unstabilities from overly small sigma
      clipping) can have their variance properly estimated.
   }
   \sstinvocation{
      CALL CCG\_WMD3x( EL, ORDDAT, WEIGHT, PBAD, NITER, TOLL, NSIGMA,
                      COVEC, XMODE, FVAR, USED, NUSED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         ORDDAT( EL ) = REAL (Given)
      }{
         An ordered (increasing or decreasing) array of data values.
      }
      \sstsubsection{
         WEIGHT( EL ) = REAL (Given)
      }{
         An array of data weights for each data value.  The weights
         should be the inverse variance of each data point. They are
         used to directly estimate the input population variance.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The sigma level to reject data values at.
      }
      \sstsubsection{
         COVEC( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of size EL, produced by
         CCG\_ORVAR.
      }
      \sstsubsection{
         XMODE = DOUBLE PRECISION (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         FVAR = DOUBLE PRECISION (Returned)
      }{
         An estimate of the uncorrupted variance of the data points.
      }
      \sstsubsection{
         USED( EL ) = LOGICAL (Returned)
      }{
         If a value is not rejected then its corresponding used element
         will be set true.
      }
      \sstsubsection{
         NUSED = INTEGER (Returned)
      }{
         Number of the input data values which are actually used when
         forming the estimate of the mean. This value will be zero or
         less if all values are rejected.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The X and W
         arguments supplied to the routine must have the data type
         specified.

         \sstitem
          The input data must be sorted.  The output variances are only
          accurate if the input data values have a normal distribution.
      }
   }
}
\sstroutine{
   CCG\_WTM2x
}{
   Forms the weighted median of a list of ordered data values.
   Incrementing the contributing pixel buffers
}{
   \sstdescription{
      This routine finds a value which can be associated with the half-
      weight value.  It sums all weights then finds a value for the
      half-weight.  The comparison with the half-weight value proceeds
      in halves of the weights for each data point (half of the first
      weight, then the second half of the first weight and the first
      half of the second weight etc.) until the half weight is exceeded.
      The data values around this half weight position are then found
      and a linear interpolation of these values is the wtdmdn. The
      values which contribute to the result are flagged and passed
      through the USED array.
   }
   \sstinvocation{
      CALL CCG\_WTM2x( EL. ORDDAT, WEIGHT, USED, RESULT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of entries in the data array.
      }
      \sstsubsection{
         ORDDAT( EL ) = ? (Given)
      }{
         The list of ordered data for which the weighted median is
         required
      }
      \sstsubsection{
         WEIGHT( EL ) = ? (Given)
      }{
         The weights of the values.
      }
      \sstsubsection{
         USED = LOGICAL (Returned)
      }{
         If a value contributes to the median value it is flagged as
         true in this array, otherwise the array is set to false.
      }
      \sstsubsection{
         RESULT = DOUBLE PRECISION (Returned)
      }{
         The weighted median
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The ORDDAT and
         WEIGHT arguments supplied to the routine must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The input data must be ordered increasing.  No BAD values may be
         present.
      }
   }
}
\sstroutine{
   CCG\_WTM3x
}{
   Forms the weighted median of a list of ordered data values.
   Incrementing the contributing pixel buffers and estimating the
   variance change
}{
   \sstdescription{
      This routine finds a value which can be associated with the half-
      weight value.  It sums all weights then finds a value for the
      half-weight.  The comparison with the half-weight value proceeds
      in halves of the weights for each data point (half of the first
      weight, then the second half of the first weight and the first
      half of the second weight etc.) until the half weight is
      exceeded. The data values around this half weight position are
      then found and a linear interpolation of these values is the
      weighted median.  The values which contribute to the result are
      flagged and passed through the USED array.  This routine also
      uses the order statistic covariance array (for a population EL
      big) to estimate the change in the variance from a optimal
      measurement from the given population, returning the adjusted
      variance.
   }
   \sstinvocation{
      CALL CCG\_WTM3x( CALCMV, EL, ORDDAT, WEIGHT, VAR, COVAR, USED,
                      RESULT, RESVAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CALCMV = LOGICAL (Given)
      }{
         If .FALSE. then the output variances are estimated by scaling
         the variance on the weighted mean (rather than the weighted
         median) by pi/2.  Otherwise, the output variances are
         calculated using the COVEC array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of entries in the data array.
      }
      \sstsubsection{
         ARR( EL ) = ? (Given)
      }{
         The list of ordered data for which the weighted median is
         required
      }
      \sstsubsection{
         WEIGHT( EL ) = ? (Given)
      }{
         The weights of the values.
      }
      \sstsubsection{
         VAR = DOUBLE PRECISION (Given)
      }{
         The variance of the unordered sample now ordered in ARR.
      }
      \sstsubsection{
         COVAR( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of size EL. Not used if CALCMV is .FALSE.
      }
      \sstsubsection{
         USED( EL ) = LOGICAL (Returned)
      }{
         If a value contributes to the median value it is flagged as
         true in this array, otherwise the array is set to false.
      }
      \sstsubsection{
         RESULT = DOUBLE PRECISION (Returned)
      }{
         The weighted median
      }
      \sstsubsection{
         RESVAR = DOUBLE PRECISION (Returned)
      }{
         The variance of result.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The ORDDAT and
         WEIGHT arguments supplied to the routine must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The input data must be ordered increasing. No BAD values may be
         present.
      }
   }
}
\sstroutine{
   CCG\_WTM4x
}{
   Forms the weighted median of a list of ordered data values.
   Incrementing the contributing pixel buffers and estimating the
   variance change
}{
   \sstdescription{
      This routine finds a value which can be associated with the half-
      weight value.  It sums all weights then finds a value for the
      half-weight.  The comparison with the half-weight value proceeds
      in halves of the weights for each data point (half of the first
      weight, then the second half of the first weight and the first
      half of the second weight etc.) until the half weight is
      exceeded.  The data values around this half weight position are
      then found and a linear interpolation of these values is the
      weighted median.  The values which contribute to the result are
      flagged and passed through the USED array.  This routine also
      uses the order statistic covariance array (for a population EL
      big) to estimate the change in the variance from a optimal
      measurement from the given population, returning the adjusted
      variance.

      This version is specialised to accept bounds for the values that
      can be used in ARR, these are from ARR(LBND:UBND). It is designed
      for use when some outliers of the population have already been
      flagged for removal (say by some clipping algorithm and the
      variance still needs to be determined from the original population
      size).
   }
   \sstinvocation{
      CALL CCG\_WTM4x( EL, ORDDAT, WEIGHT, VAR, LBND, UBND, COVAR,
                      USED, RESULT, RESVAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of entries in the data array.
      }
      \sstsubsection{
         ARR( EL ) = ? (Given)
      }{
         The list of ordered data for which the weighted median is
         required
      }
      \sstsubsection{
         WEIGHT( EL ) = ? (Given)
      }{
         The weights of the values.
      }
      \sstsubsection{
         VAR = DOUBLE PRECISION (Given)
      }{
         The variance of the unordered sample now ordered in ARR.
      }
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         Lower bound of data to be considered in ARR.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         Upper bound of data to be considered in ARR.
      }
      \sstsubsection{
         COVAR( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of size EL.
      }
      \sstsubsection{
         USED( EL ) = LOGICAL (Returned)
      }{
         If a value contributes to the median value it is flagged as
         true in this array, otherwise the array element is set to
         false.
      }
      \sstsubsection{
         RESULT = DOUBLE PRECISION (Returned)
      }{
         The weighted median
      }
      \sstsubsection{
         RESVAR = DOUBLE PRECISION (Returned)
      }{
         The variance of result.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision: replace {\tt "}x{\tt "}
         in the routine name by D or R as appropriate.  The ORDDAT and
         WEIGHT arguments supplied to the routine must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The input data must be ordered increasing. No BAD values may be
         present, although you may restrict the range (LBND, UBND).
      }
   }
}
\sstroutine{
   FTS1\_ASTWN
}{
   Displays any AST warning messages stored in the supplied FitsChan
}{
   \sstdescription{
      The AST library can store warning messages in a FItsChan in the
      form of header cards with the keyword {\tt "}ASTWARN{\tt "}. This routine
      searches for such cards and displays them nicely if any are found.
   }
   \sstinvocation{
      CALL FTS1\_ASTWN( FC, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FC = INTEGER (Given)
      }{
         The AST pointer to the FitsChan.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier for the NDF being created.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_AXIS
}{
   Create an axis structure within an NDF from FITS header
   information
}{
   \sstdescription{
      The routine searches the FITSD header for the keywords that
      describe the axis structure.  If at least one reference value,
      CRVALn, exists then an axis component is created and filled with
      the appropriate values.  CDELTn defines the step between axis
      values.  If it is not present in the header it is set to 1.
      CRPIXn defines the reference pixel to which the reference value
      corresponds.  If is absent form the header pixel 1 is assumed to
      be the reference pixel.  If CTYPEn is in the header it is used to
      assigned a value to the nth axis{\tt '}s label component.

      The precision of the output axis-centre array depends on the
      absolute relative size of the offset to the scale.  Single
      precision is used if this ratio is greater than one hundred times
      the floating-point precision.
   }
   \sstinvocation{
      CALL FTS1\_AXIS( NCARD, HEADER, SCARD, NDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS header {\tt '}cards{\tt '}, each element corresponding to a
         80-character card.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the search will begin.  This
         is needed because the headers make contain a dummy header
         prior to an extension.
      }
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The identifier for the NDF to contain the axis structure.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_BLCAR
}{
   Determines whether or not the first card in a FITS record has a
   blank keyword
}{
   \sstdescription{
      This routine is needed for UNIX portability, since the calling
      application only knows the pointer to the FITS record, and not the
      actual values.  Hence a function is required.
   }
   \sstinvocation{
      RESULT = FTS1\_BLCAR( RECORD )
   }
   \sstarguments{
      \sstsubsection{
         RECORD( 36 ) = CHARACTER $*$ ( 80 ) (Given)
      }{
         The FITS record to be tested.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         FTS1\_BLCAR = LOGICAL
      }{
         If true, the first card image in RECORD has a blank keyword,
         i.e. characters 1 to 8 in the card image are blank.
      }
   }
}
\sstroutine{
   FTS1\_BLVAL
}{
   Blanks out the value from a FITS-header card
}{
   \sstdescription{
      This routine modifies a FITS-header card by replacing the value
      with blank characters, leaving the keyword, value indicator and
      any comment in situ.  If the header has no value, the header is
      returned unchanged.
   }
   \sstinvocation{
      CALL FTS1\_BLVAL( HEADER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         HEADER = CHARACTER $*$ ( 80 ) (Given \& Returned)
      }{
         The FITS-header card.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_BSWAP
}{
   Swaps adjacent bytes in an array of bytes
}{
   \sstdescription{
      This swaps adjacent pairs of bytes in an array in situ.  This is
      VAX specific.
   }
   \sstinvocation{
      CALL FTS1\_BSWAP( NBYTE, BYTES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NBYTE = INTEGER (Returned)
      }{
         Number of bytes.  An SAI\_\_ERROR will be returned if this is not
         an even number.
      }
      \sstsubsection{
         BYTES( NBYTE ) = BYTE (Given and Returned)
      }{
         The 16-bit words whose bytes are to be swapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_COMNT
}{
   Get the value of a FITS COMMENT card from a buffer of cards
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for the next card with keyword COMMENT.  The
      search begins at a defined card image; and ends when the next end
      of a header block, marked by the END keyword, is encountered or
      the buffer is exhausted.  The routine returns the comment string,
      and the number of the card image within the buffer array that
      contains the comment.  If the keyword is is present \%THERE is
      true, otherwise it is false.
   }
   \sstinvocation{
       CALL FTS1\_COMNT( NCARD, BUFFER, STCARD, THERE, VALUE, CARD,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         STCARD = INTEGER (Given)
      }{
         The number of the card from which to search for the next
         comment card
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true the parameter \%NAME is present.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment string of the first COMMENT keyword found at or
         after \%STCARD.  The length should be at least 72 characters.
      }
      \sstsubsection{
         CARD = INTEGER(Returned)
      }{
         The number of the card containing the first COMMENT card.  If
         no COMMENT card could be found this is returned with a value of
         zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_CRNDF
}{
   For a FITS data array create an NDF, generating the NDF{\tt '}s name in
   some circumstances
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to create an output NDF.  In automatic mode
      the filename is generated and put into the parameter to prevent
      prompting.  In manual mode the user is prompted for the file
      name of the NDF.
   }
   \sstinvocation{
       CALL FTS1\_CRNDF( PNNDF, FILROO, GCOUNT, NG, AUTO, FORMAT, NDIM,
      :                 DIMS, NDF, FILNAM, ASSOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter by which the filename of the output
         NDF will be obtained.
      }
      \sstsubsection{
         FILROO = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The rootname of the output NDF.  The suffix Gn, where n=\%NG, is
         appended in group-format mode to generate the filename.
         Otherwise in automatic mode the NDF filename is the rootname.
      }
      \sstsubsection{
         GCOUNT = INTEGER (Given)
      }{
         Number of data arrays in the FITS sub-file.  It should be one
         if there are no groups.
      }
      \sstsubsection{
         NG = INTEGER (Given)
      }{
         Number of the group.  It should be one if there are no groups.
      }
      \sstsubsection{
         AUTO = LOGICAL (Given)
      }{
         If true the processing should be done in automatic mode, where
         the user is not prompted for file names, since these are
         generated from the prefix, file and sub-file numbers.
      }
      \sstsubsection{
         FORMAT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The destination HDS format of the data array in the output
         file.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Dimensionality of the NDF.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF.
      }
      \sstsubsection{
         NDF = INTEGER (Returned)
      }{
         The identifier of the created NDF.
      }
      \sstsubsection{
         FILNAM = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The filename of the output NDF.
      }
      \sstsubsection{
         ASSOC = LOGICAL (Returned)
      }{
         If false the NDF name was generated automatically.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_DREAD
}{
   Obtains a FITS record from a disk file
}{
   \sstdescription{
      This routine reads the byte stream from the FITS disk file
      and extracts a FITS record of 2880 bytes.  The blocksize of
      the disk file is arbitrary save that it be no more than the
      maximum FITS blocksize of 28800.
   }
   \sstinvocation{
       CALL FTS1\_DREAD ( LU, BLKSIZ, ACTSIZ, LINIT, BUFFER, OFFSET,
      :                  RECORD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LU = INTEGER (Given)
      }{
         The logical unit number for the disk-FITS file.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the file block.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size.  This need not be a multiple of the
         FITS record length of 2880 bytes.  It must be known on input.
      }
      \sstsubsection{
         LINIT = LOGICAL (Given)
      }{
         If true, the current record counter (RECNUM) is reset to one.
         Should be true if a file is being read for the first time.
      }
      \sstsubsection{
         BUFFER( ACTSIZ ) = BYTE (Given and Returned)
      }{
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         RECORD( 2880 ) = BYTE (Returned)
      }{
         The current FITS record.  Successive calls will read of the
         FITS records in sequence.
      }
      \sstsubsection{
         STATUS  = INTEGER(Given and Returned)
      }{
         Global status value.
      }
   }
   \sstdiytopic{
      Prior requirements
   }{
      \sstitemlist{

         \sstitem
         The disk file should already be open and the first block
         read.
      }
   }
}
\sstroutine{
   FTS1\_DTYPE
}{
   Obtain the input data type, scales and offsets for a FITS file
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to define the input data types, the scale
      factor and offset, the data-blank value, the number of bytes per
      data values.  This includes the group count, number of parameters
      per group and their group scalings for a non-standard data array.
   }
   \sstinvocation{
       CALL FTS1\_DTYPE( DARRAY, NONSDA, BITPIX, SCARD, NCARD, HEADER,
      :                 MXPARM, NDIM, DIMS, BSCALE, BZERO, BLANK, BADPIX,
      :                 IEEE, GCOUNT, PCOUNT, PTYPE, PSCALE, PZERO,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DARRAY = LOGICAL (Given)
      }{
         If true there is a data array present if the FITS file.
      }
      \sstsubsection{
         NONSDA = LOGICAL (Given)
      }{
         If true the data array is not standard, i.e. in group format.
         It is ignored if \%DARRAY is false.
      }
      \sstsubsection{
         BITPIX = INTEGER (Given)
      }{
         The value of the BITPIX keyword in the FITS header, i.e. the
         number of bits per data value.  If it is negative this
         indicates an IEEE-format file.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the searches of the header
         will begin.  This is needed because the headers make contain a
         dummy header prior to an extension.
      }
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the header.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS headers in 80-character records.
      }
      \sstsubsection{
         MXPARM = INTEGER (Given)
      }{
         The maximum number of group parameters, and the dimension size
         for the various group arrays.
      }
      \sstsubsection{
         NDIM = INTEGER (Given and Returned)
      }{
         Dimensionality of the data array.  It may be modified if a)
         there is no data array, because a valid NDF must have a data
         array with physical dimensions (set to 1); or b) it is a
         non-standard array (i.e. groups) where the first dimension is
         zero, and so the dimensionality is reduced by one.
      }
      \sstsubsection{
         DIMS( DAT\_\_MXDIM ) = INTEGER (Given and Returned)
      }{
         The dimensions of the table.  It may be modified if a)
         there is no data array, because a valid NDF must have a data
         array with physical dimensions (set to 2 in 1-d); or b) it is
         a non-standard array (i.e. groups) where the first dimension
         is zero, and so the dimension sizes are shifted down one
         dimension.
      }
      \sstsubsection{
         BSCALE = REAL (Returned)
      }{
         The scale factor of the FITS integer data for their conversion
         to the true floating-point values.
      }
      \sstsubsection{
         BZERO = REAL (Returned)
      }{
         The offset of the FITS integer data for their conversion to
         the true floating-point values.
      }
      \sstsubsection{
         BLANK = INTEGER (Returned)
      }{
         The data-blank value equivalent to the bad-pixel flag.  It
         should be ignored if \%BADPIX is false.
      }
      \sstsubsection{
         BADPIX = LOGICAL (Returned)
      }{
         If true the data-blank was defined in the FITS header.
      }
      \sstsubsection{
         IEEE = LOGICAL (Returned)
      }{
         If true the FITS data are in IEEE floating-point format.
      }
      \sstsubsection{
         GCOUNT = INTEGER (Returned)
      }{
         The number of groups in the FITS sub-file.
      }
      \sstsubsection{
         PCOUNT = INTEGER (Returned)
      }{
         The number of group parameters in each group.
      }
      \sstsubsection{
         PTYPE( MXPARM ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The type (descriptive name) of each group parameter.
      }
      \sstsubsection{
         PSCALE( MXPARM ) = DOUBLE PRECISION (Returned)
      }{
         The scale factors of the group parameters so that the
         parameters may be converted to the true floating-point values.
      }
      \sstsubsection{
         PZERO( MXPARM ) = DOUBLE PRECISION (Returned)
      }{
         The offsets of the group parameters so that the parameters may
         be converted to the true floating-point values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The non-standard case of a floating-point data-blank value (BLANK)
      is handled assuming it is the true blank value as opposed to the
      blank value in the FITS data.  This is achieved by subtracting the
      offset and dividing by the scale factor and taking the nearest
      integer.
   }
}
\sstroutine{
   FTS1\_EDFEX
}{
   Edits non-reserved keyword cards in a FITS extension of an NDF
}{
   \sstdescription{
      This subroutine edits a number of non-reserved keyword cards in
      the FITS extension of an NDF file.  This subroutine inserts,
      updates, moves, deletes, reports, and tests the existence of a
      number of keyword cards in the FITS extension of an NDF.  The
      occurrence of keywords may be defined, when there are more than
      one cards of the same name.  The location of each insertion or
      move is immediately before some occurrence of a corresponding
      keyword.

      This routine itself merely deals with accessing and enlarging the
      FITS extension, obtaining worksapce, and being able to pass the
      mapped character arrays in the desired order to routine
      FTS1\_EDKEY via a dummy routine.  FTS1\_EDKEY actually performs the
      editing; look there for more details of the editing functions and
      rules.
   }
   \sstinvocation{
      CALL FTS1\_EDFEX( NKEY, EDITS, NAMES, PSTNS, KOCCUR, POCCUR,
                       VALUES, COMNTS, TYPES, FTSLOC, THERE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NKEY = INTEGER (Given)
      }{
         The number of keyword cards to be inserted into the FITS
         extension.
      }
      \sstsubsection{
         EDITS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The editing commands.  These need only be one character per
         element.  Allowed values are {\tt '}Amend{\tt '}, {\tt '}Delete{\tt '}, {\tt '}Exist{\tt '},
         {\tt '}Move{\tt '}, {\tt '}Null{\tt '}{\tt '}, {\tt '}Rename{\tt '}, {\tt '}Print{\tt '}, {\tt '}Update{\tt '}, and {\tt '}Write{\tt '},
         which can be abbreviated to the initial letter.

         {\tt '}Amend{\tt '} acts as {\tt '}Update{\tt '} if the keyword exists, but as {\tt '}Write{\tt '}
         if the keyword is absent.

         {\tt '}Delete{\tt '} removes a named keyword.

         {\tt '}Exist{\tt '} reports TRUE to standard output if the named keyword
         exists in the header, and FALSE if the keyword is not present.

         {\tt '}Move{\tt '} relocates a named keyword to be immediately before a
         second keyword.  When this positional keyword is not supplied,
         it defaults to the END card, and if the END card is absent,
         the new location is at the end of the headers.

         {\tt '}Null{\tt '} nullifies the value of the named keyword.  Spaces
         substitute the keyword{\tt '}s value.

         {\tt '}Print{\tt '} causes the value of a named keyword to be displayed to
         standard output.  This will be a blank for a comment card.

         {\tt '}Rename{\tt '} renames a keyword, using the value as the new keyword.

         {\tt '}Update{\tt '} revises the value and/or the comment.  If a secondary
         keyword is defined explicitly, the card may be relocated at
         the same time.  If the secondary keyword does not exist, the
         card being edited is not moved.  Update requires that the
         keyword being edited exists.

         {\tt '}Write{\tt '} creates a new card given a value and an optional
         comment.  Its location uses the same rules as for the Move
         command.
      }
      \sstsubsection{
         NAMES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names of the keywords to be edited in the FITS card array.
         A name may be compound to handle hierarchical keywords, and it
         has the form keyword1.keyword2.keyword3 etc.  The maximum
         number of keywords per FITS card is 20.  Each keyword must be
         no longer than 8 characters, and be a valid FITS keyword
         comprising alphanumeric characters, hyphen, and unsderscore.
         Any lowercase letters are converted to uppercase and blanks
         are removed before inserted or comparison with the existing
         keywords.

         The keywords {\tt '} {\tt '}, {\tt '}COMMENT{\tt '}, and {\tt '}HISTORY{\tt '} are comment cards
         and do not have a value.

         The keyword must exist except for the Write and Exist commands.
      }
      \sstsubsection{
         PSTNS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The position keyword names.  A position name may be compound
         to handle hierarchical keywords, and it has the form
         keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is twenty.  Each keyword must be no
         longer than eight characters.  When locating the position card,
         comparisons are made in uppercase and with the blanks removed.

         The new keywords are inserted immediately before each
         corresponding position keyword.  If any name in it does not
         exist in FITS array, the consequences will be as follows.  In
         the Write, Amend (new keyword), and Move edits its
         corresponding keyword will be inserted just before the END
         card or appended to FITS array when the END card does not
         exist; however, the card is not relocated for an Update or
         Amend (with an existing keyword) edit.  If two or more new
         cards have the same position name, they will all be put just
         before the position name in the same order as they are in
         NAMES.

         A positional keyword is used by the Move, Write, Amend, and
         Update editing commands.
      }
      \sstsubsection{
         KOCCUR( NKEY ) = INTEGER (Given)
      }{
         The occurrences of the NAMES keywords to use.  Values less than
         or equal to 1 will manipulate the first occurrence of the
         keyword to insert.
      }
      \sstsubsection{
         POCCUR( NKEY ) = INTEGER (Given)
      }{
         The occurrences of the PSTNS keywords to use.  Values less than
         or equal to 1 will situate the inserted keyword immediately
         before the first occurrence of the positional keyword.
      }
      \sstsubsection{
         VALUES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The new values of the NAMES keywords for the Update and Write
         editing commands.  The special value {\tt '}\$V{\tt '} means use the
         current value of the NAMES keyword.  This makes it possible to
         modify a comment, leaving the value unaltered.  In addition
         \$V(keyword) requests that the value of the keyword given
         between the parentheses be assigned to the keyword being
         edited.  This positional keyword must exist and have a value
         for a Write edit; whereas the FITS-header value is unchanged
         for Update if there are problems with this positional keyword.

         For a Rename edit, VALUES has a different meaning; in this
         case it stores the replacement keyword name.
      }
      \sstsubsection{
         COMNTS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The comments to be written to the NAMES keywords for the
         Update and Write editing commands.  The special value {\tt '}\$C{\tt '}
         means use the current comment.  In addition \$C(keyword)
         requests that the comment of the keyword given between the
         parentheses be assigned to the keyword being edited.  If this
         positional keyword does not exist the comment is unchanged for
         Update, and is blank for a Write edit.
      }
      \sstsubsection{
         TYPES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The data types of the values to Write or Update.  This does
         allow some numeric or logical values to be written as strings.
         These will be one of the following: {\tt '}\_CHAR{\tt '},  {\tt '}\_DOUBLE{\tt '},
         {\tt '}\_INTEGER{\tt '}, {\tt '}\_LOGICAL{\tt '}, {\tt '}\_REAL{\tt '}.  In addition there are two
         special values: {\tt '}COMMENT{\tt '} to indicate that the card is a
         comment (so strictly it has no type), and {\tt '} {\tt '} to indicate that
         the data type is unknown, as occurs for a value defined by a
         reference keyword.  The length should be at least 8
         characters.
      }
      \sstsubsection{
         FTSLOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The locator to the FITS extension of the NDF.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         Result of final {\tt "}Exist{\tt "} operation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The FITS extension is mapped for update access.  It therefore must
      have some values assigned before using the routine.
   }
}
\sstroutine{
   FTS1\_EDKEY
}{
   Edits keywords in a FITS card array
}{
   \sstdescription{
      This subroutine inserts, updates, moves, deletes, reports, and
      tests the existence of a number of keyword cards in a FITS-header
      array.  The occurrence of keywords may be defined, when there are
      more than one cards of the same name.  The location of each
      insertion or move is immediately before some occurrence of a
      corresponding keyword.  The routine returns the modified
      FITS-header array.
   }
   \sstinvocation{
      CALL FTS1\_EDKEY( NOCARD, NKEY, MXCARD, EDITS, NAMES, PSTNS,
                       KOCCUR, POCCUR, VALUES, COMNTS, TYPES, FTSCAR,
                       ACTNUM, IARY1, IARY2, CARY, EXISTS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NOCARD = INTEGER (Given)
      }{
         Number of cards in the original FITS array.
      }
      \sstsubsection{
         NKEY = INTEGER (Given)
      }{
         The number of keyword cards to be inserted into the FITS-header
         array.
      }
      \sstsubsection{
         MXCARD = INTEGER (Given)
      }{
         Maximum number of cards in the resultant FITS array.  This must
         be not less than NOCARD $+$ NKEY $+$ 1.
      }
      \sstsubsection{
         EDITS( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The editing commands.  Allowed values are {\tt '}Amend{\tt '}, {\tt '}Delete{\tt '},
         {\tt '}Exist{\tt '}, {\tt '}Move{\tt '}, {\tt '}Rename{\tt '}, {\tt '}Print{\tt '}, {\tt '}Update{\tt '}, and {\tt '}Write{\tt '}.
         Each element can be abbreviated to the initial letter.

         {\tt '}Amend{\tt '} acts as {\tt '}Update{\tt '} if the keyword exists, but as {\tt '}Write{\tt '}
         if the keyword is absent.

         {\tt '}Delete{\tt '} removes a named keyword.

         {\tt '}Exist{\tt '} reports TRUE to standard output if the named keyword
         exists in the header, and FALSE if the keyword is not present.

         {\tt '}Move{\tt '} relocates a named keyword to be immediately before a
         second keyword.  When this positional keyword is not supplied,
         it defaults to the END card, and if the END card is absent,
         the new location is at the end of the headers.

         {\tt '}Null{\tt '} nullifies the value of the named keyword.  Spaces
         substitute the keyword{\tt '}s value.

         {\tt '}Print{\tt '} causes the value of a named keyword to be displayed to
         standard output.  This will be a blank for a comment card.

         {\tt '}Rename{\tt '} renames a keyword, using the value as the new keyword.

         {\tt '}Update{\tt '} revises the value and/or the comment.  If a secondary
         keyword is defined explicitly, the card may be relocated at
         the same time.  If the secondary keyword does not exist, the
         card being edited is not moved.  Update requires that the
         keyword being edited exists.

         {\tt '}Write{\tt '} creates a new card given a value and an optional
         comment.  Its location uses the same rules as for the Move
         command.
      }
      \sstsubsection{
         NAMES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names of the keywords to be edited in the FITS card
         array.  A name may be compound to handle hierarchical
         keywords, and it has the form keyword1.keyword2.keyword3 etc.
         The maximum number of keywords per FITS card is twenty.  Each
         keyword must be no longer than eight characters, and be a valid
         FITS keyword comprising alphanumeric characters, hyphen, and
         unsderscore.  Any lowercase letters are converted to uppercase
         and blanks are removed before inserted or comparison with the
         existing keywords.

         The keywords {\tt '} {\tt '}, {\tt '}COMMENT{\tt '}, and {\tt '}HISTORY{\tt '} are comment cards
         and do not have a value.

         The keyword must exist except for the Amend, Write, and Exist
         commands.
      }
      \sstsubsection{
         PSTNS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The position keyword names.  A position name may be compound
         to handle hierarchical keywords, and it has the form
         keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is twenty.  Each keyword must be no
         longer than eight characters.  When locating the position card,
         comparisons are made in uppercase and with the blanks removed.

         The new keywords are inserted immediately before each
         corresponding position keyword.  If any name in it does not
         exist in FITS array, the consequences will be as follows.  In
         the Write, Amend (new keyword), and Move edits its
         corresponding keyword will be inserted just before the END
         card or appended to FITS array when the END card does not
         exist; however, the card is not relocated for an Update or
         Amend (with an existing keyword) edit.  If two or more new
         cards have the same position name, they will all be put just
         before the position name in the same order as they are in
         NAMES.

         A positional keyword is used by the Move, Write, Amend, and
         Update editing commands.
      }
      \sstsubsection{
         KOCCUR( NKEY ) = INTEGER (Given)
      }{
         The occurrences of the NAMES keywords to use.  Values less than
         or equal to 1 will manipulate the first occurrence of the
         keyword to insert.
      }
      \sstsubsection{
         POCCUR( NKEY ) = INTEGER (Given)
      }{
         The occurrences of the PSTNS keywords to use.  Values less than
         or equal to 1 will situate the inserted keyword immediately
         before the first occurrence of the positional keyword.
      }
      \sstsubsection{
         VALUES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The new values of the NAMES keywords for the Update and Write
         editing commands.  The special value {\tt '}\$V{\tt '} means use the
         current value of the NAMES keyword.  This makes it possible to
         modify a comment, leaving the value unaltered.  In addition
         \$V(keyword) requests that the value of the keyword given
         between the parentheses be assigned to the keyword being
         edited.  This positional keyword must exist and have a value
         for a Write edit; whereas the FITS-header value is unchanged
         for Update if there are problems with this positional keyword.
         edited.

         For a Rename edit, VALUES has a different meaning; in this
         case it stores the replacement keyword name.
      }
      \sstsubsection{
         COMNTS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The comments to be written to the NAMES keywords for the Amend,
         Update, and Write editing commands.  The special value {\tt '}\$C{\tt '}
         means use the current comment.  In addition \$C(keyword)
         requests that the comment of the keyword given between the
         parentheses be assigned to the keyword being edited.  If this
         positional keyword does not exist the comment is unchanged for
         Update, and is blank for a Write edit.
      }
      \sstsubsection{
         TYPES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The data types of the values to Write or Update.  This does
         allow some numeric or logical values to be written as strings.
         These will be one of the following: {\tt '}\_CHAR{\tt '},  {\tt '}\_DOUBLE{\tt '},
         {\tt '}\_INTEGER{\tt '}, {\tt '}\_LOGICAL{\tt '}, {\tt '}\_REAL{\tt '}.  In addition there are two
         special values: {\tt '}COMMENT{\tt '} to indicate that the card is a
         comment (so strictly it has no type), and {\tt '} {\tt '} to indicate that
         the data type is unknown, as occurs for a value defined by a
         reference keyword.  The length should be at least eight
         characters.
      }
      \sstsubsection{
         FTSCAR( MXCARD ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry its first NOCARD elements hold the original FITS
         cards. On exit, its first ACTNUM elements hold the FITS cards
         after the insersion.
      }
      \sstsubsection{
         ACTNUM = INTEGER (Returned)
      }{
         The actual number of cards in the FITS array after inserting.
      }
      \sstsubsection{
         IARY1( MXCARD ) = INTEGER (Returned)
      }{
         The first temporary working space.
      }
      \sstsubsection{
         IARY2( MXCARD ) = INTEGER (Returned)
      }{
         The second temporary working space.
      }
      \sstsubsection{
         CARY( MXCARD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         A temporary working space.
      }
      \sstsubsection{
         EXISTS = LOGICAL (Returned)
      }{
         The result of the last {\tt "}Exist{\tt "} operation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         When an error occurs during editing, warning messages are sent
         at the normal reporting level, and processing continues to the
         next editing command.

         \sstitem
         The FITS fixed format is used for writing or updating
         headers, except for double-precision values requiring more space.
         The comment is delineated from the value by the string {\tt '} / {\tt '}.

         \sstitem
         The comments in comment cards begin one space following the
         keyword or from column 10 whichever is greater.

         \sstitem
         At present the following reserved keywords are neither
         modifiable nor movable: SIMPLE, BITPIX, NAXIS, NAXISn, EXTEND,
         PCOUNT, GCOUNT, XTENSION, BLOCKED, and END.  This is because
         order in the extension should be fixed and should not be
         changed by any routine.
      }
   }
}
\sstroutine{
   FTS1\_EVKEY
}{
   Extracts a keyword and occurrence, and validates the keyword
}{
   \sstdescription{
      This routine serves FTS1\_RFMOD.  It takes a string containing a
      keyword and an optional occurrence in brackets, and extracts the
      keyword and any occurrence.  It validates the keyword or the
      hierarchical keywords.  It also returns the length of the keyword.
   }
   \sstinvocation{
      CALL FTS1\_EVKEY( STRING, KEYWRD, LENGTH, OCCUR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the keyword or hierarchical keyword in
         the form keyword1.keyword2.keyword3 etc.  There may be a
         trailing [number] string which defines the occcurence of the
         keyword.
      }
      \sstsubsection{
         KEYWRD = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The extracted keyword in uppercase.  The supplied length is
         recommended to be at least 48 to allow for six full-length
         keywords.
      }
      \sstsubsection{
         LENGTH = INTEGER (Returned)
      }{
         The length in characters of the keyword, so the keyword is
         KEYWRD( :LENGTH ).
      }
      \sstsubsection{
         OCCUR = INTEGER (Returned)
      }{
         The occurrence of the keyword to use.  If none is supplied in
         the STRING or the value is not a positive integer, OCCUR is
         assigned the value 1.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_FNDFS
}{
   Read the first FrameSet from the supplied FitsChan
}{
   \sstdescription{
      This routine reads Objects from the supplied FitsChan until a
      FrameSet is obtained, and returns the FrameSet.
   }
   \sstinvocation{
      CALL FTS1\_FNDFS( FC, OBJ, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FC = INTEGER (Given)
      }{
         An AST pointer to the FitsChan.
      }
      \sstsubsection{
         OBJ = INTEGER (Given)
      }{
         The AST pointer to the FrameSet.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The FitsChan is not rewound before reading. The first read
         starts at the current Card in the FitsChan.

         \sstitem
         No value is set for the FitsChan Encoding attribute.

         \sstitem
         OBJ is returned equal to AST\_\_NULL if no FrameSet can be read
         from the supplied FitsChan, or if an error occurs.
      }
   }
}
\sstroutine{
   FTS1\_FRMT
}{
   Obtain the input and output data format for a FITS file
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to define the input and output data formats
      (HDS types).
   }
   \sstinvocation{
       CALL FTS1\_FRMT( BITPIX, IEEE, FMTCNV, BPV, FMTIN, FMTOUT,
      :                STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BITPIX = INTEGER (Given)
      }{
         The value of the BITPIX keyword in the FITS header, i.e. the
         number of bits per data value.  If it is negative this
         indicates an IEEE-format file.
      }
      \sstsubsection{
         IEEE = LOGICAL (Given)
      }{
         If true the FITS data are in IEEE floating-point format.
      }
      \sstsubsection{
         FMTCNV = LOGICAL (Given)
      }{
         If true, format conversion from the integer FITS data to
         the real output data array is required.
      }
      \sstsubsection{
         BPV = INTEGER (Returned)
      }{
         The number of bytes per data value.
      }
      \sstsubsection{
         FMTIN = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The HDS format of the data in the FITS file.
      }
      \sstsubsection{
         FMTOUT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The destination HDS format of the data array in the output
         file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_FTWCS
}{
   Uses coordinate system information in the supplied FITS headers
   to create WCS and AXIS components in an NDF
}{
   \sstdescription{
      This constructs an AST FrameSet from the supplied FITS headers
      and adds it into the existing WCS information in the supplied NDF.
      It can also create AXIS structures (see below).

      The information needed to create the FrameSet can be stored
      several times in a single FITS header, using different keywords
      each time. Each of these descriptions is known as an {\tt "}encoding{\tt "}
      and AST supports several different encoding schemes (e.g.
      FITS-WCS, FITS-IRAF, DSS, NATIVE).  If the supplied FITS header
      contains more than one encoding then we need to choose which one
      to use. This decision is important because is is possible for
      encodings to be inconsistent (i.e. software may modify one
      encoding without making equivalent modifications to the other
      encodings). The simplest way to make this decision is to hand
      responsibility for it over to the user. In this case, the user
      supplies a list of preferred encodings, and the first of these
      encodings that exists in the FITS header gets used. If the user
      does not know which encoding to use, then we can make an
      intelligent guess by comparing the encodings to see which ones are
      consistent and which ones are not.

      In addition to the WCS component, this routine also creates AXIS
      Centre, Label and Units components in the NDF, but only if they do
      not already exist, and if the FrameSet read from the FITS header
      contains an AXIS Frame. NDF2FITS does not write out the AXIS Frame
      if it is equivalent to pixel co-ordinates, and so no AXIS
      structures will be created by this routine in this case. Also, if
      the AXIS Frame represents linear axis co-ordinates, then there
      will already be AXIS structures in the NDF (created earlier within
      FITSIN), and so again no AXIS  structures will be created by this
      routine. Thus, this routine will only create AXIS structures in
      the cases where the axis co-ordinates are non-linear.
   }
   \sstinvocation{
      CALL FTS1\_FTWCS( NCARD, HEADER, SCARD, INDF, NENCOD, ENCODS,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of cards in the array of headers, from the start of
         the first header section to the end of the current one.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where searches will begin, and
         copying of the headers to the FITS extension.   Therefore
         NCARD - SCARD $+$ 1 headers will appear in the extension. This
         argument is needed because the headers make contain a dummy
         header prior to an extension.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         NENCOD = INTEGER (Given)
      }{
         The number of encodings supplied in ENCODS.
      }
      \sstsubsection{
         ENCODS( NENCOD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The user{\tt '}s preferred AST encodings. If NENCOD is zero, then
         this is ignored, and an intelligent guess is made as to which
         encoding to use (see FTS1\_WCSIM).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_GKEYC
}{
   Gets the value and comment of a named header of type CHARACTER
   from a buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for a keyword NAME; and returns its value (as a
      character string) and comment, and the number of the card image
      within the buffer array that contains the named keyword.  The
      search ends when the next end of a header block, marked by the
      END keyword, is encountered or the buffer is exhausted.  If the
      keyword is present THERE is true, otherwise it is false.  If the
      keyword is expected to be present more than once then the
      argument NOCCUR controls which occurrence will be retrieved.  If
      a keyword is not found then no error results and the argument
      VALUE remains unmodified.

      The name may be compound to permit reading of hierarchical
      keywords (with a blank regulation keyword).  This routine will
      also work for HISTORY, COMMENT and the {\tt '} {\tt '} (blank) keyword
      comment cards.  Cards without an equals sign present are also
      regarded as comment cards.  Comment cards have no returned
      value, only a comment.
   }
   \sstinvocation{
      CALL FTS1\_GKEYC( NCARD, BUFFER, SCARD, NAME, NOCCUR, THERE, VALUE,
                       COMENT, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the search will begin.  This
         is needed because the headers may contain a dummy header
         prior to an extension.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword whose value is required.  This may be
         a compound name to handle hierarchical keywords, and it has
         the form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         NOCCUR = INTEGER (Given)
      }{
         The value of this argument specifies which occurrence of a
         keyword should be used, if multiple ones are expected.  Any
         value less than or equal to 1 indicates the first occurrence.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If .TRUE., the keyword given by argument NAME is present,
         regardless of the exit status.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The value of the keyword.  The string is truncated to the
         length of VALUE if the FITS value contains more characters than
         that.
      }
      \sstsubsection{
         COMENT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment associated with the keyword.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the card containing the named keyword.  If the
         card could not be found this is set to zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_GPARM
}{
   Add the group parameters to the FITS header records
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to add the group parameters to the HDS
      structure that contains the FITS header cards.  It also writes
      the group parameters to a log file is required.

      Each group parameter is evaluated in double precision from its
      scale and offset, and with the parameter name a pseudo FITS
      card is generated.  In the header structure the last card---has
      the END keyword---is overwritten. Once all the group parameters
      have been copied into the header structure, an END card is placed
      after them to preserve a valid FITS header section.
   }
   \sstinvocation{
       CALL FTS1\_GPARM( NCARD, HEADER, PCOUNT, PARAMS, PTYPE, PSCALE,
      :                 PZERO, BAD, BLANK, LOGHDR, FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of header 80-character cards in the original FITS
         header.  It excludes the number of group parameters.
      }
      \sstsubsection{
         HEADER( NCARD $+$ PCOUNT ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS headers in 80-character cards.  The aditional PCOUNT
         elements are for the group parameters.
      }
      \sstsubsection{
         PCOUNT = INTEGER (Given)
      }{
         The number of group parameters in each group.
      }
      \sstsubsection{
         PARAMS( PCOUNT ) = INTEGER (Given)
      }{
         The values of the group parameters in the header, i.e. before
         any scale and offset have been applied.
      }
      \sstsubsection{
         PTYPE( PCOUNT ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The type (descriptive name) of each group parameter.
      }
      \sstsubsection{
         PSCALE( PCOUNT ) = DOUBLE PRECISION (Given)
      }{
         The scale factors of the group parameters so that the
         parameters may be converted to the true floating-point values.
      }
      \sstsubsection{
         PZERO( PCOUNT ) = DOUBLE PRECISION (Given)
      }{
         The offsets of the group parameters so that the parameters may
         be converted to the true floating-point values.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true, testing and replacement of undefined parameters is to
         occur.  A blank value, as specified by \%BLANK, is replaced
         by the standard magic value.  If false, the value of \%BLANK
         is ignored.
      }
      \sstsubsection{
         BLANK = INTEGER (Given)
      }{
         Value of an undefined parameter.
      }
      \sstsubsection{
         LOGHDR = LOGICAL (Given)
      }{
         If true the evaluated group parameters written in FITS-card
         format will be written to the log file.
      }
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor for the log file.  It is ignored if \%LOGHDR
         is false.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_GVALC
}{
   Extracts a string value from a FITS header
}{
   \sstdescription{
      This routines determines the location of a character value within
      a FITS header and hence the value itself.  The location of the
      delimiting quote marks and string value are returned.
   }
   \sstinvocation{
      CALL FTS1\_GVALC( HEADER, CSTART, CEND, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         HEADER = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The FITS header {\tt '}card{\tt '} whose value is to be extractd.
      }
      \sstsubsection{
         CSTART = INTEGER (Given)
      }{
         The column containing the leading quote of the string value.
         This is set to zero if no string value could be found.
      }
      \sstsubsection{
         CEND = INTEGER (Given)
      }{
         The column containing the trailing quote of the string value.
         This is set to zero if no string value could be found.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The character value.  CARD should contain at least 68
         characters.  A blabnnk string is returned if the header failed
         to contain a character value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         It is assumed that the header conforms to the FITS Standard,
         with one exception.  Single quotes within a string---these should
         be doubled---are detected provided that the next solidus after a
         single quote will be a comment delimiter rather than literal text
         in the string.
      }
   }
}
\sstroutine{
   FTS1\_HDLOG
}{
   Outputs the FITS header cards to an ASCII file
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to write the FITS header cards (80-character)
      into an ASCII file.  A heading is also written giving the
      file and sub-file numbers.  The maximum record length of the
      ASCII file supported by this routine is 132 characters.  The
      minimum is 80 characters---an error is reported if it is smaller
      than 80.

      The file name appears in the caption before the headers.  It may
      be truncated if it is longer than the file recordsize less 30
      characters.  Truncation occurs at the start of the name and is
      designated via an ellipsis.
   }
   \sstinvocation{
      CALL FTS1\_HDLOG( HEADER, FD, CFN, SUBFIL, NHEADS, HDNUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         HEADER( $*$ ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS headers in 80-character records.
      }
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor for the log file.
      }
      \sstsubsection{
         CFN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The input filename or tape file number of the FITS file being
         processed.
      }
      \sstsubsection{
         SUBFIL = INTEGER (Given)
      }{
         The number of the sub-file/extension within the current FITS
         file being processed.
      }
      \sstsubsection{
         NHEADS = INTEGER (Given)
      }{
         The number of header sections in the sub-file.  This includes
         dummy FITS header sections.
      }
      \sstsubsection{
         HDNUM( $*$ ) = INTEGER (Given)
      }{
         The number of header cards within each header in the sub-file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The ASCII file must be opened.
      }
   }
}
\sstroutine{
   FTS1\_I2VXD
}{
   Converts a vector of 64-bit IEEE floating-point numbers to Vax-D
   format
}{
   \sstdescription{
      This is a dummy routine used to build the KAPPA FITS readers on
      UNIX.
   }
   \sstinvocation{
      CALL FTS1\_I2VXD( BSWAP, EL, BUF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BSWAP = LOGICAL (Given)
      }{
         Whether or not adjacent bytes are to be swapped.  If and only
         if BSWAP is 1 will the bytes be swapped.  Swapping must occur
         either prior or within this routine to obtain the correct
         Vax-D values.  An expression must not be given for this
         argument.  Bytes in the order 1 2 3 4 5 6 7 8 become
         2 1 4 3 6 5 8 7 after swapping.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of IEEE numbers to be converted.
      }
      \sstsubsection{
         BUF( EL ) = DOUBLE PRECISION (Given and Returned)
      }{
         On input the IEEE numbers to be converted.  On return these
         are converted to Vax-D format.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         {\tt "}IEEE Standard for Binary Floating-Point Arithmetic{\tt "},
         ANSI/IEEE 754, 1985.

         \sstitem
         {\tt "}Floating Point Agreement for FITS{\tt "}, D.C. Wells \& P. Grosbol,
         1990.
      }
   }
}
\sstroutine{
   FTS1\_I2VXR
}{
   Converts a vector of 32-bit IEEE floating-point numbers to Vax-F
   format
}{
   \sstdescription{
      This is a dummy routine used to build the KAPPA FITS readers on
      UNIX.
   }
   \sstinvocation{
      CALL FTS1\_I2VXR( BSWAP, WSWAP, EL, BUF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BSWAP = INTEGER (Given)
      }{
         Whether or not byte swapping is to take place.  If and only if
         BSWAP is 1 will the bytes be swapped.  Swapping must occur
         either prior or within this routine to obtain the correct Vax-F
         values.  An expression must not be given for this argument.
      }
      \sstsubsection{
         WSWAP = INTEGER (Given)
      }{
         Whether or not word swapping is to take place.  If and only if
         WSWAP is 1 will the words be swapped.  Swapping must occur
         either prior or within this routine to obtain the correct Vax-F
         values.  An expression must not be given for this argument.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of IEEE numbers to be converted.
      }
      \sstsubsection{
         BUF( EL ) = DOUBLE PRECISION (Given and Returned)
      }{
         On input the IEEE numbers to be converted.  On return these
         are converted to Vax-F format.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         {\tt "}IEEE Standard for Binary Floating-Point Arithmetic{\tt "},
         ANSI/IEEE 754, 1985.

         \sstitem
         {\tt "}Floating Point Agreement for FITS{\tt "}, D.C. Wells \& P. Grosbol,
         1990.
      }
   }
}
\sstroutine{
   FTS1\_INKEY
}{
   Insert keywords to a FITS card array
}{
   \sstdescription{
      This subroutine inserts a number of keyword cards into a
      FITS-header array just before some given keywords, and returns
      the position of these newly inserted cards in the FITS array
      after insertion.  If a given position keyword is not in the FITS
      header or is blank, its corresponding keyword card will be
      inserted just before the end card or appended to the present FITS
      array when end card does not exist.  If a keyword card to be
      inserted already exists in the FITS array, that card will
      be deleted and moved to the specified position.  For those new
      keyword cards, an equals sign {\tt '}={\tt '} will be put at the 9th column
      for simple keyword or immediately after keywords for compound
      ones; and a character value {\tt '}\{undefined\}{\tt '} will be given to them.

      The following reserved keywords are not modified: SIMPLE, BITPIX,
      NAXIS, NAXISn, EXTEND, PCOUNT, GCOUNT, XTENSION, BLOCKED, and END.
   }
   \sstinvocation{
      CALL FTS1\_INKEY( NOLDCA, NKEY, NAMES, PSTNS, FTSCAR,
      :                ACTNUM, IARY1, IARY2, CARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NOLDCA = INTEGER (Given)
      }{
         Number of cards in the original FITS array.
      }
      \sstsubsection{
         NKEY = INTEGER (Given)
      }{
         The number of keyword cards to be inserted into the FITS-header
         array.
      }
      \sstsubsection{
         NAMES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The keywords to be inserted into FITS card array.
      }
      \sstsubsection{
         PSTNS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The position keyword names, before them the new keywords is
         inserted.  If any name in it does not exit in FITS array, its
         corresponding keyword will be inserted just before the end card
         or appended to FITS array when end card does not exist.  If two
         or more new cards have the same position name, they will all be
         put just before the position name in the same order as they are
         in NAMES.
      }
      \sstsubsection{
         FTSCAR( NOLDCA $+$ NKEY ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry its first NOLDCA elements hold the original FITS
         cards. On exit, its first ACTNUM elements hold the FITS cards
         after the insersion.
      }
      \sstsubsection{
         ACTNUM = INTEGER (Returned)
      }{
         The actual number of cards in the FITS array after inserting.
      }
      \sstsubsection{
         IARY1( NOLDCA $+$ NKEY ) = INTEGER (Returned)
      }{
         The first temporary working space.
      }
      \sstsubsection{
         IARY2( NOLDCA $+$ NKEY ) = INTEGER (Returned)
      }{
         The second temporary working space.
      }
      \sstsubsection{
         CARY( NOLDCA $+$ NKEY ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         A temporary working space.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_ISKEY
}{
   Inquires whether or not a string is a valid FITS keyword
}{
   \sstdescription{
      This routine tests whether a given string would be a valid FITS
      header keyword or not.  For a keyword to be valid it must be
      no more than eight characters, and must comprise only uppercase
      Latin letters, numbers, underscore, and hyphen.
   }
   \sstinvocation{
      CALL FTS1\_ISKEY( KEYWRD, VALID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         KEYWRD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string to be tested.
      }
      \sstsubsection{
         VALID = LOGICAL (Returned)
      }{
         If true, the string is a valid FITS header keyword.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine does not convert the string to uppercase or remove
      leading blanks before validation.
   }
}
\sstroutine{
   FTS1\_LOKEY
}{
   Locates an occurrence of a keyword in a FITS header
}{
   \sstdescription{
      This routines find the location of a certain occurrence of a
      named keyword in an array of FITS headers.  Hierarchical
      keywords are allowed.  A bad status is returned if the desired
      keyword is not present in the header array.
   }
   \sstinvocation{
      CALL FTS1\_LOKEY( NCARD, HEADER, KEYWRD, OCCUR, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of cards in the FITS header array.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ ( 80 ) (Given)
      }{
         The array of FITS headers.
      }
      \sstsubsection{
         KEYWRD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The keyword to search for in the array.  This may be a
         compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         OCCUR = INTEGER (Given)
      }{
         The occurrence of the keyword to locate.  Values less than 1
         obtain the first occurrence.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of card containing the desired keyword.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_MANDH
}{
   Obtain the values of the mandatory headers in a FITS file
}{
   \sstdescription{
      This routine searches for the mandatory FITS header keywords
      stored in a buffer, and their values are returned, if they
      are present.  Should an item be missing or have an unsupported
      value an error is reported, a bad status is set and the routine
      exits. This version supports mandatory descriptors that are not
      in the correct order.

      Currently, only simple FITS and group-format FITS are supported.

      The number of dimensions is reduced when the highest dimension is
      one.
   }
   \sstinvocation{
      CALL FTS1\_MANDH( FIRST, NCARD, HEADER, SCARD, BITPIX, NDIM, AXIS,
                       DARRAY, NONSDA, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FIRST = LOGICAL (Given)
      }{
         If true the buffer contains the first header of a FITS file.
         It is used to validate the header.
      }
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the header.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The array of headers (80-character cards) to be searched for
         the mandatory keywords.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the searches of the header
         will begin.  This is needed because the headers make contain a
         dummy header prior to an extension.
      }
      \sstsubsection{
         BITPIX = INTEGER (Returned)
      }{
         The number of bits per pixel of the data array.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         The number of active dimensions.
      }
      \sstsubsection{
         AXIS( DAT\_\_MXDIM ) = INTEGER (Returned)
      }{
         The dimensions of the data array.
      }
      \sstsubsection{
         DARRAY = LOGICAL (Returned)
      }{
         If true there is a data array.
      }
      \sstsubsection{
         NONSDA = LOGICAL (Returned)
      }{
         If true the data array is non-standard.
      }
      \sstsubsection{
         SIZE = INTEGER  (Returned)
      }{
         The number of pixels in the (or each) data array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_NDFCM
}{
   Create the title, units, axes, wcs, and FITS extension in an NDF
   from the FITS headers
}{
   \sstdescription{
      This routine adds the character components, axis structure, WCS
      component and FITS extension to an NDF.  It searches a buffer
      containing the FITS header card images for the OBJECT keyword
      whose value, if present, becomes the NDF title.  Similarly BUNIT
      is mapped to the NDF units.  The supplied header structure is
      copied to the FITS extension.
   }
   \sstinvocation{
      CALL FTS1\_NDFCM( NCARD, HEADER, SCARD, NDF, NENCOD, ENCODS,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of cards in the array of headers, from the start of
         the first header section to the end of the current one.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where searches will begin, and
         copying of the headers to the FITS extension.   Therefore
         NCARD - SCARD $+$ 1 headers will appear in the extension. This
         argument is needed because the headers make contain a dummy
         header prior to an extension.
      }
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         Identifier of the NDF to which to write the additional
         components and the FITS extension.
      }
      \sstsubsection{
         NENCOD = INTEGER (Given)
      }{
         The number of AST encodings supplied in ENCODS.
      }
      \sstsubsection{
         ENCODS( NENCOD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The user{\tt '}s preferred AST encodings.  If NENCOD is zero, then
         this is ignored, and an intelligent guess is made as to which
         encoding to use.  The encoding determines which FITS headers
         are used to create the NDF WCS component.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_NDF
}{
   Makes an NDF from a simple or group-format FITS file
}{
   \sstdescription{
      This is a server routine for FITSIN/FITSDIN, hence the large
      argument list.  It packages up the operations required to create
      and name an NDF; copy the FITS data to the NDF{\tt '}s data array,
      performing a data conversion if requested and flagging blank data
      with the standard bad-pixel values; generate the other
      components: title, units, WCS, axis structure and the FITS
      extension.  For group-format FITS data, a series of NDFs are
      created, one per group, each with a generated filename.  A null
      NDF may be given and this routine will exit, but permit the
      calling routine to continue to the next FITS file.
   }
   \sstinvocation{
      CALL FTS1\_NDF( HEADER, BFPNTR, RCPNTR, AUTO, PNNDF, MEDIUM, MD,
                     VMS, LENDIA, SIZE, NDIM, DIMS, BPV, FMTCNV, FMTIN,
                     FMTOUT, IEEE, BADPIX, BLANK, BSCALE, BZERO, DARRAY,
                     NONSDA, GCOUNT, PCOUNT, MXPARM, PTYPE, PSCALE,
                     PZERO, FILROO, LOGHDR, FD, CFN, SUBFIL, GEXTND,
                     NCARD, HEADER, SCARD, NENCOD, ENCODS, BLKSIZ,
                     ACTSIZ, OFFSET, CURREC, NEXT, PARAMS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         HEADER( $*$ ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS headers in 80-character records.
      }
      \sstsubsection{
         BFPNTR = INTEGER (Given)
      }{
         Pointer to BUFFER( BLKSIZ ) = CHARACTER $*$ ( 1 ) (Given and
         Returned).  The buffer containing the block of data.  This is
         only read when \%OFFSET does not equal \%ACTSIZ, i.e. there are
         some non-header data within it.
      }
      \sstsubsection{
         RCPNTR = INTEGER (Given)
      }{
         Pointer to RECORD( 36 ) = CHARACTER $*$ ( 80 ) (Given and
         Returned).  The buffer to hold the current FITS record.
      }
      \sstsubsection{
         AUTO = LOGICAL (Given)
      }{
         If true the processing should be done in automatic mode, where
         the user is not prompted for file names, since these are
         generated from \%FILROO with the sub-file or group numbers
         appended.
      }
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter by which the filename of the output
         NDF will be obtained.
      }
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported are
         {\tt '}DISK{\tt '} for a disk file, and {\tt '}TAPE{\tt '} for standard magnetic tape.
      }
      \sstsubsection{
         MD = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         VMS = LOGICAL (Given)
      }{
         If true, the operating system is VMS or RSX.  If false, the
         operating system is assumed to be UNIX.
      }
      \sstsubsection{
         LENDIA = LOGICAL (Given)
      }{
         If true, the machine uses Little Endian byte order (bytes
         swapped compared to FITS).  LENDIA is ignored when
         VMS = .TRUE..
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The number of elements in the data array.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Dimensionality of the NDF.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF.
      }
      \sstsubsection{
         BPV = INTEGER (Given)
      }{
         The number of bytes per data value.
      }
      \sstsubsection{
         FMTCNV = LOGICAL (Given)
      }{
         If true, format conversion from the integer FITS data to
         the real output data array is required.  This is ignored
         when BADPIX is false (which should be the case for IEEE
         floating-point data).
      }
      \sstsubsection{
         FMTIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The HDS format of the data in the FITS file.  It will be
         ignored if there is no format conversion.
      }
      \sstsubsection{
         FMTOUT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The destination HDS format of the data array in the output
         file.
      }
      \sstsubsection{
         IEEE = LOGICAL (Given)
      }{
         If true the FITS data are in IEEE floating-point format.
      }
      \sstsubsection{
         BADPIX = LOGICAL (Given)
      }{
         If true the data-blank was defined in the FITS header.  It
         will be ignored if the data are in IEEE format.
      }
      \sstsubsection{
         BLANK = INTEGER (Given)
      }{
         The data-blank value equivalent to the bad-pixel flag.  It
         should be ignored if \%BADPIX is false.
      }
      \sstsubsection{
         BSCALE = REAL (Given)
      }{
         The scale factor of the FITS integer data for their conversion
         to the true floating-point values.
      }
      \sstsubsection{
         BZERO = REAL (Given)
      }{
         The offset of the FITS integer data for their conversion to
         the true floating-point values.
      }
      \sstsubsection{
         DARRAY = LOGICAL (Given)
      }{
         If true there is a data array present if the FITS file.
      }
      \sstsubsection{
         NONSDA = LOGICAL (Given)
      }{
         If true the data array is not standard, i.e. in group format.
         It is ignored if \%DARRAY is false.
      }
      \sstsubsection{
         GCOUNT = INTEGER (Given)
      }{
         The number of groups in the file.
      }
      \sstsubsection{
         PCOUNT = INTEGER (Given)
      }{
         The number of parameters per group in the file.
      }
      \sstsubsection{
         MXPARM = INTEGER (Given)
      }{
         The maximum number of group parameters, and the dimension size
         for the various group arrays.
      }
      \sstsubsection{
         PTYPE( MXPARM ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The type (descriptive name) of each group parameter.
      }
      \sstsubsection{
         PSCALE( MXPARM ) = DOUBLE PRECISION (Given)
      }{
         The scale factors of the group parameters so that the
         parameters may be converted to the true floating-point values.
      }
      \sstsubsection{
         PZERO( MXPARM ) = DOUBLE PRECISION (Given)
      }{
         The offsets of the group parameters so that the parameters may
         be converted to the true floating-point values.
      }
      \sstsubsection{
         FILROO = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The rootname of the output NDF.  The suffix Gn, where n=\%NG, is
         appended in group-format mode to generate the filename.
         Otherwise in automatic mode the NDF filename is the rootname.
      }
      \sstsubsection{
         LOGHDR = LOGICAL (Given)
      }{
         If true there is a log file open and records of the output file
         names will be written to it.
      }
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor for the log file.  It is ignored if \%LOGHDR
         is false.
      }
      \sstsubsection{
         CFN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The number on the tape of the FITS file being processed if
         MEDIUM is {\tt '}TAPE{\tt '}, or the input disk-FITS filename if MEDIUM
         is {\tt '}TAPE{\tt '}.
      }
      \sstsubsection{
         SUBFIL = INTEGER (Given)
      }{
         The number of the sub-file/extension within the current FITS
         file being processed.
      }
      \sstsubsection{
         GEXTND = LOGICAL (Given)
      }{
         If true there may be extensions in the FITS sub-file.
      }
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of header 80-character cards in the header.  Note
         the size of the structure will not do because it will normally
         have unfilled elements at the end, because of the way the
         work space is obtained in quanta.  It should be the sum of the
         headers and the group parameters.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the searches of the header
         will begin.  This is needed because the headers make contain a
         dummy header prior to an extension.
      }
      \sstsubsection{
         NENCOD = INTEGER (Given)
      }{
         The number of AST encodings supplied in ENCODS.
      }
      \sstsubsection{
         ENCODS( NENCOD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The user{\tt '}s preferred AST encodings.  If NENCOD is zero, then
         this is ignored, and an intelligent guess is made as to which
         encoding to use.  The encoding determines which FITS headers
         are used to create the NDF WCS component.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the tape/disk buffer.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         CURREC = LOGICAL (Given and Returned)
      }{
         If true the current FITS record is to be used immediately, i.e.
         it has alrady been read from tape or disk into \%RECORD.
      }
      \sstsubsection{
         NEXT = LOGICAL (Returned)
      }{
         This qualifies the status.  If true it instructs the calling
         routine to go to the next FITS sub-file, and if status is bad
         the calling routine should flush the error messages.
      }
      \sstsubsection{
         PARAMS( MXPARM $*$ BPV ) = BYTE (Returned)
      }{
         Numerical values of parameters associated with a group-format
         array.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_PHEAD
}{
   Process the headers in a FITS file on tape or disk
}{
   \sstdescription{
      This routine reads selected files off a FITS tape or disk and
      writes the header data into an HDS file, and they are reported to
      the user.  The dimension of the HDS buffer array in the HDS
      structure is enlarged if the buffer is filled.  The number of
      bytes of header cards in the last data block (of the current
      file) containing header data is returned.  This is to enable
      other routines to know where the data array starts in that
      buffer.  If this number equals the actual blocksize this means a
      new data block needs to be read to access the data array.
   }
   \sstinvocation{
       CALL FTS1\_PHEAD( BFPNTR, RCPNTR, RECORD, MEDIUM, MD, LOC, BLKSIZ,
      :                 MAXHDR, REPORT, ACTSIZ, OFFSET, CURREC, HSTART,
      :                 HDNUM, EXTEND, NHEADS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BFPNTR = INTEGER  (Given)
      }{
         Pointer to the BUFFER byte array
      }
      \sstsubsection{
         RCPNTR = INTEGER  (Given)
      }{
         Pointer to the RECORD byte array
      }
      \sstsubsection{
         RECORD( 36 ) = CHARACTER $*$ ( 80 ) (Given and Returned)
      }{
         The buffer to hold the current FITS record.  Note that this
         out of order for SGP/16, but it is needed here so that a
         mapped array may be passed.  This is a temporary kludge until
         the FITS readers are redesigned.
      }
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported is
         {\tt '}DISK{\tt '} for a disk file.
      }
      \sstsubsection{
         MD = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given)
      }{
         The locator to the HDS object that will contain the header
         cards.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the data buffer.
      }
      \sstsubsection{
         MAXHDR = INTEGER (Given)
      }{
         The maximum number of header sections in the current sub-file.
      }
      \sstsubsection{
         REPORT = LOGICAL (Given)
      }{
         If true the header cards are reported to the user.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted
         as the header plus any earlier sub files.
      }
      \sstsubsection{
         CURREC = LOGICAL (Given and Returned)
      }{
         If true the current FITS record is to be used immediately, i.e.
         it has alrady been read from tape or disk into \%RECORD.  On
         exit it is true when a new record has been read to determine
         whether or not there is an extension, but no extension is
         found.
      }
      \sstsubsection{
         HSTART( MAXHDR ) = INTEGER (Returned)
      }{
         The number of the header card where each FITS header starts.
      }
      \sstsubsection{
         HDNUM( MAXHDR ) = INTEGER (Returned)
      }{
         The number of header records processed and stored in the
         output data structure, one per header section in the current
         sub-file.
      }
      \sstsubsection{
         EXTEND = LOGICAL (Returned)
      }{
         If true there are extensions in the FITS sub-file.
      }
      \sstsubsection{
         NHEADS = INTEGER (Returned)
      }{
         The number of header sections in the sub-file.  This includes
         dummy FITS header sections.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_PRVAL
}{
   Prints the value of a specified card in an array of FITS headers
}{
   \sstdescription{
      This routine reports the value of a keyword in an array of FITS
      headers via the Messaging system.  It also returns the value and
      comment assoiciated with the header.  Hierarchical keywords are
      allowed.  A bad status is returned if the desired keyword is not
      present in the header array, or the card index is out of bounds.
   }
   \sstinvocation{
      CALL FTS1\_PRVAL( NCARD, HEADER, KEYWRD, OCCUR, CARD, SVALUE,
                       COMENT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of cards in the FITS header array.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ ( 80 ) (Given)
      }{
         The array of FITS headers.
      }
      \sstsubsection{
         KEYWRD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The keyword to search for in the array.  This may be a
         compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         OCCUR = INTEGER (Given)
      }{
         The occurrence of the keyword to locate.  Values less than 1
         obtain the first occurrence.
      }
      \sstsubsection{
         CARD = INTEGER (Given)
      }{
         The index number of card containing the desired keyword.
         Must be between 1 and NCARD.
      }
      \sstsubsection{
         SVALUE =  CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The value.  This should have length of at least 68 characters.
      }
      \sstsubsection{
         COMENT =  CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The value.  This should have length of at least 60 characters,
         although normally 47 characters suffice.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The comments and values are extracted from a single card.
   }
}
\sstroutine{
   FTS1\_PTKEY
}{
   Puts non-reserved keyword cards into the FITS extension of an NDF
   file
}{
   \sstdescription{
      This subroutine inserts a number of non-reserved keyword cards
      into the FITS extension of an NDF file at the positions just
      before a specified keyword card.  If a keyword card exists in the
      extension, the routine will move the card to the specified
      position.  This provides a way to relocate the existing keyword
      card.  If a keyword card does not exist in the extension, the
      routine will put the keyword card at the specified position and
      will add an equals sign to it, at column 9 for simple keywords or
      immediately after the keyword for compound ones.  To those newly
      added keywords, a character value {\tt '}\{undefined\}{\tt '} is assigned.  To
      write new values for these keywords, you should use subroutine
      FTS1\_WKEYx.

      Following keywords are regarded as reserved keywords: SIMPLE,
      BITPIX, NAXIS, NAXISn, EXTEND, PCOUNT, GCOUNT and XTENSION.
      Their order in the extension should be fixed and should not be
      changed by any routine.  Therefore if any of them is included in
      the NAMES, it will be ignored.

      This subroutine can not be used to insert comment cards, that is,
      the cards with keyword {\tt '}COMMENT{\tt '} or {\tt '}HISTORY{\tt '}, etc.
   }
   \sstinvocation{
      CALL FTS1\_PTKEY( FTSLOC, NKEY, NAMES, PSTNS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FTSLOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The locator to the FITS extension of the NDF.
      }
      \sstsubsection{
         NKEY = INTEGER (Given)
      }{
         The number of keyword cards to be inserted into the FITS
         extension.
      }
      \sstsubsection{
         NAMES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names of the keywords to be inserted.  This may be a
         compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Each keyword must be no longer
         than 8 characters.  When inserted, the lower case letters are
         converted to uppercase and blanks are removed.
      }
      \sstsubsection{
         PSTNS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names of the cards before which the corresponding new
         keyword cards are inserted.  If any name in PSTNS does not
         exist in the original FITS card array or is blank, its
         corresponding new card will be inserted just before end-card
         or be appended to the original FITS card array when there is no
         end-card.  If two or more new cards have the same PSTNS name,
         they will all be put before the PSTNS name in the same order
         as they are in NAMES.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The FITS extension is mapped for update access.  It therefore must
      have some values assigned before using the routine.
   }
}
\sstroutine{
   FTS1\_QTYPE
}{
   Determines the data type of a FITS header value
}{
   \sstdescription{
      This routine takes a FITS header card and determines the HDS data
      type of the value.  If there is no value because there is no
      equals sign present or the keyword is HISTORY or COMMENT, the
      type is returned as {\tt '}COMMENT{\tt '}.
   }
   \sstinvocation{
      CALL FTS1\_QTYPE( CARD, TYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CARD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The FITS header card.  It should be 80 character long, but
         the routine might work with less depending on the length of
         the value and keyword.
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The HDS data type of the header{\tt '}s value.   It is one of the
         following: {\tt '}\_INTEGER{\tt '}, {\tt '}\_REAL{\tt '}, {\tt '}\_DOUBLE{\tt '}, {\tt '}\_LOGICAL{\tt '}, {\tt '}\_CHAR{\tt '},
         or {\tt '}COMMENT{\tt '}.  The length should be at least
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_RDATA
}{
   Read the data of a FITS file on disk or tape
}{
   \sstdescription{
      This routine reads the byte stream in the data blocks from the
      FITS tape or disk file written in the simple format, and writes
      the data into an array.  The bytes may be reversed for VAX/VMS.
   }
   \sstinvocation{
       CALL FTS1\_RDATA ( MEDIUM, MD, SIZE, BPV, REVERS, BLKSIZ, ACTSIZ,
      :                  BUFFER, OFFSET, RECORD, RDISP, DARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported is
         {\tt '}DISK{\tt '} for a disk file.
      }
      \sstsubsection{
         MD     = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         SIZE   = INTEGER (Given)
      }{
         Number of elements in the data array.
      }
      \sstsubsection{
         BPV    = INTEGER (Given)
      }{
         The number of bytes per data value.
      }
      \sstsubsection{
         REVERS = LOGICAL (Given)
      }{
         If true the FITS data bytes are to be reversed within each
         word (when BPV is 2) or each integer (when BPV is 4) etc.  If
         BPV=1 this flags makes no difference.  Normally, only 2{\tt '}s
         complement integer data need be reversed.  Floating-point data
         require adjacent bytes to be swapped.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the tape/disk buffer.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         BUFFER( BLKSIZ ) = BYTE (Given and Returned)
      }{
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         RECORD( 2880 ) = BYTE (Given and Returned)
      }{
         The buffer to hold the current FITS record.
      }
      \sstsubsection{
         RDISP = INTEGER (Given and Returned)
      }{
         The number of bytes in the current record already interpreted.
         If this displacement is equal to the record length then a new
         FITS record will be obtained.  The displacement will be updated
         during processing of the group parameters and data, and
         therefore can have an arbitrary value between 0 and 2880.  Do
         not modify this argument outside this routine once initialised.
      }
      \sstsubsection{
         DARRAY( SIZE $*$ BPV ) = BYTE (Returned)
      }{
         The data array used to store the data read.
      }
      \sstsubsection{
         STATUS  = INTEGER(Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_RFMOD
}{
   Reads a text file containing instructions for editing an NDF{\tt '}s
   FITS extension
}{
   \sstdescription{
      This routines opens a text file and parses it to determine how to
      modify an NDF{\tt '}s FITS extension.  Details of the format and its
      interpretation is given in the item called {\tt "}File Format{\tt "}.  The
      routine returns the editing command, keyword, position, values,
      comment, and data type in arrays.
   }
   \sstinvocation{
      CALL FTS1\_RFMOD( FD, MAXMOD, NWRITE, EDITS, KEYWDS, KEYPOS,
                       KOCCUR, POCCUR, VALUES, COMNTS, TYPES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The FIO identifier of the text file containing the editing
         instructions.
      }
      \sstsubsection{
         MAXMOD = INTEGER (Given)
      }{
         The maximum number of modifications.
      }
      \sstsubsection{
         NWRITE = INTEGER (Returned)
      }{
         The number of modifications actually made.
      }
      \sstsubsection{
         EDITS( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The editing commands.  Thus need only be one character per
         element.
      }
      \sstsubsection{
         KEYWDS( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The FITS keywords to be modified into FITS card array.  The
         length should be at least 48 characters to allow for
         hierarchical keywords.
      }
      \sstsubsection{
         KEYPOS( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The position keyword names.  The new keywords are inserted
         immediately before each corresponding position keyword.
         The length should be at least 48 characters to allow for
         hierarchical keywords.
      }
      \sstsubsection{
         KOCCUR( MAXMOD ) = INTEGER (Returned)
      }{
         The occurrences of the KEYWDS keywords to use.
      }
      \sstsubsection{
         POCCUR( MAXMOD ) = INTEGER (Returned)
      }{
         The occurrences of the KEYPOS keywords to use.
      }
      \sstsubsection{
         VALUES( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The values to be given to the KEYWDS keywords.  The length
         should be at least 68 characters to allow for the maximum
         length of a value.
      }
      \sstsubsection{
         COMNTS( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comments of the NAME keywords to use.  The length should
         be at least 68 characters to allow for the maximum length of a
         comment, but normally 50 should be adequate.
      }
      \sstsubsection{
         TYPES( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The data types of the values to write.  These will be one of
         the following: {\tt '}\_CHAR{\tt '},  {\tt '}\_DOUBLE{\tt '}, {\tt '}\_INTEGER{\tt '}, {\tt '}\_LOGICAL{\tt '},
         {\tt '}\_REAL{\tt '}.  In addition there are two special values: {\tt '}COMMENT{\tt '}
         to indicate that the card is a comment (so strictly it has no
         type), and {\tt '} {\tt '} to indicate that the data type is unknown, as
         occurs for a value defined by a reference keyword.  The length
         should be at least 8 characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      File Format
   }{
      The file consists of a series of lines, one per editing
      instruction, although blank lines and lines beginning with a ! or
      \# are treated as comments.  Note that the order does matter, as
      the edits are performed in the order given.

      The format is summarised below:

        command keyword\{[occur]\}\{(keyword\{[occur]\})\} \{value \{comment\}\}

      where braces indicate optional values, and occur is the
      occurrence of the keyword.  In effect there are four fields
      delineated by spaces that define the edit operation, keyword,
      value and comment.

      Field 1:  This specifies the editing operation.  Allowed values
      are Amend, Delete, Exist, Move, Null, Read, Write, and Update, and
      can be abbreviated to the initial letter.  Delete removes a named
      keyword.  Read causes the value of a named keyword to be
      displayed to standard output.  Exist reports TRUE to standard
      output if the named keyword exists in the header, and FALSE if
      the keyword is not present.  Move relocates a named keyword to be
      immediately before a second keyword.  When this positional
      keyword is not supplied, it defaults to the END card, and if the
      END card is absent, the new location is at the end of the
      headers.  Write creates a new card given a value and an optional
      comment.  Its location uses the same rules as for the Move
      command.  Update revises the value and/or the comment.  If a
      secondary keyword is defined explicitly, the card may be
      relocated at the same time.  Update requires that the keyword
      exists.  Amend behaves as Write if the keyword in Field 2 is
      not already present, or as Update if the keyword exists.  Null
      replaces the value of a named keyword with blanks.

      Field 2:  This specifies the keyword to edit, and optionally the
      position of that keyword in the header after the edit (for Move,
      Write, Update, and Amend edits).  The new position in the header
      is immediately before a positional keyword, whose name is given in
      parentheses concatenated to the edit keyword.  See {\tt "}Field 1{\tt "} for
      defaulting when the position parameter is not defined or is null.

      Both the editing keyword and position keyword may be compound to
      handle hierarchical keywords.  In this case the form is
      keyword1.keyword2.keyword3 etc.  All keywords must be valid FITS
      keywords.  This means they must be no more than 8 characters
      long, and the only permitted characters are uppercase alphabetic,
      numbers, hyphen, and underscore.  Invalid keywords will be
      rejected.

      Both the edit and position keyword may have an occurrence
      specified in brackets [].  This enables editing of a keyword that
      is not the first occurrence of that keyword, or locate a edited
      keyword not at the first occurrence of the positional keyword.
      Note that it is not normal to have multiple occurrences of a
      keyword in a FITS header, unless it is blank, COMMENT or HISTORY.
      Any text other than a positive integer is interpreted as the
      first occurrence.

      Use a null value ({\tt '}{\tt '} or {\tt "}{\tt "}) if you want the card to be a comment
      with keyword other than COMMENT or HISTORY.  As blank keywords are
      used for hierarchical keywords, to write a comment in a blank
      keyword you must give a null edit keyword.  These have no keyword
      appears before the left parenthesis or bracket, such as (), [],
      [2], or (EPOCH).

      Field 3:
      This specifies the value to assign to the edited keyword in the
      the Amend, Write, and Update operations, or the name of the new
      keyword in the Rename modification.  If the keyword exists, the
      existing value or keyword is replaced, as appropriate.  The data
      type used to store the value is inferred from the value itself.
      See topic {\tt "}Value Data Types{\tt "}.

      For the Update and Write modifications there is a special value,
      \$V, which means use the current value of the edited keyword,
      provided that keyword exists.  This makes it possible to modify a
      comment, leaving the value unaltered.  In addition \$V(keyword)
      requests that the value of the keyword given between the
      parentheses be assigned to the keyword being edited.

      The value field is ignored when the keyword is COMMENT, HISTORY
      or blank and the modification is an Update or Write.

      Field 4:
      This specifies the comment to assign to the edited keyword for the
      Amend, Write, and Update operations.  A leading {\tt '}/{\tt '} should not be
      supplied.

      There is a special value, \$C, which means use the current comment
      of the edited keyword, provided that keyword exists.  This makes
      it possible to modify a value, leaving the comment unaltered.  In
      addition \$C(keyword) requests that the comment of the keyword
      given between the parentheses be assigned to the edited keyword.

      To obtain leading spaces before some commentary, use a quote ({\tt '})
      or double quote ({\tt "}) as the first character of the comment.  There
      is no need to terminate the comment with a trailing and matching
      quotation character.  Also do not double quotes should one form
      part of the comment.
   }
   \sstdiytopic{
      Value Data Types
   }{
      The data type of the value is determined as follows:
      \sstitemlist{

         \sstitem
            Values enclosed in quotes ({\tt '}) or doubled quotes ({\tt "}) are
            strings.  Note that numeric or logical string values must
            be quoted to prevent them being converted to a numeric or
            logical value in the FITS extension.

         \sstitem
            Otherwise type conversions of the first word after the
            keywords are made to integer, double precision, and logical
            types in turn.  If a conversion is successful, that becomes the
            data type.  In the case of double precision, the type is set
            to real when the number of significant digits only warrants
            single precision.  If all the conversions failed the value
            is deemed to be a string.
      }
   }
   \sstdiytopic{
      Examples of the File Format
   }{
      The best way to illustrate the options is by listing some example
      lines.

          P AIRMASS
      This reports the value of keyword AIRMASS to standard output.

          E FILTER
      This determines whether keyword FILTER exists and reports TRUE or
      FALSE to standard output.

          D OFFSET
      This deletes the keyword OFFSET.

          Delete OFFSET[2]
      This deletes any second occurrence of keyword OFFSET.

          Rename OFFSET1[2] OFFSET2
      This renames the second occurrence of keyword OFFSET1 to have
      keyword OFFSET2.

          W AIRMASS 1.379
      This writes a real value to new keyword AIRMASS, which will be
      located at the end of the FITS extension.

          A AIRMASS 1.379
      This writes a real value to keyword AIRMASS if it exists,
      otherwise it writes a real value to new keyword AIRMASS located
      at the end of the FITS extension.

          N AIRMASS
      This blanks the value of the AIRMASS keyword, if it exists.

          W FILTER(AIRMASS) Y
      This writes a logical true value to new keyword FILTER, which
      will be located just before the AIRMASS keyword, if it exists.

          Write FILTER(AIRMASS) {\tt '}Y{\tt '}
      As the preceding example except that this writes a character
      value {\tt "}Y{\tt "}.

          W COMMENT(AIRMASS) . Following values apply to mid-observation
      This writes a COMMENT card immediately before the AIRMASS card,
      the comment being {\tt "}Following values apply to mid-observation{\tt "}.

          W DROCOM(AIRMASS) {\tt '}{\tt '} Following values apply to mid-observation
      As the preceding example but this writes to a non-standard
      comment keyword called DROCOM.  Note the need to supply a null
      value.

          W (AIRMASS) {\tt '}{\tt '} Following values apply to mid-observation
      As the preceding example but this writes to a blank-keyword
      comment.

          U OBSERVER {\tt "}Dr. Peter O{\tt '}Leary{\tt "} Name of principal observer
      This updates the OBSERVER keyword with the string value
      {\tt "}Dr. Peter O{\tt '}Leary{\tt "}, and comment {\tt "}Name of principal observer{\tt "}.
      Note that had the value been enclosed in single quotes ({\tt '}), the
      apostrophe would need to be doubled.

          M OFFSET
      This moves the keyword OFFSET to just before the END card.

          Move OFFSET(SCALE)
      This moves the keyword OFFSET to just before the SCALE card.

          Move OFFSET[2](COMMENT[3])
      This moves the second occurrence of keyword OFFSET to just
      before the third COMMENT card.
   }
}
\sstroutine{
   FTS1\_RGRDA
}{
   Read the data of a FITS file in group format from disk or tape
}{
   \sstdescription{
      This routine reads a data block from the FITS tape or disk file
      that has byte stream of data in the groups format, and writes the
      data into an array.  The values of the parameters associated with
      the data array are also obtained.  The bytes may be reversed for
      VAX/VMS.
   }
   \sstinvocation{
       CALL FTS1\_RGRDA ( MEDIUM, MD, SIZE, BPV, REVERS, PCOUNT, BLKSIZ,
      :                  ACTSIZ, BUFFER, OFFSET, RECORD, RDISP, PARAM,
      :                  DARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported is
         {\tt '}DISK{\tt '} for a disk file.
      }
      \sstsubsection{
         MD     = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         SIZE   = INTEGER (Given)
      }{
         Number of elements in the data array.  Note this is not the
         same as the number of bytes.
      }
      \sstsubsection{
         BPV    = INTEGER (Given)
      }{
         The number of bytes per data value.
      }
      \sstsubsection{
         REVERS = LOGICAL (Given)
      }{
         If true the FITS data bytes are to be reversed within each
         word (when BPV is 2) or each integer (when BPV is 4) etc.  If
         BPV=1 this flags makes no difference.  Normally, only 2{\tt '}s
         complement integer data need be reversed.  Floating-point data
         require adjacent bytes to be swapped.  Note that the group
         parameters are by definition in 2{\tt '}s complement integers, so are
         reversed regardless of the sense of this flag.
      }
      \sstsubsection{
         PCOUNT    = INTEGER (Given)
      }{
         The number of parameters associated with the data array.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the tape/disk buffer.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         BUFFER( BLKSIZ ) = BYTE (Given and Returned)
      }{
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         RECORD( 2880 ) = BYTE (Given and Returned)
      }{
         The buffer to hold the current FITS record.
      }
      \sstsubsection{
         RDISP = INTEGER (Given and Returned)
      }{
         The number of bytes in the current record already interpreted.
         If this displacement is equal to the record length then a new
         FITS record will be obtained.  The displacement will be updated
         during processing of the group parameters and data, and
         therefore can have an arbitrary value between 0 and 2880.  Do
         not modify this argument outside this routine once initialised.
      }
      \sstsubsection{
         PARAM( PCOUNT $*$ BPV ) = BYTE (Returned)
      }{
         The parameters associated with the data array.
      }
      \sstsubsection{
         DARRAY( SIZE $*$ BPV ) = BYTE (Returned)
      }{
         The data array.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_ROOTN
}{
   Creates the rootname for an NDF
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to define the rootname for NDFs in
      automatic mode.  The rootname is the prefix followed by the
      file number underscore sub-file number (if present).
   }
   \sstinvocation{
       CALL FTS1\_ROOTN( MEDIUM, FN, SUBFIL, PREFIX, FILROO, NCROOT,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported are
         {\tt '}DISK{\tt '} for a disk file, and {\tt '}TAPE{\tt '} for standard magnetic tape.
      }
      \sstsubsection{
         CFN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The number on the tape of the FITS file being processed if
         MEDIUM is {\tt '}TAPE{\tt '}, or the input disk-FITS filename if MEDIUM
         is {\tt '}TAPE{\tt '}.
      }
      \sstsubsection{
         SUBFIL = INTEGER (Given)
      }{
         The number of the sub-file/extension within the current FITS
         file being processed.
      }
      \sstsubsection{
         PREFIX = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The prefix to be given to the file name of catalogues produced
         in automatic mode.  It is ignored when \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         FILROO = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The root file name of NDFs (to be used in automatic mode).
      }
      \sstsubsection{
         NCROOT = INTEGER (Returned)
      }{
         The length in characters of the rootname.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_RSTAB
}{
   Read the table format from a FITS file and write to an ASCII file
}{
   \sstdescription{
      This routine reads the data blocks from a FITS table-format tape
      or disk file, and creates an ASCII file into which it writes the
      table.
   }
   \sstinvocation{
      CALL FTS1\_RSTAB ( TABLE, MEDIUM, MD, PNTABL, TABNAM, AUTO,
                        AXIS1, AXIS2, BLKSIZ, ACTSIZ, BUFFER,
                        OFFSET, CURREC, RECORD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TABLE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The work buffer to store a line of the table, i.e. must be
         AXIS1$+$1 bytes long.
      }
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported is
         {\tt '}DISK{\tt '} for a disk file.
      }
      \sstsubsection{
         MD     = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         PNTABL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name used to create and associate the table
         file.
      }
      \sstsubsection{
         TABNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The suggested name of the table file, unless \%AUTO is true
         when it is the actual name of the table file to be created.
      }
      \sstsubsection{
         AUTO = LOGICAL (Given)
      }{
         If true the supplied file name is used to open the table file
         rather than obtaining the file name via the parameter system.
      }
      \sstsubsection{
         AXIS1 = INTEGER (Given)
      }{
         Number of characters in a line of the table.
      }
      \sstsubsection{
         AXIS2 = INTEGER (Given)
      }{
         The number of lines in the table.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the tape/disk buffer.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         BUFFER( BLKSIZ ) = BYTE (Given and Returned)
      }{
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         CURREC = LOGICAL (Given and Returned)
      }{
         If true the current FITS record is to be used immediately, i.e.
         it has alrady been read from tape or disk into \%RECORD.
      }
      \sstsubsection{
         RECORD( 2880 ) = BYTE (Given and Returned)
      }{
         The buffer to hold the current FITS record.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_SCOFB
}{
   Applies scale and zero to a REAL data vector, and substitutes
   magic values for blank FITS data
}{
   \sstdescription{
      This routine applies scale and offset to a 1-d REAL array.  Any
      pixels with the \%BLANK value are substituted by the standard
      magic value. On output, pixel is input value times scale plus
      offset.
   }
   \sstinvocation{
       CALL FTS1\_SCOFB ( BSCALE, BZERO, UNDEF, BLANK, SIZE, ARRAY,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BSCALE = REAL (Given)
      }{
         Scale factor to be applied to the array.
      }
      \sstsubsection{
         BZERO = REAL (Given)
      }{
         Offset to be applied to the array.
      }
      \sstsubsection{
         UNDEF = LOGICAL (Given)
      }{
         If true, testing and replacement of undefined data values is
         to occur.  A blank value, as specified by \%BLANK, is replaced
         by the standard magic value.  If false, the value of \%BLANK
         is ignored.
      }
      \sstsubsection{
         BLANK = INTEGER (Given)
      }{
         Value of an undefined datum.
      }
      \sstsubsection{
         SIZE  = INTEGER (Given)
      }{
         Number of elements in the data array.
      }
      \sstsubsection{
         ARRAY( SIZE ) = REAL (Given and Returned)
      }{
         The data array to which scaling and offset is to be applied.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   FTS1\_SCTAB
}{
   Create an ASCII catalogue and description file in SCAR format
   from a FITS tape or disk file
}{
   \sstdescription{
      This is a server routine for FITSIN/FITSDIN.  It packages up the
      operations required to handle a FITS ASCII table file and turn it
      into an ASCII catalogue and SCAR description file.  The names of
      the output files are recorded in the logfile.
   }
   \sstinvocation{
       CALL FTS1\_SCTAB( HEADER, PNDSCF, PNTAB, MEDIUM, MD, NCARD, SCARD,
      :                 NDIM, DIMS, LOGHDR, FD, CFN, SUBFIL, PREFIX,
      :                 AUTO, BLKSIZ, ACTSIZ, BFPNTR, OFFSET, CURREC,
      :                 RCPNTR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS headers in 80-character records.
      }
      \sstsubsection{
         PNDSCF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter by which the filename of the SCAR
         description file will be obtained.
      }
      \sstsubsection{
         PNTAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter by which the filename of the
         table will be obtained.
      }
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported are
         {\tt '}DISK{\tt '} for a disk file, and {\tt '}TAPE{\tt '} for standard magnetic tape.
      }
      \sstsubsection{
         MD = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the searches of the header
         will begin.  This is needed because the headers make contain a
         dummy header prior to an extension.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Dimensionality of the table.  At present only 2-d is supported.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the table.
      }
      \sstsubsection{
         LOGHDR = LOGICAL (Given)
      }{
         If true there is a log file open and records of the output file
         names will be written to it.
      }
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor for the log file.  It is ignored if \%LOGHDR
         is false.
      }
      \sstsubsection{
         CFN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The number on the tape of the FITS file being processed if
         MEDIUM is {\tt '}TAPE{\tt '}, or the input disk-FITS filename if MEDIUM
         is {\tt '}TAPE{\tt '}.
      }
      \sstsubsection{
         SUBFIL = INTEGER (Given)
      }{
         The number of the sub-file/extension within the current FITS
         file being processed.
      }
      \sstsubsection{
         PREFIX = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The prefix to be given to the file name of catalogues produced
         in automatic mode. It is ignored when \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         AUTO = LOGICAL (Given)
      }{
         If true the processing should be done in automatic mode, where
         the user is not prompted for file names, since these are
         generated from the prefix, file and sub-file numbers in the
         case where the medium is tape.  The form is prefix\_file or
         prefix\_file\_subfile if the subfile is greater than 1.
         \%MEDIUM = {\tt '}DISK{\tt '} the prefix is ignored.
      }
      \sstsubsection{
         BLKSIZ = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The maximum block size and dimension of \%BUFFER.
      }
      \sstsubsection{
         ACTSIZ = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The actual block size on tape or disk (a multiple of the FITS
         record length of 2880 bytes). It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         BFPNTR = INTEGER (Given)
      }{
         Pointer to the buffer containing catalogue data, the buffer
         itself will be updated each time a tape block is read.
         If the offset equals the block size then the existing data
         in the buffer will not be used.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted
         as the header plus any earlier FITS files.
      }
      \sstsubsection{
         CURREC = LOGICAL (Given and Returned)
      }{
         If true the current FITS record is to be used immediately, i.e.
         it has alrady been read from tape or disk into \%RECORD.
      }
      \sstsubsection{
         RCPNTR = INTEGER (Given)
      }{
         A pointer to the buffer to hold the current FITS record of 36
         80-character card images.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The magnetic tape or disk file must already be associated, and
         any log file must be opened.
         [routine\_prior\_requirements]...
      }
   }
}
\sstroutine{
   FTS1\_SDSCF
}{
   Create a SCAR description file from a FITS table-format headers
}{
   \sstdescription{
      This routine searches for the mandatory FITS-Tables-format header
      cards stored in a buffer, and their values are returned, if they
      are present. Should an item be missing or have an unsupported
      value an error is reported, a bad status is set and the routine
      exits. This version supports mandatory descriptors that are not
      in the correct order.

      There are two methods of opening the FACTS description file. The
      first associates the file with a parameter. Unfortunately, FIO
      filename parameters cannot be given dynamic values.  Therefore,
      the name of the table in the header card images is presented, and
      the naming rule for an FACTS description file given.  The user has
      to type in the file name, when prompted for the FACTS file to be
      created for ADC(/SCAR) usage. However, in the alternative,
      automatic mode, the supplied file name is used with the DSCF
      prefix to open the FACTS file without recourse to the parameter
      system. Information in the FITS headers is transferred to this
      description file.  The mandatory FACTS parameters for a sequential
      disk file are written plus EPOCH, VERSION, NRECORDS and AUTHOR
      where these are known. These are followed by FACTS records
      describing the fields in the table, and the ENDFIELD record.
      Finally all the comment lines in the FITS header are copied, in
      order, to the FACTS file.  Blank comment entries are inserted in
      the

      The syntax of the field{\tt '}s format descriptor is checked to see that
      it is standard.
   }
   \sstinvocation{
       CALL FTS1\_SDSCF( NCARD, HEADER, SCARD, PNDSCF, AUTO, TABNAM,
      :                 DSCFNM, NDIM, AXIS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the header.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The buffer containing the table-format FITS header.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the searches of the header
         will begin.  This is needed because the headers make contain a
         dummy header prior to an extension.
      }
      \sstsubsection{
         PNDSCF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name used to create and associate the FACTS
         description file. It is only used when \%AUTO is false.
      }
      \sstsubsection{
         AUTO = LOGICAL (Given)
      }{
         If true the supplied file name is used to open the file
         rather than obtaining the file name via the parameter system.
      }
      \sstsubsection{
         TABNAM = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The name of the table file. It is read if \%AUTO is true and
         written when \%AUTO is false.
      }
      \sstsubsection{
         DSCFNM = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the description file.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         The number of active dimensions.
      }
      \sstsubsection{
         AXIS( DAT\_\_MXDIM ) = INTEGER (Returned)
      }{
         The dimensions of the data array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The format specifier for each field is validated.
      }
   }
}
\sstroutine{
   FTS1\_SKIP
}{
   Skip over the data of a FITS file
}{
   \sstdescription{
      This routine skips over the data in a FITS file by reading the
      data blocks from the FITS file.  The file may be basic FITS,
      groups or an extension.
   }
   \sstinvocation{
       CALL FTS1\_SKIP ( MEDIUM, MD, SIZE, BPV, GCOUNT, PCOUNT, BLKSIZ,
      :                 ACTSIZ, BUFFER, OFFSET, RECORD, RDISP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported is
         {\tt '}DISK{\tt '} for a disk file.
      }
      \sstsubsection{
         MD     = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         SIZE   = INTEGER (Given)
      }{
         The number of elements in the data array.
      }
      \sstsubsection{
         BPV    = INTEGER (Given)
      }{
         The number of bytes per data value.
      }
      \sstsubsection{
         GCOUNT = INTEGER (Given)
      }{
         The number of groups in the file.
      }
      \sstsubsection{
         PCOUNT = INTEGER (Given)
      }{
         The number of parameters per group in the file.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the tape buffer.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         BUFFER( BLKSIZ ) = BYTE (Given and Returned)
      }{
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         RDISP = INTEGER (Given and Returned)
      }{
         The number of bytes in the current record already interpreted.
         If this displacement is equal to the record length then a new
         FITS record will be obtained.  The displacement will be updated
         during processing of the group parameters and data, and
         therefore can have an arbitrary value between 0 and 2880.  Do
         not modify this argument outside this routine once initialised.
      }
      \sstsubsection{
         RECORD( 2880 ) = BYTE (Given and Returned)
      }{
         The buffer to hold the current FITS record.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_UKEYC
}{
   Writes the value of type CHARACTER to a keyword from a buffer
   of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for card with keyword \%NAME; and, if found,
      override its original value or with the given character value
      \%VALUE.  The keyword can have a comment string leading by the
      character specified by \%CMTBGN.  In addition comment-type
      keywords---those with keywords COMMENT, HISTORY, and blank,
      or argument COMCAR is .TRUE.---may also have their comments
      revised by \%COMNT (whereupon \%VALUE is ignored).  Selection of
      the desired card (especially important for commentary cards) can
      be controlled by the starting the search at card numbered
      \%STCARD.  The search ends when the next end of a header block,
      marked by the END keyword, is encountered or the buffer is
      exhausted.  If the keyword is present \%THERE is true, otherwise
      it is false.  If the parameter is present more than once in the
      header, only the first occurence will be used.

      The name may be compound to permit writing of hierarchical
      keywords.

      The buffer of FITS header card image should be mapped in the
      {\tt '}UPDATE{\tt '} mode.
   }
   \sstinvocation{
      CALL FTS1\_UKEYC( NCARD, BUFFER, STCARD, NAME, VALUE, CMTBGN,
                       COMNT, COMCAR, THERE, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         STCARD = INTEGER (Given)
      }{
         The number of the card from which to start search.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword to be written a new value.  This may be
         a compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.  The total length must not exceed
         48 characters.  This is to allow for the value, and indentation
         into a blank-keyword card (as hierarchical keywords are not
         standard and so cannot be part of the standard keyword name).
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The value to be used to override the original value of the
         keyword.  It is ignored when the keyword is COMMENT, HISTORY,
         or blank.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
         It is ignored when the keyword is COMMENT, HISTORY, or blank.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value for
         non-commentary keywords.
      }
      \sstsubsection{
         COMCAR = LOGICAL (Given)
      }{
         If .TRUE., the supplied card is a comment and thus the value
         and comment delimiter are ignored, and just the keyword and
         comment string are used to generate the header card.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true, the specified keyword is present.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the last continuation comment card whose contents
         are included in the returned string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.

         \sstitem
         The BUFFER appears out of standard order because when this
         routine is called, BUFFER is expected to be a mapped array.
         This order prevents having to append several \%VAL(length)
         arguments instead of just the one.
      }
   }
}
\sstroutine{
   FTS1\_VHEAD
}{
   Validates a FITS header card and reconstitutes to the standard
}{
   \sstdescription{
      This routines takes a buffer containing text similar to a FITS
      header card and attempts to produce a correctly formatted FITS
      header card.  The validation process performs the following
      checks the input buffer:
        a) the length of the input buffer is no more than 80
        characters, otherwise it is truncated;
        b) the keyword only contains uppercase Latin alphabetic
        characters, numbers, underscore, and hyphen (this is a fatal
        error except for lowercase letters);
        c) value cards have an equals sign in column 9 and a space in
        column 10;
        d) quotes enclose character values;
        e) single quotes inside string values are doubled;
        f) character values are left justified to column 11 (retaining
        leading blanks) and contain at least 8 characters (padding with
        spaces if necessary);
        g) non-character values are right justified to column 30 for
        mandatory keywords, or when the fixed format is requested
        (unless the value is double-precision requiring more than 20
        digits);
        h) the comment delimiter is in column 32 for the mandatory
        keywords or when the fixed format is requested for non-character
        values, or is at least two characters following the value
        otherwise;
        i) an equals sign in column 9 of a commentary card is replaced
        by a space, issuing a warning message at normal reporting
        level; and
        j) comments begin at least two columns after the end of the
        comment delimiter.

      Some non-fatal errors---a), b), c), d), and i)---produce warning
      messages at message level MSG\_\_NORM.
   }
   \sstinvocation{
      CALL FTS1\_VHEAD( BUFFER, FIXED, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BUFFER = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The FITS header {\tt '}card{\tt '} to be validated.
      }
      \sstsubsection{
         FIXED = LOGICAL (Given)
      }{
         If this is .TRUE., all values use the FITS fixed format with
         left-justified character strings starting two columns after
      }
      \sstsubsection{
         CARD = CHARACTER $*$ ( 80 ) (Returned)
      }{
         The validated FITS header {\tt '}card{\tt '}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_WCSAX
}{
   Re-creates AXIS structures from a WCS component FrameSet
}{
   \sstdescription{
      This routine creates NDF Axis structures from an AXIS Frame in the
      supplied FrameSet. It looks for AXIS and PIXEL Frames in the
      supplied FrameSet. If either of these Frames is not found, it does
      nothing. Otherwise, it attempts to create AXIS structures in the NDF
      from the AXIS Frame in the FrameSet. The AXIS Centre, Label and Unit
      components are set.
   }
   \sstinvocation{
      CALL FTS1\_WCSAX( INDF, FS, NDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         FS = INTEGER (Given)
      }{
         An AST pointer for a FrameSet.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes in the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_WCSDF
}{
   Sees if two FrameSets are different after being written to a
   FitsChan
}{
   \sstdescription{
      The returned function value indicates if the two FrameSets are
      inconsistent with each other. The two supplied FrameSets are written
      to two FitsChans, using the specified encoding. All keyword values
      in the two FitsChans are then compared. If any keyword has a
      significantly different value in the two FitsChans, then the
      FrameSets are inconsistent, and a .TRUE value is returned. Otherwise,
      .FALSE. is returned.
   }
   \sstinvocation{
      RETURN = FTS1\_WCSDF( ENCOD, FS1, FS2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ENCOD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The encoding scheme to use when converting the supplied
         FrameSets into FITS header cards.
      }
      \sstsubsection{
         FS1 = INTEGER (Given)
      }{
         An AST pointer to the first FrameSet.
      }
      \sstsubsection{
         FS2 = INTEGER (Given)
      }{
         An AST pointer to the second FrameSet.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A value of .TRUE. is returned if an error has already occurred,
         or if this function should fail for any reason.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      FTS1\_WCSDF = LOGICAL (Returned)
         .TRUE. if the supplied FrameSets are inconsistent, and .FALSE.
         otherwise.
   }
}
\sstroutine{
   FTS1\_WCSIM
}{
   Imports WCS information from the supplied FitsChan into the supplied
   NDF
}{
   \sstdescription{
      An attempt is made to read an AST FrameSet (see SUN/210) from the
      supplied FitsChan. If succesful, it is added into the FrameSet
      representing the NDF{\tt '}s WCS component. This is done by connecting
      the base Frames of the two FrameSets with a UnitMap (on the
      assumption that they are equivalent). The modified FrameSet is
      then stored back in the NDF (the NDF library will automatically
      remove any PIXEL, GRID and AXIS Frames from the FrameSet as these
      are generated afresh each time NDF\_GTWCS is called).

      The supplied FitsChan may contain more than one description (or
      {\tt "}encoding{\tt "}) of the FrameSet to be added to the NDF, each
      encoding using a different set of header cards. These encodings
      may not all be consistent with each other. For instance, if a
      Starlink application stores a FrameSet twice in a FITS header using
      FITS-WCS and AST native encodings, an IRAF application may then
      modify the FITS-WCS encoding without making equivalent modifications
      to the native encoding. In this case, we should use the FITS-WCS
      encoding in preference to the native encoding when reconstructing
      the NDFs WCS component. On the other hand, if the two encodings were
      still consistent, it would be preferable to use the native encoding
      since the FITS-WCS encoding may not give a complete description of the
      original FrameSet.

      The choice of encoding has several stages:

      o  If the caller has supplied a list of preferred encodings in the
      ENCODS argument, then the first available encoding in this list is
      used.
      o  If no preferred encodings are supplied, then a check is made to
      see if a native encoding is available. If there is no native encoding,
      then the default encoding supplied by AST is used. This will be a
      non-native encoding selected on the basis of the header cards available
      in the FitsChan.
      o  If a native encoding is available, and is the only available
      encoding, then it is used.
      o  If both native and non-native encodings are available, then the
      first non-native encoding to be found which is inconsistent with the
      native encoding is used. If all encodings are consistent, then the
      native encoding is used. The first inconsistent encoding is used on
      the assumption that software which modifies the native encoding
      (i.e. mainly Starlink software) will also modify the non-native
      encodings so that they remain consistent. Foreign software however
      (i.e. non-AST software) will probably not bother to modify the native
      encoding when the non-native encoding is modified.
   }
   \sstinvocation{
      CALL FTS1\_WCSIM( FC, INDF, NENCOD, ENCODS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FC = INTEGER (Given)
      }{
         An AST pointer to the FitsChan in which to store the NDF{\tt '}s WCS
         information.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         NENCOD = INTEGER (Given)
      }{
         The number of encodings supplied in ENCODS.
      }
      \sstsubsection{
         ENCODS( NENCOD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The preferred encodings to use, in order of preference (most
         preferable first). Ignored if NENCOD is zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_WCSUT
}{
   Remove the spurious copy of the AXIS Frame which is left in
   WCS component when using non-Native encodings
}{
   \sstdescription{
      This routine removes the Current Frame in the WCS component of an
      NDF if no value has been set for its Domain attribute, and if it
      corresponds closely to the AXIS Frame (i.e. if the Mapping from the
      Current Frame to the AXIS Frame is nearly a UnitMap).

      When using non-Native encoding, the AXIS Frame written by NDF2FITS
      will not have any associated Domain value, and so will not be
      recognised by the NDF library as an AXIS Frame when it is read back
      in by FITS2NDF. The Frame will therefore be left in the WCS
      component of the NDF, even though it is in reality a copy of the AXIS
      Frame. This routine removes such Frames.
   }
   \sstinvocation{
      CALL FTS1\_WCSUT( INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_WKEYC
}{
   Writes a FITS-header card for a CHARACTER value or a comment
}{
   \sstdescription{
      This routine writes a FITS-header card using the supplied keyword,
      value, comment, and comment delimiter.  The card is either a
      character string value, or a comment card.  The latter occurs when
      the keyword is blank, HISTORY or COMMENT, or the COMCAR argument
      is .TRUE.; in this case both the supplied value and comment
      delimiter are ignored.  The name may be compound to permit
      writing of hierarchical keywords.
   }
   \sstinvocation{
      CALL FTS1\_WKEYC( NAME, VALUE, CMTBGN, COMNT, COMCAR, HEADER,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword to be written.  This may be a compound
         name to handle hierarchical keywords, and it has the form
         keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  The value is converted to
         uppercase and blanks are removed before being used.  Each
         keyword must be no longer than 8 characters.  The total length
         must not exceed 48 characters.  This is to allow for the
         value, and indentation into a blank-keyword card (as
         hierarchical keywords are not standard and so cannot be part
         of the standard keyword name).
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The value of the keyword.  It is ignored when the keyword is
         COMMENT, HISTORY, or blank, or COMCAR = .TRUE..
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
         It is ignored when the keyword is COMMENT, HISTORY, or blank,
         or COMCAR = .TRUE..
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value for
         non-commentary keywords.
      }
      \sstsubsection{
         COMCAR = LOGICAL (Given)
      }{
         If .TRUE., the supplied card is a comment and thus the value
         and comment delimiter are ignored, and just the keyword and
         comment string are used to generate the header card.
      }
      \sstsubsection{
         HEADER = CHARACTER $*$ ( 80 ) (Returned)
      }{
         The created FITS-header card.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL FTS1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   FTS1\_GKEYx
}{
   Gets the value and comment of a named header of type $<$COMM$>$ from
   a buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for a keyword NAME; and returns its value and
      comment, and the number of the card image within the buffer array
      that contains the named keyword.  The search ends when the next
      end of a header block, marked by the END keyword, is encountered
      or the buffer is exhausted.  If the keyword is present, THERE is
      .TRUE., otherwise it is .FALSE.   Since all cards images are in
      character format, type conversion is performed.  An error status
      will be returned if the conversion has failed.  If the keyword
      expected to be present more than once, then the argument NOCCUR
      controls which occurrence will be retrieved.  If a keyword is not
      found, then no error results and the argument VALUE remains
      unmodified.

      The name may be compound to permit reading of hierarchical
      keywords.  This routine will probably only work for HISTORY,
      COMMENT and {\tt '} {\tt '} (blank) if there is just one value given on the
      line, i.e. only one {\tt "}keyword = value{\tt "} before any comment
      marker.  An error will result otherwise.
   }
   \sstinvocation{
      CALL FTS1\_GKEYx( NCARD, BUFFER, SCARD, NAME, NOCCUR, THERE,
                       VALUE, COMENT, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the search will begin.  This
         is needed because the headers may contain a dummy header
         prior to an extension.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword whose value is required.  This may be
         a compound name to handle hierarchical keywords, and it has
         the form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         NOCCUR = INTEGER (Given)
      }{
         The value of this argument specifies which occurrence of a
         keyword should be used, if multiple ones are expected.  Any
         value less than or equal to 1 indicates the first occurrence.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If .TRUE., the keyword given by argument NAME is present,
         regardless of the exit status.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The value of the keyword.
      }
      \sstsubsection{
         COMENT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment associated with the keyword.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the card containing the named keyword.  If the
         card could not be found this is set to zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by
         L, I, R or D as appropriate.
      }
   }
}
\sstroutine{
   FTS1\_UKEYx
}{
   Writes the value of type $<$COMM$>$ to the specified keyword from a
   buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for card with keyword \%NAME; and, if found,
      override its original value with the given value \%VALUE of type
      $<$COMM$>$.  The keyword can have a comment string leading by the
      character specified by \%CMTBGN.  The search ends when the next
      end of a header block, marked by the END keyword, is encountered
      or the buffer is exhausted.  If the keyword is present \%THERE is
      true, otherwise it is false.  If the parameter is present more
      than once in the header, only the first occurence will be used.

      The name may be compound to permit writing of hierarchical
      keywords.

      The buffer of FITS header card image should be mapped in the
      {\tt '}UPDATE{\tt '} mode.
   }
   \sstinvocation{
      CALL FTS1\_UKEYx( NCARD, BUFFER, STCARD, NAME, VALUE, CMTBGN,
                       COMNT, THERE, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         STCARD = INTEGER (Given)
      }{
         The number of the card from which to start search.
      }
      \sstsubsection{
         NAME = CHARACTER $*$( $*$ ) (Given)
      }{
         The name of the keyword to be written a new value.  This may be
         a compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.  The total length must not exceed
         48 characters.  This is to allow for the value, and indentation
         into a blank-keyword card (as hierarchical keywords are not
         standard and so cannot be part of the standard keyword name).
      }
      \sstsubsection{
         VALUE = $<$TYPE$>$ (Given)
      }{
         The value to be used to override the original value of the
         keyword.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true, the specified keyword is present.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the last continuation comment card whose contents
         are included in the returned string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by L,
         I, R or D as appropriate.

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.

         \sstitem
         The BUFFER appears out of standard order because when this
         routine is called, BUFFER is expected to be a mapped array.
         This order prevents having to append several \%VAL(length)
         arguments instead of just the one.
      }
   }
}
\sstroutine{
   FTS1\_WKEYx
}{
   Writes a FITS-header card for a value of type $<$COMM$>$
}{
   \sstdescription{
      This routine writes a FITS-header card using the supplied
      keyword, value, comment, and comment delimiter.  The value has
      data type $<$COMM$>$.  The name may be compound to permit writing
      of hierarchical keywords.
   }
   \sstinvocation{
      CALL FTS1\_WKEYx( NAME, VALUE, CMTBGN, COMNT, HEADER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$( $*$ ) (Given)
      }{
         The name of the keyword to be written.  This may be a compound
         name to handle hierarchical keywords, and it has the form
         keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  The value is converted to
         uppercase and blanks are removed before being used.  Each
         keyword must be no longer than 8 characters.  The total length
         must not exceed 48 characters.  This is to allow for the
         value, and indentation into a blank-keyword card (as
         hierarchical keywords are not standard and so cannot be part
         of the standard keyword name).
      }
      \sstsubsection{
         VALUE = $<$TYPE$>$ (Given)
      }{
         The value of the keyword.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value.
      }
      \sstsubsection{
         HEADER = CHARACTER $*$ ( 80 ) (Returned)
      }{
         The created FITS-header card.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by L,
         I, R or D as appropriate.

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.
      }
   }
}
\sstroutine{
   FTS1\_RNAND
}{
   Replaces NaN values with bad values in a vector of 64-bit IEEE
   floating-point numbers
}{
   \sstdescription{
      This routine replaces any IEEE not-a-number (NaN) values present
      in a vector of 64-bit IEEE-754 floating-point numbers to the
      standard \_DOUBLE bad-pixel value.  Also converted to the standard
      bad-pixel value are values who exponent is greater than maximum
      provided by the host machine.
   }
   \sstinvocation{
      CALL FTS1\_RNAND( EL, BUF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of IEEE numbers to be processed.  An expression must
         not be given.
      }
      \sstsubsection{
         BUF( EL ) = DOUBLE PRECISION (Given and Returned)
      }{
         The IEEE numbers to be cleansed of NaN values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         {\tt "}IEEE Standard for Binary Floating-Point Arithmetic{\tt "},
         ANSI/IEEE 754, 1985.
      }
   }
}
\sstroutine{
   FTS1\_RNANR
}{
   Replaces NaN values with bad values in a vector of 32-bit IEEE
   floating-point numbers
}{
   \sstdescription{
      This routine replaces any IEEE not-a-number (NaN) values present
      in a vector of 32-bit IEEE-754 floating-point numbers to the
      standard \_REAL bad-pixel value.  Also converted to the standard
      bad-pixel value are values who exponent is greater than maximum
      provided by the host machine.
   }
   \sstinvocation{
      CALL FTS1\_RNANR( EL, BUF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of IEEE numbers to be processed.  An expression must
         not be given.
      }
      \sstsubsection{
         BUF( EL ) = REAL (Given and Returned)
      }{
         The IEEE numbers to be cleansed of NaN values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         {\tt "}IEEE Standard for Binary Floating-Point Arithmetic{\tt "},
         ANSI/IEEE 754, 1985.
      }
   }
}
\sstroutine{
   IRA\_ANNUL
}{
   Annul an IRA identifier
}{
   \sstdescription{
      This routine should be called when access to the astrometry
      information associated with an IRA identifier is no longer
      needed. It releases the resources used to store the astrometry
      information.

      This routine attempts to execute even if STATUS is bad on entry.
      However, in this case no error report will be produced if this
      routine subsequently fails.
   }
   \sstinvocation{
      CALL IRA\_ANNUL( IDA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDA = INTEGER ( Given )
      }{
         The IRA identifier to be annulled.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_CLOSE
}{
   Close down the IRA astrometry package
}{
   \sstdescription{
      This routine should be called once IRA facilities are no longer
      needed. It annulls any currently valid IRA identifiers, releasing
      any resources reserved by them. Once this routine has been called,
      any further use of IRA must be preceeded with a call to IRA\_INIT.

      This routine attempts to execute even if STATUS is set to a bad
      value on entry.
   }
   \sstinvocation{
      CALL IRA\_CLOSE( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_CONVT
}{
   Convert sky coordinates from one system to another
}{
   \sstdescription{
      This routine use SLALIB to convert a list of sky coordinates from
      one supported Sky Coordinate System (SCS) to any other supported
      system.  It is assumed that the observations were made at the
      date given by the Julian epoch supplied.  If the input and output
      coordinates are referred to different mean equinox, then
      precession is applied to convert the input coordinates to the
      output system.  No correction for nutation is included. If any of
      the input coordinate values are equal to the Starlink {\tt "}BAD{\tt "} value
      (VAL\_\_BADD) then the corresponding output values will both be set
      to the bad value.
   }
   \sstinvocation{
      CALL IRA\_CONVT( NVAL, AIN, BIN, SCSIN, SCSOUT, EPOCH, AOUT, BOUT,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The number of sky coordinate pairs to be converted.
      }
      \sstsubsection{
         AIN( NVAL ) = DOUBLE PRECISION (Given)
      }{
         A list of sky longitude coordinate values to be converted, in
         radians.
      }
      \sstsubsection{
         BIN( NVAL ) = DOUBLE PRECISION (Given)
      }{
         A list of sky latitude coordinate values to be converted, in
         radians.
      }
      \sstsubsection{
         SCSIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string holding the name of the sky coordinate system of the
         input list. Any unambiguous abbreviation will do. An optional
         equinox specifier may be included in the name (see ID2 section
         {\tt "}Sky Coordinates{\tt "}).
      }
      \sstsubsection{
         SCSOUT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string holding the name of the sky coordinate system
         required for the output list. Any unambiguous abbreviation
         will do.An optional equinox specifier may be included in the
         name.
      }
      \sstsubsection{
         EPOCH = DOUBLE PRECISION (Given)
      }{
         The Julian epoch at which the observations were made. When
         dealing with IRAS data, the global constant IRA\_\_IRJEP should
         be specified. This constant is a Julian epoch suitable for all
         IRAS data.
      }
      \sstsubsection{
         AOUT( NVAL ) = DOUBLE PRECISION (Returned)
      }{
         The list of converted sky longitude coordinate values, in
         radians.
      }
      \sstsubsection{
         BOUT( NVAL ) = DOUBLE PRECISION (Returned)
      }{
         The list of converted sky latitude coordinate values, in
         radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_CREAT
}{
   Create an identifier for specified astrometry information
}{
   \sstdescription{
      The supplied astrometry information is stored in internal common
      blocks and an {\tt "}IRA identifier{\tt "} is returned which can be passed to
      other IRA routines to refer to the stored astrometry information.
      This identifier should be annulled when it is no longer required
      by calling IRA\_ANNUL. In addition, a call to IRA\_EXPRT may
      optionally be made to store the astrometry information in an NDF
      (see argument INDF).

      The projection used is specified by the argument PROJ, and must
      be one of the supported projection types (see routine IRA\_IPROJ).
      For more information on the available projections, see the ID/2
      appendix {\tt "}Projection Equations{\tt "}. Each projection requires the
      values for several parameters to be supplied in argument P. These
      parameters have the same meaning for all projections (for further
      details see ID/2 appendix {\tt "}Projection Equations{\tt "}):

      P(1): The longitude (in the Sky Coordinate System specified by
            argument SCS) of the reference point in radians.

      P(2): The latitude (in the Sky Coordinate System specified by
            argument SCS) of the reference point in radians.

      P(3): The first image coordinate (i.e. X value) of the reference
            point. Image coordinates are fractional values in which the
            centre of the pixel (1,1) has coordinates (0.5,0.5).

      P(4): The second image coordinate (i.e. Y value) of the
            reference point.

      P(5): The size along the X image axis, of a pixel centred at the
            reference point, in radians. Actual pixel size will vary
            over the image due to the distorting effect of the
            projection. The absolute value is used.

      P(6): The size along the Y image axis, of a pixel centred at the
            reference point, in radians. The absolute value is used.

      P(7): The position angle of the Y image axis, in radians. That is,
            the angle from north to the positive direction of the Y
            image axis, measured positive in the same sense as
            rotation from north to east. (Here {\tt "}north{\tt "} and {\tt "}east{\tt "} are
            defined by the value of SCS). The X image axis is 90 degrees
            west of the Y axis.

      P(8): An angle through which the celestial sphere is to be rotated
            before doing the projection. The axis of the rotation is a
            radius passing through the reference point. The rotation is
            in an anti-clockwise sense when looking from the reference
            point towards the centre of the celestial sphere. The value
            should be in radians. Changing this angle does not change
            the orientation of the image axes with respect to north
            (which is set by p(7)).
   }
   \sstinvocation{
      CALL IRA\_CREAT( PROJ, NP, P, SCS, EPOCH, INDF, IDA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PROJ = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The projection type (see routine IRA\_IPROJ for a list of
         currently recognised values). Any unambiguous abbreviation can
         be given.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of array P.
      }
      \sstsubsection{
         P( NP ) = DOUBLE PRECISION (Given)
      }{
         The parameter values required by the projection.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the Sky Coordinate System which the projection is
         to create, or an unambiguous abbreviation. See routine IRA\_ISCS
         for a list of currently recognised values.  See ID2 section
         {\tt "}Sky Coordinates{\tt "}) for general information of Sky Coordinate
         Systems.
      }
      \sstsubsection{
         EPOCH = DOUBLE PRECISION (Given)
      }{
         The Julian epoch at which the observations were made. A single
         mean epoch is sufficient to describe all IRAS observations.
         Such a value is contained in the IRA constant IRA\_\_IRJEP.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier for the NDF in which the astrometry information
         is to be stored. If an invalid NDF identifier is given (eg the
         value NDF\_\_NOID) then the astrometry information is not stored
         in an NDF (but IDA can still be used to refer to the astrometry
         information).
      }
      \sstsubsection{
         IDA = INTEGER (Returned)
      }{
         The returned IRA identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_CTOD1
}{
   Converts a single formatted sky coordinate value into a double
   precision value
}{
   \sstdescription{
      The input string is presumed to hold a sky coordinate value in
      character form. If NC is 1, the string is interpreted as a
      longitude value. If NC is 2, the string is interpreted as a
      latitude value.  This routine reads the string and produces a
      double precision value holding the coordinate value in radians.
      The value is not shifted into the first order range (eg if an
      angular value equivalent to 3$*$PI is given, the value 3$*$PI will be
      returned, not 1$*$PI). If the input string is blank the output
      value is set to the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD). Refer to
      IRA\_CTOD for details of the allowed format for the input string.
   }
   \sstinvocation{
      CALL IRA\_CTOD1( TEXT, SCS, NC, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the formatted version of the sky
         coordinate value. If this string is blank, VALUE is returned
         with the {\tt "}BAD{\tt "} value (VAL\_\_BADD), but no error report is
         made.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The sky coordinate system (see ID2 section {\tt "}Sky Coordinates{\tt "}).
         Any unambiguous abbreviation will do.
      }
      \sstsubsection{
         NC = INTEGER (Given)
      }{
         Determines which sky coordinate is to be used. If a value of 1
         is supplied, the string is interpreted as a longitude value
         (eg RA if an equatorial system is being used). If a value of 2
         is supplied, the string is interpreted as a latitude value.
         Any other value results in an error being reported.
      }
      \sstsubsection{
         VALUE = DOUBLE PRECISION (Returned)
      }{
         The numerical value of the sky coordinate represented by the
         string in TEXT. The value is in radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_CTOD
}{
   Converts formatted sky coordinate values into double precision
   values
}{
   \sstdescription{
      The input strings are presumed to hold sky coordinate values in
      character form.  This routine reads the strings and produces
      double precision values holding the coordinate values, in
      radians.

      Each input string can consist of a set of up to three {\tt "}fields{\tt "}.
      Each field starts with a numeric value (which can have a
      fractional part) terminated by a character string. This character
      string consists of an optional single character, called the
      terminator character, followed by an arbitrary number of spaces
      The terminator character (if present) must be one of the letters
      h,d,m,s or r.  An h terminator indicates that the field value is
      in units of hours. A d terminator indicates that the field value
      is in units of degrees.  An r terminator indicates that the field
      value is in units of radians.  An m terminator indicates that the
      field value is in units of minutes.  An s terminator indicates
      that the field value is in units of seconds.  The interpretation
      of minutes and seconds depends on whether the value is a time
      value or an angle value. The longitude value for equatorial sky
      coordinate systems (RA) is expected to be a measure of time, all
      other coordinate values are expected to be a measure of angle.
      These defaults are overriden if the first field is a {\tt "}degrees{\tt "},
      {\tt "}hours{\tt "} or {\tt "}radians{\tt "} field (as indicated by the presence of a d,
      h or r terminator character).  The interpretation of fields with
      no terminator character depends on which field is being
      considered. If the first field has no terminator, it is assumed
      to be either a degrees or hours field.  If the second or third
      field has no terminator, it is assumed to be a seconds field if
      the previous field was a minutes field, and a minutes field if
      the previous value was an hours or degrees field.

      In addition, an input string may contain a single field with no
      terminator character in an {\tt "}encoded{\tt "} form. {\tt "}Encoded{\tt "} fields are
      identified by the fact that the field contains 5 or more digits
      to the left of the decimal point (including leading zeros if
      necessary).  These fields are decoded into hours or degrees as
      follows: Any fractional part is taken as the fractional part of
      the seconds field, the tens and units digits are taken as the
      integer part of the seconds field, the hundreds and thousands
      digits are taken as the minutes fields, the remaining digits are
      taken as the degrees or hours field. Thus -12345.4 would be
      interpreted as (- 1 hour 23 mins 45.4 seconds) or (- 1 degree 23
      mins 45.4 seconds). The same value could also be specified as
      \sstitemlist{

         \sstitem
         1 23 45.5, -1h 23m 45.5s (if it represents a time value), or

         \sstitem
         1d 23 45.5 (if it represents an angular value).

      }
      The supplied values must be in their first order ranges (i.e. 0
      to 2.PI for longitude values and -PI/2 to $+$PI/2 for latitude
      values). Values outside these ranges cause an error to be
      reported, and the status value IRA\_\_RANGE is returned). The
      exception to this is if the string is prefixed with a {\tt "}$*${\tt "}
      character, in which case any numeric value may be supplied. In
      this case the supplied value is returned directly (eg if the
      string {\tt "}$*$400D{\tt "} is given, the radian equivalent of 400 degrees
      will be returned, not 40 (=400-360) degrees).  If either of the
      input strings are blank the corresponding output value is set to
      the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD).
   }
   \sstinvocation{
      CALL IRA\_CTOD( ATEXT, BTEXT, SCS, A, B, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ATEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the formatted version of the longitude
         value. If this string is blank, A is returned with the {\tt "}BAD{\tt "}
         value (VAL\_\_BADD), but no error is reported.
      }
      \sstsubsection{
         BTEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the formatted version of the latitude
         value. If this string is blank, B is returned with the {\tt "}BAD{\tt "}
         value (VAL\_\_BADD), but no error is reported.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The sky coordinate system (see ID2 section {\tt "}Sky Coordinates{\tt "}).
         Any unambiguous abbreviation will do.
      }
      \sstsubsection{
         A = DOUBLE PRECISION (Returned)
      }{
         The longitude value represented by the string ATEXT, in
         radians.
      }
      \sstsubsection{
         B = DOUBLE PRECISION (Returned)
      }{
         The latitude value represented by the string BTEXT, in
         radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_DTOC1
}{
   Convert a single floating point sky coordinate value to
   character form
}{
   \sstdescription{
      This routine creates a text string containing a formatted version
      of the given sky coordinate value. The value is assumed to be a
      longitude value if NC is 1, and a latitude if NC is 2. The
      formats of the output string are as described in routine
      IRA\_DTOC. Longitude values are shifted into the range 0 - 2$*$PI
      before being used.  Latitude values are shifted into the range
      $+$/- PI before being used. An error is reported if a latitude
      value then has an absolute value greater than PI/2 (this differs
      from the behaviour of IRA\_NORM which always reduces the latitude
      value to $+$/- PI/2).
   }
   \sstinvocation{
      CALL IRA\_DTOC1( VALUE, SCS, NC, STYLE, TEXT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = DOUBLE PRECISION (Given)
      }{
         The value of the sky coordinate to be formatted, in radians.
         If VALUE has the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD) then the
         output string TEXT is set blank.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The sky coordinate system in use (see ID2 section {\tt "}Sky
         Coordinates{\tt "}). Any unambiguous abbreviation will do.
      }
      \sstsubsection{
         NC = INTEGER (Given)
      }{
         Determines which sky coordinate is given. If a value of 1 is
         supplied, VALUE is interpreted as a longitude value (eg RA if
         an equatorial system is being used).  If a value of 2 is
         supplied, VALUE is interpreted as a latitude value. Any other
         value causes an error to be reported.
      }
      \sstsubsection{
         STYLE = INTEGER (Given)
      }{
         A value in the range 1 to 5 which specifies the style of
         output formatting required. In addition a value of zero can be
         specified which causes a default style to be used dependant on
         the value of SCS. See routine IRA\_DTOC for a description of
         the styles and defaults.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The string containing the formatted description of the sky
         coordinate value. The variable supplied for TEXT should have a
         declared length equal to the value of parameter IRA\_\_SZFSC.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_DTOC
}{
   Convert a pair of double precision sky coordinate values to
   character form
}{
   \sstdescription{
      This routine creates a pair of text strings containing formatted
      versions of the given sky coordinate values.  The exact format
      depends on the type of sky coordinate system in use and the value
      of STYLE (see the {\tt "}Notes{\tt "} section below). The input coordinate
      values are shifted into their first order ranges before being used
      (see IRA\_NORM).
   }
   \sstinvocation{
      CALL IRA\_DTOC( A, B, SCS, STYLE, ATEXT, BTEXT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         A = DOUBLE PRECISION  (Given)
      }{
         The value of the sky longitude to be formatted, in radians. If
         A has the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD) then the output
         string ATEXT is set blank.
      }
      \sstsubsection{
         B = DOUBLE PRECISION  (Given)
      }{
         The value of the sky latitude to be formatted, in radians. If
         B has the {\tt "}BAD{\tt "} value then the output string BTEXT is set
         blank.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The sky coordinate system in use (see ID2 section {\tt "}Sky
         Coordinates{\tt "}). Any unambiguous abbreviation will do.
      }
      \sstsubsection{
         STYLE = INTEGER (Given)
      }{
         A value in the range 1 to 5 which specifies the style of
         output formatting required.  Additionally, a value of zero can
         specified which causes a default style to be used dependant on
         the value of SCS.  See the {\tt "}Notes{\tt "} section below for a
         description of the individual styles and defaults for each
         SCS.
      }
      \sstsubsection{
         ATEXT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The string containing the formatted description of the sky
         longitude value A. The variable supplied for ATEXT should
         have a declared length equal to the value of parameter
         IRA\_\_SZFSC.
      }
      \sstsubsection{
         BTEXT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The string containing the formatted description of the sky
         latitude value B. The variable supplied for BTEXT should
         have a declared length equal to the value of parameter
         IRA\_\_SZFSC.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         SCS = {\tt "}EQUATORIAL{\tt "}
           Default is style 2 (used if argument STYLE is zero on entry).

      }
         STYLE = 1:  (a full description)

            {\tt "}RA = 12hrs 3m 0.02s{\tt "} and  {\tt "}DEC = -33deg 23m 0.00s{\tt "}

         STYLE = 2:  (a more brief form readable by IRA\_CTOD)

            {\tt "}12h 3m 0.02s{\tt "} and {\tt "}-33d 23m 0.00s{\tt "}

         STYLE = 3:  ( a very brief form readable by IRA\_CTOD)

            {\tt "}120300.00{\tt "} and {\tt "}-332300.00{\tt "} ( eg hhmmss.ss and ddmmss.ss )

         STYLE = 4:  (a brief form readable by IRA\_CTOD)

            {\tt "}12 03 0.02{\tt "} and {\tt "}-33 23 0.00{\tt "}

         STYLE = 5:  (a brief form readable by IRA\_CTOD)

            {\tt "}12.050006{\tt "} and {\tt "}-33.383333{\tt "} (eg fractional values in
                                       hours (RA) and degrees (DEC) )

      \sstitemlist{

         \sstitem
         SCS = {\tt "}GALACTIC{\tt "}
           Default is style 5 (used if argument STYLE is zero on entry).

      }
         STYLE = 1:

            {\tt "}l = 12deg 3m 0.02s{\tt "} and  {\tt "}b = -33deg 23m 0.00s{\tt "}

         STYLE = 2:

            {\tt "}12deg 3m 0.02s{\tt "} and {\tt "}-33d 23m 0.00s{\tt "}

         STYLE = 3:

            {\tt "}0120300.00{\tt "} and {\tt "}-332300.00{\tt "} (eg dddmmss.ss and ddmmss.ss )

         STYLE = 4:  (a brief form readable by IRA\_CTOD)

            {\tt "}12 03 0.02{\tt "} and {\tt "}-33 23 0.00{\tt "}

         STYLE = 5:  (a brief form readable by IRA\_CTOD)

            {\tt "}12.050006{\tt "} and {\tt "}-33.383333{\tt "} (eg fractional values in
                                         degrees )

      \sstitemlist{

         \sstitem
         SCS = {\tt "}ECLIPTIC{\tt "}
           Default is style 5 (used if argument STYLE is zero on entry).

      }
         STYLE = 1:

            {\tt "}Lambda = 12deg 3m 0.02s{\tt "} and  {\tt "}Beta = -33deg 23m 0.00s{\tt "}

         STYLE = 2:

            {\tt "}12deg 3m 0.02s{\tt "} and {\tt "}-33d 23m 0.00s{\tt "}

         STYLE = 3:

            {\tt "}0120300.00{\tt "} and {\tt "}-332300.00{\tt "} (eg dddmmss.ss and ddmmss.ss )

         STYLE = 4:  (a brief form readable by IRA\_CTOD)

            {\tt "}12 03 0.02{\tt "} and {\tt "}-33 23 0.00{\tt "}

         STYLE = 5:  (a brief form readable by IRA\_CTOD)

            {\tt "}12.050006{\tt "} and {\tt "}-33.383333{\tt "} (eg fractional values in
                                         degrees )
   }
}
\sstroutine{
   IRA\_EXPRT
}{
   Store astrometry information in an NDF
}{
   \sstdescription{
      An HDS structure is created containing the astrometry information
      identified by IDA. This {\tt "}astrometry structure{\tt "} is stored as a
      component of an extension within the NDF specified by INDF (any
      previous astrometry structure is over-written). The names of the
      NDF extension and the astrometry structure are set by a call to
      IRA\_LOCAT. If no such call is made the names of the extension and
      astrometry structure retain the values set up in IRA\_INIT ({\tt "}IRAS{\tt "}
      and {\tt "}ASTROMETRY{\tt "}).  The astrometry structure has an HDS data type
      of IRAS\_ASTROMETRY. The NDF extension must already exist before
      calling this routine.

      Any existing astrometry structure is first deleted from the NDF
      (in which ever extension it was found) before creating the new
      one.
   }
   \sstinvocation{
      CALL IRA\_EXPRT( IDA, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         An IRA identifier for the astrometry information.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier for the NDF in which the astrometry information
         is to be stored.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_FIND
}{
   Find an astrometry structure within an NDF
}{
   \sstdescription{
      A search is made for an astrometry structure within an NDF.  If
      one is found, THERE is returned true. If one is not found, no
      error is reported but THERE is returned false.  The name of the
      extension in which it was found is returned, together with the
      name of the astrometry structure, and a locator to the extension.
   }
   \sstinvocation{
      CALL IRA\_FIND( INDF, THERE, XNAME, ASNAME, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         True if an astrometry structure was found, false otherwise.
      }
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the NDF extension in which the astrometry
         structure was found. Blank if none found.
      }
      \sstsubsection{
         ASNAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of a component of the NDF extension holding the
         astrometry information. Blank if none found.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         A locator to the extension identified by XNAME. DAT\_\_NOLOC if
         no astrometry structure is found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_GETCO
}{
   Obtain a pair of sky coordinates from the ADAM environment
}{
   \sstdescription{
      The ADAM parameters specified by arguments APAR and BPAR are used
      to acquire values for the first and second sky coordinates
      respectively, in the sky coordinate system specified by argument
      SCS. The parameters are obtained as literal character strings and
      decoded into floating point values. See routine IRA\_CTOD for a
      description of the allowed formats of the strings associated with
      these parameters. The input values of arguments A and B can
      optionally be supplied to the user as default parameter values.
      The parameter prompt strings contained in the application{\tt '}s
      interface file can be overridden by giving a non-blank value for
      argument PRMAPP. In this case, the prompts are formed by
      appending the value of PRMAPP to the coordinate descriptions
      returned by routine IRA\_SCNAM. For instance, if PRMAPP = {\tt "} of the
      field centre{\tt "}, and an equatorial sky coordinate system is in use,
      then the prompt for APAR will be {\tt "}Right Ascension of the field
      centre{\tt "}, and the prompt for BPAR will be {\tt "}Declination of the
      field centre{\tt "}. Note, the total length of the prompt strings is
      limited to 80 characters. If PRMAPP is blank, then the current
      prompt strings are used (initially equal to the values in the
      interface file).
   }
   \sstinvocation{
      CALL IRA\_GETCO( APAR, BPAR, PRMAPP, SCS, DEFLT, A, B, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CHARACTER = APAR (Given)
      }{
         The name of the ADAM parameter (type LITERAL) to use
         for the sky longitude value.
      }
      \sstsubsection{
         CHARACTER = BPAR (Given)
      }{
         The name of the ADAM parameter (type LITERAL) to use
         for the sky latitude value.
      }
      \sstsubsection{
         PRMAPP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string to append to each axis description to form the
         parameter prompt strings. If this is blank then the current
         prompt strings are used (i.e. initially set to the values in
         the interface file).
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the sky coordinate system to use. Any unambiguous
         abbreviation will do (see ID2 section {\tt "}Sky Coordinates{\tt "}).
      }
      \sstsubsection{
         DEFLT = LOGICAL (Given)
      }{
         True if the input values of A and B are to be communicated to
         the environment as run-time defaults for the parameters
         specified by APAR and BPAR. If A or B is {\tt "}BAD{\tt "} on entry
         (i.e. equal to VAL\_\_BADD ) then no default is set up for the
         corresponding parameter.
      }
      \sstsubsection{
         A = DOUBLE PRECISION (Given and Returned)
      }{
         The value of the first sky coordinate. In radians.
      }
      \sstsubsection{
         B = DOUBLE PRECISION (Given and Returned)
      }{
         The value of the second sky coordinate. In radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_GETEQ
}{
   Extract the epoch of the reference equinox from a string
   specifying a Sky Coordinate System
}{
   \sstdescription{
      If, on entry, the argument SCS contains an explicit equinox
      specifier (see routine IRA\_ISCS), the epoch contained within it
      is returned in argument EQU as a double precision value, and
      argument BJ is returned equal to the character {\tt "}B{\tt "} or {\tt "}J{\tt "}
      depending on whether the epoch is Besselian or Julian. If there is
      no equinox specifier in argument SCS on entry, then the default of
      B1950 is returned.

      If the sky coordinate system specified by SCS is not referred to
      the equinox (eg GALACTIC) then EQU is returned equal to the
      Starlink {\tt "}BAD{\tt "} value VAL\_\_BADD, and BJ is returned blank.

      The argument NAME is returned holding the full (unabbreviated)
      name of the sky coordinate system without any equinox specifier.
      On exit, the argument SCS holds the full name plus an explicit
      equinox specifier (for systems which are referred to the
      equinox). Thus, if SCS contained {\tt "}EQUAT{\tt "} on entry, it would
      contain {\tt "}EQUATORIAL(B1950){\tt "} on exit.
   }
   \sstinvocation{
      CALL IRA\_GETEQ( SCS, EQU, BJ, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry this should contain an SCS name (or any unambiguous
         abbreviation), with or without an equinox specifier. On exit,
         it contains the full SCS name with an explicit equinox
         specifier (for those sky coordinate systems which are referred
         to the equinox). If no equinox specifier is present on entry,
         then a value of B1950 is used (if required). This variable
         should have a declared length given by the symbolic constant
         IRA\_\_SZSCS.
      }
      \sstsubsection{
         EQU = DOUBLE PRECISION (Returned)
      }{
         The epoch of the reference equinox. This is extracted
         from any explicit equinox specifier contained in SCS on entry.
         If there is no equinox specifier in SCS, a value of 1950.0
         is returned. If the sky coordinate system is not referred to
         the equinox (eg GALACTIC) the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD)
         is returned, irrespective of any equinox specifier in SCS.
      }
      \sstsubsection{
         BJ = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Returned holding either the character B or J. Indicates if
         argument EQU gives a Besselian or Julian epoch. Returned blank
         if the sky coordinate system is not referred to the equinox.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full name of the sky coordinate system without any equinox
         specifier. This variable should have a declared length given by
         the symbolic constant IRA\_\_SZSCS.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_GTCO1
}{
   Obtain a single sky coordinate value from the ADAM environment
}{
   \sstdescription{
      The ADAM parameter specified by argument PARAM is used to acquire
      a longitude or latitude value in the requested sky coordinate
      system. Argument NC determines which is to be obtained.  The
      string is decoded into a double precision number representing the
      sky position.  See the documentation for IRA\_CTOR for a
      description of the allowed formats.  The input sky coordinate
      value can optionally be communicated to the environment as a
      dynamic default.
   }
   \sstinvocation{
      CALL IRA\_GTCO1( PARAM, PROMPT, SCS, NC, DEFLT, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter used to get the sky
         coordinate value.
      }
      \sstsubsection{
         PROMPT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string to override the current prompt for the parameter.
         If this is blank, the prompt is left at its current value.
         The initial value for the prompt is defined in the interface
         file. Note, unlike routine IRA\_GETCO, the axis name is not
         automatically included in the prompt.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The sky coordinate system in use. Any unambiguous abbreviation
         will do  (see ID2 section {\tt "}Sky Coordinates{\tt "}).
      }
      \sstsubsection{
         NC = INTEGER (Given)
      }{
         Determines which sky coordinate is to be returned. If a value
         of 1 is supplied, the string obtained for the parameter is
         interpreted as a longitude value (eg RA if an equatorial
         system is being used). If a value of 2 is supplied, the string
         is interpreted as a latitude value.  Any other value causes an
         error to be reported.
      }
      \sstsubsection{
         DEFLT = LOGICAL (Given)
      }{
         If true, then the value of VALUE on entry is communicated to
         the environment as a dynamic default. If false, or if VALUE is
         {\tt "}BAD{\tt "} on entry (i.e. equal to VAL\_\_BADD), then no dynamic
         default is set up.
      }
      \sstsubsection{
         VALUE = DOUBLE PRECISION (Given and Returned)
      }{
         The sky coordinate value. On input it contains the default
         value (in radians) to use if DEFLT is true. On exit it
         contains the decoded value obtained from the environment, in
         radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_GTSCS
}{
   Get the full name of a Sky Coordinate System (with equinox
   specifier) from the environment
}{
   \sstdescription{
      The ADAM parameter specified by argument SCSPAR is used to get a
      character string from the environment. A check is done to make
      sure that the string obtained represents a supported Sky
      Coordinate System (SCS). The user may include an equinox
      specifier (see IRA\_ISCS) in the text string to override the
      default reference equinox of B1950. If an illegal SCS name is
      entered the user is reprompted. If DEFLT is given true, the value
      of SCS on entry is used as a default for the parameter.  The
      value of SCS is expanded (both on entry and exit) to a full SCS
      name (an abbreviation of the SCS may be supplied either by the
      calling routine or by the user instead of the full name).
   }
   \sstinvocation{
      CALL IRA\_GTSCS( SCSPAR, DEFLT, SCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCSPAR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter to use, which should be of type
         LITERAL.
      }
      \sstsubsection{
         DEFLT = LOGICAL (Given)
      }{
         If true, then the value of argument SCS on entry is used (after
         expansion) as the run-time default for the parameter.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry, specifies the default value for the parameter. On
         exit, contains the full version of the sky coordinate system
         entered by the user. The supplied variable should have a
         declared length given by symbolic constant IRA\_\_SZSCS.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_IDEPOCH
}{
   Get the epoch associated with an IRA identifier
}{
   \sstdescription{
      This routine returns the epoch associated with an IRA identifier.
   }
   \sstinvocation{
      CALL IRA\_IDEPOCH( IDA, EPOCH, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         The IRA identifier for the astrometry information.
      }
      \sstsubsection{
         EPOCH = DOUBLE PRECISION (Returned)
      }{
         Returned holding the epoch associated with the IRA identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_IDPROJN
}{
   Get the projection name associated with an IRA identifier
}{
   \sstdescription{
      This routine returns the Sky Coordinate System associated with an
      IRA identifier.
   }
   \sstinvocation{
      CALL IRA\_IDPROJN( IDA, PROJN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         The IRA identifier for the astrometry information.
      }
      \sstsubsection{
         PROJN = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         On exit, contains the projection name associated with the IRA
         identifier. The supplied variable should have a declared length
         given by symbolic constant IRA\_\_SZPRJ.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_IDPROJP
}{
   Get a projection parameter value associated with an IRA identifier
}{
   \sstdescription{
      This routine returns the value of a projection parameter
      associated with an IRA identifier.
   }
   \sstinvocation{
      CALL IRA\_IDPROJP( IDA, IPAR, PROJP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         The IRA identifier for the astrometry information.
      }
      \sstsubsection{
         IPAR = INTEGER (Given)
      }{
         The index of the required projection parameter, in the range 1
         to IRA\_\_MAXP.
      }
      \sstsubsection{
         PROJP = DOUBLE PRECISION (Returned)
      }{
         Returned holding the value of the projection parameter.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_IDSCS
}{
   Get the Sky Coordinate System associated with an IRA identifier
}{
   \sstdescription{
      This routine returns the Sky Coordinate System associated with an
      IRA identifier.
   }
   \sstinvocation{
      CALL IRA\_IDSCS( IDA, SCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         The IRA identifier for the astrometry information.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         On exit, contains the full version of the sky coordinate system
         associated with the IRA identifier. The supplied variable should
         have a declared length given by symbolic constant IRA\_\_SZSCS.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_INIT
}{
   Initialise the IRA astrometry package
}{
   \sstdescription{
      This routine must be called before calling any other IRA routine
      which has an {\tt "}IDA{\tt "} argument. It is not necessary to call this
      routine before using routines such as IRA\_DIST which do not have
      an {\tt "}IDA{\tt "} argument. This routine annulls any currently valid IRA
      identifiers, sets the NDF extension name in which the astrometry
      structure is located to {\tt "}IRAS{\tt "}, sets the name of the astrometry
      structure to {\tt "}ASTROMETRY{\tt "}, and resets graphics options to their
      default values.
   }
   \sstinvocation{
      CALL IRA\_INIT( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_IPROJ
}{
   Return a list of supported projection names
}{
   \sstdescription{
      A string is returned containing the list of supported projection
      names and equivalent names. The names are separated by commas. The
      currently supported projections are:

      GNOMONIC ( or equivalently TANGENT\_PLANE )

      LAMBERT (  or equivalently CYLINDRICAL )

      AITOFF (  or equivalently ALL\_SKY )

      ORTHOGRAPHIC

      See ID/2 appendix {\tt "}Projection Equations{\tt "} for more details about
      the supported projections.
   }
   \sstinvocation{
      CALL IRA\_IPROJ( LIST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LIST = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The list of supported projections and equivalent names. The
         character variable supplied for this argument should have a
         declared size equal to the value of parameter IRA\_\_SZPLS. If
         the supplied string is not long enough to hold all the names, a
         warning message is given, but no error status is returned. Each
         returned projection name has a maximum length given by symbolic
         constant IRA\_\_SZPRJ.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_ISCS
}{
   Return a list of supported sky coordinate systems
}{
   \sstdescription{
      A string is returned containing a list of names identifying the
      supported sky coordinate systems. The names in the output list
      are separated by commas.

      By default, Equatorial and Ecliptic coordinates are referred to
      the mean equinox of Besselian epoch 1950.0. The calling
      application can override this default by appending a string known
      as an {\tt "}equinox specifier{\tt "} to the end of the SCS name (in fact all
      IRA routines will accept any unambiguous abbreviation of the SCS
      name). An equinox specifier consists of a year with upto 4
      decimal places, preceded with the letter B or J to indicate a
      Besselian or Julian epoch, and enclosed in parentheses. The
      named coordinate system is then referred to the mean equinox of
      the epoch given in the equinox specifier. The following are
      examples of legal SCS values; EQUATORIAL(B1950), EQUAT(J2000),
      ECLIP, ECLIP(1983.2534), etc. If the date is not preceded with
      either B or J (as in the last example), a Besselian epoch is
      assumed if the date is less than 1984.0, and a Julian epoch is
      assumed otherwise.

      The currently supported sky coordinate systems are:

      EQUATORIAL

             The longitude axis is Right Ascension, the latitude axis
             is Declination. Other legal names can be made by appending
             an equinox specifier (eg EQUATORIAL(B1983.5) ). If no
             equinox specifier is added, the coordinates are referred
             to the mean equinox of Besselian epoch 1950.0. If the
             equinox is described by a Besselian epoch, the old FK4
             Bessel-Newcomb system is used. If a Julian epoch is used,
             the new IAU 1976, FK5, Fricke system is used.

      GALACTIC

             The longitude axis is galactic longitude and the latitude
             axis is galactic latitude, given in the IAU 1958 galactic
             coordinate system.

      ECLIPTIC

             The longitude axis is ecliptic longitude and the latitude
             axis is ecliptic latitude. Other legal names can be made
             by appending an equinox specifier (eg ECLIPTIC(B1983.5) ).
             If no equinox specifier is added, the coordinates are
             referred to the mean equinox of Besselian epoch 1950.0.

      AZEL

             The longitude axis is horizon azimuth and the latitude axis is
             horizon elevation.

      All sky coordinate values supplied to, or returned from any IRA
      routine, are given in units of radians.
   }
   \sstinvocation{
      CALL IRA\_ISCS( LIST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LIST = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The list of supported sky coordinate system names. The
         character variable supplied for this argument should have a
         declared size equal to the value of parameter IRA\_\_SZCLS. If
         the supplied string is not long enough to hold all the names, a
         warning message is given, but no error status is returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_LOCAT
}{
   Set the location for new IRA astrometry structures
}{
   \sstdescription{
      By default, IRA\_CREAT and IRA\_EXPRT store astrometry information
      in a component named {\tt "}ASTROMETRY{\tt "} within the {\tt "}IRAS{\tt "} NDF
      extension.  These names may be changed if necessary by calling
      this routine. The supplied arguments give the name of the NDF
      extension and the component name to be used by all future calls
      to IRA\_CREAT or IRA\_EXPRT. It should be ensured that the
      extension exists before calling IRA\_CREAT or IRA\_EXPRT.
   }
   \sstinvocation{
      CALL IRA\_LOCAT( XNAME, ASNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of NDF extension in which astrometry structures are to
         be created. If a blank value is supplied the current value is
         left unchanged.
      }
      \sstsubsection{
         ASNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of a component of the NDF extension in which to store
         astrometry information. If a blank value is supplied the
         current value is left unchanged.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_NORM
}{
   Convert sky coordinate values to the equivalent first order
   values
}{
   \sstdescription{
      The given latitude value is shifted into the range $+$/- PI/2 ( a
      shift of PI may be introduced in the longitude value to achieve
      this). The longitude value is then shifted into the range 0 to
      2$*$PI. If either A or B has the Starlink {\tt "}BAD{\tt "} value on entry
      (VAL\_\_BADD) then both A and B are left unchanged on exit. Latitude
      values which are within 0.01 arc-seconds of either pole are
      modified to put them exactly at the pole.
   }
   \sstinvocation{
      CALL IRA\_NORM( A, B, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         A = DOUBLE PRECISION (Given and Returned)
      }{
         The longitude, in radians. On exit, the value is shifted in to
         the range 0 to 2$*$PI.
      }
      \sstsubsection{
         B = DOUBLE PRECISION (Given and Returned)
      }{
         The latitude value, in radians. On exit, the value is shifted
         in to the range -PI/2 to $+$PI/2.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_READ
}{
   Gets an identifier for astrometry information stored in an HDS
   astrometry structure
}{
   \sstdescription{
      An attempt is made to read astrometry information from the
      supplied HDS object, assuming the object is an IRA astrometry
      structure. The astrometry information is copied into internal
      common blocks and an {\tt "}IRA identifier{\tt "} is returned which can be
      passed to other IRA routines to refer to the stored astrometry
      information.  This identifier should be annulled when it is no
      longer required by calling IRA\_ANNUL.
   }
   \sstinvocation{
      CALL IRA\_READ( LOC, IDA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         An HDS locator to an astrometry structure. The constant
         IRA\_\_HDSTY gives the HDS type required for this object.
      }
      \sstsubsection{
         IDA = INTEGER (Returned)
      }{
         The IRA identifier which is used by other IRA routines to
         access the astrometry information.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_SETEQ
}{
   Encode the epoch of a reference equinox within an SCS name
}{
   \sstdescription{
      On entry, SCS contains the name of a Sky Coordinate System (or an
      unambiguous abbreviation), with or without an equinox specifier
      (see routine IRA\_ISCS). On exit, SCS contains the full name of
      the Sky Coordinate System with an equinox specifier appended,
      determined by arguments EQU and BJ. Any old equinox specifier is
      first removed. If the Sky Coordinate System is not referred to
      the equinox (eg GALACTIC) then no equinox specifier is included
      in SCS on exit.
   }
   \sstinvocation{
      CALL IRA\_SETEQ( EQU, BJ, SCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EQU = DOUBLE PRECISION (Given)
      }{
         The epoch of the reference equinox. After calling this routine,
         the sky coordinates described by SCS are referred to the mean
         equinox of the epoch given by EQU. If EQU has the Starlink
         {\tt "}BAD{\tt "} value (VAL\_\_BADD) then no equinox specifier is included
         in SCS on exit.
      }
      \sstsubsection{
         BJ = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Determines if the epoch specified by argument EQU is a
         Besselian or Julian epoch. BJ should have the value {\tt "}B{\tt "} or {\tt "}J{\tt "}.
         Any other value causes an error report (except that a blank
         value causes {\tt "}B{\tt "} to be used if EQU is less than 1984.0 and {\tt "}J{\tt "}
         otherwise).
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry, SCS should contain an unambiguous abbreviation of a
         supported Sky Coordinate System (see routine IRA\_ISCS), with or
         without an equinox specifier. On exit, SCS contains the full
         name of the Sky Coordinate System, appended with an equinox
         specifier determined by arguments EQU and BJ. If the Sky
         Coordinate System is not one that is referred to the equinox
         (eg GALACTIC) then no equinox specifier is included in SCS on
         exit. SCS should have a declared length equal to the symbolic
         constant IRA\_\_SZSCS.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_TRANS
}{
   Transform coordinate data
}{
   \sstdescription{
      Coordinate data are transformed from sky coordinates to image
      coordinates, or vice-versa, using the projection information
      identified by IDA. The direction of the transformation is
      determined by the argument FORWRD.  If any input coordinate
      values are equal to the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD) then
      both the output values are set to the bad value.
   }
   \sstinvocation{
      CALL IRA\_TRANS( NVAL, IN1, IN2, FORWRD, SCS, IDA,
                      OUT1, OUT2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The number of coordinate points to be transformed.
      }
      \sstsubsection{
         IN1( NVAL ) = DOUBLE PRECISION (Given)
      }{
         If FORWRD is true, then IN1 holds values of the first image
         coordinate (X), otherwise IN1 holds values of the sky
         longitude.
      }
      \sstsubsection{
         IN2( NVAL ) = DOUBLE PRECISION (Given)
      }{
         If FORWRD is true, then IN2 holds values of the second image
         coordinate (Y), otherwise IN2 holds values of the sky
         latitude.
      }
      \sstsubsection{
         FORWRD = LOGICAL (Given)
      }{
         If true then the forward mapping is used from image coordinate
         to sky coordinate. Otherwise, the inverse mapping from sky
         coordinate to image coordinates is used.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the sky coordinate system in which sky coordinates
         are required (if FORWRD is true), or supplied (if FORWRD is
         false). Any unambiguous abbreviation will do. This need not be
         the same as the SCS identified by IDA.  See ID2 section {\tt "}Sky
         Coordinates{\tt "} for more information on Sky Coordinate Systems.
         A blank value will cause the system associated with IDA to be
         used.
      }
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         The IRA identifier for the astrometry information.
      }
      \sstsubsection{
         OUT1( NVAL ) = DOUBLE PRECISION (Returned)
      }{
         If FORWRD is true, then OUT1 holds values of the sky longitude
         corresponding to the image coordinates given in arrays IN1 and
         IN2. Otherwise, OUT1 holds values of the first image
         coordinate (X) corresponding to the input sky coordinates.
      }
      \sstsubsection{
         OUT2( NVAL ) = DOUBLE PRECISION (Returned)
      }{
         If FORWRD is true, then OUT2 holds values of the sky latitude
         corresponding to the image coordinates given in arrays IN1 and
         IN2. Otherwise, OUT2 holds values of the second image
         coordinate (Y) corresponding to the input sky coordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_WRITE
}{
   Write astrometry information into an HDS object
}{
   \sstdescription{
      The astrometry information identified by IDA is stored within the
      object located by argument LOC. The constant IRA\_\_HDSTY gives the
      HDS type required for the object. The object must have this type
      and be empty.
   }
   \sstinvocation{
      CALL IRA\_WRITE( IDA, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         An IRA identifier for the astrometry information.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A locator to the object to which the astrometry information is
         to be written.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   COPY1D
}{
   copy one 1-D array to another
}{
   \sstdescription{
      The input 1-D array, ARRIN, of dimension DIM, is copied into the
      output 1-D array, ARROUT, of the same dimension.
      An immediate return will occur if STATUS has an error value on
      entry.
   }
   \sstinvocation{
      CALL COPY1D( DIM, ARRIN, ARROUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM = INTEGER( READ )
      }{
         Dimension of the input and output arrays.
      }
      \sstsubsection{
         ARRIN( DIM ) = REAL( READ )
      }{
         1-D array to be copied.
      }
      \sstsubsection{
         ARROUT( DIM ) = REAL( WRITE )
      }{
         Output array is returned as a copy of the input array.
      }
      \sstsubsection{
         STATUS = INTEGER( READ )
      }{
         This is the global status, if this variable has an error
         value on entry then an immediate return will occur.
      }
   }
}
\sstroutine{
   COPY2D
}{
   copy one 2-D array into another
}{
   \sstdescription{
      The input 2-D array, ARRIN, of dimension DIM1, DIM2, is copied
      into the output 2-D array, ARROUT, of the same dimensions.
      An immediate return will occur if STATUS has an error value on
      entry.
   }
   \sstinvocation{
      CALL COPY2D( DIM1, DIM2, ARRIN, ARROUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM1 = INTEGER( READ )
      }{
         The first dimension of the 2-d arrays.
      }
      \sstsubsection{
         DIM2 = INTEGER( READ )
      }{
         The second dimension of the 2-d arrays.
      }
      \sstsubsection{
         ARRIN( DIM1, DIM2 ) = REAL( READ )
      }{
         Array to be copied.
      }
      \sstsubsection{
         ARROUT( DIM1, DIM2 ) = REAL( WRITE )
      }{
         Will be returned containing a copy of the input array.
      }
      \sstsubsection{
         STATUS = INTEGER( READ )
      }{
         This is the global status, if this variable has an error
           value on entry then an immediate return will occur.
      }
   }
}
\sstroutine{
   COPY3D
}{
   copy one 3-D array into another
}{
   \sstdescription{
      The input 3-D array, ARRIN, of dimensions in DIM1, DIM2, DIM3, is
      copied into the output 3-D array, ARROUT, of the same dimensions.
      An immediate return will occur if STATUS has an error value on
      entry.
   }
   \sstinvocation{
      CALL COPY3D( DIM1, DIM2, DIM3, ARRIN, ARROUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM1 = INTEGER( READ )
      }{
         The first dimension of the 2-d arrays.
      }
      \sstsubsection{
         DIM2 = INTEGER( READ )
      }{
         The second dimension of the 2-d arrays.
      }
      \sstsubsection{
         DIM3 = INTEGER( READ )
      }{
         The third dimension of the 2-d arrays.
      }
      \sstsubsection{
         ARRIN( DIM1, DIM2, DIM3 ) = REAL( READ )
      }{
         Array to be copied.
      }
      \sstsubsection{
         ARROUT( DIM1, DIM2, DIM3 ) = REAL( WRITE )
      }{
         Will be returned containing a copy of the input array.
      }
      \sstsubsection{
         STATUS = INTEGER( READ )
      }{
         This is the global status, if this variable has an error
           value on entry then an immediate return will occur.
      }
   }
}
\sstroutine{
   CPSECR
}{
   Copy region of 2-D image
}{
   \sstdescription{
      This routine copies the 2-D data of a specified region of an
      image.
   }
   \sstinvocation{
      CALL  CPSECR( IMAGE, DIM1, DIM2, X1, Y1, X2, Y2, RXDIM, RYDIM,
   }
   \sstarguments{
      \sstsubsection{
         IMAGE( DIM1, DIM2 ) = REAL( READ )
      }{
         The array containing the raw image data.
      }
      \sstsubsection{
         DIM1 = INTEGER( READ )
      }{
         The first dimension of the 2-d array.
      }
      \sstsubsection{
         DIM2 = INTEGER( READ )
      }{
         The second dimension of the 2-d array.
      }
      \sstsubsection{
         X1 = INTEGER( READ )
      }{
         The X co-ordinate of the first point from which the region
           is determined.
      }
      \sstsubsection{
         Y1 = INTEGER( READ )
      }{
         The Y co-ordinate of the first point.
      }
      \sstsubsection{
         X2 = INTEGER( READ )
      }{
         The X co-ordinate of the second point.
      }
      \sstsubsection{
         Y2 = INTEGER( READ )
      }{
         The Y co-ordinate of the second point.
      }
      \sstsubsection{
         RXDIM = INTEGER( READ )
      }{
         The X-dimension of the region.
      }
      \sstsubsection{
         RYDIM = INTEGER( READ )
      }{
         The Y-dimension of the region.
      }
      \sstsubsection{
         REGION( RXDIM, RYDIM ) = REAL( WRITE )
      }{
         The array into which the region is copied.
      }
      \sstsubsection{
         STATUS = INTEGER( READ )
      }{
         The status value on entry to this routine.
      }
   }
}
\sstroutine{
   CREOUT
}{
   creates and returns a locator to an IMAGE type structure
}{
   \sstdescription{
      An IMAGE-type data structure, associated with the parameter name
      in PARNAM, is created. A locator for this structure is returned
      in LOCAT. A TITLE component, associated with the parameter name in
      TLENAM, is created within the structure and a character value,
      up to 72 characters long, is obtained from the parameter system
      and written to the TITLE component. A DATA\_ARRAY component is
      created, this has dimensionality NDIM and dimensions DIMS( NDIM )
      and is of type \_REAL.
      An immediate return will occur if STATUS has an error value on
      entry.
   }
   \sstinvocation{
      CALL CREOUT( PARNAM, LABNAM, NDIM, DIMS, LOCAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARNAM = CHAR$*$($*$)( READ )
      }{
         Parameter name associated with the IMAGE type structure to
         be created.
      }
      \sstsubsection{
         TLENAM = CHAR$*$($*$)( READ )
      }{
         Parameter name associated with the TITLE component created
         in the new IMAGE-type structure.
      }
      \sstsubsection{
         NDIM   = INTEGER( READ )
      }{
         Dimensionality of the DATA\_ARRAY component of the new
         IMAGE-type structure.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER( READ )
      }{
         Dimensions of the DATA\_ARRAY component of the new IMAGE-type
         structure.
      }
      \sstsubsection{
         LOCAT  = CHAR$*$($*$)( WRITE )
      }{
         Locator to the new IMAGE-type structure.
      }
      \sstsubsection{
         STATUS = INTEGER( UPDATE )
      }{
         This is the global status, if this variable has an error
         value on entry then an immediate return will occur. If an
         error occurs during the execution of this routine STATUS
         will be returned containing the appropriate error value.
      }
   }
}
\sstroutine{
   DIMLST
}{
   Writes the dimensions of an array in a shorthand form
}{
   \sstdescription{
      Returns a character variable containing the dimensions of
      an array separated by commas and bounded by parentheses,
      unless there is only one dimension when no parentheses and
      comma are included. This enables the calling routine to require
      only one message call.
   }
   \sstinvocation{
      CALL DIMLST( NDIMS, DIMS, NCHDIM, DIMSTR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMS  =  INTEGER( READ )
      }{
         Number of dimensions of array
      }
      \sstsubsection{
         DIMS ( NDIMS )  =  INTEGER( READ )
      }{
         Dimensions of the array
      }
      \sstsubsection{
         NCHDIM  =  INTEGER( WRITE )
      }{
         Number of characters in DIMSTR less trailing blanks
      }
      \sstsubsection{
         DIMSTR  =  CHARACTER$*$($*$)( WRITE )
      }{
         Character string of dimension list enclosed in parentheses
      }
      \sstsubsection{
         STATUS  = INTEGER( READ, WRITE )
      }{
         Global status value
      }
   }
}
\sstroutine{
   EXPARR
}{
   take the exponential of an array, pixel by pixel
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the exponential of the pixels of the input array
      to the base specified, i.e. New value = Base $*$$*$ Old value.
      If the result is bigger than the maximum-allowed Vax real,
      then a bad pixel value is used.
   }
   \sstinvocation{
      CALL EXPARR( INARR, DIMS, BASE, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INARR( DIMS )  =  REAL( READ )
      }{
         Array containing input image data
      }
      \sstsubsection{
         DIMS  =  INTEGER( READ )
      }{
         Dimension of input and output arrays
      }
      \sstsubsection{
         BASE  =  REAL( READ )
      }{
         Base of exponential to be used - must be a positive number
      }
      \sstsubsection{
         OUTARR( DIMS )  =  REAL( WRITE )
      }{
         Array containing results of processing input data
      }
      \sstsubsection{
         STATUS  =  INTEGER( READ )
      }{
         Global status value
      }
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   ICMMM
}{
   Iteratively finds the mean, median and mode using the
}{
   \sstdescription{
      This finds the mean, median and mode (mmm) of a sample of data
      taken from a background region of an astronomical plate. It should
      not be used as a general mmm routine as there are special features
      which are peculiar to the problem of contamination by stars. The
      data should not include any invalid pixel values as these are not
      trapped. The data need not be sorted as a NAG sorting routine
      (M01CAE, single precision) is called internally. The routine also
      returns the standard deviation and the skew of the sample.

      The magic-value method is used for bad pixels.
   }
   \sstinvocation{
      CALL ICMMM ( ARRAY, DIM, SMEAN, SMED, SMODE, SIGMA, SKEW, NSAM,
   }
   \sstarguments{
      \sstsubsection{
         ARRAY( DIM ) = REAL( READ )
      }{
         Vector of data samples.
      }
      \sstsubsection{
         DIM = INTEGER( READ )
      }{
         The number of data in the sample.
      }
      \sstsubsection{
         SMEAN = REAL( WRITE )
      }{
         The mean of the sample.
      }
      \sstsubsection{
         SMED = REAL( WRITE )
      }{
         The median of the sample.
      }
      \sstsubsection{
         SMODE = REAL( WRITE )
      }{
         The mode of the sample.
      }
      \sstsubsection{
         SIGMA = REAL( WRITE )
      }{
         The standard deviation of the sample.
      }
      \sstsubsection{
         SKEW = REAL( WRITE )
      }{
         The skewness of the sample.
      }
      \sstsubsection{
         NSAM = INTEGER( WRITE )
      }{
         The population of the sample after the iterative procedure.
      }
      \sstsubsection{
         NINVAL = INTEGER( WRITE )
      }{
         The number of bad pixels in the sample.
      }
      \sstsubsection{
         STATUS  =  INTEGER( READ, WRITE )
      }{
         Global status value.
      }
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   INSET
}{
   will be .TRUE. if STRING is a member of the {\tt "}set{\tt "} SET
}{
   \sstdescription{
      Checks a character variable, STRING, for being equal to any of a
      number of possible values given in the pseudo set, SET, which is
      also a character variable. The possible values can be any length
      and can differ in length throughout the set. They should be
      separated by a comma. Upper and lower case are treated as being
      equivalent.
   }
   \sstinvocation{
      RESULT = INSET( SET, STRING )
   }
   \sstarguments{
      \sstsubsection{
         SET = CHAR$*$($*$)( READ )
      }{
         The pseudo set of possible values for string. This {\tt "}set{\tt "}
         takes the following form : {\tt '}string1,string2,.......,stringN{\tt '}
         where each of the substrings string1 up to stringN can be of
         different lengths.
      }
      \sstsubsection{
         STRING = CHAR$*$($*$)( READ )
      }{
         The string to be checked for membership of the pseudo set.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         INSET = LOGICAL
      }{
         .TRUE. if STRING is a member of the {\tt "}set{\tt "} SET, otherwise
         .FALSE. .
      }
   }
}
\sstroutine{
   KPG1\_ABSET
}{
   Separates a list of items into a character array
}{
   \sstdescription{
      The routine separates a list of items into an character array and
      finds the minimum number of characters required to specify each
      item uniquely, and the length in characters of the longest item
      of the list.
   }
   \sstinvocation{
      CALL KPG1\_ABSET( SEPAR, OPTS, ARRAY, NELM, MINCH, MAXNOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SEPAR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The separator that divides the list of items.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Contains a list of items separated by the delimiter SEPAR.  It
         is limited to 132 characters.
      }
      \sstsubsection{
         ARRAY( $*$ ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The list divided into an array of values.  The list is in
         alphabetic order.
      }
      \sstsubsection{
         NELM = INTEGER (Returned)
      }{
         The number of elements in the list, and stored in ARRAY.
      }
      \sstsubsection{
         MCH( $*$ ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The minimum number of initial characters to identify each of
         the items in the list uniquely.  In the special case when an
         option equals the start of another option, MCH for the first
         option equals the option{\tt '}s length (ignoring trailing blanks)
         in characters; MCH for the the second will be at least one
         character greater.
      }
      \sstsubsection{
         MINCH = INTEGER (Returned)
      }{
         The minimum number of initial characters that can identify an
         item in the list uniquely.  In other words, the minimum value
         of the elements of MCH.
      }
      \sstsubsection{
         MAXNOC = INTEGER (Returned)
      }{
         The maximum length of an item in the array, ignoring trailing
         blanks.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The size and dimension of the character array must be
            sufficient to accommodate the length and number of strings.

         \sstitem
         Error status SAI\_\_ERROR is returned when the list of options
            is ambiguous.
      }
   }
}
\sstroutine{
   KPG1\_AGATC
}{
   Reports the character attributes of the current picture in the
   graphics database
}{
   \sstdescription{
      This routine inquires the name, comment, and label (if one is
      present) of the current picture in the AGI graphics database
      and reports their values.
   }
   \sstinvocation{
      CALL KPG1\_AGATC( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AGFND
}{
   Selects the highest picture of a given name within the current AGI
   picture
}{
   \sstdescription{
      This routine searches forwards through the AGI database for a
      picture of a given name that lies within the current picture,
      including the current picture itself.  If one is found it
      becomes the new current picture.  If it could not be found a
      bad status will be returned, and the current picture is unchanged.
   }
   \sstinvocation{
      CALL KPG1\_AGFND( NAME, PICID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the picture to be searched for in the graphics
         database.
      }
      \sstsubsection{
         PICID = INTEGER (Returned)
      }{
         The picture identifier of the most-recent picture named NAME.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AGREF
}{
   Obtains a name of or a locator to an object referenced in the
   graphics database
}{
   \sstdescription{
      This routine determines whether a given picture in the AGI
      graphics database has an object associated with it by reference.
      If it has, the name of the object or a locator to the object is
      returned with the desired access mode.
   }
   \sstinvocation{
      CALL KPG1\_AGREF( PICID, ACCESS, THERE, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PICID = INTEGER (Given)
      }{
         The identifier of the picture with which a data object may
         be associated by reference.
      }
      \sstsubsection{
         ACCESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Access mode to the object: {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '} or {\tt '}UPDATE{\tt '}.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true the picture has an associated object and the returned
         name is meaningful.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the data object referenced by picture PICID, or a
         locator to that object.  It should be ignored if THERE is
         .FALSE..  The value should be tested to see if it a locator or
         a name.  If it is a locator, it should be annulled by
         REF\_ANNUL.  A reasonable number of characters should be allowed
         to accommodate a name including its path and section.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The code is a little convoluted because of a bug in AGI\_GTREF
      which means that a long name cannot be passed to it, if the
      reference is via a locator.
   }
}
\sstroutine{
   KPG1\_ALSYS
}{
   Allow the user to change the AlignSystem attribute in a Frame/
}{
   \sstdescription{
      This routine obtains a value from the environment that is used to
      specify a new value for the AlignSystem attribute of a supplied Frame.
      This attribute determines the coordinate system in which the Frame
      will align with other similar Frames.
   }
   \sstinvocation{
      CALL KPG1\_ALSYS( PARAM, FRM1, FRM2, AXIS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         FRM1 = INTEGER (Given)
      }{
         A pointer to the AST Frame which is to have its AlignSystem
         value changed.
      }
      \sstsubsection{
         FRM2 = INTEGER (Given)
      }{
         A pointer to an AST Frame. The System value from this Frame will
         be used as the AlignSystem value for FRM1 if the user supplied the
         value {\tt "}Data{\tt "} for the parameter.
      }
      \sstsubsection{
         AXIS = INTEGER (Given)
      }{
         The index (one or more) of a single axis within FRM1 which is to
         have its AlsignSystem value changed, or zero. If zero is
         supplied, the new AlignSystem value is applied to the whole Frame.
         Supplying an axis index allows a single Frame within a CmpFrame
         to have its AlignSystem value changed. If FRM1 is not a
         CmpFrame, then the supplied value is ignored and a value of zero
         is assumed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ARCOG
}{
   Allow the user to select an array component in a supplied NDF
}{
   \sstdescription{
      This routine allows the user to select an NDF array component
      selected from the ones available in the supplied NDF. Any of
      {\tt '}Data{\tt '}, {\tt '}Quality{\tt '}, {\tt '}Variance{\tt '}, and {\tt '}Error{\tt '} can be selected if
      they are present in the NDF. The user is re-prompted until a
      valid component name is obtained, or an error occurs.
   }
   \sstinvocation{
      CALL KPG1\_ARCOG( PARAM, INDF, MCOMP, COMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter to use.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         MCOMP = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the selected array component for use with NDF\_MAP.
         The  returned values are {\tt '}Data{\tt '}, {\tt '}Quality{\tt '}, {\tt '}Variance{\tt '}, and
         {\tt '}Error{\tt '} for the array components DATA, QUALITY, VARIANCE, and
         ERROR respectively. Returned equal to {\tt '}Data{\tt '} if an error occurs.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Equal to MCOMP except that {\tt '}Variance{\tt '} is substituted in place of
         {\tt '}Error{\tt '}. Only NDF\_MAP accepts {\tt '}Error{\tt '} as a component name. All
         other NDF routines require {\tt '}Variance{\tt '} to be specified instead
         and so should use COMP instead of MCOMP.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ARCOL
}{
   Forms a list of the available array components in an NDF
}{
   \sstdescription{
      This routine takes a list of array components and checks whether
      or not each is defined within an NDF, and if it is, copy the
      component name to the output list.
   }
   \sstinvocation{
      CALL KPG1\_ARCOL( NDF, INLIST, EXLIST, LENGTH, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The identifier of the NDF to be inspected for certain array
         components.
      }
      \sstsubsection{
         INLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the array components whose presence
         is to be tested.  Valid component names are {\tt '}Data{\tt '}, {\tt '}Quality{\tt '},
         {\tt '}Variance{\tt '}, and {\tt '}Error{\tt '}.  The component names may be
         abbreviated.
      }
      \sstsubsection{
         EXLIST = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         A comma-separated list of the array components of INLIST that
         are defined in the NDF.  Its length should be as long as the
         fully expanded list of components.  The components are tested
         in the order supplied.  Note that mixed case components are
         returned so that they may be used in reports to users.  Thus
         the  returned values are {\tt '}Data{\tt '}, {\tt '}Quality{\tt '}, {\tt '}Variance{\tt '}, and
         {\tt '}Error{\tt '} for the array components DATA, QUALITY, VARIANCE, and
         ERROR respectively.
      }
      \sstsubsection{
         LENGTH = INTEGER (Returned)
      }{
         The effective length of the output list. Returned equal to 1 if
         an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASAGD
}{
   Transform AGI world co-ordinates to AGI data co-ordinates
}{
   \sstdescription{
      This routine transforms AGI world co-ordinates to AGI data co-ordinates
      using the TRANSFORM structure associated with the current AGI
      picture. It is intended for use as a transformation routine by an
      AST IntraMap.
   }
   \sstinvocation{
      CALL KPG1\_ASAGD( THIS, NPOINT, NCOORD\_IN, INDIM, IN, FORWARD,
                       NCOORD\_OUT, OUTDIM, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Bad input co-ordinates will be set to AST\_\_BAD, but TRANSFORM uses
         VAL\_\_BADD to mark bad values. We assume here that VAL\_\_BADD and
         AST\_\_BAD are the same.
      }
   }
}
\sstroutine{
   KPG1\_ASAPA
}{
   Determines which pixel axis is most closely aligned with a WCS
   axis
}{
   \sstdescription{
      This routine aligns a supplied WCS axis to the best-matching
      pixel axis of an NDF.  It also returns pixel co-ordinates
      corresponding to supplied WCS-axis limits, and where possible a
      mapping with one input and one output that transforms current
      Frame co-ordinates into pixel co-ordinates.

      It first attempts to split the mapping to derive a one-to-one
      mapping.  Failing that it
   }
   \sstinvocation{
      CALL KPG1\_ASAPA( INDF, FRM, MAP, IAXIS, AXLOW, AXHIGH, PAXIS,
                       PXLOW, PXHIGH, MAP1D, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier of the NDF containing a WCS component.
      }
      \sstsubsection{
         FRM = INTEGER (Given)
      }{
         An AST pointer to the current Frame in the NDF.
      }
      \sstsubsection{
         MAP = INTEGER (Given)
      }{
         The mapping from the PIXEL Frame to the current WCS Frame.
         This can also be a mapping from GRID to the current Frame.
         In which case the returned co-ordinates and mapping apply
         to GRID co-ordinates instead of PIXEL.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         The index of the WCS axis in the current Frame to be aligned.
      }
      \sstsubsection{
         AXLOW = DOUBLE PRECISION (Given)
      }{
         Lower bound of the WCS axis.  If either AXLOW or AXHIGH is
         set to AST\_\_BAD, then the whole axis range is used.
      }
      \sstsubsection{
         AXHIGH = DOUBLE PRECISION (Given)
      }{
         Upper bound of the WCS axis.  If either AXLOW or AXHIGH is
         set to AST\_\_BAD, then the whole axis range is used.
      }
      \sstsubsection{
         PAXIS = INTEGER (Returned)
      }{
         The index of the pixel most closely aligned with the supplied
         WCS axis.
      }
      \sstsubsection{
         PXLOW = DOUBLE PRECISION (Given)
      }{
         Lower bound of the PIXEL axis corresponding to the AXLOW in
         the WCS axis.
      }
      \sstsubsection{
         PXHIGH = DOUBLE PRECISION (Given)
      }{
         Upper bound of the PIXEL axis corresponding to the AXHIGH in
         the WCS axis.
      }
      \sstsubsection{
         MAP1D = INTEGER (Returned)
      }{
         The mapping from the current WCS Frame to PIXEL whose input
         is purely along the chosen axis (IAXIS).  It is set to
         AST\_\_NULL if the supplied mapping (MAP) could not be split.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASCRV
}{
   Draw a polyline using AST
}{
   \sstdescription{
      This routine draw a polyline between the supplied positions. These
      positions are presumed to refer to the (2D) Current coordinate Frame
      in the supplied AST Plot.

      If FAST is .TRUE., the supplied positions are transformed into
      graphics coordinates, and the polyline is then drawn as a series
      of straight line segments using PGPLOT directly. Drawing performed
      with FAST = .TRUE. is buffered to increase efficiency. Call this
      routine with N=0 to flush the buffer.

      If FAST is .FALSE., AST\_CURVE is used to draw the polyline as a
      series of geodesic curves in the Current Frame of the Plot. This
      will take into account any discontinuities in the Mapping from
      the Current Frame to the graphics coordinate Frame, but will be
      slower.
   }
   \sstinvocation{
      CALL KPG1\_ASCRV( IPLOT, FAST, N, X, Y, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         A pointer to a Plot.
      }
      \sstsubsection{
         FAST = LOGICAL (Given)
      }{
         Is faster plotting required?
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of points in the polyline. Zero to flush the buffer
         when drawing in fast mode.
      }
      \sstsubsection{
         X( N ) = REAL (Given)
      }{
         The X coordinates at the polyline points, in the Current Frame of
         the Plot.
      }
      \sstsubsection{
         Y( N ) = REAL (Given)
      }{
         The Y coordinates at the polyline points, in the Current Frame of
         the Plot.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASDIS
}{
   Find the distance between two points
}{
   \sstdescription{
      This routine returns the distance between two positions in the
      supplied co-ordinate Frame. Either the geodesic or Euclidean distance
      can be returned.
   }
   \sstinvocation{
      RESULT = KPG1\_ASDIS( FRAME, DIM, NAX, POS, I1, I2, GEO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         An AST pointer to the Frame. Only accessed if GEO is .TRUE.
      }
      \sstsubsection{
         DIM = INTEGER (Given)
      }{
         The size of the first dimension of the POS array.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame.
      }
      \sstsubsection{
         POS( DIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         An array holding the co-ordinates at DIM positions within the
         supplied Frame.
      }
      \sstsubsection{
         I1 = INTEGER (Given)
      }{
         The index of the first position, in the range 1 to DIM.
      }
      \sstsubsection{
         I2 = INTEGER (Given)
      }{
         The index of the second position, in the range 1 to DIM.
      }
      \sstsubsection{
         GEO = LOGICAL (Given)
      }{
         Is the geodesic distance required?
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         KPG1\_ASDIS = DOUBLE PRECISION
      }{
         The distance between the two points.
      }
   }
}
\sstroutine{
   KPG1\_ASDSV
}{
   Find the distances between a set of points
}{
   \sstdescription{
      This routine returns the distance to each point in a set of points,
      from the first point, measured along the path joining the points.
      Geodesic distances within the supplied Frame are used.
   }
   \sstinvocation{
      CALL KPG1\_ASDSV( FRM, NP, NAX, POS, NORM, DIS, BAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRM = INTEGER (Given)
      }{
         An AST pointer to the Frame.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of the first dimension of the POS array.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame.
      }
      \sstsubsection{
         POS( NP, NAX ) = DOUBLE PRECISION (Given)
      }{
         An array holding the co-ordinates at NP positions within the
         supplied Frame.
      }
      \sstsubsection{
         NORM = LOGICAL (Given)
      }{
         If .TRUE., the returned distances are normalised to a maximum
         value of 1.0.
      }
      \sstsubsection{
         DIS( NP ) = DOUBLE PRECISION (Returned)
      }{
         The distance along the path to each position, starting at the
         first position.
      }
      \sstsubsection{
         BAD = LOGICAL (Returned)
      }{
         Are there any AST\_\_BAD values in the returned array?
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_ASFFR
}{
   Finds an Frame with a given Domain within a FrameSet
}{
   \sstdescription{
      This routine finds the last Frame with a given Domain within a
      FrameSet, and returns its index. The Current Frame in the FrameSet
      is not changed.

      The first and last component Frames within CmpFrames are included
      in the search (component Frames in the middle of a CmpFrame cannot
      be found as yet). If a matching Frame is found within a CmpFrame,
      then a copy of the matching Frame is appended to the FrameSet. The
      returned Frame index refers to this extracted component Frame, rather
      than the CmpFrame from which it was extracted.
   }
   \sstinvocation{
      CALL KPG1\_ASFFR( TARGET, DOMAIN, IFRM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TARGET = INTEGER (Given)
      }{
         An AST pointer for a FrameSet containing the Frames to be
         searched.
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain name to be searched for.
      }
      \sstsubsection{
         IFRM = INTEGER (Returned)
      }{
         The index of the matching Frame within the returned FrameSet.
         Returned equal to AST\_\_NOFRAME if no match was found, or if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASFGT
}{
   Create a new Frame specified through the environment
}{
   \sstdescription{
      This routine creates a new AST Frame with properties specified by
      the given environment parameter. The parameter value is interpreted
      as an HDS path containing a WCS FrameSet in the form created by
      KPG1\_WWRT. If this is succesful, the current Frame of the FrameSet
      is returned. Otherwise, an attempt is made to interpret the parameter
      value as an NDF name. If the NDF is opened succesfully, its current
      WCS Frame is returned. If this fails, and the parameter value ends
      with {\tt "}.FIT{\tt "}, am attempt is made to interpret the parameter value as
      the name of a FITS file. If successful, the primary WCS Frame from
      the primary HDU headers is returned. If the above attempt fails,
      an attempt is made to interpret the parameter value as the name of a
      text file containing either an AST Frame dump, or a set of FITS
      headers.

      If all the above fails, and the parameter value looks like an IRAS90
      {\tt "}Sky Co-ordinate System{\tt "} (SCS) specification, then a SkyFrame is
      returned with the properties specified by the SCS. Otherwise, a
      simple Frame is returned with Domain set to the parameter value,
      the number of axes in the Frame being specified by another environment
      parameter.
   }
   \sstinvocation{
      CALL KPG1\_ASFGT( PDOM, PDIM, PEP, FRM, NAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of parameter to use to get Frame Domain.
      }
      \sstsubsection{
         PDIM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of parameter to use to get number of Frame axes. Only
         accessed if the value obtained for PDOM is not an IRAS90 SCS.
      }
      \sstsubsection{
         PEP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of parameter to use to get the epoch of observation. Only
         accessed if the value obtained for PDOM is an IRAS90 SCS.
      }
      \sstsubsection{
         FRM = INTEGER (Returned)
      }{
         An AST pointer to the returned Frame. Returned equal to
         AST\_\_NULL if an error occurs.
      }
      \sstsubsection{
         NAX = INTEGER (Returned)
      }{
         The number of axes in the returned Frame. Returned equal to zero
         if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASFIL
}{
   Read spatial positions from a text file
}{
   \sstdescription{
      This routine obtains formatted positions from a text file specified by
      an environment parameter. The positions are assumed to represent
      axis values in the supplied Frame.

      The file should contain 1 position per line. Each position is given by
      a set of strings delimited by comma, space or tab (the first gives the
      value for axis 1, the second for axis 2, etc). The number of strings
      per line should equal the number of axes in the supplied Frame.
      The user can specify the columns to use using parameter PARAM2.

      The file may contain blank lines, and comment lines commencing with
      {\tt "}!{\tt "} or {\tt "}\#{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_ASFIL( PARAM1, PARAM2, FRM, NP, IPOUT, FNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM1 = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of an environment parameter to use to get the file.
      }
      \sstsubsection{
         PARAM2 = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of an environment parameter to use to get the indices of
         the columns within the text file which are to be used. If blank,
         the file must contain a column for every axis in FRM, all of which
         are used in the order 1, 2, 3, etc.
      }
      \sstsubsection{
         FRM = INTEGER (Given)
      }{
         A pointer to an AST Frame.
      }
      \sstsubsection{
         NP = INTEGER (Returned)
      }{
         The number of positions read from the file.
      }
      \sstsubsection{
         IPOUT = INTEGER (Returned)
      }{
         A pointer to an \_DOUBLE array {\tt "}COR( NP, $*$ ){\tt "} holding the obtained
         co-ordinates. The second dimension of the array is equal to the
         number of axes in the suppleid Frame. Should be released using
         PSX\_FREE when no longer needed.
      }
      \sstsubsection{
         FNAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The file{\tt '}s name. Not accesed if the declared length of the
         supplied string is 1 character.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASFIX
}{
   Modify the WCS FrameSet of an NDF to take account of
   re-gridding the pixel array
}{
   \sstdescription{
      This routine copies the WCS FrameSet from NDF1 to NDF2, re-mapping
      the PIXEL Frame using the specified Mapping in the process. It should
      be used to set up the WCS FrameSet of a newly created output NDF
      which has been formed by applying a geometric transformation to an
      input NDF.
   }
   \sstinvocation{
      CALL KPG1\_ASFIX( MAP, INDF1, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MAP = INTEGER (Given)
      }{
         An AST Mapping from pixel co-ordinates in the INDF1 to pixel
         co-ordinates in INDF2.
      }
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         The input NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Given)
      }{
         The output NDF. Any existing WCS FrameSet is discarded and
         replaced by a re-mapped copy of the WCS FrameSet from the input
         NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASFRM
}{
   Sets the current Frame in a FrameSet to a Frame specified through
   the environment
}{
   \sstdescription{
      This routine allows the user to specify a new Current Frame for a
      FrameSet using an environment parameter.
   }
   \sstinvocation{
      CALL KPG1\_ASFRM( PARAM, EPARAM, IWCS, WCDOM, DCDOM, PROMPT, TOKEN,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of parameter to use to get Frame description.
      }
      \sstsubsection{
         EPARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of parameter to use to get Epoch value (if needed).
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer to the FrameSet.
      }
      \sstsubsection{
         WCDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain name to use if the user requests {\tt "}WORLD{\tt "} co-ordinates.
         No translation of WORLD takes place if a blank value is supplied.
      }
      \sstsubsection{
         DCDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain name to use if the user requests {\tt "}DATA{\tt "} co-ordinates.
         No translation of DATA takes place if a blank value is supplied.
      }
      \sstsubsection{
         PROMPT = LOGICAL (Given)
      }{
         An error is always reported if the requested Frame is not
         available in the FrameSet. PROMPT controls what happens after
         the error has been reported. If .TRUE., then the error is
         flushed, the parameter is cancelled, and the user is re-prompted
         for a new \%PARAM value. Otherwise, the error is retained, and the
         routine exits with STATUS set to SAI\_\_ERROR.
      }
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string containing an MSG message token reference (eg {\tt "}$\wedge$FRED{\tt "}).
         The value of the token is used within error messages and should
         describe the object (NDF, catalogue, etc) from which the supplied
         FrameSet is derived. If the token reference string is blank it is
         ignored.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine may add a new co-ordinate Frame into the FrameSet.

         \sstitem
         If the FrameSet contains more than one Frame with the requested
            Domain, then the last matching Frame in the FrameSet will be
            used (i.e. the one with highest index).
      }
   }
   \sstdiylist{
      Environment Parameters
   }{
      \sstsubsection{
         \%PARAM = LITERAL (Read)
      }{
         A string specifying the new co-ordinate Frame. If a null parameter
         value is supplied, then the error is annulled and the current Frame
         is left unchanged. The string can be one of the following:

         \sstitemlist{

            \sstitem
            A Domain name such as SKY, AXIS, PIXEL, etc. The two
            {\tt "}pseudo-domains{\tt "} WORLD and DATA may be supplied and will be
            translated into the values supplied for arguments WCDOM and DCDOM
            respectively, so long as the FrameSet does not contain Frames with
            Domains WORLD or DATA.

            \sstitem
            An integer value giving the index of the required Frame within
            the WCS component.

            \sstitem
            An IRAS90 Sky Co-ordinate System (SCS) values such as
            EQUAT(J2000) (see SUN/163).
         }
      }
      \sstsubsection{
         \%EPARAM = \_DOUBLE (Read)
      }{
         If a celestial co-ordinate system is supplied (using parameter
         \%PARAM) then an epoch value is needed to qualify it. This is the
         epoch at which the supplied sky positions were determined. It should
         be given as a decimal years value, with or without decimal places
         ({\tt "}1996.8{\tt "} for example). Such values are interpreted as a Besselian
         epoch if less than 1984.0 and as a Julian epoch otherwise.
      }
   }
}
\sstroutine{
   KPG1\_ASGDP
}{
   Find a position with good output co-ordinates within a given input
   region of a supplied Mapping
}{
   \sstdescription{
      This routine finds a position which has good co-ordinates in the
      output Frame of the given Mapping, and returns both the input and
      output co-ordinates at this position. The position is constrained
      to lie within a specified box within the input Frame. The first
      point to be tested is the centre of the box. If this does not give
      valid output co-ordinates then a set of 10000 points randomly
      distributed within the box is tested. An error is reported if no
      good position can be found.
   }
   \sstinvocation{
      CALL KPG1\_ASGDP( MAP, NDIM1, NDIM2, LBND, UBND, INPOS, OUTPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MAP = INTEGER (Given)
      }{
         The Mapping to use.
      }
      \sstsubsection{
         NDIM1 = INTEGER (Given)
      }{
         The number of input co-ordinates.
      }
      \sstsubsection{
         NDIM2 = INTEGER (Given)
      }{
         The number of output co-ordinates.
      }
      \sstsubsection{
         LBND( NDIM1 ) = DOUBLE PRECISION (Given)
      }{
         The lower bounds of the test box, within the input Frame of the
         supplied Mapping.
      }
      \sstsubsection{
         UBND( NDIM1 ) = DOUBLE PRECISION (Given)
      }{
         The upper bounds of the test box, within the input Frame of the
         supplied Mapping.
      }
      \sstsubsection{
         INPOS( NDIM1 ) = DOUBLE PRECISION (Returned)
      }{
         The returned input co-ordinates at the selected position.
         There will be no AST\_\_BAD values in this array.
      }
      \sstsubsection{
         OUTPOS( NDIM2 ) = DOUBLE PRECISION (Returned)
      }{
         The returned output co-ordinates at the selected position.
         There will be no AST\_\_BAD values in this array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASGET
}{
   Gets an AST FrameSet from the WCS component of an NDF
}{
   \sstdescription{
      This routine determines the axes to be used from an NDF and returns a
      FrameSet representing the WCS information in the NDF.

      Each axis of the supplied NDF is checked to see if it is significant
      (i.e. has a size greater than 1).  The index of each significant axis
      is returned in SDIM, and the bounds of the axis are returned in SLBND
      and SUBND.  If EXACT is .TRUE., an error is reported if the number of
      significant axes is not exactly NDIM.  This mode is intended for case
      where (say) the user has supplied a single plane from a 3D data cube
      to an application which requires a 2D array.

      If EXACT is .FALSE. an error is only reported if the number of
      significant dimensions is higher than NDIM.  If there are less than
      NDIM significant dimensions then the insignificant dimensions are
      used (starting from the lowest) to ensure that the required number
      of dimensions are returned. This mode is intended for cases where (say)
      the user supplies a 1D data stream to an application which requires a
      2D array.

      The GRID Frame (i.e. the Base Frame) obtained from the NDFs WCS
      component is modified so that it has NDIM axes corresponding to the
      axes returned in SDIM (the value 1.0 is used for the other axes).

      Likewise, the PIXEL Frame obtained from the NDFs WCS component is
      modified so that it has NDIM axes corresponding to the axes returned
      in SDIM (the lower pixel bound is used for the other axes). The
      original PIXEL Frame is retained, but with Domain changed to
      NDF\_PIXEL.

      If TRIM is .TRUE., then the Current Frame obtained from the NDFs WCS
      component is also modified so that it has NDIM axes. If the original
      Current Frame has more than NDIM axes, then the axes to use are
      obtained from the environment using parameter USEAXIS. A new Current
      Frame is then made by picking these axes from the original Current
      Frame, assigning the value AST\_\_BAD to the axes which have not been
      chosen.

      If the original Current Frame has less than NDIM axes, then simple
      axes are added into the new Current Frame to make up a total of
      NDIM. These axes are given the value 1.0.

      Various environment parameters may be used to obtain options, etc. The
      names of these parameters are hard-wired into this subroutine in
      order to ensure conformity between applications.
   }
   \sstinvocation{
      CALL KPG1\_ASGET( INDF, NDIM, EXACT, TRIM, REQINV, SDIM, SLBND, SUBND,
                       IWCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier for the NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions required by the application.
      }
      \sstsubsection{
         EXACT = LOGICAL (Given)
      }{
         Must the NDF have exactly NDIM significant axes? Otherwise it is
         acceptable for the NDIM axes to include some insignificant axes.
      }
      \sstsubsection{
         TRIM = LOGICAL (Given)
      }{
         Should the returned FrameSet be trimmed to ensure that the
         Current Frame has NDIM axes? Otherwise, the Current Frame read
         from the NDF is not changed.
      }
      \sstsubsection{
         REQINV = LOGICAL (Given)
      }{
         Is the inverse mapping (from Current Frame to Base Frame)
         required? If it is, an error is reported if the inverse mapping
         is not available. REQINV should be supplied .TRUE. in most cases.
      }
      \sstsubsection{
         SDIM( NDIM ) = INTEGER (Returned)
      }{
         The indices of the significant dimensions.
      }
      \sstsubsection{
         SLBND( NDIM ) = INTEGER (Returned)
      }{
         The lower pixel index bounds of the significant dimensions.  These
         are stored in the same order as the indices in SDIM.
      }
      \sstsubsection{
         SUBND( NDIM ) = INTEGER (Returned)
      }{
         The upper pixel index bounds of the significant dimensions.  These
         are stored in the same order as the indices in SDIM.
      }
      \sstsubsection{
         IWCS = INTEGER (Returned)
      }{
         An AST pointer to the WCS FrameSet. Returned equal to AST\_\_NULL
         if an error occurs. The Base Frame is an NDIM-dimensional GRID
         Domain.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the Current Frame in the returned FrameSet has no Title, then
         the Title is set to the value of the NDF TITLE component (so long
         as the NDF TITLE is not blank or undefined).
      }
   }
   \sstdiylist{
      Environment Parameters
   }{
      \sstsubsection{
         USEAXIS = LITERAL (Read)
      }{
         A set of NDIM axes to be selected from the Current Frame. Each
         axis can be specified either by giving its index within the Current
         Frame in the range 1 to the number of axes in the Frame, or by
         giving its symbol. This parameter is only accessed if TRIM is
         .TRUE. and the original Current Frame in the supplied NDF has
         too many axes. The dynamic default selects the axes with the same
         indices as the selected NDF axes. The value should be given as a
         GRP group expression, with default control characters.
      }
   }
}
\sstroutine{
   KPG1\_ASGFR
}{
   Reads a line of an AST Object description from a GRP group
}{
   \sstdescription{
      This routine reads a line of an AST Object description from a GRP
      group, removing the first character if it is a {\tt "}\#{\tt "} or a {\tt "}!{\tt "}. It then
      returns the line of text to the AST library using AST\_PUTLINE. It is
      intended to be used as a source function with AST\_CHANNEL.
   }
   \sstinvocation{
      CALL KPG1\_ASGFR( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASGFW
}{
   Writes a line of an AST Object description to a GRP group
}{
   \sstdescription{
      This routine writes a line of an AST Object description to a GRP
      group, optionally prepending it with the a given string. It is
      intended to be used as a sink function with AST\_CHANNEL.
   }
   \sstinvocation{
      CALL KPG1\_ASGFW( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASGRD
}{
   Draw a border or an annotated coordinate grid over an AST Plot
}{
   \sstdescription{
      This routine call AST\_BORDER to draw a border, or AST\_GRID to draw an
      annotated coordinate Grid over the supplied Plot. The current pgplot
      viewport can optionally be extended prior to drawing the grid so that
      it covers a specified AGI picture. If the pgplot viewport is left
      matching the plotting area supplied when the Plot was created, then
      certain component of the grid (i.e. exterior tick marks), are clipped
      by pgplot. To avoid this, IPIC should normally be given as the AGI
      identifier for the FRAME picture containing the plot.
   }
   \sstinvocation{
      CALL KPG1\_ASGRD( IPLOT, IPIC, GRID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to the Plot.
      }
      \sstsubsection{
         IPIC = INTEGER (Given)
      }{
         An AGI identifier for the FRAME picture. Supply this as -1 if the
         current pgplot viewport is not to be changed.
      }
      \sstsubsection{
         GRID = LOGICAL (Read)
      }{
         Draw a grid using AST\_GRID? If .FALSE. then a border only is drawn
         (using AST\_BORDER).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The PGPLOT interface to the AGI library should be opened before
         calling this routine.
      }
   }
}
\sstroutine{
   KPG1\_ASGRP
}{
   Read spatial positions from a GRP group
}{
   \sstdescription{
      This routine reads formatted positions from a GRP group. The
      positions are assumed to be in the supplied Frame. Each element
      in the group should contain 1 position per line. Each position is
      given by a set of strings delimited by comma, space or tab (the
      first gives the value for axis 1, the second for axis 2, etc). The
      number of strings per element in the group should equal the number
      of axes in the Base Frame of the supplied FrameSet.

      An error is reported if any unreadable elements are found.
   }
   \sstinvocation{
      CALL KPG1\_ASGRP( PARAM, FRM, IGRP, NP, NAX, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of an environment parameter to use to get the indices of
         the columns within the text file which are to be used. If blank,
         the file must contain exactly NAX columns, all of which are used.
         If a null value is supplied, the dynamic default values will be
         used which is [1,2,3... NAX].
      }
      \sstsubsection{
         FRM = INTEGER (Given)
      }{
         A pointer to an AST Frame.
      }
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for the group to read.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The number of positions which can be stored in the returned array.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the supplied Frame.
      }
      \sstsubsection{
         OUT( NP, NAX ) = DOUBLE PRECISION (Returned)
      }{
         The array to hold the returned co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASIRA
}{
   Creates an AST FrameSet from an IRAS90 astrometry structure
}{
   \sstdescription{
      This routine creates an AST Frame describing the sky co-ordinates
      stored in an IRAS90 astrometry structure (see SUN/165), together with
      a Mapping from IRAS90 {\tt "}image co-ordinates{\tt "} to sky co-ordinates.
   }
   \sstinvocation{
      CALL KPG1\_ASIRA( IDA, FRM, MAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine requires access to the IRA internal common blocks,
         and uses IRA internal subroutines.
      }
   }
}
\sstroutine{
   KPG1\_ASLOG
}{
   Take log base 10 of each axis value (an AST IntraMap routine)
}{
   \sstdescription{
      This routine transforms axis values by taking the logarithm (base
      10). The inverse exponentiates the supplied axis values. It is intended
      for use as a transformation routine by an AST IntraMap.
   }
   \sstinvocation{
      CALL KPG1\_ASLOG( THIS, NPOINT, NCOORD\_IN, INDIM, IN, FORWARD,
                       NCOORD\_OUT, OUTDIM, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Bad input co-ordinates will be set to AST\_\_BAD, but TRANSFORM uses
         VAL\_\_BADD to mark bad values. We assume here that VAL\_\_BADD and
         AST\_\_BAD are the same.
      }
   }
}
\sstroutine{
   KPG1\_ASMRG
}{
   Merges two FrameSets by aligning them in a common Frame
}{
   \sstdescription{
      This routine merges two FrameSet by aligning them in a suitable
      common Frame. The Current Frame in the second FrameSet becomes the
      Current Frame in the merged FrameSet. The domain search order for
      finding a suitable Frame is:

      1) The domain of the Current Frame in IWCS2, if not blank.
      2) {\tt "}SKY{\tt "}
      3) {\tt "}SPECTRUM{\tt "}
      4) {\tt "}PIXEL{\tt "}
      5) {\tt "}GRID{\tt "}
      6) The domain specified by argument DOMAIN, if not blank. If DOMAIN
         is blank, {\tt "}AGI\_WORLD{\tt "} is used.
      7) Any other suitable Frame.

      For each of these Domains, the current Frame is checked first. An error
      is reported if alignment is not possible, and a message identifying the
      alignment Frame is displayed if alignment is possible.

      If either FrameSet contains a second Frame with the same Domain as
      the alignment Frame then a warning is issued.

      If the above attempt to align the Frames directly using astConvert
      fails, then a further attempt is made if one of the two Frames is a
      SpecFrame or SkyFrame, and the other Frame is a CmpFrame. In this
      case, the CmpFrame is searched for a Frame that can be aligned with
      the SkyFrame or SpecFrame. If this is succesful, the other axes in
      the CmpFrame are fed bad values by the Mapping which connects the
      two Frames.
   }
   \sstinvocation{
      CALL KPG1\_ASMRG( IWCS1, IWCS2, DOMAIN, QUIET, IND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS1 = INTEGER (Given)
      }{
         An AST pointer to the first FrameSet. This is modified by adding
         all the Frames from IWCS2 into it. The Current Frame on exit is
         inherited from IWCS2.
      }
      \sstsubsection{
         IWCS2 = INTEGER (Given)
      }{
         An AST pointer to the second FrameSet. The Current and Base Frames
         are unchanged on exit.
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma separated list of domains in which alignment of the FrameSets
         should be attempted if alignment is not possible in the Current Frame
         of the second FrameSet, or SKY, SPECTRUM, PIXEL or GRID.
      }
      \sstsubsection{
         QUIET = LOGICAL (Given)
      }{
         Suppress the message identifying the alignment Frame?
      }
      \sstsubsection{
         IND = INTEGER (Given)
      }{
         The alignment message is padded with IND leading spaces.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASOFF
}{
   Find a position offset by a given distance from one position
   towards another position
}{
   \sstdescription{
      This routine returns the co-ordinates of a position which is a given
      distance along a curve joining one position to another position.
      The curve can be either be the geodesic or Euclidean curve joining
      the two points.
   }
   \sstinvocation{
      CALL KPG1\_ASOFF( FRAME, DIM, NAX, POS, I1, I2, GEO, DIS, OFFPOS,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         An AST pointer to the Frame. Only accessed if GEO is .TRUE.
      }
      \sstsubsection{
         DIM = INTEGER (Given)
      }{
         The size of the first dimension of the POS array.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame.
      }
      \sstsubsection{
         POS( DIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         An array holding the co-ordinates at DIM positions within the
         supplied Frame.
      }
      \sstsubsection{
         I1 = INTEGER (Given)
      }{
         The index of the first position, in the range 1 to DIM.
      }
      \sstsubsection{
         I2 = INTEGER (Given)
      }{
         The index of the second position, in the range 1 to DIM.
      }
      \sstsubsection{
         GEO = LOGICAL (Given)
      }{
         Is the geodesic distance required?
      }
      \sstsubsection{
         DIS = DOUBLE PRECISION (GIVEN)
      }{
         The distance to move away from position I1 towards position I2.
      }
      \sstsubsection{
         OFFPOS( NAX ) = DOUBLE PRECISION (Returned)
      }{
         The returned position.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_ASPCL
}{
   Apply clipping to a Plot so that border and coordinate grid are
   restricted to the well bahaved regions
}{
   \sstdescription{
      This routine imposes clipping on a Plot (using the AST\_CLIP routine)
      that restricts drawing to the regions that seem well bahaved.
      Specifically, drawing is restricted to a rectangular region within
      the base Frame of the Plot that is determined by transforming the
      supplied PIXEL bounding box into the current Frame, then converting
      it to the base Frame.
   }
   \sstinvocation{
      CALL KPG1\_ASPCL( IPLOT, LBND, UBND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to the Plot.
      }
      \sstsubsection{
         LBND( $*$ ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the Plot in the PIXEL Frame.
      }
      \sstsubsection{
         UBND( $*$ ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the Plot in the PIXEL Frame.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASPLG
}{
   Store a given KeyMap for future use by KPG1\_ASPLN
}{
   \sstdescription{
      This routine stores the supplied AST KeyMap pointer in common so
      that subsequent calls to KPG1\_ASPLN can use it. If KPG1\_ASPLN has
      been registered with a Plot using AST\_GRFSET, then it will be
      called by AST whenever AST needs to draw a line. It will then draw
      the required line and store a description of the line in the AST
      KeyMap supplied to this routine. Consequently, this routine should
      usually be called before calling AST\_GRFSET.
   }
   \sstinvocation{
      CALL KPG1\_ASPLG( KEYMAP, BLEDGE, X1, X2, Y1, Y2 )
   }
   \sstarguments{
      \sstsubsection{
         KEYMAP = INTEGER (Given)
      }{
         The KeyMap in which to store descriptions of the lines drawn by
         the AST Plot class.
      }
      \sstsubsection{
         BLEDGE = LOGICAL (Given)
      }{
         If TRUE, then do not draw lines that touch an edge of the box
         specified by X1, X2, Y1 and Y2.
      }
      \sstsubsection{
         X1 = REAL (Given)
      }{
         The X value at the left hand edge. Unused if BLEDGE Is .FALSE.
      }
      \sstsubsection{
         X2 = REAL (Given)
      }{
         The X value at the right hand edge. Unused if BLEDGE Is .FALSE.
      }
      \sstsubsection{
         Y1 = REAL (Given)
      }{
         The Y value at the bottom edge. Unused if BLEDGE Is .FALSE.
      }
      \sstsubsection{
         Y2 = REAL (Given)
      }{
         The Y value at the top edge. Unused if BLEDGE Is .FALSE.
      }
   }
}
\sstroutine{
   KPG1\_ASPLN
}{
   Draw a line for an AST Plot and log it at the same time
}{
   \sstdescription{
      This routine is intended to be registered with an AST Plot (using
      AST\_GRFSET) so that it is subsequently used to draw all lines. When
      called by AST, it calls the underlying PGPLOT line drawing function
      to draw the polyline specified by N, X and Y, and then records the
      details of the drawn polyline in an AST KeyMap (previously specified
      by calling KPG1\_ASPLG). This KeyMap can then be interogated in order
      to determine what lines were drawn. A new entry is added to the
      KeyMap each time this function is called. Each such entry is itself
      a KeyMap containing three entries with keys {\tt "}N{\tt "}, {\tt "}X{\tt "} and {\tt "}Y{\tt "}. The {\tt "}N{\tt "}
      entry is a scalar integer holding the corresponding N value, and
      the other two are single precision vector entries holding the X and
      Y values.

      KPG1\_ASPLG should be called prior to registering this function
      using AST\_GRFSET.
   }
   \sstinvocation{
      RESULT = KPG1\_ASPLN( GRFCON, N, X, Y )
   }
   \sstarguments{
      \sstsubsection{
         GRFCON = INTEGER (Given)
      }{
         A KeyMap containing information passed from the calling application.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of pointsin the polyline.
      }
      \sstsubsection{
         X( N ) = REAL (Given)
      }{
         The graphics X coord at each point on the polyline.
      }
      \sstsubsection{
         Y( N ) = REAL (Given)
      }{
         The graphics Y coord at each point on the polyline.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The PGPLOT interface to the AGI library should be opened before
         calling this routine.
      }
   }
}
\sstroutine{
   KPG1\_ASPLT
}{
   Create an AST Plot covering the current PGPLOT viewport
}{
   \sstdescription{
      This routine create a Plot covering the current PGPLOT viewport.
      The bounds of the PGPLOT window are changed if necessary to ensure
      that the PGPLOT world co-ordinate system corresponds to milliemtres
      from the bottom left corner of the view surface. This is the
      co-ordinate system used in the Base (GRAPHICS) Frame of the returned
      Plot.
   }
   \sstinvocation{
      CALL KPG1\_ASPLT(  IWCS, BOX, OPTS, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         The FrameSet to include in the Plot. May be AST\_\_NULL.
      }
      \sstsubsection{
         BOX( 4 ) = DOUBLE PRECISION (Given)
      }{
         An array holding the bounds of the area within the Base Frame of
         IWCS which is to be mapped linearly onto the current PGPLOT
         viewport. The first pair of values should give the coordinates at
         the bottom left corner of the plotting area and the second pair
         should give the coordinates at the top right corner. The coordinate
         on the horizontal axis should be given first in each pair.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A set of Plot attribute settings to be used when creating the
         Plot.
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         An AST pointer to the Plot. Returned equal to AST\_\_NULL if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The PGPLOT interface to the AGI library should be opened before
         calling this routine.
      }
   }
}
\sstroutine{
   KPG1\_ASPRP
}{
   Propagates the WCS component from one NDF to another with the same
   number of axes, allowing for a linear mapping of the pixel
   co-ordinates
}{
   \sstdescription{
      This routine copies the WCS FrameSet from INDF1, re-mapping the
      GRID Frame in the process so that pixel co-ordinates in the output
      NDF are related to pixel co-ordinates in the input NDF by the
      supplied linear transformation. The mapping from pixel
      co-ordinates in INDF1 ({\tt "}PIX1{\tt "}) to the corresponding pixel
      co-ordinates in INDF2 ({\tt "}PIX2{\tt "}) is:

         PIX2 = MATRIX . PIX1 $+$ OFFSET

      For instance, for NDIM = 2:

         X2 = MATRIX( 1, 1 ).X1 $+$ MATRIX( 2, 1 ).Y1 $+$ OFFSET( 1 )
         Y2 = MATRIX( 1, 2 ).X1 $+$ MATRIX( 2, 2 ).Y1 $+$ OFFSET( 2 )
   }
   \sstinvocation{
      CALL KPG1\_ASPRP( NDIM, INDF1, INDF2, MATRIX, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions. This should be the value returned by
         NDF\_BOUND for INDF2.
      }
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         An identifier for the source NDF. If this does not have NDIM
         pixel axes, a NDF section with NDIM axes will be obtained from
         the supplied NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Given)
      }{
         An identifier for the destination NDF. This must have NDIM
          pixel axes.
      }
      \sstsubsection{
         MATRIX( NDIM, NDIM ) = DOUBLE PRECISION (Given)
      }{
         The matrix connecting PIX1 and PIX2.
      }
      \sstsubsection{
         OFFSET( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The offset vector for PIX2.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASPSY
}{
   Establish synonyms for AST attribute names
}{
   \sstdescription{
      This routine establishes synonyms for AST attribute names or
      attribute qualifiers (qualifiers are strings in parenthesise following
      the attribute name - the {\tt "}graphical elements{\tt "} used by some Plot
      attributes are examples of qualifiers). The routine KPG1\_ASCHP is
      used to translated synonyms into values recognised by AST.

      Note, substitutions for synonyms are performed in the order in
      which they are defined, with later substitutions potentially
      modifying the results of earlier substitutions. For this reason,
      synonyms for specific name/qualifer pairs (eg {\tt "}FORMAT(VEC$*$TOR){\tt "} )
      should be defined $*$before$*$ synonyms for qualifiers alone (eg
      {\tt "}(VEC$*$TOR){\tt "} ). If these two examples were defined in the opposite
      order, then the qualifier in FORMAT(VEC) (i.e. {\tt "}VEC{\tt "}) would get
      replaced by the translation supplied for synonym {\tt "}(VEC$*$TOR){\tt "}, so
      that the resulting string would then fail to match the synonym
      {\tt "}FORMAT(VEC$*$TOR){\tt "} and so would not result in the correct translation.
   }
   \sstinvocation{
      CALL KPG1\_ASPSY( SYNON, TRAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SYNON = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A synonym for an AST attribute name and/or qualifier. The
         supplied value is converted to upper case, and stripped of spaces.
         If the synonym contains just a qualifier (i.e. no attribute
         name), then KPG1\_ASCHP will substitute the qualifier from the
         translation irespective of the attribute name. Minimum
         abbreviations for attribute qualifiers may be given by including
         an asterisk in the qualifier to mark the end of the minimum
         abbreviation. If a blank value is supplied, then the resources used
         to store the synonyms and translations are released.
      }
      \sstsubsection{
         TRAN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The translation for the supplied synonym. This should be a legal
         AST attribute name/qualifier combination (but no check is made
         on this). The supplied value is converted to upper case, and
         stripped of spaces.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASPTP
}{
   Put a formatted AST position into a string
}{
   \sstdescription{
      This routine puts a formatted position into a text string starting
      at a specified index within the string. Axis symbols may optionally
      be included. The axis values are separated by a specified string.
   }
   \sstinvocation{
      CALL KPG1\_ASPTP( FRAME, NAX, POS, SYMBLS, SEP, TEXT, IAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         The Frame in which the position is defined.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame.
      }
      \sstsubsection{
         POS( NAX ) = DOUBLE PRECISION (Given)
      }{
         The position to format.
      }
      \sstsubsection{
         SYMBLS = LOGICAL (Given)
      }{
         Are axis symbols to be included? If so, each axis value is
         formatted with a {\tt "}symbol=value{\tt "} string.
      }
      \sstsubsection{
         SEP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The separator for axis values. Trailing spaces are significant.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The text to hold the formatted values.
      }
      \sstsubsection{
         IAT = INTEGER (Given and Returned)
      }{
         On entry, the index of the last character before the point at
         which the text is to be placed. On exit, the index of the last
         character written by this routine.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASREF
}{
   Associates an NDF optionally from a reference name or locator
}{
   \sstdescription{
      This routine obtains an NDF.  There is a search path of sources
      for the NDF checked in the following order: a) command line, b) a
      reference locator or name, c) elsewhere in the parameter system
      (usually by prompting.)  For a) and c) the NDF is obtained by
      association.  For b) a locator or name is imported into the NDF\_
      system; an error will result if the locator does not point to a
      valid NDF.  The role of this routine is to permit automatic
      processing of NDFs associated with database pictures.  The
      command-line access allows the NDF reference stored with the last
      DATA picture to be overridden.
   }
   \sstinvocation{
      CALL KPG1\_ASREF( PNNDF, MODE, GOTNAM, NAME, NDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the Starlink parameter to be associated with the
         input NDF. May be blank, in which case no attempt will be made
         to obtain the NDF form the environment.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Access mode to the NDF required: {\tt '}READ{\tt '} or {\tt '}UPDATE{\tt '}.
      }
      \sstsubsection{
         GOTNAM = LOGICAL (Given)
      }{
         If .TRUE., a name or locator to a potential NDF has already
         been obtained and is supplied to this routine through the NAME
         argument.  The name or locator may come from a reference in
         the graphics database.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the potential NDF, or a locator to it.
      }
      \sstsubsection{
         NDF = INTEGER (Returned)
      }{
         The identifier to the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The parameter should not have been associated before calling
         this routine.
      }
   }
}
\sstroutine{
   KPG1\_ASREG
}{
   Registers all AST IntraMaps known by KAPPA
}{
   \sstdescription{
      This routine registers all AST IntraMaps known to KAPPA. It should
      be called before any AST routine which may use an IntraMap (such
      as a transformation routine, plotting routine, read/write routine,
      etc).
   }
   \sstinvocation{
      CALL KPG1\_ASREG( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_ASRGG
}{
   Register all graphical AST IntraMaps known by KAPPA
}{
   \sstdescription{
      This routine registers all graphical AST IntraMaps known to
      KAPPA. It should be called before any AST routine which may use an
      IntraMap (such as a transformation routine, read/write routine, etc).
   }
   \sstinvocation{
      CALL KPG1\_ASRGG( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      Use KPG1\_ASREG to register all IntraMaps (graphical and non-graphical).
      Use KPG1\_ASRGN to register just non-graphical IntraMaps.
   }
}
\sstroutine{
   KPG1\_ASRGN
}{
   Register all non-graphical AST IntraMaps known by KAPPA
}{
   \sstdescription{
      This routine registers all non-graphical AST IntraMaps known to
      KAPPA. It should be called before any AST routine which may use an
      IntraMap (such as a transformation routine, read/write routine, etc).
   }
   \sstinvocation{
      CALL KPG1\_ASRGN( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      Use KPG1\_ASREG to register all IntraMaps (graphical and non-graphical).
      Use KPG1\_ASRGG to register just graphical IntraMaps.
   }
}
\sstroutine{
   KPG1\_ASSET
}{
   Allows the specification of attribute values for an AST Object
}{
   \sstdescription{
      This routine allows the user to set attributes for an AST Object (see
      SUN/210). The value to which an attribute is set in the returned
      Object is determined as follows.

      \sstitemlist{

         \sstitem
         If the user supplies a value for the attribute using the given
         parameter, then the Object is returned with the attribute set to the
         supplied value. The user supplies the attribute values as a GRP
         group expression in which each element is an AST attribute setting.

         \sstitem
         Otherwise, if the Object already had an explicit value set for the
         attribute on entry (i.e. if AST\_TEST returns .TRUE. for the
         attribute), then the value is unchanged on exit.

         \sstitem
         Otherwise, a search is made for a default value for the attribute
         using the search path described below. If a default value is found
         for the attribute then the Object is returned with the attribute set
         to the default value. The use of these defaults can be suppressed
         by including the string {\tt "}CLEAR{\tt "} as the first element in the group of
         attribute values supplied for the specified environment parameter.

      }
      Defaults are specified as a group of attribute setting strings within a
      {\tt "}defaults{\tt "} text file. This file is found using the following search
      path:

      1) If the environment variable $<$APP$>$\_$<$PARAM$>$ is defined ($<$APP$>$ and
      $<$PARAM$>$ in upper case), its value is taken to be the full path to
      the defaults file.

      2) If $<$APP$>$\_$<$PARAM$>$ is not defined, the file \$HOME/$<$app$>$\_$<$param$>$.def
      is used ($<$app$>$ and $<$param$>$ in lower case).

      3) If the file \$HOME/$<$app$>$\_$<$param$>$.def cannot be accessed, the file
      \$KAPPA\_DIR/$<$app$>$\_$<$param$>$.def is used.

      4) If the file \$KAPPA\_DIR/$<$app$>$\_$<$param$>$.def cannot be accessed, the
      value of environment variable KAPPA\_$<$PARAM$>$ is taken to be the full
      path to the defaults file.

      5) If KAPPA\_$<$PARAM$>$ is not defined, the file \$HOME/kappa\_$<$param$>$.def
      is used.

      6) If the file \$HOME/kappa\_$<$param$>$.def cannot be accessed, the file
      \$KAPPA\_DIR/kappa\_$<$param$>$.def is used.

      Each attribute setting within a group of settings should be of the
      form {\tt "}$<$name$>$=$<$value$>${\tt "}, where $<$name$>$ is taken to be the name of a
      Object attribute (or synonym set by KPG1\_ASPSY), and $<$value$>$ is taken
      to be the value to assign to the attribute. These attributes are
      described in SUN/210. No error is reported if unrecognised attribute
      names or illegal attribute values are specified.

      Before being used, the attribute settings are edited to replace any
      synonyms by their corresponding AST attribute names established by
      earlier calls to KPG1\_ASPSY. Colour names are also replaced by
      corresponding PGPLOT colour indices.
   }
   \sstinvocation{
      CALL KPG1\_ASSET( APP, PARAM, IOBJ, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the calling application in the form
         $<$package$>$\_$<$application$>$ (eg {\tt "}KAPPA\_DISPLAY{\tt "}), for use in messages.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use for getting the group expression.
      }
      \sstsubsection{
         IOBJ = INTEGER (Given and Returned)
      }{
         An AST pointer to the Object to be modified. Returned unchanged if
         an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Colour attribute values may be supplied in any form recognised
         by KPG1\_PGCOL (eg colour name, MIN, MAX, integer index, etc), and
         the nearest colour in the current KAPPA pallette is used.

         \sstitem
         If a null value is supplied for the parameter, the error is
         annulled and the Object is returned unchanged (except for any
         defaults obtained using the usual search path).
      }
   }
}
\sstroutine{
   KPG1\_ASSHR
}{
   Shrink a Plot so that it covers an area which allows all annotation
   to fit within the specified area
}{
   \sstdescription{
      This routine creates a new Plot covering the same window as the
      current PGPLOT window, but thw window is shrunk in GRAPHICS space
      so that all the annotation produced by AST\_GRID falls within the PGPLOT
      viewport which is current on entry. The sizes of annotations, gaps,
      etc are shrunk if this is necessary in order to fit the annotations
      within the current PGPLOT viewport.
   }
   \sstinvocation{
      CALL KPG1\_ASSHR( ASP, F, X1, X2, Y1, Y2, JUST, IPLOT, OK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ASP = LOGICAL (Given)
      }{
         The aspect ratio of the required plotting area (i.e. excluding
         annotation) after shrinking. If this is zero or negative, the
         largest possible area is used for the plotting area.
      }
      \sstsubsection{
         F = REAL (Given)
      }{
         An amount by which to extend the margins left for annotation,
         expressed as a factor of the height or width of the plotting
         area. For instance, a value of 0.1 could be given to fit the
         annotation {\tt "}comfortably{\tt "} into the Plot. A value of 0.0 will
         result in the annotation being hard up against the edge of the
         plot.
      }
      \sstsubsection{
         X1 = REAL (Given)
      }{
         The GRAPHICS X co-ordinate at the left edge of the area into
         which the annotation is to fit.
      }
      \sstsubsection{
         X2 = REAL (Given)
      }{
         The GRAPHICS X co-ordinate at the right edge of the area into
         which the annotation is to fit.
      }
      \sstsubsection{
         Y1 = REAL (Given)
      }{
         The GRAPHICS Y co-ordinate at the bottom edge of the area into
         which the annotation is to fit.
      }
      \sstsubsection{
         Y2 = REAL (Given)
      }{
         The GRAPHICS Y co-ordinate at the top edge of the area into
         which the annotation is to fit.
      }
      \sstsubsection{
         JUST = CHARACTER$*$2 (Given)
      }{
         Indicates the justification of the new plot within the specified
         area.  {\tt '}BL{\tt '}, {\tt '}BC{\tt '}, {\tt '}BR{\tt '}, {\tt '}CL{\tt '}, {\tt '}CC{\tt '}, {\tt '}CR{\tt '}, {\tt '}TL{\tt '}, {\tt '}TC{\tt '} or {\tt '}TR{\tt '},
         where B is Bottom, C is Centre, T is Top, L is Left and R is
         Right. Only used if ASP $>$ 0. Must be upper case. Unrecognised
         values are treated as {\tt "}C{\tt "}.
      }
      \sstsubsection{
         IPLOT = INTEGER (Given and Returned)
      }{
         The Plot. The supplied Plot is annulled and a new one is
         returned in its place. The new Plot contains all the Frames of
         the supplied Plot, but its Plot attributes are all cleared. It may
         be necessary for the caller to re-instate these attributes.
      }
      \sstsubsection{
         OK = LOGICAL (Returned)
      }{
         Returned .FALSE. if there was insufficient room for the required
         Plot. No error is reported in this case, and IPLOT os returned
         unchanged.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASSIG
}{
   Ensure that the Current Frame from an NDF WCS FrameSet has no
   insignificant axes
}{
   \sstdescription{
      This routine looks for insignificant axes in the Current Frame of
      the supplied WCS FrameSet (an axis is insignificant if all pixels
      within the NDF pixel array has the same position on the axis). If
      any insignificant axes are found, a new Frame is added to the
      FrameSet containing only the significant axes from the Current Frame.
      This new Frame is added into the FrameSet and becomes the new
      Current Frame. The PermMap which connects it to the original
      Current Frame assigns the correct constant values to the
      insignificant axes whn used in the inverse direction.
   }
   \sstinvocation{
      CALL KPG1\_ASSIG( IWCS, NDIM, LBND, UBND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         The WCS FrameSet from the NDF, as returned by KPG1\_GTWCS.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in the NDF, as returned by NDF\_BOUND.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Returned)
      }{
         The lower pixel index bounds of the NDF, as returned by NDF\_BOUND.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Returned)
      }{
         The upper pixel index bounds of the NDF, as returned by NDF\_BOUND.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASSIM
}{
   Simplify a FrameSet
}{
   \sstdescription{
      This routine simplifies a FrameSet by adding a copy of the Current
      Frame into it, using a simplified version of the Mapping from
      Base to Current Frame. The new Frame becomes the Current Frame.

      This routine should be called before doing any plotting with a
      Plot (remember, a Plot is a FrameSet) in order to avoid the possiblity
      of intermediate Frames being used in which positions are undefined.

      Care should be taken decding where to call this routine since
      the simplification process can be expensive. Do not call it within
      a deep nested loop!
   }
   \sstinvocation{
      CALL KPG1\_ASSIM( IWCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer to the FrameSet.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASSIR
}{
   Set the attributes of a SkyFrame to match an IRAS90 SCS
}{
   \sstdescription{
      This routine modifies the supplied skyframe so that it describes
      the celestial co-ordinate system given by the supplied IRAS90 {\tt "}Sky
      Co-ordinate System{\tt "} specified (see SUN/163). A .FALSE. function value
      is returned if the supplied string is not a valid IRAS90 SCS, but no
      error is reported.
   }
   \sstinvocation{
      RESULT = KPG1\_ASSIR( FRM, SCS, PEP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         KPG1\_ASSIR = LOGICAL
      }{
         .TRUE. if the supplied SCS string was a valid IRAS90 Sky
         Co-ordinate System specifier, and ,FALSE. otherwise.
      }
   }
}
\sstroutine{
   KPG1\_ASSMP
}{
   Returns co-ordinates at evenly spaces positions along a given
   poly-line
}{
   \sstdescription{
      This routine returns an a pointer to an array holding the
      co-ordinates at a set of NSAMP positions evenly spaced along a
      poly-line defined by NPOS {\tt "}profile positions{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_ASSMP( FRAME, ARRDIM, NAX, NPOS, POS, GEO, NSAMP, SAMP,
                       DELTA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         An AST pointer to the Frame in which the polyline is defined.
         This is used to define geodesic curves joining the supplied
         profile positions. Only accessed if GEO is .TRUE.
      }
      \sstsubsection{
         ARRDIM = INTEGER (Given)
      }{
         The size of the first dimension of POS.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame.
      }
      \sstsubsection{
         NPOS = INTEGER (Given)
      }{
         The number of profile positions defining the poly-line. This
         must be less than or equal to ARRDIM.
      }
      \sstsubsection{
         POS( ARRDIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         The profile positions. The first axis indexes the position
         number, and the first NPOS elements should be used. The second
         axis indexes the axis number. An error is reported if any
         invalid positions are supplied.
      }
      \sstsubsection{
         GEO = LOGICAL (Given)
      }{
         Should the poly-line be constructed from geodesic curves in the
         supplied Frame? If not, the poly-line is made up of
         straight-line segments in the supplied Frame.
      }
      \sstsubsection{
         NSAMP = INTEGER (Given)
      }{
         The number of samples required along the poly-line.
      }
      \sstsubsection{
         DELTA = DOUBLE PRECISION (Given and Returned)
      }{
         The increment between samples. If not known, this should be set
         to zero. Returned holding the used increment.
      }
      \sstsubsection{
         SAMP( NSAMP, NAX ) = DOUBLE PRECISION (Returned)
      }{
         The array holding the sample positions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_ASSPL
}{
   Get a set of 1-d Mappings for each axis in a FrameSet
}{
   \sstdescription{
      This routine returns a set of AST Mapping pointers. Each Mapping
      has 1 input and 1 output. The I{\tt '}th Mapping goes from axis I in the
      Base Frame of the supplied FrameSet, to axis I in the Current Frame
      of the FrameSet.

      There should usually be a one-to-one correspondance between the
      axes in the Base and Current Frames in the FrameSet.
   }
   \sstinvocation{
      CALL KPG1\_ASSPL( IWCS, MXAX, MAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         The AST pointer to the FrameSet.
      }
      \sstsubsection{
         MXAX = INTEGER (Given)
      }{
         The maximum number of mappings to be returned. Un-used elements
         are returned holding AST\_\_NULL.
      }
      \sstsubsection{
         MAP( MXAX ) = INTEGER (Returned)
      }{
         The Mapping pointers.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASSTS
}{
   Apply an attribute setting to a Plot
}{
   \sstdescription{
      This routine applies the supplied attribute setting to the supplied
      Plot. The attribute setting should be of the form {\tt "}name=value{\tt "} where
      {\tt "}name{\tt "} is an AST attribute name or a synonym for an AST attribute
      name established by a call to KPG1\_ASPSY, and {\tt "}value{\tt "} is the value
      to assign to the attribute. If the attribute name contains either COLOR
      or COLOUR then the value string is checked to see if it is the name
      of a colour, and if so, the corresponding colour index is used
      instead. The resulting setting, after translation of synonyms and
      colour names is applied to the supplied Plot. If the Plot already
      has a set value for the specified attribute, then the behaviour depends
      on OVER; if OVER is .TRUE. then the new attribute value over-writes
      the value already in the Plot; if OVER is .FALSE. then the supplied
      setting is ignored.
   }
   \sstinvocation{
      CALL KPG1\_ASSTS( SETTNG, REPORT, OVER, IPLOT, BADAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SETTING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The attribute setting string.
      }
      \sstsubsection{
         REPORT = LOGICAL (Given)
      }{
         Should an error be reported if the attribute setting string
         is not legal?
      }
      \sstsubsection{
         OVER = LOGICAL (Given)
      }{
         Over-write existing attribute values in the Plot?
      }
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to the Plot to be modified.
      }
      \sstsubsection{
         BADAT = LOGICAL (Returned)
      }{
         Was the setting string invalid? If so, an appropriate error
         message will have been reported (unless REPORT is .FALSE.).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Colour attribute values may be supplied in any form recognised
         by KPG1\_PGCOL (eg colour name, MIN, MAX, integer index, etc), and
         the nearest colour in the current KAPPA pallette is used.
      }
   }
}
\sstroutine{
   KPG1\_ASSTY
}{
   Checks for synonyms and colour names in AST attribute settings
}{
   \sstdescription{
      This routine splits the supplied AST attribute setting string up
      into a name and a value, replacing synonyms for AST attribute names
      or qualifiers with the corresponding AST names and qualifiers, and
      replacing colour names within the attribute value with corresponding
      PGPLOT colour indices. Synonyms for AST attribute names or
      qualifiers are set up using KPG1\_ASPSY.

      Matching of attribute names and attribute qualifiers are performed
      separately. The names are matched first. An attempt to match any
      supplied attribute qualifier against a synonym is only made if the
      attribute names match, or if the synonym does not contain an
      attribute name. Synonyms may specify minimum abbreviations for
      attribute qualifiers by including an asterisk within the qualifier
      string. The asterisk marks the end of the minimum abbreviation.
   }
   \sstinvocation{
      CALL KPG1\_ASSTY( SETTNG, NAME, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SETTNG = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to be checked, potetially containing synonyms and
         colour names.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The corresponding AST attribute name (with a possible qualifier).
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The corresponding AST attribute value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AST2H
}{
   Copy AST\_ data to an HDS object
}{
   \sstdescription{
      This routine copies a line of text representing AST\_ data into a
      specified element of a 1-dimensional character array. It is
      intended for use when writing AST\_ data to an HDS object (i.e an
      HDS \_CHAR array).
   }
   \sstinvocation{
      CALL KPG1\_AST2H( DATA, ILINE, LINE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( $*$ ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The character array into which the text is to be copied.
      }
      \sstsubsection{
         ILINE = INTEGER (Given)
      }{
         The index of the element in DATA which is to receive the text
         (the contents of other elements are returned unchanged).
      }
      \sstsubsection{
         LINE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The line of text to be inserted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine departs from the conventional argument order so as to
      accommodate the case where the DATA argument is a mapped HDS
      character array.
   }
}
\sstroutine{
   KPG\_ASTCMN
}{
   Define functional accessor/setter interface to KPG\_AST common block
}{
   \sstdescription{
      This file contains a set of functions that enable access to the
      KPG\_AST common block from outside of the KPG library. Routines
      are only added on demand.
   }
   \sstinvocation{
      CALL KPG1\_SETASTxxx    or   VALUE = KPG1\_GETASTxxx
   }
   \sstnotes{
      Since the routines are only 3 lines long, they are all in
      a single file with minimal comment wrapper. Types of the argument
      for SET methods match the type in the common block.
   }
   \sstdiytopic{
      Implementation Details
   }{
      The following routines are available:
        KPG1\_SETASTLN( LN ) - Set the ASTLN integer
        KPG1\_SETASTGRP( GRP ) - Set the ASTGRP identifier
        KPG1\_SETASTGSP( CHAR ) - Set ASTGSP character
        KPG1\_SETASTDSB( DRDSB ) - Set DRWDSB flag
        KPG1\_SETASTFIT( FIT ) - Set FIT flag
        KPG1\_SETASTPLN( PLN ) - KeyMap used to store details of lines drawn
        KPG1\_SETASTBLE( BLE ) - Are plot edges to be kept free of ticks etc?
        KPG1\_SETASTX1( X1 ) - Left hand X value in Plot.
        KPG1\_SETASTX2( X2 ) - Right hand X value in Plot.
        KPG1\_SETASTY1( Y1 ) - Bottom Y value in Plot.
        KPG1\_SETASTY2( Y2 ) - Top Y value in Plot.
        KPG1\_GETASTNPS()
        KPG1\_GETASTING()
        KPG1\_GETASTOUG()
        KPG1\_GETASTDSB()
        KPG1\_GETASTFIT()
        KPG1\_GETASTPLN()
        KPG1\_GETASTBLE()
        KPG1\_GETASTX1()
        KPG1\_GETASTX2()
        KPG1\_GETASTY1()
        KPG1\_GETASTY2()
   }
}
\sstroutine{
   KPG1\_ASTRM
}{
   Trims axes from the current Frame of a FrameSet
}{
   \sstdescription{
      This routine ensures that the number of axes in the current Frame of
      the supplied FrameSet is the same as the number in the base Frame.
      If this is not the case on entry, a new Frame with the required number
      of axes is created and added into the FrameSet and becomes the new
      current Frame.

      If the original current Frame has too few axes, the new Frame is a
      copy of the original current frame with extra simple axes added to
      the end. These extra axes are supplied a value of AST\_\_BAD by the
      Mapping which connects the original current Frame to the new current
      Frame.

      If the original current Frame has too many axes, the user is
      allowed to select a subset of the original axes using the environment
      parameter USEAXIS (see below). A new Frame is created by picking
      these selected axes from the original current Frame. This Frame is
      added into the FrameSet using a Mapping which has a forward
      transformation which simply drops the values for the unselected axes.
      The inverse transformation (from new to old Frame) attempts to
      assign usable values for the dropped axes if possible. This is only
      possible if the value for a dropped axis can be determined uniquely
      from the value of one of the selected axes. This may be the case
      for instance in a situation where (RA,wavelength) axes were
      selected from the (RA,Dec,Wavelength) axes describing a 2D longslit
      spectrum. The missing Dec value can probably be determined from the
      RA value because the relationship between RA and Dec is determined
      by the position and orientation of the slit on the sky. If it is
      not possible to determine the value for a dropped axis in this way,
      then what happens depends on whether or not any Frames can be found
      in the FrameSet that are Regions having a Domain name of {\tt "}ROI$<$n$>${\tt "},
      where {\tt "}$<$n$>${\tt "} is a positive integer. If no such Frame can be found,
      AST\_\_BAD is supplied for the dropped axis.

      If the supplied current Frame has too many axes, and one or more ROI
      Regions are found in the FrameSet, then a new Frame is added into
      the FrameSet for each ROI Region found. These new Frames are all
      equivalent, containing axes from the supplied current Frame as
      specified by the USEAXIS parameter, and they are all connected to
      the supplied current Frame via a PermMap. Each PermMap has a
      forward transformation that simply drops the unwanted axis values.
      The inverse transformation of each PermMap supplies suitable values
      for the unwanted axes. These are determined by transforming the
      bounding box of the corresponding ROI Region into the original current
      Frame. The Domain name of the corresponding ROI Region is stored in
      the Ident attribute of the new Frame, and is also appended to the
      end of the Frame{\tt '}s Domain. The new Frame corresponding to the lowest
      numbered ROI Region is left as the current Frame on exit.

      Various environment parameters may be used to obtain options, etc. The
      names of these parameters are hard-wired into this subroutine in
      order to ensure conformity between applications.
   }
   \sstinvocation{
      CALL KPG1\_ASTRM( IWCS, DEFAX, LBND, UBND, WORK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         The FrameSet to use. A new current Frame may be added to the
         FrameSet by this routine.
      }
      \sstsubsection{
         DEFAX( $*$ ) = INTEGER (Given)
      }{
         This array should have one element for each axis in the base
         Frame of the supplied FrameSet. The i{\tt '}th value is the index
         within the original current Frame of the axis which is to be
         associated with the i{\tt '}th base Frame axis by default. Only used
         if no better defaults can be found by splitting the FrameSet
         Mapping.
      }
      \sstsubsection{
         LBND( $*$ ) = INTEGER (Given)
      }{
         The lower pixel bound on each pixel axis. Array length should be
         at least equal to the number of base Frame axes in IWCS.
      }
      \sstsubsection{
         UBND( $*$ ) = INTEGER (Given)
      }{
         The upper pixel bound on each pixel axis. Array length should be
         at least equal to the number of base Frame axes in IWCS.
      }
      \sstsubsection{
         WORK( $*$ ) = INTEGER (Given)
      }{
         Work space. It{\tt '}s length should be at least twice as large as the
         largest pixel dimension implied by LBND and UBND.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiylist{
      Environment Parameters
   }{
      \sstsubsection{
         USEAXIS = LITERAL (Read)
      }{
         A set of NDIM axes to be selected from the current Frame. Each
         axis can be specified either by giving its index within the current
         Frame in the range 1 to the number of axes in the Frame, or by
         giving its symbol. This parameter is only accessed if the original
         current Frame in the supplied FrameSet has too many axes. The value
         should be given as a GRP group expression, with default control
         characters.
      }
   }
}
\sstroutine{
   KPG1\_ASTTL
}{
   Set the Title attribute of a Plot
}{
   \sstdescription{
      This routine sets the Title attribute of an AST Plot. The Title
      string can be obtained from a variety of places, and the following
      priority order is used:

      The value of the Title attribute supplied by the user via the
      application{\tt '}s STYLE parameter is given top priority. If no Title
      was supplied then the Title component of the NDF is used. If this
      is blank, then the TItle attribute stored in the current Frame of
      the NDF{\tt '}s WCS FrameSet is used, if it has been set explicitly (i.e.
      is not just a default value). Otherwise, the name of the NDF is used.
   }
   \sstinvocation{
      CALL KPG1\_ASTTL( IPLOT, IWCS, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer for the Plot. The Title attribute of the current
         Frame will be set on exit.
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer for the WCS FrameSet obtained from the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An NDF identifier for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AVLUT
}{
   Associates, validates and maps an lookup table stored in an NDF
}{
   \sstdescription{
      This routine associates for read access an NDF that is presumed
      to contain a lookup table in its data array.  A series of
      validation checks are made: the array must be 2-dimensional, the
      first dimension must be 3, the range of values must lie in the
      range 0.0--1.0.  The last of these requires that the data array
      is mapped therefore for convenience and efficiency a pointer and
      length are returned.  The lookup table mapped with type \_REAL.
   }
   \sstinvocation{
      CALL KPG1\_AVLUT( PNLUT, NDFL, PNTRI, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNLUT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter to be associated with the NDF.
      }
      \sstsubsection{
         NDFL = INTEGER (Returned)
      }{
         The identifier for the NDF containing the lookup table.
      }
      \sstsubsection{
         PNTRI( 1 ) = INTEGER (Returned)
      }{
         The pointer to the mapped NDF lookup table.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The length of the mapped NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AXANO
}{
   Generates an axis annotation from the NDF{\tt '}s axis label and units
}{
   \sstdescription{
      This routine examines a nominated axis for a label and units.
      It creates a string of the form {\tt "}label (units){\tt "} or {\tt "}label{\tt "} if the
      label but not the units are present.  If neither are present a
      supplied default is returned instead.
   }
   \sstinvocation{
      CALL KPG1\_AXANO( NDF, IAXIS, DEFAUL, AXSLAB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         The number of the axis whose character components are to be
         used.
      }
      \sstsubsection{
         DEFAUL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default to return in AXSLAB should there be no axis label.
      }
      \sstsubsection{
         AXSLAB = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The axis annotation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The identifier should be associated with an NDF.
      }
   }
}
\sstroutine{
   KPG1\_AXRNG
}{
   Calculate the extent of an NDF along an axis
}{
   \sstdescription{
      This routine calculates the starting and ending positions of an
      NDF{\tt '}s pixels along an axis, taking account of the axis width
      values.
   }
   \sstinvocation{
      CALL KPG1\_AXRNG( EL, CENTRE, WIDTH, ASTART, AEND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis arrays.
      }
      \sstsubsection{
         CENTRE( EL ) = DOUBLE PRECISION (Given)
      }{
         The centres of the pixels on the axis.
      }
      \sstsubsection{
         WIDTH( EL ) = DOUBLE PRECISION (Given)
      }{
         The widths of the pixels on the axis.
      }
      \sstsubsection{
         ASTART = DOUBLE PRECISION (Returned)
      }{
         If the axis centre positions increase with NDF pixel index,
         this argument returns the axis position of the edge of the
         first pixel which has the lower co-ordinate. Otherwise it
         returns the axis position of the edge with the higher
         co-ordinate.
      }
      \sstsubsection{
         AEND = DOUBLE PRECISION (Returned)
      }{
         If the axis centre positions increase with NDF pixel index,
         this argument returns the axis position of the edge of the
         last pixel which has the higher co-ordinate. Otherwise it
         returns the axis position of the edge with the lower
         co-ordinate.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AXTYP
}{
   Determines the implementation type for NDF axis arrays
}{
   \sstdescription{
      The routine returns the highest precision required to process
      the NDF axis component in all dimensions.  {\tt '}\_DOUBLE{\tt '} is returned
      if any of the arrays have type {\tt '}\_INTEGER{\tt '} or {\tt '}DOUBLE{\tt '}.
   }
   \sstinvocation{
      CALL KPG1\_AXTYP( NDF, COMP, ATYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the axis array component whose implementation type
         is required: {\tt '}CENTRE{\tt '}, {\tt '}VARIANCE{\tt '}, or {\tt '}WIDTH{\tt '}.
      }
      \sstsubsection{
         ATYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The implementation type of the axis arrays.  It is in uppercase
         and is either {\tt '}\_REAL{\tt '} or {\tt '}\_DOUBLE{\tt '}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The NDF identifier must be valid and there must be an axis
      structure.
   }
}
\sstroutine{
   KPG1\_BADBX
}{
   Obtain an NDF section containing all good data in the supplied NDF
}{
   \sstdescription{
      This routine finds the pixel bounding box that encloses all good
      data values in the DATA array of supplied NDF. It then creates and
      returns an NDF section corresponding to this bounding box.
   }
   \sstinvocation{
      CALL KPG1\_BADBX( NDF, MXDIM, NGOOD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         The input NDF identifier.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         An identifier for the smallest NDF section that contains all
         good DATA values in the the input NDF.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         The number of good DATA values in the supplied NDF$>$
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_BILNR
}{
   Perform bi-linear interpolation checking for bad values
}{
   \sstdescription{
      An imaginary pixel is centred on the supplied interpolation
      position. The area of the overlap between this imaginary pixel
      and each of the four surrounding real pixels is found, and used
      as the weight for the corresponding pixel value. The returned
      interpolated value is the weighted mean of the four surrounding
      pixel values. A bad value is returned if any of these four pixels
      lie outside the image or have a bad value.

      The associated variance value is also returned if input variances
      are supplied.
   }
   \sstinvocation{
      CALL KPG1\_BILNR( X, Y, XLO, XHI, YLO, YHI, USEVAR, DATA, VAR,
                       INTERP, INTERV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X = REAL (Given)
      }{
         The pixel X coordinate at which to perform the interpolation.
      }
      \sstsubsection{
         Y = REAL (Given)
      }{
         The pixel Y coordinate at which to perform the interpolation.
      }
      \sstsubsection{
         XLO = INTEGER (Given)
      }{
         The lower bound on the array X axis.
      }
      \sstsubsection{
         XHI = INTEGER (Given)
      }{
         The upper bound on the array X axis.
      }
      \sstsubsection{
         YLO = INTEGER (Given)
      }{
         The lower bound on the array Y axis.
      }
      \sstsubsection{
         YHI = INTEGER (Given)
      }{
         The upper bound on the array Y axis.
      }
      \sstsubsection{
         USEVAR = LOGICAL (Given)
      }{
         Should a variance be returned?
      }
      \sstsubsection{
         DATA( XLO:XHI, YLO:YHI ) = REAL (Given)
      }{
         The data array to be interpolated.
      }
      \sstsubsection{
         VAR( XLO:XHI, YLO:YHI ) = REAL (Given)
      }{
         The variance array (only accessed if USEVAR is .TRUE.).
      }
      \sstsubsection{
         INTERP = REAL (Returned)
      }{
         The interpolated data value.
      }
      \sstsubsection{
         INTERV = REAL (Returned)
      }{
         The interpolated variance value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_CCPRO
}{
   Gets a character component for an output NDF with optional
   propagation from another NDF
}{
   \sstdescription{
      This routine uses the parameter sysyem to obtain a value for a
      selected character component of an output or updated NDF.  If the
      null value is supplied, the character component is copied from
      an input NDF to the output NDF, unless the component is undefined,
      in the input, in which case it is left undefined in the output.
   }
   \sstinvocation{
      CALL KPG1\_CCPRO( PNCOMP, COMP, NDFI, NDFO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNCOMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter used to obtain the character
         component{\tt '}s value.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the character component.  It must be {\tt '}TITLE{\tt '},
         {\tt '}LABEL{\tt '}, or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         NDFI = INTEGER (Given)
      }{
         The identifier of the input NDF from which a character
         component is to be copied to the output NDF.
      }
      \sstsubsection{
         NDFO = INTEGER (Given)
      }{
         The identifier of the output or updated NDF to which a
         character component is to be written.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_CEIL
}{
   Return the smallest integer larger than or equal to a supplied value
}{
   \sstdescription{
      This routine returns the smallest integer larger than or equal to
      a supplied value.
   }
   \sstinvocation{
      RESULT = KPG1\_CEIL( VALUE )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = REAL (Given)
      }{
         The value.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      KPG1\_CEIL = INTEGER
         The smallest integer larger than or equal to the supplied value.
   }
}
\sstroutine{
   KPG1\_CGET
}{
   Obtain an NDF character component, removing escape sequences
}{
   \sstdescription{
      The routine obtains the value of the specified character
      component of an NDF (i.e. the value of the LABEL, TITLE or UNITS
      component). It is identical to NDF\_CGET except that any PGPLOT or
      AST escape sequences in the string are removed.
   }
   \sstinvocation{
      CALL KPG1\_CGET( INDF, COMP, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the character component whose value is required:
         {\tt '}LABEL{\tt '}, {\tt '}TITLE{\tt '} or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The component{\tt '}s value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the requested component is in an undefined state, then the
         VALUE argument will be returned unchanged. A suitable default
         should therefore be established before calling this routine.

         \sstitem
         If the length of the VALUE argument is too short to
         accommodate the returned result without losing significant
         (non-blank) trailing characters, then this will be indicated by
         an appended ellipsis, i.e. {\tt '}...{\tt '}. No error will result.
      }
   }
}
\sstroutine{
   KPG1\_CMULD
}{
   Multiply each element of a vectorised double precision array by a
   constant
}{
   \sstdescription{
      The routine multiplies each element of a vectorised double
      precision array by a constant to produce a new double precision
      array. Bad value checking is performed if required.
   }
   \sstinvocation{
      CALL KPG1\_CMULD( BAD, EL, A, CONST, B, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = DOUBLE PRECISION (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant by which each array element is to be multiplied.
      }
      \sstsubsection{
         B( EL ) = DOUBLE PRECISION (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of bad values in the output array B.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine is intended for processing double precision data
         only. There is a related generic routine for processing other data
         types.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements.
      }
   }
}
\sstroutine{
   KPG1\_CNLIM
}{
   Parse a character string into integer bounds
}{
   \sstdescription{
      This routine is used to parse a character specification which
      defines a range of integers.  The specification is of the form:

        Number[-number]

      If the second number is specified then it is assumed that a
      sequence of numbers are to be parsed, e.g. 4-6 (or 6-4) specifies
      integers 4, 5, 6; and bounds 4 and 6 are returned.  If only one
      number is specified, then both the returned bounds are set equal
      to it.

      An asterisk may be used as a wildcard.  Thus 5-$*$ specifies all
      numbers upwards from 5 inclusive, the upper bound being given by
      the largest integer.  $*$ indicates all integers, i.e. the bounds
      would be the smallest (non-bad) and largest integers. $*$-4
      would specify a range from the smallest integer to 4 inclusive.
   }
   \sstinvocation{
      CALL KPG1\_CNLIM( NOS, FIRST, LAST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NOS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Number specification.
      }
      \sstsubsection{
         FIRST = INTEGER (Returned)
      }{
         First integer in the sequence.
      }
      \sstsubsection{
         LAST  = INTEGER (Returned)
      }{
         Last integer in the sequence.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_COLNM
}{
   Finds the named colour nearest to an RGB triple
}{
   \sstdescription{
      This returns the name of a colour in the standard colour set that
      matches an input R-G-B colour, or failing that, that is nearest
      to the input colour.  A city-block metric is used.
   }
   \sstinvocation{
      CALL KPG1\_COLNM( R, G, B, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         R = REAL (Given)
      }{
         The red intensity of the colour to be identified.  It should
         be in the range 0.0 to 1.0.
      }
      \sstsubsection{
         G = REAL (Given)
      }{
         The green intensity of the colour to be identified.  It should
         be in the range 0.0 to 1.0.
      }
      \sstsubsection{
         B = REAL (Given)
      }{
         The blue intensity of the colour to be identified.  It should
         be in the range 0.0 to 1.0.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the nearest colour in the named colour set to the
         input RGB colour.  Note at least eighteen characters are
         required to avoid truncation.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The actual R-G-B colours used will be constrained to lie in the
         range 0.0--1.0.
      }
   }
}
\sstroutine{
   KPG1\_COPYC
}{
   Copy a 1D array of character strings
}{
   \sstdescription{
      This routine copies a 1D array of character strings.
   }
   \sstinvocation{
      CALL KPG1\_COPYC( NEL, IN, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NEL = INTEGER (Given)
      }{
         The length of the array.
      }
      \sstsubsection{
         IN = CHARACTER( NEL ) $*$ ( $*$ ) (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OUT = CHARACTER( NEL ) $*$ ( $*$ ) (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_COPY
}{
   To copy an array of a given type to another array of the same
   type
}{
   \sstdescription{
      This routine copies a 1-D array of numerical or character values
      from an input array to an output array.
   }
   \sstinvocation{
      CALL KPG1\_COPY( TYPE, NEL, IPIN, IPOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The data type to be copied. Must be one of the HDS numeric
         types, \_BYTE, \_UBYTE, \_WORD, \_UWORD, \_INTEGER, \_REAL or \_DOUBLE,
         or {\tt "}\_CHAR$*$$<$N$>$){\tt "} where {\tt "}$<$N$>${\tt "} is an integer giving the length of
         the character strings.
      }
      \sstsubsection{
         NEL = INTEGER (Given)
      }{
         The number of elements in the vectorised arrays pointed to by
         IPIN and IPOUT.
      }
      \sstsubsection{
         IPIN = INTEGER (Given)
      }{
         Pointer to the data to be copied.
      }
      \sstsubsection{
         IPOUT = INTEGER (Given and Returned)
      }{
         Pointer to the array to contain the copied data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Uses array pointers.
      }
   }
}
\sstroutine{
   KPG1\_CPSTY
}{
   Copy the plotting style for an AST element to another AST element
}{
   \sstdescription{
      This routine copies the AST attributes which determine the colour,
      style, width, font and size. If IN is non-blank, then the
      attributes are copied from the element given by IN, to the
      element given by OUT - the original values of these attributes for
      element OUT are returned in ATTRS. If IN is blank, then the
      values supplied in ATTRS are copied to the element given by OUT -
      the original values of these attributes for element OUT are again
      returned in ATTRS.
   }
   \sstinvocation{
      CALL KPG1\_CPSTY( IPLOT, IN, OUT, ATTRS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         The AST Plot.
      }
      \sstsubsection{
         IN = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the source element (e.g. {\tt "}CURVES{\tt "}, {\tt "}AXIS1{\tt "}, etc), or
         blank.
      }
      \sstsubsection{
         OUT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the destination element (e.g. {\tt "}CURVES{\tt "}, {\tt "}AXIS1{\tt "}, etc).
      }
      \sstsubsection{
         ATTRS( 5 ) = REAL (Given and Returned)
      }{
         The entry values are ignored unless IN is blank, in which case
         the entry values should be the colour, width, style, size and font
         attribute values to associate with element OUT. On exit, the
         original colour, width, style, size and font attribute values
         associated with element OUT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_CROUT
}{
   Creates and returns locators to the top-level and data-array of
   an NDF-type structure
}{
   \sstdescription{
      An NDF-type data structure, associated with the supplied
      parameter name is created.  A locator for this structure is
      returned.  A TITLE component, associated with another parameter
      name is created within the structure and a character value, is
      obtained from the parameter system and written to the TITLE
      component.  A DATA\_ARRAY component is created.  If the supplied
      origins are all one, DATA\_ARRAY is primitive, having the supplied
      dimensionality and dimensions, and is of type \_REAL.  Otherwise
      DATA\_ARRAY is a simple ARRAY-type structure containing the
      primitive \_REAL data array and origin information.  The locator to
      the primitive data array is also returned.
   }
   \sstinvocation{
      CALL KPG1\_CROUT( PARNAM, TLENAM, NDIM, DIMS, ORIGIN, LOCAT,
                       DATLOC, DNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name associated with the NDF-type structure to
         be created.
      }
      \sstsubsection{
         TLENAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name associated with the TITLE component created
         in the new NDF-type structure.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Dimensionality of the data-array component of the new
         NDF-type structure.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         Dimensions of the data-array component of the new NDF-type
         structure.
      }
      \sstsubsection{
         ORIGIN( NDIM ) = INTEGER (Given)
      }{
         The origin information of the data array.  If a primitive
         NDF is to be created these should all be set to 1.  Note though
         if other ARRAY-type components---QUALITY and VARIANCE---are
         propagated, the origin data of ARRAY-type components must be
         consistent not to invalidate the NDF.  Therefore use the values
         returned by KPG1\_GETIM unless QUALITY and VARIANCE are not
         propagated.
      }
      \sstsubsection{
         LOCAT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Locator to the new NDF-type structure.  If status is bad on
         exit this locator is annulled.  If status is bad on exit this
         locator is annulled.
      }
      \sstsubsection{
         DATLOC  = CHARACTER $*$ ( DAT\_\_SZLOC ) (Returned)
      }{
         The locator to the structure containing the primitive
         form of the data array.  If it is the top-level of the NDF
         structure, it will be a clone of LOCAT.  Either way it will
         require annulment.  If status is bad on exit this locator is
         annulled.
      }
      \sstsubsection{
         DNAME = CHARACTER $*$ ( DAT\_\_SZNAM ) (Returned)
      }{
         The name of the data array as this will be needed for access,
         and it is different depending on its location.  This argument
         is probably unnecessary, but it is here defensively, in case
         the origin is changed to or from the default.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This a stop-gap routine until the remainder of KAPPA
         IMAGE-format applications are converted to NDF.  It enables both
         primitive (i.e. IMAGE-format) and simple NDFs to be processed.

         \sstitem
         The maximum length of the TITLE component produced by this
         routine is 72 characters.
      }
   }
}
\sstroutine{
   KPG1\_CSHFT
}{
   Shift the characters left or right in a string
}{
   \sstdescription{
      This routine shifts all characters in a string by a given number of
      characters, padding with spaces at the ends.
   }
   \sstinvocation{
      CALL KPG1\_CSHFT( N, TEXT )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Returned)
      }{
         The number of characters to shift to the right. Negative values
         produce shifts to the left.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The text to be shifted.
      }
   }
}
\sstroutine{
   KPG1\_CTCPC
}{
   Copies string values from a catalogue column to a GRP group
}{
   \sstdescription{
      This routine gets NEL values for a given CAT (see SUN/181)
      column, derived from rows 1 to NEL of a given catalogue,
      selection, or index, and appends them to the end of the supplied
      GRP group (a new group is created if necessary).
   }
   \sstinvocation{
      CALL KPG1\_CTCPC( CI, GI, NEL, IGRP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI = INTEGER (Given)
      }{
         The CAT identifier for the catalogue, selection or index
         containing the required data.
      }
      \sstsubsection{
         GI = INTEGER (Given)
      }{
         The CAT identifier for the column, expression or parameter
         to be evaluated for rows 1 to NEL of the component identified
         by CI.
      }
      \sstsubsection{
         NEL = INTEGER (Given)
      }{
         The number of rows to copy.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The identiier for the GRP group in which the column values are
         to be stored. If this is supplied as GRP\_\_NOID, then a new group
         is created. Otherwise the values are appended to the end of the
         supplied group.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_CTCPx
}{
   Copies values from catalogue columns to an AST KeyMap
}{
   \sstdescription{
      This routine gets NEL values for a set of given CAT (see SUN/181)
      columns, derived from rows 1 to NEL of a given catalogue,
      selection, or index, and stores them in a KeyMap.
   }
   \sstinvocation{
      CALL KPG1\_CTCPK( CI, NAX, GI, NEL, KEYMAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI = INTEGER (Given)
      }{
         The CAT identifier for the catalogue, selection or index
         containing the required data.
      }
      \sstsubsection{
         NAX= INTEGER (Given)
      }{
         The number of columns from which values are to be read.
      }
      \sstsubsection{
         GI( NAX ) = INTEGER (Given)
      }{
         The CAT identifiers for the column, expressions or parameters
         to be evaluated for rows 1 to NEL of the component identified
         by CI.
      }
      \sstsubsection{
         NEL = INTEGER (Given)
      }{
         The number of rows to copy.
      }
      \sstsubsection{
         KEYMAP = INTEGER (Given)
      }{
         The KeyMap. Each column value is stored as a scalar string with
         key {\tt "}$<$colname$>$\_$<$row index$>${\tt "}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_DANOT
}{
   Generates an annotation from the NDF{\tt '}s label and units
}{
   \sstdescription{
      This routine examines the NDF for a label and units.  It creates a
      string of the form {\tt "}label (units){\tt "} or {\tt "}label{\tt "} if the label but not
      the units are present.  If neither are present a string comprising
      the array component followed by {\tt '} values in FILE{\tt '} is created. Where
      {\tt "}FILE{\tt "} is the NDF filename. If the label is defined but is blank,
      this same default is used.  Blank units are omitted.  The units
      are squared for the variance component.
   }
   \sstinvocation{
      CALL KPG1\_DANOT( NDF, COMP, DATLAB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component: {\tt '}DATA{\tt '}, {\tt '}QUALITY{\tt '}, {\tt '}VARIANCE{\tt '},
         or {\tt '}ERROR{\tt '}, though it is used literally and not checked to
         be a member of this set.
      }
      \sstsubsection{
         DATLAB = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The composite annotation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The identifier should be associated with an NDF.
      }
   }
}
\sstroutine{
   KPG1\_DATCP
}{
   Get an AST FrameSet from an NDF
}{
   \sstdescription{
      Recursively copy an object into a component. This means that the
      complete object (including its components and its components{\tt '}s
      components, etc.) is copied, not just the top level.

      This routine is exactly like DAT\_COPY except that it will copy
      array slices, which DAT\_COPY will not.
   }
   \sstinvocation{
      CALL KPG1\_DATCP( LOC1, LOC2, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Object locator.
      }
      \sstsubsection{
         LOC2 = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Structure locator.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Component name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_DAUNI
}{
   Generates a string containing the units of an NDF{\tt '}s data or
   variance component allowing for truncation
}{
   \sstdescription{
      This routines generates a string containing the units of an
      NDF{\tt '}s data or variance component.  If the length of the
      variable to store the string is shorter than the units field,
      the units string is truncated and an ellipsis is inserted.
      For the variance the data units are enclosed in parentheses
      and followed by {\tt '}$*$$*$2{\tt '}.  Again if the the length of the units
      string is too short, truncate the units within the parentheses
      and insert an ellipsis.  A null string is returned if the UNITS
      component does not exist within the NDF.
   }
   \sstinvocation{
      CALL KPG1\_DAUNI( NDF, COMP, UNITS, NCU, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The NDF component: {\tt '}DATA{\tt '}, {\tt '}VARIANCE{\tt '}, {\tt '}QUALITY{\tt '} or {\tt '}ERROR{\tt '}.
         Any other component will result in a SAI\_\_ERROR status being
         returned immediately.
      }
      \sstsubsection{
         UNITS = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The string containing the units for the component, possibly
         truncated.  It is recommended that string should be at least
         20 characters long.  If COMP = {\tt '}VARIANCE{\tt '} the length must be
         no less than 9 characters; for COMP = {\tt '}DATA{\tt '} the minimum is 4
         characters; for COMP = {\tt '}ERROR{\tt '} the minimum is 5 characters;
         otherwise the routine returns immediately with the SAI\_\_ERROR
         status.
      }
      \sstsubsection{
         NCU = INTEGER (Returned)
      }{
         The length of the units string in characters ignoring trailing
         blanks. Always returned equal to zero if COMP = {\tt '}QUALITY{\tt '}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_DEBUG
}{
   Should the speified package report debug diagnostics?
}{
   \sstdescription{
      This routine returns a logical flag indicating if a specified
      applications package should report debug diagnostics. This is the
      case if the environment variable $<$PACK$>$\_DEBUG is defined (the value
      assigned to the environment variable is immaterial).
   }
   \sstinvocation{
      CALL KPG1\_DEBUG( VERB, PACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DEBUG = LOGICAL (Returned)
      }{
         Should the package run in debug mode? Returned .FALSE, if an
         error has already occurred, or if this routine should fail for
         any reason.
      }
      \sstsubsection{
         PACK = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the package (eg {\tt "}KAPPA{\tt "}, {\tt "}POLPACK{\tt "}, etc).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set to an
         error on entry.
      }
   }
}
\sstroutine{
   KPG1\_DNAG2R
}{
   Converts an NAG Hermitian Fourier transform array into an array
   usable by FFTPACK routine KPG1\_DRFFTB
}{
   \sstdescription{
      This subroutine modifies the supplied array of Fourier co-efficients
      (as produced by NAG subroutine C06FAF) so that an inverse FFT can be
      performed on them using FFTPACK routine KPG1\_DRFFTB. The resulting inverse
      will have the same normalisation as the original data transformed
      using KPG1\_DRFFTF.

      This function is equivalent to PDA\_NAG2R except that it uses work
      space for greater speed.
   }
   \sstinvocation{
      CALL KPG1\_DNAG2R( NP, R, WORK )
   }
   \sstarguments{
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of the array.
      }
      \sstsubsection{
         R( NP ) = DOUBLE PRECISION (Given and Returned)
      }{
         The array holding the Fourier co-efficients. Supplied in NAG
         format and returned in FFTPACK format.
      }
      \sstsubsection{
         WORK( NP ) = DOUBLE PRECISION (Given and Returned)
      }{
         Work space.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A call to KPG1\_DR2NAG followed by a call to KPG1\_DNAG2R will result in
         the original data being divided by NP.
      }
   }
}
\sstroutine{
   KPG1\_DR2NAG
}{
   Converts an FFTPACK Hermitian Fourier transform array into
   the equivalent NAG array
}{
   \sstdescription{
      This subroutine re-orders and normalises the supplied array of
      Fourier co-efficients (as produced by FFTPACK subroutine KPG1\_DRFFTF)
      so that the returned array looks like the equivalent array returned
      by NAG routine C06FAF.

      This function is equivalent to PDA\_DR2NAG except that it uses work
      space for greater speed.

      The real and imaginary co-efficients produced by KPG1\_DRFFTF are numerically
      larger than the corresponding C06FAF co-efficients by a factor of
      SQRT( NP ), and are ordered differently. Both routines return A0
      (the zeroth real term, i.e. the DC level in the array) in element 1.
      KPG1\_DRFFTF then has corresponding real and imaginary terms in adjacent
      elements, whereas C06FAF has all the real terms together, followed by
      all the imaginary terms (in reverse order):

         KPG1\_DRFFTF:  A0,    A1, B1,     A2, B2,     A3, B3,   ...
         C06FAF:       A0,    A1, A2, A3, ...,        ..., B3, B2, B1

      The zeroth imaginary term (B0) always has the value zero and so is
      not stored in the array. Care has to be taken about the parity of the
      array size. If it is even, then there is one more real term than
      there is imaginary terms (excluding A0), i.e. if NP = 10, then the
      co-efficients are stored as follows:

         KPG1\_DRFFTF:  A0, A1, B1, A2, B2, A3, B3, A4, B4, A5
         C06FAF:       A0, A1, A2, A3, A4, A5, B4, B3, B2, B1

      If NP = 9, then the co-efficients are stored as follows:

         KPG1\_DRFFTF:  A0, A1, B1, A2, B2, A3, B3, A4, B4
         C06FAF:       A0, A1, A2, A3, A4, B4, B3, B2, B1
   }
   \sstinvocation{
      CALL KPG1\_DR2NAG( NP, R )
   }
   \sstarguments{
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of the array.
      }
      \sstsubsection{
         R( NP ) = DOUBLE PRECISION (Given and Returned)
      }{
         The array holding the Fourier co-efficients. Supplied in FFTPACK
         format and returned in NAG format.
      }
      \sstsubsection{
         WORK( NP ) = DOUBLE PRECISION (Given and Returned)
      }{
         Work space.
      }
   }
}
\sstroutine{
   KPG1\_DSFR1
}{
   Displays a textual description of the Current Frame in a FrameSet
}{
   \sstdescription{
      This routine displays a textual description of the supplied AST
      Frame.  The displayed information does not include any
      axis-specific details that are common to all classes of Frame
      (such as axis units, labels, etc).
   }
   \sstinvocation{
      CALL KPG1\_DSFR1( FRM, TEXT, NIND, FULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRM = INTEGER (Given)
      }{
         An AST pointer to the Frame.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Text to display before the Frame description. May contain MSG
         tokens.
      }
      \sstsubsection{
         NIND = INTEGER (Given)
      }{
         Number of spaces to display at the start of each line.
      }
      \sstsubsection{
         FULL = LOGICAL (Given)
      }{
         Display full information?
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_DSFRM
}{
   Display a textual description of the Current Frame in a FrameSet
}{
   \sstdescription{
      This routine displays a textual description of the Current Frame
      in the supplied AST FrameSet.
   }
   \sstinvocation{
      CALL KPG1\_DSFRM( FSET, TEXT, FULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FSET = INTEGER (Given)
      }{
         An AST pointer to the FrameSet.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Text to display before the Frame description. May contain MSG
         tokens. This may be prefixed with a string that indicates
         further processing options. Currently the only such string
         recognised is {\tt "}ndftrace:{\tt "}, which causes the pixel scales to be
         written out to the output parameter FPIXSCALE. Any such string is
         not included in the displayed title.
      }
      \sstsubsection{
         FULL = LOGICAL (Given)
      }{
         Display full information?
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ELGAU
}{
   Calculates the axis ratio, inclination and minor-axis width of a
   star image, given the Gaussian widths of marginal profiles at
   45-degree intervals
}{
   \sstdescription{
      The reciprocal of the square of the width varies approximately
      like the length of an ellipse diameter as the angle of projection
      varies.  The routine calculates the required parameters assuming
      this relationship holds, then iterates, calculating the expected
      deviation from this law and subtracting it from the data before
      calculating a new estimate.  The solution of the ellipse
      equations is analogous to using the Stokes parameters of linear
      polarization to find the ellipse parameters.
   }
   \sstinvocation{
      CALL KPG1\_ELGAU( SIG, SIG0, AXISR, THETA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SIG( 4 ) = REAL (Given)
      }{
         The Gaussian widths of the marginal profiles of the star in
         directions at 0, 45, 90 and 135 degrees to the x axis.
      }
      \sstsubsection{
         SIG0 = REAL (Returned)
      }{
         The width of the minor axis of the ellipse.
      }
      \sstsubsection{
         AXISR = REAL (Returned)
      }{
         The axis ratio of the ellipse.
      }
      \sstsubsection{
         THETA = REAL (Returned)
      }{
         The inclination of the major axis to the x axis in radians
         (x through y positive).
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The routine assumes a Gaussian profile for the star.
   }
}
\sstroutine{
   KPG1\_ENV0R
}{
   Reads a floating point value from an environment variable
}{
   \sstdescription{
      This routine reads a floating point value from a specified
      environment variable. No error occurs if the environment variable
      is not defined, or has a non-numeric value, and the supplied value
      is returned unchanged.
   }
   \sstinvocation{
      CALL KPG1\_ENV0R( VARNAM, RVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The environment variable to check.
      }
      \sstsubsection{
         RVAL = REAL (Returned)
      }{
         The value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ENVDF
}{
   See if an environment variable is defined
}{
   \sstdescription{
      This routine returns a logical flag indicating if the specified
      environment variable is defined.
   }
   \sstinvocation{
      CALL KPG1\_ENVDF( VARNAM, DEF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The environment variable to check.
      }
      \sstsubsection{
         DEF = LOGICAL (Returned)
      }{
         Is the environment variable defined?
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set to an
         error on entry.
      }
   }
}
\sstroutine{
   KPG1\_FFTBD
}{
   Takes the inverse (Backward) FFT of a real image
}{
   \sstdescription{
      The input array should hold a Fourier transform of a purely real
      image, in Hermitian format as produced by KPG1\_FFTFD, or
      KPG1\_HMLTD.  The inverse FFT of this image is taken and returned
      in OUT.
   }
   \sstinvocation{
      CALL KPG1\_FFTBD( M, N, IN, WORK, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows in the input array.
      }
      \sstsubsection{
         IN( M, N ) = DOUBLE PRECISION (Given)
      }{
         The input array (a Fourier transform of a real image, stored in
         Hermitian format).
      }
      \sstsubsection{
         WORK( $*$ ) = DOUBLE PRECISION (Given)
      }{
         Work space.  This must be at least ( 3$*$MAX( M, N ) $+$ 15 )
         elements long.
      }
      \sstsubsection{
         OUT( M, N ) = DOUBLE PRECISION (Returned)
      }{
         The inverse FFT of the input array (a purely real image).
         Note, the same array can be specified for both input and
         output, in which case the supplied values are overwitten.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_FFTBR
}{
   Takes the inverse (Backward) FFT of a real image
}{
   \sstdescription{
      The input array should hold a Fourier transform of a purely real
      image, in Hermitian format as produced by KPG1\_FFTFR, or
      KPG1\_HMLTR.  The inverse FFT of this image is taken and returned
      in OUT.
   }
   \sstinvocation{
      CALL KPG1\_FFTBR( M, N, IN, WORK, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows in the input array.
      }
      \sstsubsection{
         IN( M, N ) = REAL (Given)
      }{
         The input array (a Fourier transform of a real image, stored in
         Hermitian format).
      }
      \sstsubsection{
         WORK( $*$ ) = REAL (Given)
      }{
         Work space.  This must be at least ( 3$*$MAX( M, N ) $+$ 15 )
         elements long.
      }
      \sstsubsection{
         OUT( M, N ) = REAL (Returned)
      }{
         The inverse FFT of the input array (a purely real image).
         Note, the same array can be specified for both input and
         output, in which case the supplied values are overwitten.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_FHDAT
}{
   Converts the NDF history date into a more-pleasing format
}{
   \sstdescription{
      This makes a few minor modifications to the date string obtained
      from NDF history records to make it more like UNIX and
      astronomical style.  Specifically two hyphens around the month are
      replaced by spaces, and the second and third letters of the month
      are made lowercase.
   }
   \sstinvocation{
      CALL KPG1\_FHDAT( DATE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATE = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On input the NDF format for a date and time, namely
         YYYY-MMM-DD HH:MM:SS.SSS.  On exit, the KAPPA format for a
         date and time, namely YYYY Mmm DD HH:MM:SS.SSS
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_FLOOR
}{
   Return the largest integer smaller than or equal to a supplied value
}{
   \sstdescription{
      This routine returns the largest integer smaller than or equal to
      a supplied value.
   }
   \sstinvocation{
      RESULT = KPG1\_FLOOR( VALUE )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = REAL (Given)
      }{
         The value.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      KPG1\_FLOOR = INTEGER
         The largest integer smaller than or equal to the supplied value.
   }
}
\sstroutine{
   KPG1\_FLPTH
}{
   Get the full path to a file given relative to a specified root directory
}{
   \sstdescription{
      This routine returns the full path to a file specified relative to
      the \$ROOT directory. The supplied file spec should be a UNIX-style
      file spec., but the returned full file path will be translated into
      the VMS equivalent if required.
   }
   \sstinvocation{
      CALL KPG1\_FLPTH( INSTR, OUTSTR, NC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ROOT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         An environment variable which is to be translated to get the
         full path to the root directory. Eg, HOME, KAPPA\_DIR, etc. If a
         blank value is supplied, then the current working directory is
         used (\$PWD on Unix and \$PATH on VMS).
      }
      \sstsubsection{
         INSTR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The file spec relative to the root directory. E.g. fred.dat,
         adam/display.sdf, etc.
      }
      \sstsubsection{
         OUTSTR = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file path. E.g. /home/dsb/fred.dat (DISK\$USER:[DSB]FRED.DAT
         on VMS), or /home/dsb/adam/display.sdf (DISK\$USER:[DSB.ADAM]DISPLAY.SDF on VMS).
         Returned blank if an error occurs.
      }
      \sstsubsection{
         NC = INTEGER (Returned)
      }{
         Number of characters used in OUTSTR. Returned equal to 0 if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GAXLB
}{
   Obtains an axis annotation for an NDF axis
}{
   \sstdescription{
      This routine obtains an axis annotation from the parameter system.
      The suggested default is of the form {\tt "}label (units){\tt "} when there
      is both an axis label and units, or {\tt "}label{\tt "} if the label but not
      the units are present.  If neither are present a supplied default
      is used instead.  If a bad status, other than abort, is returned
      by the parameter system when getting the value, the error is
      annulled and the output annotation is the suggested default value.
   }
   \sstinvocation{
      CALL KPG1\_GAXLB( NDF, IAXIS, PNAXL, DEFAUL, AXSLAB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         The number of the axis whose character components are to be
         used.
      }
      \sstsubsection{
         PNAXL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter from which the annotation will
         be obtained.
      }
      \sstsubsection{
         DEFAUL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The suggested default when the NDF axis does not have a label,
         and the actual value returned when a null (!) value or any
         other non-abort bad status is obtained from the parameter
         system.
      }
      \sstsubsection{
         AXSLAB = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The annotation obtained from the parameter system.  The dynamic
         default is limited to 128 characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GTCHV
}{
   Obtains a vector of choices from the environment
}{
   \sstdescription{
      This routine gets up to MAXVAL strings from the user, selected
      from those supplied in OPTS.  The indices of the supplied strings
      within OPTS are returned.  The user supplies the strings in the
      form of a GRP group expression, using the default GRP control
      characters.

      The user may supply an integer value instead of a string, in
      which case the integer is understood to be the index of the
      required string within OPTS.  If the supplied list of strings
      contains the integer itself, then the integer is understood to be
      a string, not an index.
   }
   \sstinvocation{
      CALL KPG1\_GCHMV( PARAM, NOPT, OPTS, MAXVAL, IDEF, NVAL, VALS,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         NOPT = INTEGER (Given)
      }{
         The number of available options supplied in OPTS.
      }
      \sstsubsection{
         OPTS( NOPT ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         An array holding the options from which the user must choose.
         Leading and trailing white space is ignored. Blank options are
         not allowed.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of choices.
      }
      \sstsubsection{
         IDEF( MAXVAL ) = INTEGER (Given)
      }{
         The indices within OPTS of the default strings to use if a
         null (!) value is supplied for the parameter.  If the first
         value is zero, a null parameter value results in a PAR\_\_NULL
         status being returned.
      }
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The number of choices supplied.
      }
      \sstsubsection{
         VALS( MAXVAL ) = INTEGER (Returned)
      }{
         The indices within OPTS of the selected options.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Case is insignificant when comparing supplied strings with
         available options.

         \sstitem
         A dynamic default is set for the parameter before accessing it
         if IDEF supplied suitable defaults.  The default consists of a
         comma-separated list of the default options.
      }
   }
}
\sstroutine{
   KPG1\_GDARE
}{
   Defines a region within the current PGPLOT window
}{
   \sstdescription{
      This subroutine defines a two-dimensional region in the current
      PGPLOT window.  The region is defined by the given position
      justification, and the linear fraction along each axis of the
      current PGPLOT window; and an aspect ratio.  The linear fraction is
      applied first followed by the aspect-ratio constraint.
   }
   \sstinvocation{
      CALL KPG1\_GDARE( JUST, FRACT, ASPECT, X1, X2, Y1, Y2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         JUST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Justification of the new region specified by a two-character
         code.  The first character controls the vertical location, and
         may be T, B, or C to create the new region at the top, bottom,
         or in the centre respectively.  The second defines the
         horizontal situation, and may be L, R, or C to define a new
         region to the left, right, or in the centre respectively.
         Thus a code of BR will make a new region in the bottom-right
         corner.  The justification code need not be in uppercase.
      }
      \sstsubsection{
         FRACT( 2 ) = REAL (Given)
      }{
         The fractional size of the new region applied along each axis.
         So values of 0.5,0.5 would create a picture 0.25 the area of
         the current window.
      }
      \sstsubsection{
         ASPECT  = REAL (Given)
      }{
         The aspect ratio of the new region (x/y).  If the value is
         negative, no aspect-ratio constraint is applied to define the
         new region.
      }
      \sstsubsection{
         X1 = REAL (Returned)
      }{
         Lower x world co-ordinate in the current window of the new
         region.
      }
      \sstsubsection{
         X2 = REAL (Returned)
      }{
         Upper x world co-ordinate in the current window of the new
         region.
      }
      \sstsubsection{
         Y1 = REAL (Returned)
      }{
         Lower y world co-ordinate in the current window of the new
         region.
      }
      \sstsubsection{
         Y2 = REAL (Returned)
      }{
         Upper y world co-ordinate in the current window of the new
         region.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_GDBND
}{
   Get the bounds of a new PGPLOT window from the environment
}{
   \sstdescription{
      This routine defines a 2-d region in the current PGPLOT window,
      getting the bounds of the region from the environment.
   }
   \sstinvocation{
      CALL KPG1\_GDBND( PNLOW, PNUPP, LBND, UBND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNLOW = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name of lower-bound co-ordinates that defines a
         region.
      }
      \sstsubsection{
         PNUPP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name of lower-bound co-ordinates that defines a
         region.
      }
      \sstsubsection{
         LBND( 2 ) = REAL (Returned)
      }{
         Co-ordinates of the lower bound that defines a region.
      }
      \sstsubsection{
         UBND( 2 ) = REAL (Returned)
      }{
         Co-ordinates of the upper bound that defines a region.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GDFND
}{
   Selects the highest picture of a given name with WCS within the
   current AGI picture
}{
   \sstdescription{
      This routine searches forwards through the AGI database for a
      picture of a given name that lies within the current picture and
      has an associated AST Plot structure. The the current picture
      itself is included in the search.  If such a picture is found it
      becomes the new current picture.  Otherwise, a bad status will be
      returned, and the current picture is unchanged.

      This routine is like KPG1\_AGFND except that KPG1\_AGFDN does not
      require the returned picture to have an associated Plot.
   }
   \sstinvocation{
      CALL KPG1\_GDFND( NAME, IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the picture to be searched for in the graphics
         database.
      }
      \sstsubsection{
         IPIC = INTEGER (Returned)
      }{
         The picture identifier of the most-recent picture named NAME.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GDFNP
}{
   Selects the highest picture of a given name that embraces a
   position and has WCS
}{
   \sstdescription{
      This routine returns an AGI identifier for the youngest picture
      that has the specified name, embraces the given position and
      lies within the bounds of the current picture. In this sense it is
      like AGI\_RCLP. However, it also applies an extra requirement that
      the returned picture should have associated WCS. If no picture with
      associated WCS can be found, then it abandons this extra requirement
      and just returns the youngest picture encompassing the supplied
      position.
   }
   \sstinvocation{
      CALL KPG1\_GDFNP( NAME, X, Y, IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the picture to be searched for in the graphics
         database.
      }
      \sstsubsection{
         X = REAL (Given)
      }{
         X position of test point
      }
      \sstsubsection{
         Y = REAL (Given)
      }{
         Y position of test point
      }
      \sstsubsection{
         IPIC = INTEGER (Returned)
      }{
         The picture identifier of the most-recent picture named NAME.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GDGET
}{
   Get the AST Plot associated with an AGI picture
}{
   \sstdescription{
      This routine makes the specified AGI picture current, creates a
      corresponding PGPLOT viewport and window, and returns a Plot
      associated with the picture.

      On exit, the PGPLOT viewport corresponds to the area encompassed by
      the specified picture. The world co-ordinate bounds within this
      viewport are set so that the PGPLOT world co-ordinate system is
      millimetres from the bottom left corner of the view surface. This
      corresponds to the Base (GRAPHICS) Frame in the returned Plot.

      The returned Plot will normally be obtained from the MORE structure
      in the graphics database (where it was stored by a previous AST-based
      application). The Base Frame will be a GRAPHICS Frame, giving
      millimetres from the bottom left corner of the view surface.

      If no Plot is available in the database, then an initial PLOT is
      created containing a Base Frame with Domain GRAPHICS (giving
      millimetres from the bottom left corner of the view surface), and
      a Current Frame corresponding to AGI world co-ordinates. The Frame
      to represent AGI world co-ordinates in the Plot may be supplied by
      the calling application (for instance, an application may supply a
      PIXEL Frame on the assumption that AGI world co-ordinates are pixel
      co-ordinates). If no such Frame is supplied then a simple Frame is
      used, with Domain set to AGI\_WORLD.

      A third Frame may optionally be added to the Plot representing AGI
      DATA co-ordinates. This Frame will have Domain AGI\_DATA, and the
      Mapping from world to data co-ordinates will be given by the
      TRANSFORM structure stored with the picture in the database. If
      present, it will be the Current Frame in the Plot on exit. See
      {\tt "}Usage{\tt "} below for warnings about using this option.

      Finally, some other Frames are added to the Plot representing
      various normalised co-ordinates:

      BASEPIC: The co-ordinates of the bottom left corner of the BASE
      picture are (0,0). The shorter dimension of the BASE picture has
      length 1.0, and the other axis has a length greater than 1.0.

      NDC: Normalized device coordinates. The bottom left corner of the
      screen is (0,0) and the top-right corner is (1,1).

      CURPIC: The co-ordinates of the bottom left corner of the current
      picture are (0,0). The shorter dimension of the current picture has
      length 1.0, and the other axis has a length greater than 1.0.

      CURNDC: The co-ordinates of the bottom left corner of the current
      picture are (0,0), and the top right corner is (1,1).

      If the Plot read from the database already contains any of these
      Frames then they are retained and no new Frame is added.
   }
   \sstinvocation{
      CALL KPG1\_GDGET( IPIC, WCFRM, MKDATA, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPIC = INTEGER (Given)
      }{
         The AGI identifier for the picture. If a value of -1 is supplied,
         the identifier for the current picture is used.
      }
      \sstsubsection{
         WCFRM = INTEGER (Given)
      }{
         A pointer to an AST Frame which will be used to describe AGI
         world co-ordinates if the picture has no associated Plot. This
         argument is ignored if the picture already has a Plot stored with
         it in the database. If a null pointer (AST\_\_NULL) is supplied, then
         a default Frame is used with Domain set to AGI\_WORLD.
      }
      \sstsubsection{
         MKDATA = LOGICAL (Given)
      }{
         Should a Frame with Domain AGI\_DATA be included in the returned
         Plot to represent AGI DATA co-ordinates? This is ignored if the
         picture has a Plot already stored with it in the database.
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         An AST pointer to the Plot. Returned equal to AST\_\_NULL if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The PGPLOT interface to the AGI library should be opened before
         calling this routine.
      }
   }
}
\sstroutine{
   KPG1\_GDNEW
}{
   Creates a new DATA picture with ancillary pictures
}{
   \sstdescription{
      This routine returns identifiers for a new DATA picture together
      with various ancillary pictures in the graphics database. On exit,
      the new DATA picture is the current AGI picture, and the PGPLOT
      viewport matches the DATA picture.

      A FRAME picture is only created if it would contain something other
      than the DATA picture (this is assumed to be the case if any
      ancillary pictures are requested, or if non-zero margins are requested
      around the DATA picture). If created, the FRAME picture has the
      maximum possible size. The DATA picture is then created with a size
      which allows all the requested ancillary pictures to be created within
      the FRAME picture.

      Various environment parameters may be used to obtain options, etc. The
      names of these parameters are hard-wired into this subroutine in
      order to ensure conformity between application.
   }
   \sstinvocation{
      CALL KPG1\_GDNEW( COMMNT, MARGIN, NP, PNAME, PSIDE, PSIZE,
                       SASPEC, BOX, IPICD, IPICF, IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         COMMENT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comment to store with the new pictures added to the AGI
         database. This will usually by an indication of the application
         being run (eg KAPPA\_DISPLAY).
      }
      \sstsubsection{
         MARGIN( 4 ) = REAL (Given)
      }{
         The width of the borders to leave round the DATA picture, given
         as fractions of the corresponding dimension of the current picture.
         These should be supplied in the order bottom, right, top, left.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The number of extra pictures to be included in the FRAME pictures
         (the DATA picture itself is not included in this list). Margins are
         left round the DATA picture with widths given by MARGIN. Any extra
         pictures are placed outside these margins, in positions described by
         PSIDE and PSIZE.
      }
      \sstsubsection{
         PNAME( NP ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names to store in the AGI database with the NP extra pictures.
      }
      \sstsubsection{
         PSIDE( NP ) = CHARACTER $*$ 1 (Given)
      }{
         Each element of this array should be one of L, R, T or B. It
         indicates which side of the FRAME picture an extra picture is to be
         placed. For Left and Right, the extra picture occupies the full
         height of the DATA picture, margins, and any previously created
         extra pictures. The picture is placed at the far Left or Right of
         all previously created pictures. For Top or Bottom, the extra picture
         occupies the full width of the DATA picture, margins, and any
         previously created extra pictures. The picture is placed at the top or
         bottom of all previously created pictures. Ignored if NP is zero.
      }
      \sstsubsection{
         PSIZE( NP ) = REAL (Given)
      }{
         The size of each extra picture. For Left and Right pictures, this
         is the width of the picture, and the value is given as a fraction
         of the width of the current picture. For Top and Bottom pictures,
         it is the height of the picture, and it is given as a fraction of
         the height of the current picture. Ignored if NP is zero.
      }
      \sstsubsection{
         SASPEC = REAL (Given)
      }{
         The aspect ratio with which a new DATA picture should be created.
         This is the height divided by the width of the DATA picture,
         assuming equal scales on each axis (eg metres). A value of zero
         causes the DATA picture to have the aspect ratio which produces
         the largest picture. The actual value used will depend on the
         value supplied for the FILL parameter (see above).
      }
      \sstsubsection{
         BOX( 4 ) = DOUBLE PRECISION (Given)
      }{
         The world coordinate bounds to give to the DATA picture if a new
         DATA picture is created. These should normally be pixel
         coordinates. The (x,y) coordinates of the bottom left corner should
         be given in elements 1 and 2, and the (x,y) coordinates of the top
         right corner should be given in elements 3 and 4. If the box has
         zero area, then world coordinates are set to centimetres from the
         bottom left corner of the DATA picture.
      }
      \sstsubsection{
         IPICD = INTEGER (Returned)
      }{
         An AGI identifier for the DATA picture.
      }
      \sstsubsection{
         IPICF = INTEGER (Returned)
      }{
         An AGI identifier for the FRAME picture. The world co-ordinate
         system is inherited from the current picture on entry. If no
         FRAME picture was created, then an AGI identifier for the current
         picture is returned.
      }
      \sstsubsection{
         IPIC( NP ) = INTEGER (Returned)
      }{
         An array of AGI identifiers corresponding to the extra pictures
         requested in ZSIDE and PSIZE. The world coordinate system for each
         picture is inherited from the FRAME picture. The actual size of a
         picture may be less than the requested size if there is insufficient
         room left in the FRAME picture to give it its requested size.
         Identifiers for pictures which would have zero size (i.e. fall
         completely outside the FRAME picture) are returned equal to -1,
         but no error is reported.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Picture identifiers are returned equal to -1 if an error occurs,
         or if the picture cannot be created.
      }
   }
   \sstdiylist{
      Environment Parameters
   }{
      \sstsubsection{
         FILL = \_LOGICAL (Read)
      }{
         TRUE if the supplied aspect ratio (SASPEC) is to be ignored,
         creating the largest possible DATA picture within the current
         picture.  When FILL is FALSE, the DATA picture is created with
         the supplied aspect ratio. Not accessed if argument SASPEC is
         supplied equal to zero (i.e. (SASPEC .EQ. 0.0) implies FILL=YES)
      }
   }
}
\sstroutine{
   KPG1\_GDOLD
}{
   Create a new DATA picture with ancillary pictures aligned with
   an existing DATA picture
}{
   \sstdescription{
      This routine creates a new DATA picture aligned with an existing
      DATA picture, together with any requested ancillary pictures. On
      exit, the new DATA picture is the current picture, and the current
      PGPLOT viewport corresponds to this picture.

      A FRAME picture is only created if it would contain something other
      than the DATA picture (this is assumed to be the case if any
      ancillary pictures are requested, or if non-zero margins are requested
      around the DATA picture). Ancillary pictures are given their
      requested sizes except that they are clipped at the bounds of the
      original current picture. The FRAME picture is also clipped at the
      bounds of the original current picture.
   }
   \sstinvocation{
      CALL KPG1\_GDOLD( MARGIN, COMMNT, NP, PNAME, PSIDE, PSIZE,
                       IPICD, IPICD0, IPICF, IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MARGIN( 4 ) = REAL (Given)
      }{
         The width of the borders to leave round the DATA picture, given
         as fractions of the corresponding dimension of the current picture.
         These should be supplied in the order bottom, right, top, left.
         They may be negative.
      }
      \sstsubsection{
         COMMNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comment to store with the new pictures added to the AGI
         database. This will usually by an indication of the application
         being run (eg KAPPA\_DISPLAY).
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The number of extra pictures to be included in the FRAME picture
         (the DATA picture itself is not included in this list). Margins are
         left round the DATA picture with widths given by MARGIN. Any extra
         pictures are placed outside these margins, in positions described by
         PSIDE and PSIZE.
      }
      \sstsubsection{
         PNAME( NP ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names to store in the AGI database with the NP extra pictures.
      }
      \sstsubsection{
         PSIDE( NP ) = CHARACTER $*$ 1 (Given)
      }{
         Each element of this array should be one of L, R, T or B. It
         indicates which side of the FRAME picture an extra picture is to be
         placed. For Left and Right, the extra picture occupies the full
         height of the DATA picture, margins, and any previously created
         extra pictures. The picture is placed at the far Left or Right of
         all previously created pictures. For Top or Bottom, the extra picture
         occupies the full width of the DATA picture, margins, and any
         previously created extra pictures. The picture is placed at the top or
         bottom of all previously created pictures. Ignored if NP is zero.
      }
      \sstsubsection{
         PSIZE( NP ) = REAL (Given)
      }{
         The size of each extra picture. For Left and Right pictures, this is
         the width of the picture, and the value is given as a fraction of
         the width of the current picture. For Top and Bottom pictures, it
         is the height of the picture, and it is given as a fraction of the
         height of the current picture. Ignored if NP is zero.
      }
      \sstsubsection{
         IPICD = INTEGER (Given)
      }{
         An AGI identifier for the existing DATA picture.
      }
      \sstsubsection{
         IPICD0 = INTEGER (Returned)
      }{
         An AGI identifier for the new DATA picture.
      }
      \sstsubsection{
         IPICF = INTEGER (Returned)
      }{
         An AGI identifier for the FRAME picture. Thw world cooridnate
         system is inherited form the current picture on entry. If no
         FRAME picture was created, then an AGI identifier for the current
         picture is returned.
      }
      \sstsubsection{
         IPIC( NP ) = INTEGER (Returned)
      }{
         An array of AGI identifiers corresponding to the extra pictures
         requested in ZSIDE and PSIZE. The world coordinate system for each
         picture is inherited from the FRAME picture. The actual size of a
         picture may be less than the requested size if there is insufficient
         room left in the FRAME picture to give it its requested size.
         Identifiers for pictures which would have zero size (i.e. fall
         completely outside the FRAME picture) are returned equal to -1,
         but no error is reported.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Picture identifiers are returned equal to -1 if an error occurs,
         or if the picture cannot be created.
      }
   }
}
\sstroutine{
   KPG1\_GDPUT
}{
   Save an AST Plot with a graphics database picture
}{
   \sstdescription{
      This routine saves the supplied AST Plot (see SUN/210) in the AGI
      database (see SUN/48) within the MORE structure of the specified
      picture. It can be retrieved if necessary using KPG1\_GDGET (see the
      prologue of KPG1\_GDGET for more information about using these two
      routines).

      If the supplied Plot contains a {\tt "}AGI Data{\tt "} Frame with the
      Domain given by DDOM in which the axes are scaled and shifted
      versions of the axes of the AGI world co-ordinate Frame
      (specified by argument WDOM), then a TRANSFORM structure defining
      AGI Data co-ordinates is stored with the DATA picture. This is purely
      for the benefit of non-AST based applications which may use AGI Data
      co-ordinates (AST-based applications should always use the Plot
      stored with the picture in preference to the TRANSFORM structure
      stored in the AGI database).

      Any Frames that are Regions and have a Domain beginning with {\tt "}ROI{\tt "}
      are deleted from the Plot before saving it. Also, any Frames that
      have an Ident value beginning with {\tt "}ROI{\tt "} are also deleted from the
      Frame (these may be added by KPG1\_ASGET).
   }
   \sstinvocation{
      CALL KPG1\_GDPUT( IPIC, WDOM, DDOM, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPIC = INTEGER (Given)
      }{
         The AGI identifier for the picture. A value of -1 causes the
         Plot to be stored with the current picture.
      }
      \sstsubsection{
         WDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Domain name of the co-ordinate Frame within IPLOT corresponding
         to AGI world co-ordinates. {\tt "}AGI\_WORLD{\tt "} is used if a blank value
         is supplied.
      }
      \sstsubsection{
         DDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Domain name of the co-ordinate Frame within IPLOT corresponding
         to AGI data co-ordinates. {\tt "}AXIS{\tt "} is used if a blank value
         is supplied.
      }
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to the Plot to be stored with the picture. If
         AST\_\_NULL is supplied, any existing Plot stored with the picture is
         deleted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The Base (GRAPHICS) Frame in the Plot should represent millimetres
         from the bottom left corner of the view surface.

         \sstitem
         An error is reported if the Plot contains any Frames which have the
         Domain AGI\_DATA.

         \sstitem
         The PGPLOT interface to the AGI library should be opened before
         calling this routine.

         \sstitem
         The Plot is stored in a component of the MORE structure named
         {\tt "}AST\_PLOT{\tt "} and with type {\tt "}WCS{\tt "}.
      }
   }
}
\sstroutine{
   KPG1\_GDQPC
}{
   Return the extent of the current picture
}{
   \sstdescription{
      This routine makes the current PGPLOT bviewport and window match
      the current AGI picture, and returns the extent of the picture in
      AGI world co-ordinates and physical coordinates (metres).
   }
   \sstinvocation{
      CALL KPG1\_GDQPC( X1, X2, Y1, Y2, XM, YM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X1 = REAL (Returned)
      }{
         The X world coordinate of the bottom left corner.
      }
      \sstsubsection{
         Y1 = REAL (Returned)
      }{
         The Y world coordinate of the bottom left corner.
      }
      \sstsubsection{
         X2 = REAL (Returned)
      }{
         The X world coordinate of the top right corner.
      }
      \sstsubsection{
         Y2 = REAL (Returned)
      }{
         The Y world coordinate of the top right corner.
      }
      \sstsubsection{
         XM = REAL (Returned)
      }{
         The extent of the Y axis in metres.
      }
      \sstsubsection{
         YM = REAL (Returned)
      }{
         The extent of the Y axis in metres.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The PGPLOT interface to the AGI library should be opened before
         calling this routine.

         \sstitem
         The PGPLOT viewport corresponds to the current AGI picture
         on exit.
      }
   }
}
\sstroutine{
   KPG1\_GDWIN
}{
   Set PGPLOT world co-ordinates to be the world co-ordinates
   of the specified AGI picture
}{
   \sstdescription{
      This routine finds the bounds of the current PGPLOT viewport within
      the world-coordinate system of a specified AGI picture, and sets the
      PGPLOT window accordingly.
   }
   \sstinvocation{
      CALL  KPG1\_GDWIN( IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPIC = INTEGER (Given)
      }{
         The AGI picture identifier. If -1, then the current picture is
         used.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GETIM
}{
   Get locators to an IMAGE-type structure and structure holding the
   data array for data input
}{
   \sstdescription{
      Returns a locator to an IMAGE-type data-structure associated with
      a supplied parameter name, if a valid locator is not supplied.
      The DATA\_ARRAY component is examined to determine whether it is
      primitive or a structure.  Given the former, the second locator
      returned is the same as that to the IMAGE structure; on the other
      hand, DATA\_ARRAY is tested for being a simple ARRAY, if it is not
      an error status is set, if it is the second locator returned
      points to the DATA\_ARRAY structure.  The simple ARRAY structure
      is searched for origin and bad-pixel information.  Should the
      origin be not at 0 for each dimension, and/or the bad-pixel flag
      be set to false, warning messages are made.

      It will not handle other NDF variants save report an error.
   }
   \sstinvocation{
      CALL KPG1\_GETIM( PARNAM, LOCAT, DATLOC, DNAME, ORIGIN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name associated with the input IMAGE-type
         structure.  If this is blank, the supplied locator, LOCAT,
         will be assumed to be the locator to the top-level of an NDF
         (IMAGE-type) structure.
      }
      \sstsubsection{
         LOCAT  = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given \& Returned)
      }{
         On input when PARNAM is blank, there will be no association
         with a parameter; the locator is assumed to point at the
         top level of an NDF, and will be unchanged on exit.

         If PARNAM is non blank, the input value of LOCAT is ignored.
         On exit LOCAT is the locator to the object associated with the
         given parameter name, unless status is bad, whereupon this
         locator is annulled.
      }
      \sstsubsection{
         DATLOC  = CHARACTER $*$ ( DAT\_\_SZLOC ) (Returned)
      }{
         The locator to the structure containing the primitive form of
         the data array.  If it is the top-level of the NDF (IMAGE)
         structure, it will be a clone of LOCAT.  Either way it will
         require annulment.  If status is bad on exit this locator is
         annulled.
      }
      \sstsubsection{
         DNAME = CHARACTER $*$ ( DAT\_\_SZNAM ) (Returned)
      }{
         The name of the data array as this will be needed for access,
         and it is different depending on its location.
      }
      \sstsubsection{
         ORIGIN( DAT\_\_MXDIM ) = INTEGER (Returned)
      }{
         The origin of the data array for each dimension.  It is set to
         1 for non-existent dimensions.  This argument returned so that
         if an output NDF is being created is will not be invalidated
         because of different origins in its ARRAY-type components.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This a stop-gap routine until the remainder of KAPPA
         IMAGE-format applications are converted to NDF.
      }
   }
}
\sstroutine{
   KPG1\_GETYP
}{
   Obtains a valid HDS primitive data type via a parameter
}{
   \sstdescription{
      This routine obtains and validates an HDS primitive data type,
      including the \_CHAR$*$n and LITERAL forms.  Unamibguous
      abbreviations may be supplied.  The user is reprompted up to four
      times if the value is not one of the allowed types.
   }
   \sstinvocation{
      CALL KPG1\_GETYP( PARAM, HDSTYP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter through which the value is to be obtained.  The
         parameter data type should be LITERAL or \_CHAR.
      }
      \sstsubsection{
         HDSTYP = CHARACTER $*$ ( DAT\_\_SZTYP ) (Given)
      }{
         The unabbreviated HDS primitive type obtained.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Error reports are made and flushed inside the loop if the
         \_CHAR$*$n has an invalid {\tt "}n{\tt "} value.

         \sstitem
         Bad status is returned if no valid type has been obtained.
      }
   }
}
\sstroutine{
   KPG1\_GILST
}{
   Selects integers within a range of values
}{
   \sstdescription{
      This routine selects integer numbers from LONUM to UPNUM. The
      routine gets a character string from the user and parses it to
      extract the specified numbers. The default selection is the all
      integers within the range LONUM to UPNUM.
   }
   \sstinvocation{
      CALL KPG1\_GILST( LONUM, UPNUM, MAXLIN, PARAM, FLAG, NUMBER,
                       NDISP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LONUM = INTEGER (Given)
      }{
         The lower limit of the selection range.
      }
      \sstsubsection{
         UPNUM = INTEGER (Given)
      }{
         The upper limit of the selection range.
      }
      \sstsubsection{
         MAXLIN = INTEGER (Given)
      }{
         The max. number of numbers can be selected.
      }
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The name of the parameter used to get the number specification
         from the user. It can be a list, separated by commas,
         comprising any reasonable combination of the following formats:

            ALL or $*$ - All integers between 1 and NUM

            xx,yy,zz - A list of integers.

            xx:yy - All integers between xx and yy inclusively. When xx
                    is omitted the range begins from 1, when yy is
                    omitted the range ends with UPNUM.

         Any number can be specified more than once but it has the same
         effect as just entering it once.
      }
      \sstsubsection{
         FLAG( LONUM : UPNUM ) = INTEGER (Returned)
      }{
         A temporary flag array used to flag the number which has been
         selected.
      }
      \sstsubsection{
         NUMBER( MAXLIN ) = INTEGER (Returned)
      }{
         The selected numbers.
      }
      \sstsubsection{
         NDISP = INTEGER (Returned)
      }{
         The number of selected numbers.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GNDFP
}{
   Gets an NDF or NDF section with a specified number of significant
   dimensions, but also may select one further significant iteration
   dimension
}{
   \sstdescription{
      The supplied parameter name PARNDF is associated with an NDF
      through the environment, and an identifier is obtained for the NDF
      using the specified access mode.  Each axis of the NDF is checked
      to see if is significant (i.e. has a size greater than 1).  The
      index of each significant axis is returned in SDIM; and the bounds
      of the axes are returned in LBND and UBND.  If the number of
      significant axes is exactly one more than NDIM, one axis may be
      chosen for later iteration over `planes{\tt '} of NDIM dimensions.
      If there are fewer than NDIM significant dimensions then the
      insignificant dimensions are used (starting from the lowest) to
      ensure that the required number of dimensions are returned.
   }
   \sstinvocation{
      CALL KPG1\_GNDFP( PARNDF, PARPAX, NDIM, MODE, INDF, SDIM, LBND,
                       UBND, PERPAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name to obtain the NDF.
      }
      \sstsubsection{
         PARPAX = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name to obtain the axis to iterate over the
         `planes{\tt '}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions required.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The access mode required for the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         An identifier for the NDF.
      }
      \sstsubsection{
         SDIM( NDIM ) = INTEGER (Returned)
      }{
         The indices of the significant dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Returned)
      }{
         The lower bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Returned)
      }{
         The upper bounds of the NDF.
      }
      \sstsubsection{
         PERPAX = INTEGER (Returned)
      }{
         The index of the axis perpendicular to the `plane{\tt '} if there is
         exactly one more significant axis than NDIM, otherwise set to
         zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GNLBU
}{
   Obtains an axis annotation for NDF data or variance
}{
   \sstdescription{
      This routine obtains an axis annotation from the parameter system.
      The suggested default has the form {\tt "}label (units){\tt "} when the NDF
      has both a label and units, or {\tt "}label{\tt "} if there is a label but
      not units.  When neither component is present the default is the
      component name follwed by {\tt "} values{\tt "}.  The units are squared for
      the variance component.  If a bad status, other than abort, is
      returned by the parameter system when getting the value, the
      error is annulled and the output annotation is the suggested
      default value.
   }
   \sstinvocation{
      CALL KPG1\_GNLBU( NDF, PNLAB, COMP, AXSLAB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         PNLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter from which the annotation will
         be obtained.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component: {\tt '}DATA{\tt '}, {\tt '}QUALITY{\tt '}, {\tt '}VARIANCE{\tt '},
         or {\tt '}ERROR{\tt '}, though it is used literally and not checked to
         be a member of this set.
      }
      \sstsubsection{
         AXSLAB = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The annotation obtained from the parameter system.  The dynamic
         default is limited to 128 characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GNTIT
}{
   Obtains a title using the NDF title as the suggested default
}{
   \sstdescription{
      This routine obtains a title from the parameter system.  The
      suggested default is title of the input NDF if it has one,
      otherwise a supplied default is used.  If a bad status, other
      than abort, is returned by the parameter system when getting the
      value, the error is annulled and the output title is the default
      value.
   }
   \sstinvocation{
      CALL KPG1\_GNTIT( NDF, PNTITL, DEFAUL, TITLE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         PNTITL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter from which the title will be
         obtained.
      }
      \sstsubsection{
         DEFAUL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The suggested default when the NDF does not have a title, or
         the actual value returned when a null (!) value or any other
         non-abort bad status is obtained from the parameter system.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The title obtained from the parameter system.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GPCOL
}{
   Obtains the red, green and blue intensities of a colour by value
   or by name for the standard colour set
}{
   \sstdescription{
      This routine obtains a colour via the ADAM parameter system.
      The colour may be either a named colour from the colour set; or
      red, green, and blue intensities separated by commas or spaces.
      If the named colour does not exist, or there is a problem
      extracting and converting the RGB values, or the RGB values are
      out of the range 0.0 to 1.0, an error is reported immediately
      and the user is prompted for another value.
   }
   \sstinvocation{
      CALL KPG1\_GPCOL( PNCOL, RGBINT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNCOL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter used to obtain the colour.  It
         must be of type \_CHAR or LITERAL.
      }
      \sstsubsection{
         RGBINT( 3 ) = REAL (Returned)
      }{
         The red, green and blue intensities of the selected colour.
         They are normalised to the range 0.0 to 1.0.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GRAPH
}{
   Draws a line graph
}{
   \sstdescription{
      Opens a graphics device and draws a graph displaying a supplied
      set of points. Each point is defined by an X and Y value, plus an
      optional error bar. An AST Plot is returned so that the calling
      application can add further graphics to the plot if needed. When
      complete, the calling application should annul the Plot, and close
      the workstation:

        CALL AST\_ANNUL( IPLOT, STATUS )
        CALL AGP\_DEASS( {\tt '}DEVICE{\tt '}, .FALSE., STATUS )

      Various environment parameter names are used by this routine,
      to encourage uniformity in parameter naming, and behaviour.
      See KPG1\_GRPHW for details.
   }
   \sstinvocation{
      CALL KPG1\_GRAPH( N, X, Y, NSIGMA, YSIGMA, XLAB, YLAB, TTL, XSYM,
                       YSYM, MODE, NULL, XL, XR, YB, YT, APP, QUIET,
                       LMODE, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of points
      }
      \sstsubsection{
         X( N ) = REAL (Given)
      }{
         X value at each point.
      }
      \sstsubsection{
         Y( N ) = REAL (Given)
      }{
         Y value at each point.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Controls the length of the vertical error bars. A value of zero
         suppresses error bars. Otherwise error bars are drawn which extend
         by from Y - NSIGMA$*$YSIGMA to Y $+$ NSIGMA$*$YSIGMA.
      }
      \sstsubsection{
         YSIGMA( N ) = REAL (Given)
      }{
         The standard deviation associated with each Y value.
      }
      \sstsubsection{
         XLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default label for the X axis. Only used if the user does not
         supply an alternative. Trailing spaces are ignored. If a Plot is
         supplied via IPLOT, then the {\tt "}Label(1){\tt "} attribute in the Plot is
         used as the default in preference to XLAB.
      }
      \sstsubsection{
         YLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default label for the Y axis. Only used if the user does not
         supply an alternative. Trailing spaces are ignored. If a Plot is
         supplied via IPLOT, then the {\tt "}Label(2){\tt "} attribute in the Plot is
         used as the default in preference to YLAB.
      }
      \sstsubsection{
         TTL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default title for the plot. Only used if the user does not
         supply an alternative. If a Plot is supplied via IPLOT, then the
         {\tt "}Title{\tt "} attribute in the Plot is used as the default in preference
         to TTL.
      }
      \sstsubsection{
         XSYM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The default symbol for the horizontal axis. Only used if the user
         does not supply an alternative. This will be stored with the Plot
         in the AGI database and (for instance) used by CURSOR as axis
         symbols when displaying the cursor positions on the screen. If
         a Plot is supplied via IPLOT, then the {\tt "}Symbol(1){\tt "} attribute in
         the Plot is used as the default in preference to XSYM.
      }
      \sstsubsection{
         YSYM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The default symbol for the horizontal axis. Only used if the user
         does not supply an alternative. This will be stored with the Plot
         in the AGI database and (for instance) used by CURSOR as axis
         symbols when displaying the cursor positions on the screen. If
         a Plot is supplied via IPLOT, then the {\tt "}Symbol(2){\tt "} attribute in
         the Plot is used as the default in preference to XSYM.
      }
      \sstsubsection{
         MODE = INTEGER (Given)
      }{
         Determines the way in which the data points are represented:
             1 - A {\tt "}staircase{\tt "} histogram, in which each horizontal line is
                 centred on the X position.
             2 - The points are joined by straight lines.
             3 - A marker is placed at each point.
             4 - (not used)
             5 - A {\tt "}chain{\tt "} in which each point is marker by a marker and also
                 join by straight lines to its neighbouring points.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If .TRUE., then the user may supply a null (!) value for most of the
         parameters accessed by this routine to indicate that nothing is to
         be plotted. In this case, no error is returned. Otherwise, a
         PAR\_\_NULL error status is returned if a null value is supplied.
      }
      \sstsubsection{
         XL = REAL (Given)
      }{
         The default value for the XLEFT parameter. If VAL\_\_BADR is
         supplied, the minimum of the X values is used (plus a small
         margin).
      }
      \sstsubsection{
         XR = REAL (Given)
      }{
         The default value for the XRIGHT parameter. If VAL\_\_BADR is
         supplied, the maximum of the X values is used (plus a small
         margin).
      }
      \sstsubsection{
         YB = REAL (Given)
      }{
         The default value for the YBOT parameter. If VAL\_\_BADR is
         supplied, the minimum of the low end of the Y error bars is
         used (plus a small margin).
      }
      \sstsubsection{
         YT = REAL (Given)
      }{
         The default value for the YTOP parameter. If VAL\_\_BADR is
         supplied, the maximum of the high end of the Y error bars is
         used (plus a small margin).
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the application in the form {\tt "}$<$package$>$\_$<$application$>${\tt "}.
         E.g. {\tt "}KAPPA\_NORMALIZE{\tt "}.
      }
      \sstsubsection{
         QUIET = LOGICAL (Given)
      }{
         If .FALSE., a message is displayed indicating the number of
         points which were plotted. If .TRUE., nothing is displayed on
         the alpha screen.
      }
      \sstsubsection{
         LMODE = LOGICAL (Given)
      }{
         If .TRUE., then the user is given the chance to specify the
         default vertical bounds for the plot using parameter LMODE. If
         .FALSE., the supplied bounds (YB, YT ) are used, and the
         eqivalent of {\tt "}Extended{\tt "} LMODE is used for any bounds which are
         not supplied.
      }
      \sstsubsection{
         IPLOT = INTEGER (Given and Returned)
      }{
         On entry, this can either be AST\_NULL or a pointer to a 2D
         Frame. If AST\_\_NULL, the supplied values for the XLAB, YLAB,
         TTL, XSYM and YSYM arguments are used without change. If a Frame
         is supplied, the Label, Title, Units and Symbol attributes of
         the Frame are used in preference to XLAB, YLAB, TTL, XSYM and
         YSYM (which are then ignored). Any supplied Frame pointer is
         annulled before returning, and a pointer to the Plot used to
         draw the axes is returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If an error occurs, or if no graphics is produced because the
         user supplied a null value for a parameter, IPLOT is returned equal
         to AST\_\_NULL, and PGPLOT is shut down.
      }
   }
}
\sstroutine{
   KPG1\_GRLM1
}{
   Find the default limits for a graph axis
}{
   \sstdescription{
      This routine returns one or both default limits for a graph axis.
      Any limits which are supplied by the calling routine are used as
      supplied. The user is only allowed to over-ride limits which are
      supplied as VAL\_\_BADR. The way in which these limits are chosen is
      specified by the user through the parameter specified by PARAM.
      This parameter can take the following values:

      \sstitemlist{

         \sstitem
            {\tt "}Range{\tt "} -- LIM1 and LIM2 are returned equal to the lowest and
            highest supplied data values (including error bars).

         \sstitem
            {\tt "}Extended{\tt "} -- LIM1 and LIM2 are returned equal to the lowest and
            highest supplied data values (including error bars), extended to
            give a margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the second
            and third elements of the array. These values are percentages of
            the total data range. So, {\tt "}Extended,10,5{\tt "} includes a margin of 10\%
            of the total data range in LIM1, and 5\% in LIM2. If only one
            numerical value is given, the same value is used for both limits. If
            no value is given, both limits default to 2.5. {\tt "}Range{\tt "} is equivalent
            to {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the array
            are interpreted as percentiles. For instance, {\tt "}Perc,5,95{\tt "} causes 5\%
            of the data points (ignoring error bars) to be below LIM1, and 10\%
            to be above the LIM2. If only 1 value (p1) is supplied, the other
            one, p2, defaults to (100 - p1). If no values are supplied, p1 and
            p2 default to 5 and 95.

         \sstitem
            {\tt "}Sigma,2,3{\tt "} -- The second and third elements of the array are
            interpreted as multiples of the standard deviation of the data
            values (ignoring error bars). For instance, {\tt "}S,2,3{\tt "} causes the
            LIM1 to be the mean of the data values, minus two sigma, and LIM2
            to be the mean plus three sigma. If only 1 value is supplied, the
            same value is used for both limits. If no values are supplied, both
            values default to 3.0.

      }
      The above strings can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Extended{\tt "} is
      assumed (i.e. LIM1 and LIM2 are chosen so that the axis encompasses
      the entire data range including error bars, with 2.5\% margin at each
      end).

      If only 1 limit is required (i.e. if LIM1 or LIM2 are supplied not
      equal to VAL\_\_BADR), then only 1 numerical value can be supplied
      in the above limit descriptions.
   }
   \sstinvocation{
      CALL KPG1\_GRLM1( PARAM, N, D1, D2, NSIGMA, SIGMA, LIM1, LIM2,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         No. of points
      }
      \sstsubsection{
         D1( N ) = REAL (Given)
      }{
         The central data value at each point.
      }
      \sstsubsection{
         D2( N ) = REAL (Given)
      }{
         An associated mask array. D1( I ) is only used if both D1( I ) and
         D2( I ) are not equal to VAL\_\_BADR.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Controls the length of the error bars. The error bars are
         assumed to extended from D1( I ) - NSIGMA$*$SIGMA( I ) to
         D1( I ) $+$ NSIGMA$*$SIGMA( I ). A value of zero suppresses error
         bars.
      }
      \sstsubsection{
         SIGMA( N ) = REAL (Given)
      }{
         The standard deviation associated with each Y value. Not
         accessed if NSIGMA is zero.
      }
      \sstsubsection{
         LIM1 = REAL (Given and Returned)
      }{
         The chosen low data limit. Only returned if a value of VAL\_\_BADR
         is supplied, Otherwise, the supplied value is returned unchanged.
      }
      \sstsubsection{
         LIM2 = REAL (Given and Returned)
      }{
         The chosen high data limit. Only returned if a value of VAL\_\_BADR
         is supplied, Otherwise, the supplied value is returned unchanged.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GRLM2
}{
   Find the default limits for a graph axis
}{
   \sstdescription{
      This routine returns the default limits for a graph axis. The
      way in which the limits are chosen is specified by the user through
      the parameter specified by PARAM. This parameter can take the
      following values:

      \sstitemlist{

         \sstitem
            {\tt "}Range{\tt "} -- LIM1 and LIM2 are returned equal to the lowest and
            highest supplied data values (including error bars).

         \sstitem
            {\tt "}Extended{\tt "} -- LIM1 and LIM2 are returned equal to the lowest and
            highest supplied data values (including error bars), extended to
            give a margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the second
            and third elements of the array. These values are percentages of
            the total data range. So, {\tt "}Extended,10,5{\tt "} includes a margin of 10\%
            of the total data range in LIM1, and 5\% in LIM2. If only one
            numerical value is given, the same value is used for both limits. If
            no value is given, both limits default to 2.5. {\tt "}Range{\tt "} is equivalent
            to {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the array
            are interpreted as percentiles. For instance, {\tt "}Perc,5,95{\tt "} causes 5\%
            of the data points (ignoring error bars) to be below LIM1, and 10\%
            to be above the LIM2. If only 1 value (p1) is supplied, the other
            one, p2, defaults to (100 - p1). If no values are supplied, p1 and
            p2 default to 5 and 95.

         \sstitem
            {\tt "}Sigma,2,3{\tt "} -- The second and third elements of the array are
            interpreted as multiples of the standard deviation of the data
            values (ignoring error bars). For instance, {\tt "}S,2,3{\tt "} causes the
            LIM1 to be the mean of the data values, minus two sigma, and LIM2
            to be the mean plus three sigma. If only 1 value is supplied, the
            same value is used for both limits. If no values are supplied, both
            values default to 3.0.

      }
      The above strings can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Extended{\tt "} is
      assumed (i.e. LIM1 and LIM2 are chosen so that the axis encompasses
      the entire data range including error bars, with 2.5\% margin at each
      end).

      If only 1 limit is required (i.e. if LIM1 or LIM2 are supplied not
      equal to VAL\_\_BADD), then only 1 numerical value can be supplied
      in the above limit descriptions.
   }
   \sstinvocation{
      CALL KPG1\_GRLM2( PARAM, N, D1, D2, USEBAR, BAR, LIM1, LIM2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         No. of points
      }
      \sstsubsection{
         D1( N ) = DOUBLE PRECISION (Given)
      }{
         The central data value at each point.
      }
      \sstsubsection{
         D2( N ) = DOUBLE PRECISION (Given)
      }{
         An associated mask array. D1( I ) is only used if both D1( I ) and
         D2( I ) are not equal to VAL\_\_BADD.
      }
      \sstsubsection{
         USEBAR = LOGICAL (Given)
      }{
         Should BAR be used?
      }
      \sstsubsection{
         BAR( N,2 ) = DOUBLE PRECISION (Given)
      }{
         The upper and lower ends of each error bar. Assumed equal to D1
         if USEBAR is .FALSE. (i.e. no error bars).
      }
      \sstsubsection{
         LIM1 = DOUBLE PRECISION (Given and Returned)
      }{
         The chosen low data limit. Only returned if a value of VAL\_\_BADD
         is supplied, Otherwise, the supplied value is returned unchanged.
      }
      \sstsubsection{
         LIM2 = DOUBLE PRECISION (Given and Returned)
      }{
         The chosen high data limit. Only returned if a value of VAL\_\_BADD
         is supplied, Otherwise, the supplied value is returned unchanged.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GRLM3
}{
   Find the default limits for a graph axis
}{
   \sstdescription{
      This routine is exactly like KPG1\_GRLM2,except that it uses single
      precision data rather than double precision. Ideally, this should be
      handled using GENERIC, but this would involve renaming the long
      standing KPG1\_GRLM2 routine, which is not a good idea.

      It returns the default limits for a graph axis. The way in which the
      limits are chosen is specified by the user through the parameter
      specified by PARAM. This parameter can take the following values:

      \sstitemlist{

         \sstitem
            {\tt "}Range{\tt "} -- LIM1 and LIM2 are returned equal to the lowest and
            highest supplied data values (including error bars).

         \sstitem
            {\tt "}Extended{\tt "} -- LIM1 and LIM2 are returned equal to the lowest and
            highest supplied data values (including error bars), extended to
            give a margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the second
            and third elements of the array. These values are percentages of
            the total data range. So, {\tt "}Extended,10,5{\tt "} includes a margin of 10\%
            of the total data range in LIM1, and 5\% in LIM2. If only one
            numerical value is given, the same value is used for both limits. If
            no value is given, both limits default to 2.5. {\tt "}Range{\tt "} is equivalent
            to {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the array
            are interpreted as percentiles. For instance, {\tt "}Perc,5,95{\tt "} causes 5\%
            of the data points (ignoring error bars) to be below LIM1, and 10\%
            to be above the LIM2. If only 1 value (p1) is supplied, the other
            one, p2, defaults to (100 - p1). If no values are supplied, p1 and
            p2 default to 5 and 95.

         \sstitem
            {\tt "}Sigma,2,3{\tt "} -- The second and third elements of the array are
            interpreted as multiples of the standard deviation of the data
            values (ignoring error bars). For instance, {\tt "}S,2,3{\tt "} causes the
            LIM1 to be the mean of the data values, minus two sigma, and LIM2
            to be the mean plus three sigma. If only 1 value is supplied, the
            same value is used for both limits. If no values are supplied, both
            values default to 3.0.

      }
      The above strings can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Extended{\tt "} is
      assumed (i.e. LIM1 and LIM2 are chosen so that the axis encompasses
      the entire data range including error bars, with 2.5\% margin at each
      end).

      If only 1 limit is required (i.e. if LIM1 or LIM2 are supplied not
      equal to VAL\_\_BADR), then only 1 numerical value can be supplied
      in the above limit descriptions.
   }
   \sstinvocation{
      CALL KPG1\_GRLM3( PARAM, N, D1, D2, USEBAR, BAR, LIM1, LIM2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         No. of points
      }
      \sstsubsection{
         D1( N ) = REAL (Given)
      }{
         The central data value at each point.
      }
      \sstsubsection{
         D2( N ) = REAL (Given)
      }{
         An associated mask array. D1( I ) is only used if both D1( I ) and
         D2( I ) are not equal to VAL\_\_BADR.
      }
      \sstsubsection{
         USEBAR = LOGICAL (Given)
      }{
         Should BAR be used?
      }
      \sstsubsection{
         BAR( N,2 ) = REAL (Given)
      }{
         The upper and lower ends of each error bar. Assumed equal to D1
         if USEBAR is .FALSE. (i.e. no error bars).
      }
      \sstsubsection{
         LIM1 = REAL (Given and Returned)
      }{
         The chosen low data limit. Only returned if a value of VAL\_\_BADR
         is supplied, Otherwise, the supplied value is returned unchanged.
      }
      \sstsubsection{
         LIM2 = REAL (Given and Returned)
      }{
         The chosen high data limit. Only returned if a value of VAL\_\_BADR
         is supplied, Otherwise, the supplied value is returned unchanged.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GRPHW
}{
   Draws a line graph, using supplied work arrays
}{
   \sstdescription{
      Opens a graphics device and draws a graph displaying a supplied
      set of points. Each point is defined by an X and Y value, plus an
      optional error bar. An AST Plot is returned so that the calling
      application can add further graphics to the plot if needed. When
      complete, the calling application should annul the Plot, and close
      the workstation:

        CALL AST\_ANNUL( IPLOT, STATUS )
        CALL KPG\_PGCLS( {\tt '}DEVICE{\tt '}, .FALSE., STATUS )

      Various environment parameters are used to obtain options, etc.
      The names of these parameters are hard-wired into this subroutine
      in order to ensure conformity between applications.
   }
   \sstinvocation{
      CALL KPG1\_GRPHW( N, X, Y, NSIGMA, YSIGMA, XLAB, YLAB, TTL,
                       XSYM, YSYM, MODE, NULL, XL, XR, YB, YT, APP,
                       QUIET, LMODE, DX, DY, DBAR, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Nuumber of points
      }
      \sstsubsection{
         X( N ) = REAL (Given)
      }{
         X value at each point.
      }
      \sstsubsection{
         Y( N ) = REAL (Given)
      }{
         Y value at each point.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Controls the length of the vertical error bars. A value of zero
         suppresses error bars. Otherwise error bars are drawn that
         extend from Y - NSIGMA$*$YSIGMA to Y $+$ NSIGMA$*$YSIGMA.
      }
      \sstsubsection{
         YSIGMA( N ) = REAL (Given)
      }{
         The standard deviation associated with each Y value. Not
         accessed if NSIGMA is zero.
      }
      \sstsubsection{
         XLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default label for the X axis. Only used if the user does not
         supply an alternative. Trailing spaces are ignored. If a Plot
         is supplied via IPLOT, then the {\tt "}Label(1){\tt "} attribute in the
         Plot is used as the default in preference to XLAB.
      }
      \sstsubsection{
         YLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default label for the Y axis. Only used if the user does not
         supply an alternative. Trailing spaces are ignored. If a Plot
         is supplied via IPLOT, then the {\tt "}Label(2){\tt "} attribute in the
         Plot is used as the default in preference to YLAB.
      }
      \sstsubsection{
         TTL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default title for the plot. Only used if the user does not
         supply an alternative. If a Plot is supplied via IPLOT, then
         the {\tt "}Title{\tt "} attribute in the Plot is used as the default in
         preference to TTL.
      }
      \sstsubsection{
         XSYM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The default symbol for the horizontal axis. Only used if the
         user does not supply an alternative. This will be stored with
         the Plot in the AGI database and (for instance) used by
         KAPPA:CURSOR as axis symbols when displaying the cursor
         positions on the screen. If a Plot is supplied via IPLOT, then
         the {\tt "}Symbol(1){\tt "} attribute in the Plot is used as the default
         in preference to XSYM.
      }
      \sstsubsection{
         YSYM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The default symbol for the horizontal axis. Only used if the
         user does not supply an alternative. This will be stored with
         the Plot in the AGI database and (for instance) used by
         KAPPA:CURSOR as axis symbols when displaying the cursor
         positions on the screen. If a Plot is supplied via IPLOT, then
         the {\tt "}Symbol(2){\tt "} attribute in the Plot is used as the default
         in preference to YSYM.
      }
      \sstsubsection{
         MODE = INTEGER (Given)
      }{
         Determines the way in which the data points are represented.
            1 -- A {\tt "}staircase{\tt "} histogram, in which each horizontal line
                 is centred on the X position.
            2 -- The points are joined by straight lines.
            3 -- A marker is placed at each point.
            4 -- (not used)
            5 -- A {\tt "}chain{\tt "} in which each point is indicated by a marker
                 and also join by straight lines to its neighbouring
                 points.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If .TRUE., then the user may supply a null (!) value for most
         of the parameters accessed by this routine to indicate that
         nothing is to be plotted. In this case, no error is returned.
         Otherwise, a PAR\_\_NULL error status is returned if a null
         value is supplied.
      }
      \sstsubsection{
         XL = REAL (Given)
      }{
         The default value for the XLEFT parameter. If VAL\_\_BADR is
         supplied, the minimum of the X values is used (plus a small
         margin).
      }
      \sstsubsection{
         XR = REAL (Given)
      }{
         The default value for the XRIGHT parameter. If VAL\_\_BADR is
         supplied, the maximum of the X values is used (plus a small
         margin).
      }
      \sstsubsection{
         YB = REAL (Given)
      }{
         The default value for the YBOT parameter. If VAL\_\_BADR is
         supplied, the minimum of the low end of the Y error bars is
         used (plus a small margin).
      }
      \sstsubsection{
         YT = REAL (Given)
      }{
         The default value for the YTOP parameter. If VAL\_\_BADR is
         supplied, the maximum of the high end of the Y error bars is
         used (plus a small margin).
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the application in the form
         {\tt "}$<$package$>$\_$<$application$>${\tt "}, for instance {\tt "}KAPPA\_NORMALIZE{\tt "}.
      }
      \sstsubsection{
         QUIET = LOGICAL (Given)
      }{
         If .FALSE., a message is displayed indicating the number of
         points which were plotted. If .TRUE., nothing is displayed on
         the alpha screen.
      }
      \sstsubsection{
         LMODE = LOGICAL (Given)
      }{
         If .TRUE., then the user is given the chance to specify the
         default vertical bounds for the plot using parameter LMODE. If
         .FALSE., the supplied bounds (YB, YT ) are used, and the
         equivalent of {\tt "}Extended{\tt "} LMODE is used for any bounds that are
         not supplied.
      }
      \sstsubsection{
         DX( N ) = DOUBLE PRECISION (Given and Returned)
      }{
         Work space.
      }
      \sstsubsection{
         DY( N ) = DOUBLE PRECISION (Given and Returned)
      }{
         Work space.
      }
      \sstsubsection{
         DBAR( N, 2 ) = DOUBLE PRECISION (Given and Returned)
      }{
         Work space. Not accessed if NSIGMA is zero.
      }
      \sstsubsection{
         IPLOT = INTEGER (Given and Returned)
      }{
         On entry, this can either be AST\_NULL or a pointer to a 2D
         Frame. If AST\_\_NULL, the supplied values for the XLAB, YLAB,
         TTL, XSYM and YSYM arguments are used without change. If a
         Frame is supplied, the Label, Title, Units and Symbol
         attributes of the Frame are used in preference to XLAB, YLAB,
         TTL, XSYM and YSYM (which are then ignored). Any supplied
         Frame pointer is annulled before returning, and a pointer to
         the Plot used to draw the axes is returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If an error occurs, or if no graphics is produced because the
         user supplied a null value for a parameter, IPLOT is returned
         equal to AST\_\_NULL, and PGPLOT is shut down.
      }
   }
   \sstdiylist{
      Environment Parameters
   }{
      \sstsubsection{
         AXES = \_LOGICAL (Read)
      }{
         TRUE if annotated axes are to be produced.
      }
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         TRUE if the graphics device is to be cleared on opening.
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device.
      }
      \sstsubsection{
         LMODE = LITERAL (Read)
      }{
         If the subroutine argument LMODE is .TRUE., then parameter
         LMODE is used to specify how the default values for YBOT and
         YTOP are found. If argument LMODE is .FALSE. then {\tt "}Extended{\tt "}
         mode is always used. This parameter can take the following
         values:

         \sstitemlist{

            \sstitem
            {\tt "}Range{\tt "} -- The lowest and highest supplied data values are
            used (including error bars).

            \sstitem
            {\tt "}Extended{\tt "} -- The lowest and highest supplied data values
            are used (including error bars), extended to give a margin
            of 2.5\% of the total data range at each end.

            \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at
            the two ends are specified as a pair of numerical value in
            the second and third elements of the array. These values are
            percentages of the total data range. So, {\tt "}Extended,10,5{\tt "}
            includes a margin of 10\% of the total data range in YBOT,
            and 5\% in YTOP. If only one numerical value is given, the
            same value is used for both limits. If no value is given,
            both limits default to 2.5. {\tt "}Range{\tt "} is equivalent to
            {\tt "}Extended,0,0{\tt "}.

            \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the
            array are interpreted as percentiles. For instance,
            {\tt "}Perc,5,95{\tt "} causes 5\% of the data points (ignoring error
            bars) to be below YBOT, and 10\% to be above the YTOP. If
            only one value (p1) is supplied, the other one, p2, defaults
            to (100 - p1). If no values are supplied, p1 and p2 default
            to 5 and 95.

            \sstitem
            {\tt "}Sigma,2,3{\tt "} -- The second and third elements of the array
            are interpreted as multiples of the standard deviation of
            the data values (ignoring error bars). For instance, {\tt "}S,2,3{\tt "}
            causes the YBOT to be the mean of the data values, minus two
            sigma, and YTOP to be the mean plus three sigma. If only one
            value is supplied, the same value is used for both limits.
            If no values are supplied, both values default to 3.0.

         }
         The above strings can be abbreviated to one character.
      }
      \sstsubsection{
         MARGIN( 4 ) = \_REAL (Read)
      }{
         The widths of the margins to leave for axis annotation,
         given as fractions of the corresponding dimension of the
         current picture. Four values may be given in the order
         bottom, right, top, left.  If fewer than four values are
         given, extra values are used equal to the first supplied
         value. If these margins are too narrow any axis
         annotation may be clipped. The dynamic default is 0.15 (for
         all edges) if either annotated axes or a key are produced,
         and zero otherwise.
      }
      \sstsubsection{
         MARKER = \_INTEGER (Read)
      }{
         The PGPLOT marker type to use. Only accessed if MODE is 3 or
         5.
      }
      \sstsubsection{
         STYLE = GROUP (Read)
      }{
         A description of the plotting style required. The following
         synonyms for graphical elements may be used.

         \sstitemlist{

            \sstitem
            {\tt "}Err(Bars){\tt "} -- Specifies colour, etc. for error bars.
            Size(errbars) scales the size of the serifs (i.e. a size
            value of 1.0 produces a default size).

            \sstitem
            {\tt "}Sym(bols){\tt "} -- Specifies colour, etc. for markers (used
            in Modes 3 and 5).

            \sstitem
            {\tt "}Lin(es){\tt "} -- Specifies colour, etc. for lines (used in
            Modes 1, 2, and 5).
         }
      }
      \sstsubsection{
         TEMPSTYLE = GROUP (Read)
      }{
         A description of plotting style required in addition to that
         define by STYLE.  See STYLE for allowed synonyms.  Unlike
         STYLE its values are not persistent between invocations.
      }
      \sstsubsection{
         XLEFT = \_REAL (Read)
      }{
         The axis value to place at the left-hand end of the
         horizontal axis. The dynamic default is specified by
         argument XL. The value supplied may be greater than or less
         than the value supplied for XRIGHT.
      }
      \sstsubsection{
         XRIGHT = \_REAL (Read)
      }{
         The axis value to place at the right-hand end of the
         horizontal axis. The dynamic default is specified by
         argument XR. The value supplied may be greater than or less
         than the value supplied for XLEFT.
      }
      \sstsubsection{
         YBOT = \_REAL (Read)
      }{
         The axis value to place at the bottom end of the vertical
         axis. The dynamic default is specified by argument YB. The
         value supplied may be greater than or less than the value
         supplied for YTOP.
      }
      \sstsubsection{
         YTOP = \_REAL (Read)
      }{
         The axis value to place at the top end of the vertical axis.
         The dynamic default is specified by argument YT. The value
         supplied may be greater than or less than the value supplied
         for YBOT.
      }
   }
}
\sstroutine{
   KPG1\_GTAXI
}{
   Select Frame axes using an environment parameter
}{
   \sstdescription{
      This routine returns the indices of selected axes in a supplied
      Frame. The axes to select are determined using the supplied
      environment parameter. Each axis can be specified either by giving
      its index within the Frame in the range 1 to the number of axes in
      the Frame, or by giving its symbol. Spectral, time and celestial
      longitude/latitude axes may also be specified using the options {\tt "}SPEC{\tt "},
      {\tt "}TIME{\tt "}, {\tt "}SKYLON{\tt "} and {\tt "}SKYLAT{\tt "}. If the first value supplied in
      AXES is not zero, the supplied axes are used as the dynamic default
      for the parameter. The parameter value should be given as a GRP group
      expression, with default GRP control characters.
   }
   \sstinvocation{
      CALL KPG1\_GTAXI( PARAM, FRAME, NAX, AXES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         An AST pointer for the Frame from which axes may be chosen.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes which must be selected.
      }
      \sstsubsection{
         AXES( NAX ) = INTEGER (Given and Returned)
      }{
         On entry, the axes to be specified as the dynamic default for the
         parameter (if AXES( 1 ) is not zero). On exit, the indices of the
         selected axes. If AXES(1) is zero the supplied values are ignored
         and a PAR\_\_NULL status value is returned if a null (!) value is
         supplied for the parameter. Otherwise, the PAR\_NULL status is
         annulled if a null value is supplied, and the supplied axes are
         returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Case is insignificant when comparing supplied strings with
         available axis symbols.
      }
   }
}
\sstroutine{
   KPG1\_GTAXI
}{
   Selects Frame axes using an environment parameter
}{
   \sstdescription{
      This routine returns the indices of selected axes in a supplied
      Frame.  The axes to select are determined using the supplied
      environment parameter.  Each axis can be specified either by
      giving its index within the Frame in the range 1 to the number of
      axes in the Frame, or by giving its symbol.  Spectral, time and
      celestial longitude/latitude axes may also be specified using the
      options {\tt "}SPEC{\tt "}, {\tt "}TIME{\tt "}, {\tt "}SKYLON{\tt "} and {\tt "}SKYLAT{\tt "}.  If the first value
      supplied in AXES is not zero, the supplied axes are used as the
      dynamic default for the parameter.  The parameter value should be
      given as a GRP group expression, with default GRP control
      characters.
   }
   \sstinvocation{
      CALL KPG1\_GTAXM( PARAM, FRAME, MAXAX, AXES, NAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         An AST pointer for the Frame from which axes may be chosen.
      }
      \sstsubsection{
         MAXAX = INTEGER (Given)
      }{
         The maximum number of axes that can be be selected.
      }
      \sstsubsection{
         AXES( NAX ) = INTEGER (Given and Returned)
      }{
         On entry, the axes to be specified as the dynamic default for
         the parameter (if AXES( 1 ) is not zero).  On exit, it holds
         the indices of the selected axes.  If AXES(1) is zero the
         supplied values are ignored and a PAR\_\_NULL status value is
         returned if a null (!) value is supplied for the parameter.
         Otherwise, the PAR\_NULL status is annulled if a null value is
         supplied, and the supplied axes are returned.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes actually selected.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Case is insignificant when comparing supplied strings with
         available axis symbols.
      }
   }
}
\sstroutine{
   KPG1\_GTAXV
}{
   Gets one or more formatted axis values from the environment
}{
   \sstdescription{
      This routine obtains one or more formatted values for a specified axis
      from the environment, using a specified parameter.

      If the string supplied for the parameter consists of a single colon,
      then a description of the Current co-ordinate Frame is displayed,
      together with an indication of the format required for each axis
      value, and a new parameter value is then obtained.
   }
   \sstinvocation{
      CALL KPG1\_GTAXV( PARAM, MXVAL, EXACT, FRAME, IAXIS, AXVAL, NVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         MXVAL = INTEGER (Given)
      }{
         The maximum number of values which can be supplied. It is not an
         error for less than MXVAL to be supplied. Must be no more than 20.
      }
      \sstsubsection{
         EXACT = LOGICAL( Given)
      }{
         If .TRUE., then the user must supply exactly MXVAL values, and
         he is reprompted if less than MXVAL are given. If .FALSE. then
         the user can give between 1 and MXVAL values.
      }
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         A pointer to an AST Frame in which the axis lives.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         The index of the axis within the Frame for which a value is required.
      }
      \sstsubsection{
         AXVAL( MXVAL ) = DOUBLE PRECISION (Given and Returned)
      }{
         On entry, holds the axis values to use as the dynamic default for the
         parameter. On exit, holds the supplied axis value. No dynamic
         default is used if any of the supplied values is AST\_\_BAD.
      }
      \sstsubsection{
         NVAL = INTEGER (Returned)
      }{
         The number of values obtained using the parameter and returned in
         AXVAL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a null (!) parameter value is supplied, the supplied value of
         AXVAL is returned, and the error is annulled if the AXVAL value is
         not equal to AST\_\_BAD.

         \sstitem
         AXVAL is left unchanged if an error has already occurred.

         \sstitem
         AST\_\_BAD is returned in AXVAL if an error occurs during this routine.
      }
   }
}
\sstroutine{
   KPG1\_GTCHV
}{
   Obtain a vector of choices from the environment
}{
   \sstdescription{
      This routine gets NVAL strings from the user, selected from those
      supplied in OPTS. The indices of the supplied strings within OPTS
      are returned. The user supplies the strings in the form of a GRP
      group expression, using the default GRP control characters.

      The user may supply an integer value instead of a string, in which
      case the integer is understood to be the index of the required string
      within OPTS. If the supplied list of strings contains the integer
      itself, then the integer is understood to be a string, not an index.
   }
   \sstinvocation{
      CALL KPG1\_GTCHV( NOPT, OPTS, PARAM, NVAL, IDEF, VALS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NOPT = INTEGER (Given)
      }{
         The number of available options supplied in OPTS.
      }
      \sstsubsection{
         OPTS( NOPT ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         An array holding the options from which the user must choose.
         Leading and trailing white space is ignored. Blank options are
         not allowed.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The number of choices required. The user must supply exactly
         this number of choices.
      }
      \sstsubsection{
         IDEF( NVAL ) = INTEGER (Given)
      }{
         The indices within OPTS of the default strings to use if a null (!)
         value is supplied for the parameter. If the first value is zero,
         a null parameter value results in a PAR\_\_NULL status being returned.
      }
      \sstsubsection{
         VALS( NVAL ) = INTEGER (Returned)
      }{
         The indices within OPTS of the selected options.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Case is insignificant when comparing supplied strings with
         available options.

         \sstitem
         A dynamic default is set for the parameter before accessing it if
         IDEF supplied suitable defaults. The default consists of a
         comma-separated list of the default options.
      }
   }
}
\sstroutine{
   KPG1\_GTGRP
}{
   Obtain a group of strings from the environment
}{
   \sstdescription{
      This routine obtains  group of strings using the specified
      parameter, and returns them in a GRP group (see SUN/150).

      The user specifies the strings by supplying a GRP group expression
      for the parameter value. If the final character in the supplied
      string is the group {\tt "}flag character{\tt "} (a minus sign by default), then
      the user is re-prompted for another group expression, and the strings
      specified by the second group expression are appended to the
      returned group. This continues until a group expression is supplied
      which does not end with the continuation character, or a null value is
      supplied (which is annulled).

      Normally, the {\tt "}current value{\tt "} for the parameter on exit would be
      the final group expression. If more than one group expression was
      supplied, then this will not represent the entire group. For this
      reason, this routine concatenates all the group expressions supplied,
      and stores the total group expression as the parameter value before
      exiting. Since a new value is stored for the parameter, the parameter
      should ne be given an access mode of READ in the interface file.

      If a null value is supplied the first time the parameter value is
      obtained, then the PAR\_\_NULL status is returned, and SIZE is returned
      as zero (a valid GRP identifier is still returned however). If a null
      value is supplied on a subsequent access to the parameter, then the
      PAR\_\_NULL status is annulled, and the group is returned containing
      any values obtained earlier.
   }
   \sstinvocation{
      CALL KPG1\_GTGRP( PARAM, IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The group to use. If this is GRP\_\_NOID then a new group is
         created with default control characters and its identifier is
         returned. If the group already exists, its contents are discarded
         before adding new strings.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total size of the returned group. Returned equal to zero if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GTMOR
}{
   Create an HDS structure holding a user-supplied set of keyword=value
   strings
}{
   \sstdescription{
      This routine returns a locator for a temporary HDS structure that
      holds a set of keyword values obtained from the environment.
   }
   \sstinvocation{
      CALL KPG1\_GTMOR( PARAM, MORE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the environment parameter to use. The parameter is
         accessed as a group of text strings, using GRP. Each string
         should be of the form {\tt "}keyword=value{\tt "}. The keyword can be a
         single name or a dot-delimited heirarchy. The returned HDS
         object will contain a sinmilar heiracrhy.
      }
      \sstsubsection{
         MORE = CHARACTER $*$ (DAT\_\_SZLOC) (Returned)
      }{
         A locator for the returned temporary HDS object. It will be a
         scalar structure with HDS type of {\tt "}KPG1\_GTMOR\_TYPE{\tt "}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GTNDF
}{
   Gets an NDF or NDF section with a specified number of significant
   dimensions
}{
   \sstdescription{
      The supplied parameter name is associated with an NDF through the
      environment, and an identifier is obtained for the NDF using the
      specified access mode.  Each axis of the NDF is checked to see if
      is significant (i.e. has a size greater than 1).  The index of
      each significant axis is returned in SDIM, and the bounds of the
      axis are returned in SLBND and SUBND.  If EXACT is .TRUE., an
      error is reported if the number of significant axes is not
      exactly NDIM.  If EXACT is .FALSE. an error is only reported if
      the number of significant dimensions is higher than NDIM.  If
      there are less than NDIM significant dimensions then the
      insignificant dimensions are used (starting from the lowest) to
      ensure that the required number of dimensions are returned.
   }
   \sstinvocation{
      CALL KPG1\_GTNDF( PARAM, NDIM, EXACT, MODE, INDF, SDIM, SLBND,
                       SUBND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions required.
      }
      \sstsubsection{
         EXACT = LOGICAL (Given)
      }{
         This should be supplied .FALSE. if an NDF with less than NDIM
         significant dimensions can be used.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The access mode required for the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         An identifier for the NDF.
      }
      \sstsubsection{
         SDIM( NDIM ) = INTEGER (Returned)
      }{
         The indices of the significant dimensions.
      }
      \sstsubsection{
         SLBND( NDIM ) = INTEGER (Returned)
      }{
         The lower bounds of the significant dimensions.  These are
         stored in the same order as the indices in SDIM.
      }
      \sstsubsection{
         SUBND( NDIM ) = INTEGER (Returned)
      }{
         The upper bounds of the significant dimensions.  These are
         stored in the same order as the indices in SDIM.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GTOBJ
}{
   Gets an AST Object using an environment parameter
}{
   \sstdescription{
      Gets an AST Object from an NDF, FITS file, HDS path or text file
      using an environment parameter.

      First, attempt to interpret the parameter value as an HDS path. The
      HDS object must have a type of WCS, must be scalar, and must contain
      a single 1-D array component with name DATA and type \_CHAR. This is
      the scheme used for HDS structures created by KPG1\_WWRT.

      If the above attempt fails, attempt to interpret the parameter
      value as an NDF name. If the NDF is opened succesfully, its WCS
      FrameSet is returned.

      If the above attempt fails, and the parameter value ends with
      {\tt "}.FIT{\tt "}, attempt to interpret the parameter value as the name of a
      FITS file. Open the FITS file and attempt to obtained an AST
      FrameSet from the primary HDU headers.

      If the above attempt fails, attempt to interpret the parameter
      value as the name of a text file containing either an AST object
      dump, or a set of FITS headers.
   }
   \sstinvocation{
      CALL KPG1\_GTOBJ( PARAM, CLASS, ISA, IAST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name.
      }
      \sstsubsection{
         CLASS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The required class. Used in error reports (see ISA). If Objects
         of more than 1 class can be used, this should be supplied blank, and
         the calling routine should verify that the Object is usable.
      }
      \sstsubsection{
         ISA = EXTERNAL (Given)
      }{
         A suitable AST {\tt "}ISA..{\tt "} function which returns .TRUE. if an Object
         is of a suitable class. This is ignored if CLASS is blank.
         Otherwise, an error is reported if th supplied Object is not of the
         required class.
      }
      \sstsubsection{
         IAST = INTEGER (Returned)
      }{
         The AST Object, or AST\_\_NULL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GTPLR
}{
   Gets a spatial position from the environment as polar co-ordinates
}{
   \sstdescription{
      This routine obtains a two-dimensional spatial position from the
      environment, using a specified parameter.  The user supplies the
      position in polar co-ordinates about a supplied centre within the
      co-ordinate system of the Current Frame in the supplied WCS
      FrameSet.  This FrameSet must have two axes, otherwise the routine
      will exit with an error.

      To be acceptable, the supplied position must correspond to a valid
      position (on both axes) in the Base Frame of the supplied FrameSet.
      If a Frame is supplied instead of a FrameSet this restriction is
      not imposed, however polar co-ordinates cannot be supplied,
      only regular co-ordinates along both axes.

      If the polar position supplied in argument CC on entry is valid
      (i.e. does not contain any AST\_\_BAD values), then it is used as a
      dynamic default for the parameter.  Otherwise, no dynamic default
      is used.

      The parameter is accessed as a single literal string containing a
      space- or comma-separated list of radius and position-angle
      values.  For SkyFrames the position angle is measured in degrees
      from North via East; for other Frames, it is anticlockwise from
      the origin defined by argument PAORIG.  The allowed formats for
      the co-ordinates depends on the class of the Current Frame in the
      supplied FrameSet, and are described in SUN/210.

      If the string supplied for the parameter consists of a single
      colon, then a description of the Current co-ordinate Frame is
      displayed, together with an indication of the format required for
      each axis value, and a new parameter value is then obtained.
   }
   \sstinvocation{
      CALL KPG1\_GTPLR( PARAM, IWCS, NULL, POLE, PAORIG, CC, BC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         A pointer to an AST FrameSet.  If a pointer to a Frame is
         supplied instead the routine will issue a warning that it is
         unable to handle polar co-ordinates and will expect spatial
         positions like routine KPG1\_GTPOS.  This can be aborted (!!) at
         the parameter prompt.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If TRUE, a null (!) parameter value will result in the dynamic
         default value being used. If FALSE (or if there is no dynamic
         default), a null parameter value will result in a PAR\_\_NULL
         error status.
      }
      \sstsubsection{
         PAORIG = DOUBLE PRECISION (Given)
      }{
         This applies when the current Frame is not a SkyFrame.  It
         specifies the origin for the position angle in degrees from
         the the first WCS axis.  The normal convention is for this to
         be zero (i.e. from X in a Cartesian co-ordinate system) but
         another may be 90 for starting from up or Y.
      }
      \sstsubsection{
         POLE( 2 )  = DOUBLE PRECISION (Given)
      }{
         The position of the pole of the polar co-ordinates measured
         in the current co-ordinate Frame along each axis.  If any of
         the co-ordinates are bad, the routine will issue a warning that
         it is unable to handle polar co-ordinates and will expect two
         spatial positions like routine KPG1\_GTPOS.  This can be aborted
         (!!) at the parameter prompt.
      }
      \sstsubsection{
         CC( 2 ) = DOUBLE PRECISION (Given and Returned)
      }{
         On entry, holds the position to use as the dynamic default for
         the parameter, in the Current Frame of the supplied FrameSet
         (or Frame).  On exit, it holds the supplied position in the
         Current Frame.  There should be one element for both axes.
      }
      \sstsubsection{
         BC( 2 ) = DOUBLE PRECISION (Returned)
      }{
         Returned holding the Base Frame position corresponding to the
         supplied Current Frame position.  If a Frame is supplied for
         IWCS instead of a FrameSet, then BC will not be accessed.  The
         returned values will be good on both axes.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         CC and BC are left unchanged if an error has already occurred.

         \sstitem
         Values of AST\_\_BAD are returned in CC (and optionally BC) if an
         error occurs during this routine.
      }
   }
}
\sstroutine{
   KPG1\_GTPOS
}{
   Get a spatial position from the environment
}{
   \sstdescription{
      This routine obtains a spatial position from the environment, using
      a specified parameter. The user supplies the position in the
      co-ordinate system of the Current Frame in the supplied WCS FrameSet.
      To be acceptable, the supplied position must correspond to a valid
      position (on all axes) in the Base Frame of the supplied FrameSet. If
      a Frame is supplied instead of a FrameSet this restriction is not
      imposed.

      If the position supplied in argument CC on entry is valid (i.e. does
      not contain any AST\_\_BAD values) then it is used as a dynamic
      default for the parameter. Otherwise, no dynamic default is used.

      The parameter is accessed as a single literal string containing a
      space or comma separated list of axis values. The allowed formats for
      the axis values depends on the class of the Current Frame in the
      supplied FrameSet, and are described in SUN/210.

      If the string supplied for the parameter consists of a single colon,
      then a description of the Current co-ordinate Frame is displayed,
      together with an indication of the format required for each axis
      value, and a new parameter value is then obtained.
   }
   \sstinvocation{
      CALL KPG1\_GTPOS( PARAM, IWCS, NULL, CC, BC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         A pointer to an AST Frame or FrameSet.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If TRUE, a null (!) parameter value will result in the dynamic
         default value being used. If FALSE (or if there is no dynamic
         default), a null parameter value will result in a PAR\_\_NULL error
         status.
      }
      \sstsubsection{
         CC( $*$ ) = DOUBLE PRECISION (Given and Returned)
      }{
         On entry, holds the position to use as the dynamic default for the
         parameter, in the Current Frame of the supplied FrameSet (or
         Frame). On exit, holds the supplied position in the Current Frame.
         There should be one element for each axis in the Current Frame.
      }
      \sstsubsection{
         BC( $*$ ) = DOUBLE PRECISION (Returned)
      }{
         Returned holding the Base Frame position corresponding to the
         supplied Current Frame position. If a Frame is supplied for IWCS
         instead of a FrameSet, then BC will not be accessed. The returned
         values will be good on all axes.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         CC and BC are left unchanged if an error has already occurred.

         \sstitem
         Values of AST\_\_BAD are returned in CC (and optionally BC) if an
         error occurs during this routine.
      }
   }
}
\sstroutine{
   KPG1\_GTWCS
}{
   Get an AST FrameSet from an NDF
}{
   \sstdescription{
      This routine returns a FrameSet describing the WCS information
      in an NDF. If the NDF has no WCS component, any IRAS90 IRA
      structure is converted into a FrameSet and returned. If the NDF has
      no IRAS90 IRA structure, then an attempt is made to read a FrameSet
      from the FITS headers in the FITS extension. If the NDF has no FITS
      extension, then the default NDF FrameSet is returned.
   }
   \sstinvocation{
      CALL KPG1\_GTWCS( INDF, IWCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier for the NDF.
      }
      \sstsubsection{
         IWCS = INTEGER (Returned)
      }{
         An AST pointer to the WCS FrameSet. Returned equal to AST\_\_NULL
         if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a WCS FrameSet is created form an IRAS90 astrometry structure or
         a FITS extension, it will be stored in the supplied NDF if write
         access is available for the NDF.

         \sstitem
         The preferred AST encodings to use when interpreting FITS headers
         can be specified as a comma-delimited string using environment
         variable KAPPA\_ENCODINGS. If this variable is not defined, then the
         normal default encodings are used (see FITSDIN).
      }
   }
}
\sstroutine{
   KPG1\_H2AST
}{
   Copy AST\_ data from an HDS object
}{
   \sstdescription{
      This routine copies a line of text representing AST\_ data from a
      specified element of a 1-dimensional character array. It is
      intended for use when reading AST\_ data from an HDS object (i.e
      an HDS \_CHAR array).
   }
   \sstinvocation{
      CALL KPG1\_H2AST( DATA, ILINE, LINE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( $*$ ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The character array from which the text is to be copied.
      }
      \sstsubsection{
         ILINE = INTEGER (Given)
      }{
         The index of the element in DATA which is to provide the text
         (the contents of other elements are ignored).
      }
      \sstsubsection{
         LINE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The line of text obtained.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_HMSG
}{
   Assign the name of an HDS object to a message token
}{
   \sstdescription{
      The routine assigns the full name (including the file name) of an
      HDS object to a message token for use with the ERR\_ and MSG\_
      routines (SUN/104). Appropriate syntax is used to represent file
      names which do not have the standard (.SDF) file type.
   }
   \sstinvocation{
      CALL KPG1\_HMSG( TOKEN, LOC )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the message token.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Locator to the HDS object.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine has no STATUS argument and does not perform
         normal error checking. If it should fail, then no value will be
         assigned to the message token and this will be apparent in the
         final message.
      }
   }
   \sstdiytopic{
      VAX-specific features used
   }{
      \sstitemlist{

         \sstitem
         This routine makes assumptions about the form of a VMS file
         name.
      }
   }
}
\sstroutine{
   KPG1\_HRCPx
}{
   Finds the reciprocal of a purely real Hermitian image
}{
   \sstdescription{
      This routine replaces the supplied Hermitian image with one in
      which the real terms have been inverted (i.e. replaced by their
      reciprocal) and the imaginary terms have been set to zero.

      To form 1/H where H is a general complex Hermitian image, the
      numerator and denominator are both multiplied by the complex
      conjugate of H ({\tt "}H$*${\tt "}).  The denominator then becomes purely real
      and equal to the modulus squared of H.  The reciprocal of the
      denominator is then taken using this routine and the resulting
      array is multiplied by H$*$.  Thus the steps are:

      1) Call KPG1\_HCONx to form H$*$, the complex conjugate of H.
      2) Call KPG1\_HMLTx to multiply H by H$*$.  This gives a purely real
         image holding the squared modulus of H.
      3) Call KPG1\_HRCPx to take the reciprocal of H.H$*$.
      4) Call KPG1\_HMLTx to multiply the reciprocal of H.H$*$ by H$*$.
   }
   \sstinvocation{
      CALL KPG1\_HRCPx( M, N, BADVAL, D, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         The number of columns in the Hermitian image D.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of lines in the Hermitian image D.
      }
      \sstsubsection{
         BADVAL = ? (Given)
      }{
         A value to return instead of the reciprocal of the real term,
         if any real term is zero.
      }
      \sstsubsection{
         D( M, N ) = ? (Given and Returned)
      }{
         On entry, a purely real Hermitian image.  On exit, an
         Hermitian image representing the reciprocal of the supplied
         image (also purely real).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the double precision and real data
         types: replace {\tt "}x{\tt "} in the routine names by D or R as appropriate.
         The BADVAL and D arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_HSSTP
}{
   Calculates statistics from an histogram
}{
   \sstdescription{
      This routine calculates certain statistical parameters for
      an histogram.  The median is derived by linear interpolation
      within an histogram bin. The mode is estimated from 3$*$median -
      2$*$mean, which is only valid for moderately skew distributions.
   }
   \sstinvocation{
      CALL KPG1\_HSSTP( NUMBIN, HIST, VALMAX, VALMIN, SUM, MEAN,
                       MEDIAN, MODE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins in the histogram.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Given)
      }{
         The histogram whose statistics are to be derived.
      }
      \sstsubsection{
         VALMAX = DOUBLE PRECISION (Given)
      }{
         Maximum data value included in the histogram.
      }
      \sstsubsection{
         VALMIN = DOUBLE PRECISION (Given)
      }{
         Minimum data value included in the histogram.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of all values in the histogram.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the histogram.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         Median of the histogram.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Returned)
      }{
         Mode of the histogram.  The bad value (VAL\_\_BADD) is returned
         if the calculated mode lies outside the data range of the
         histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstdiytopic{
      References
   }{
      Moroney, M.J., 1957, {\tt "}Facts from Figures{\tt "} (Pelican)
      Goad, L.E. 1980, in {\tt "}Applications of Digital Image Processing to
        Astronomy{\tt "}, SPIE 264, 139.
   }
}
\sstroutine{
   KPG1\_HSTLO
}{
   Computes the values to display for a histogram
}{
   \sstdescription{
      This routine find the set of (X,Y) values representing the centre
      of each bin in a given histogram. The logarithm of the supplied
      values are used if logarithmic axes are requested. In this case,
      zero or negative values result in VAL\_\_BADR values being returned.
   }
   \sstinvocation{
      CALL KPG1\_HSTLO( NHIST, HIST, HMIN, HMAX, XLOG, YLOG,
                       XLOC, YLOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NHIST = INTEGER (Given)
      }{
         The number of bins in the histogram.
      }
      \sstsubsection{
         HIST( NHIST ) = INTEGER (Given)
      }{
         The histogram whose locus is to be found.
      }
      \sstsubsection{
         HMIN = REAL (Given)
      }{
         The minimum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         HMAX = REAL (Given)
      }{
         The maximum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         XLOG = LOGICAL (Given)
      }{
         If .TRUE., logarithmic value are returned for the X axis.
      }
      \sstsubsection{
         YLOG = LOGICAL (Given)
      }{
         If .TRUE., logarithmic value are returned for the Y axis.
      }
      \sstsubsection{
         XLOC( NHIST ) = REAL( WRITE )
      }{
         Work array for the x locus of the histogram.
      }
      \sstsubsection{
         YLOC( NHIST ) = REAL( WRITE )
      }{
         Work array for the y locus of the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         This is the status value on entry to this subroutine.
      }
   }
}
\sstroutine{
   KPG1\_IMPRG
}{
   Propagates NDF information for IMAGE-format applications
}{
   \sstdescription{
      Until the NDF access routines are fully implemented in KAPPA,
      this routine provides a means by which KAPPA applications using
      the IMAGE data format may correctly propagate an input NDF.  Thus
      a pre-V1.0 KAPPA application will behave like a post-V1.0 one
      that only works on primitive DATA\_ARRAYs, and does not process
      VARIANCE, QUALITY, or HISTORY.

      See SGP/38 for more details of the NDF and its propagation rules.
   }
   \sstinvocation{
      CALL KPG1\_IMPRG( INLOC, CLIST, OUTLOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INLOC = CHARACTER $*$ ( $*$ ) (Read)
      }{
         Locator to the input NDF.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Read)
      }{
         A comma-separated list of the NDF components which are to be
         propagated from the input to the output NDF.  By default,
         HISTORY, LABEL and all extensions are propagated.  See below
         for further details.
      }
      \sstsubsection{
         OUTLOC = CHARACTER $*$ ( $*$ ) (Read)
      }{
         Locator to the output NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Component Propagation
   }{
      The template components whose values are to be propagated to
      initialise the new data structure are specified via the CLIST
      argument. Thus CLIST={\tt '}AXIS,QUALITY{\tt '} would cause the new NDF to
      inherit its axes structures and QUALITY values (if available) from
      the input structure, in addition to those propagated by default.
   }
}
\sstroutine{
   KPG1\_ISSCS
}{
   Extract the epoch of the reference equinox from a string
   specifying an IRAS90 Sky Coordinate System
}{
   \sstdescription{
      If, on entry, the argument SCS contains an explicit IRAS90 equinox
      specifier (see SUN/163), the epoch contained within it is returned
      in argument EQU as a double precision value, and argument BJ is
      returned equal to the character {\tt "}B{\tt "} or {\tt "}J{\tt "} depending on whether the
      epoch is Besselian or Julian. If there is no equinox specifier in
      argument SCS on entry, then the default of B1950 is returned.

      If the sky coordinate system specified by SCS is not referred to
      the equinox (eg GALACTIC) then EQU is returned equal to the
      Starlink {\tt "}BAD{\tt "} value VAL\_\_BADD, and BJ is returned blank.

      The argument NAME is returned holding the full (unabbreviated)
      name of the sky coordinate system without any equinox specifier.
      On exit, the argument SCS holds the full name plus an explicit
      equinox specifier (for systems which are referred to the
      equinox). Thus, if SCS contained {\tt "}EQUAT{\tt "} on entry, it would
      contain {\tt "}EQUATORIAL(B1950){\tt "} on exit.
   }
   \sstinvocation{
      RESULT = KPG1\_ISSCS( SCS, EQU, BJ, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry this should contain an IRAS90 SCS name (or any unambiguous
         abbreviation), with or without an equinox specifier. On exit,
         it contains the full SCS name with an explicit equinox
         specifier (for those sky coordinate systems which are referred
         to the equinox). If no equinox specifier is present on entry,
         then a value of B1950 is used (if required). This variable
         should have a declared length of 25.
      }
      \sstsubsection{
         EQU = DOUBLE PRECISION (Returned)
      }{
         The epoch of the reference equinox. This is extracted
         from any explicit equinox specifier contained in SCS on entry.
         If there is no equinox specifier in SCS, a value of 1950.0
         is returned. If the sky coordinate system is not referred to
         the equinox (eg GALACTIC) the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD)
         is returned, irrespective of any equinox specifier in SCS.
      }
      \sstsubsection{
         BJ = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Returned holding either the character B or J. Indicates if
         argument EQU gives a Besselian or Julian epoch. Returned blank
         if the sky coordinate system is not referred to the equinox.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full name of the sky coordinate system without any equinox
         specifier. This variable should have a declared length of 25.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      KPG1\_ISSCS = LOGICAL
         Returned .TRUE. if the supplied string is a valid IRAS90 SCS
         specifier, and .FALSE. otherwise (no error is reported).
   }
}
\sstroutine{
   KPG1\_KGODx
}{
   Sorts through a dataset and throw away bad values
}{
   \sstdescription{
      This routine copies good data and its variance from input arrays
      to to output arrays, leaving behind bad values.
   }
   \sstinvocation{
      CALL KPG1\_KGODx( VAR, NPTS, INARR, INVAR, NGOOD, OUTARR, OUTVAR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., copy the variance array as well, else only copy
         the data array.
      }
      \sstsubsection{
         NPTS = INTEGER (Given)
      }{
         The number of points in the input array.
      }
      \sstsubsection{
         INARR( NPTS ) = ? (Given)
      }{
         Input data array.
      }
      \sstsubsection{
         INVAR( NPTS ) = ? (Given)
      }{
         Input variance array.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of good points in the input data.
      }
      \sstsubsection{
         INARR( NPTS ) = ? (Returned)
      }{
         Output data array.
      }
      \sstsubsection{
         INVAR( NPTS ) = ? (Returned)
      }{
         Output variance array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Data are still good even if variance is bad.  Put another way,
         when the data is good, its corresponding variance is copied
         regardless of its value.

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LGTRN
}{
   Saves a transformation for a base-10 logarithmic plot in the AGI
   database
}{
   \sstdescription{
      This routine defines the transformations between world and a
      log10-log10 or log10-linear world co-ordinate system, and saves
      the transformation in the AGI database with the current picture.
   }
   \sstinvocation{
      CALL KPG1\_LGTRN( XLOG, YLOG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XLOG = LOGICAL (Given)
      }{
         If true the x-axis is logarithmic in world co-ordinates,
         otherwise it is linear.
      }
      \sstsubsection{
         YLOG = LOGICAL (Given)
      }{
         If true the y-axis is logarithmic in world co-ordinates,
         otherwise it is linear.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         There must be a current AGI picture.
      }
   }
}
\sstroutine{
   KPG1\_LIKE
}{
   Create a section from an NDF that matches the area of another NDF
}{
   \sstdescription{
      This routine returns an identifier for a section of a supplied
      NDF (INDF1) that covers the same area as a second template NDF
      (INDF2). The area matched can be either the pixel area, or the WCS
      area.
   }
   \sstinvocation{
      CALL KPG1\_LIKE( INDF1, INDF2, LIKWCS, INDF3, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         The first NDF, from which a section is required.
      }
      \sstsubsection{
         INDF2 = INTEGER (Given)
      }{
         The second NDF, which defines teh required area.
      }
      \sstsubsection{
         LIKWCS = LOGICAL (Given)
      }{
         If .TRUE., then the section selected from INDF1 matches the WCS
         bounding box of INDF2. If .FALSE., then the section selected
         from INDF1 matches the pixel index bounding box of INDF2.
      }
      \sstsubsection{
         INDF3 = INTEGER (Returned)
      }{
         The required section of INDF1.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_LINTD
}{
   Obtains a linear transformation between 2 sets of x,y positions
   with least squared error
}{
   \sstdescription{
      The co-efficients of a linear transformation are returned which
      maps the (XA,YA) positions to the corresponding (XB,YB) positions
      with least squares error. The type of fit can be specified as:

        o  A shift of origin only (IFIT 1)

        o  A shift and rotation (IFIT = 2)

        o  A shift, rotation and magnification (IFIT = 3)

        o  A shift, rotation, magnification and shear (IFIT = 4)

      If the value of IFIT is too high for the supplied data, a lower
      value will be used and returned in IFIT. The returned coefficients
      are such that:

        Fitted XB position = C(1) $+$ C(2)$*$XA $+$ C(3)$*$YA

        Fitted YB position = C(4) $+$ C(5)$*$XA $+$ C(6)$*$YA
   }
   \sstinvocation{
      CALL KPG1\_LINTD( N, XA, YA, XB, YB, IFIT, C, MAXERR, RMSERR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of supplied positions.
      }
      \sstsubsection{
         XA( N ) = DOUBLE PRECISION (Given)
      }{
         The X  coordinates at the first set of positions.
      }
      \sstsubsection{
         YA( N ) = DOUBLE PRECISION (Given)
      }{
         The Y  coordinates at the first set of positions.
      }
      \sstsubsection{
         XB( N ) = DOUBLE PRECISION (Given)
      }{
         The X  coordinates at the second set of positions.
      }
      \sstsubsection{
         YB( N ) = DOUBLE PRECISION (Given)
      }{
         The Y  coordinates at the second set of positions.
      }
      \sstsubsection{
         IFIT = INTEGER (Given and Returned)
      }{
         The type of fit required. A lower value will be used (and
         returned) if a fit of the specified type could not be
         obtained.
      }
      \sstsubsection{
         C( 6 ) = DOUBLE PRECISION (Returned)
      }{
         The coefficients of the linear fit.
      }
      \sstsubsection{
         MAXERR = DOUBLE PRECISION (Returned)
      }{
         The maximum error between the supplied (XB,YB) positions and
         the fitted (XB,YB) positions, in pixels.
      }
      \sstsubsection{
         RMSERR = DOUBLE PRECISION (Returned)
      }{
         The RMS error between the supplied (XB,YB) positions and
         the fitted (XB,YB) positions, in pixels.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_LISTC
}{
   Lists a character array to an ASCII file or reports it to the
   user
}{
   \sstdescription{
      This takes a character array and either writes the array to an
      open ASCII file or uses the message system to report it to the
      user.
   }
   \sstinvocation{
      CALL KPG1\_LISTC( FD, EL, ARRAY, FILE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor for the log file.  It is ignored if
         FILE is false.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of character strings in the array.
      }
      \sstsubsection{
         ARRAY( EL ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The array of character strings.
      }
      \sstsubsection{
         FILE = LOGICAL (Given)
      }{
         If true the array is listed to the ASCII file otherwise the
         array is reported to the user.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The ASCII file must be opened.
      }
   }
}
\sstroutine{
   KPG1\_LSTAR
}{
   Write a section of a 2D array to a text file
}{
   \sstdescription{
      This routine takes an input 2-d array and lists out a specified
      section of that image, as defined by the x-and-y lower-and-upper
      bounds to a Fortran file. The file must either be already opened
      and specified by the input file descriptor, or be created in this
      routine and will be associated with the supplied parameter name.
      The first record in the file corresponds to the lowest index row.
   }
   \sstinvocation{
      CALL KPG1\_LSTAR( DIM1, DIM2, ARRAY, XLOW, YLOW, XHIGH, YHIGH,
                       OPENF, FDI, FILNAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d array.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 )  =  REAL (Given)
      }{
         The 2-d array to be listed.
      }
      \sstsubsection{
         XLOW = INTEGER (Given)
      }{
         x co-ord of lower left corner of sub-array to be listed out.
      }
      \sstsubsection{
         YLOW = INTEGER (Given)
      }{
         y co-ord of lower left corner of sub-array to be listed out.
      }
      \sstsubsection{
         XHIGH = INTEGER (Given)
      }{
         x co-ord of upper right corner of sub-array to be listed out.
      }
      \sstsubsection{
         YHIGH = INTEGER (Given)
      }{
         y co-ord of upper right corner of sub-array to be listed out.
      }
      \sstsubsection{
         OPENF =  LOGICAL (Given)
      }{
         If true the Fortran file is to be associated with \%FILNAM and
         opened. Otherwise the file is assumed to have been opened and
         has descriptor \%FD.
      }
      \sstsubsection{
         FDI = INTEGER (Given)
      }{
         The descriptor associated with the previously opened Fortran
         file.
      }
      \sstsubsection{
         FILNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name of the file to be opened and to contain the
         listing output.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
}
\sstroutine{
   KPG1\_LTGET
}{
   Obtain a locator to an array holding a colour table for the currently
   opened graphics device
}{
   \sstdescription{
      This routine returns an HDS locator for a 2-dimensional array
      holding the colour table to load into the currently open graphics
      device. The HDS object is searched for in an HDS container file in
      the users ADAM directory. The  file is called {\tt "}kappa.lut.sdf{\tt "} and
      contains a LUT for different devices. The file should have been
      created by KPG1\_LTSAV.

      Each lut in the file is a \_REAL array of shape (3,n) where
      n is the number of colours in the lut.

      Each array has a name which identifies the graphics device
      to which it refers.
   }
   \sstinvocation{
      CALL KPG1\_LTGET( PLOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PLOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Returned)
      }{
         The locator. returned equal to DAT\_\_NOLOC if the colour table
         cannot be found, or if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_LTLOD
}{
   Load the colour table for the currently open graphics device
}{
   \sstdescription{
      This routine loads the colour table for the currently open graphics
      device from an HDS container file in the users ADAM directory. The
      file is called {\tt "}kappa.lut.sdf{\tt "} and contains a LUT for
      different devices. The file should have been created by KPG1\_LTSAV.
      If the file does not exist, the colour table is set to a greyscale.

      Each lut in the file is a \_REAL array of shape (3,n) where
      n is the number of colours in the lut.

      Each array has a name which identifies the graphics device
      to which it refers.
   }
   \sstinvocation{
      CALL KPG1\_LTLOD( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_LTSAV
}{
   Save the colour table for the currently open graphics device
}{
   \sstdescription{
      This routine saves the colour table for the currently
      open graphics device in an HDS container file in the users ADAM
      directory. The file is called {\tt "}kappa\_lut.sdf{\tt "} and contains
      LUTs for different devices. Each LUT is a \_REAL array of
      shape (3,n) where n is the number of colours in the LUT. Each array
      has a name which identifies the graphics device to which it refers.
   }
   \sstinvocation{
      CALL KPG1\_LTSAV( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The HDS container file is created if it does not already exist.

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_LUTIN
}{
   Transfers a lookup table between arrays that have different
   numbers of colour indices
}{
   \sstdescription{
      This routine transfers a lookup table between arrays that may
      have different numbers of colour indices.  When they are unequal
      the lookup table is expanded or contracted to fit the destination
      array.  This may be achieved either by linear interpolation or by
      the nearest-neighbour method.  (There are different sizes
      presumably because the lookup table was created on a device with
      a differently sized colour table.)  If the arrays are of equal
      size the lookup table is merely copied between them.
   }
   \sstinvocation{
      CALL KPG1\_LUTIN( INEL, INARR, OUTEL, NN, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INEL = INTEGER (Given)
      }{
         The number of colour indices in the lookup table.
      }
      \sstsubsection{
         INARR( 3, 0:INEL-1 ) = REAL (Given)
      }{
         The source lookup table.  The first dimension is RGB.  Values
         should lie in the range 0.0--1.0.
      }
      \sstsubsection{
         OUTEL = INTEGER (Given)
      }{
         The number of colour indices available in the destination
         array.  This is usually the number of colour indices available
         on the chosen graphics device.
      }
      \sstsubsection{
         NN = LOGICAL (Given)
      }{
         If true, and the number of input and output colour indices are
         different, the nearest-neighbour method is used for assigning
         values in the output array.  Otherwise linear interpolation
         is used.  Nearest-neighbour preserves sharp edges in the
         lookup; linear interpolation is recommended for smoothly
         varying lookup tables.
      }
      \sstsubsection{
         OUTARR( 3, 0:OUTEL-1 ) = REAL (Returned)
      }{
         This is the array into which the table is put. The values will
         all lie in the range 0.0--1.0, even though the input may beyond
         this range. (Input values below 0.0 become 0.0 in OUTARR, and
         those above 1.0 become 1.0)
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_LUTK2
}{
   Set up the pixel colour indices which form a LUT key
}{
   \sstdescription{
      This routine fills the COLS array with integer colour indices
      so that the array can be used as a colour table key. It can produce
      histogram or ramp keys.
   }
   \sstinvocation{
      CALL KPG1\_LUTK2( FORM, CAXIS, LBND1, UBND1, LBND2, UBND2,
                       HSTDAT, MAXPOP, LOG, COLS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FORM = INTEGER (Given)
      }{
         Indicates the form of key required: 0 - ramp, 1 - histogram.
      }
      \sstsubsection{
         CAXIS = INTEGER (Given)
      }{
         The index of the array axis corresponding to colour index (1 or 2).
      }
      \sstsubsection{
         LBND1 = INTEGER (Given)
      }{
         The lower bound on axis 1.
      }
      \sstsubsection{
         UBND1 = INTEGER (Given)
      }{
         The upper bound on axis 1.
      }
      \sstsubsection{
         LBND2 = INTEGER (Given)
      }{
         The lower bound on axis 2.
      }
      \sstsubsection{
         UBND2 = INTEGER (Given)
      }{
         The upper bound on axis 2.
      }
      \sstsubsection{
         HSTDAT( $*$ ) = INTEGER (Given)
      }{
         A histogram of colour index counts. The length of this vector
         should be equal to the length of axis CAXIS.
      }
      \sstsubsection{
         MAXPOP = INTEGER (Given)
      }{
         The maximum population in any cell of the histogram.
      }
      \sstsubsection{
         LOG = LOGICAL (Given)
      }{
         If TRUE the histogram displays Log(count).
      }
      \sstsubsection{
         COLS( LBND1:UBND1, LBND2:UBND2 ) = INTEGER (Returned)
      }{
         The returned array of colour indices.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_LUTK3
}{
   Produce a GRAPH colour table key for KPG1\_LUTKY
}{
   \sstdescription{
      This routine produces a colour table key consisting of 1 or 3 line
      plots (1 if the colour table is a greyscale, and 3 if it is not).
      The line plots are drawn using the supplied Plot.
   }
   \sstinvocation{
      CALL KPG1\_LUTK3( IPLOT, PARAM, APP, LP, UP, X, RGB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         The Plot to use.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the style parameter to use (eg STYLE, KEYSTYLE, etc).
         The appearance of the 3 curves can be set using attribute
         qualifiers (R), (G), and (B) (eg {\tt "}width(r)=10{\tt "} ).
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The calling application, in the form {\tt "}KAPPA\_LUTVIEW{\tt "}.
      }
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The lowest PGPLOT colour index to copy.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The highest PGPLOT colour index to copy.
      }
      \sstsubsection{
         X( LP:UP, 2 ) = DOUBLE PRECISION (Returned)
      }{
         Work space to hold the X values
      }
      \sstsubsection{
         RGB( LP:UP, 3 ) = DOUBLE PRECISION (Returned)
      }{
         Work space to hold the RGB intensities.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_LUTK4
}{
   Produce an AST Mapping from pen number to RGB intensity
}{
   \sstdescription{
      This routine produces an AST Mapping which maps 1-dimensional pen
      number into 3-dimensional RGB intensity within the current PGPLOT
      graphics device.
   }
   \sstinvocation{
      CALL KPG1\_LUTK4( LP, UP, WORK, MAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The lowest PGPLOT colour index to use.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The highest PGPLOT colour index to use.
      }
      \sstsubsection{
         WORK( LP:UP, 3 ) = DOUBLE PRECISION (Returned)
      }{
         Work space.
      }
      \sstsubsection{
         MAP = INTEGER (Returned)
      }{
         The Mapping pointer.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_LUTKY
}{
   Draws a key showing a colour table
}{
   \sstdescription{
      The key consists of a ramp of colour covering the specified range
      of colour indices, with annotated axes.  Axis 1 is always the
      data-value axis (whether it is drawn vertically or horizontally).
      The whole plot (including annotation) is scaled to fit inside the
      picture specified by IPIC.
   }
   \sstinvocation{
      CALL KPG1\_LUTKY( IPIC, PARAM, HIGH, LOW, LABEL, APP, LP, UP, F,
                       GAP1, GAP2, JUST, NEL, COLDAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPIC = INTEGER (Given)
      }{
         An AGI identifier for a picture in which the key is to be
         produced.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the style parameter to use (e.g. STYLE, KEYSTYLE,
         etc.).
      }
      \sstsubsection{
         HIGH = REAL (Given)
      }{
         The X axis value (i.e. pixel value or pen number) corresponding
         to the colour index UP.
      }
      \sstsubsection{
         LOW = REAL (Given)
      }{
         The X axis value (i.e. pixel value or pen number) corresponding
         to the colour index LP.
      }
      \sstsubsection{
         LABEL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The default label to put against the data values.
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The calling application, in the form {\tt "}KAPPA\_LUTVIEW{\tt "}.
      }
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The smallest colour index to include in the display.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The largest colour index to include in the display.
      }
      \sstsubsection{
         F = REAL (Given)
      }{
         An amount by which to extend the margins left for annotation,
         expressed as a factor of the height or width of the plotting
         area.  For instance, a value of 0.1 could be given to fit the
         annotation {\tt "}comfortably{\tt "} into the Plot.  A value of 0.0 will
         result in the annotation being hard up against the edge of the
         plot.
      }
      \sstsubsection{
         GAP1 = REAL (Given)
      }{
         A gap, in millimetres, to place between the bottom or right
         edge of the supplied picture, and the nearest edge of the
         colour ramp.
      }
      \sstsubsection{
         GAP2 = REAL (Given)
      }{
         A gap, in millimetres, to place between the top or left edge
         of the supplied picture, and the nearest edge of the colour
         ramp.
      }
      \sstsubsection{
         JUST = CHARACTER$*$2 (Given)
      }{
         Indicates the justification of the new plot within the
         specified area.  {\tt '}BL{\tt '}, {\tt '}BC{\tt '}, {\tt '}BR{\tt '}, {\tt '}CL{\tt '}, {\tt '}CC{\tt '}, {\tt '}CR{\tt '}, {\tt '}TL{\tt '},
         {\tt '}TC{\tt '}, or {\tt '}TR{\tt '}, where B is Bottom, C is Centre, T is Top, L is
         Left and R is Right.  Must be uppercase.  Unrecognised values
         are treated as {\tt "}C{\tt "}.
      }
      \sstsubsection{
         NEL = INTEGER (Given)
      }{
         The size of the vector COLDAT. If this is zero, COLDAT is not
         accessed, and requested for keys in the form of a histogram
         are ignored (that is, keys are always produced in the form of a
         ramp).
      }
      \sstsubsection{
         COLDAT( NEL ) = INTEGER (Given)
      }{
         A vector of colour indices, one for each displayed data pixel.
         Only accessed if NEL is greater than zero and the STYLE
         parameter indicates that the key is to drawn in the form of a
         histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_MAP
}{
   Obtain mapped access to an array component of an NDF
}{
   \sstdescription{
      This routine is a wrapper for NDF\_MAP which obtains mapped access
      to an array component of an NDF, returning a pointer to the mapped
      values and a count of the number of elements mapped. At the moment
      this wrapper routine is a dummy which does nothing else.
   }
   \sstinvocation{
      CALL KPG1\_MAP( INDF, COMP, TYPE, MMOD, PNTR, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component to be mapped: {\tt '}DATA{\tt '},
         {\tt '}QUALITY{\tt '} or {\tt '}VARIANCE{\tt '} (or {\tt '}ERROR{\tt '}).
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Numeric type to be used for access (e.g. {\tt '}\_REAL{\tt '}).
      }
      \sstsubsection{
         MMOD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Mapping mode for access to the array: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or
         {\tt '}WRITE{\tt '}, with an optional initialisation mode {\tt '}/BAD{\tt '} or
         {\tt '}/ZERO{\tt '} appended.
      }
      \sstsubsection{
         PNTR( $*$ ) = INTEGER (Returned)
      }{
         Pointer(s) to the mapped values (see the Notes section).
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements mapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_MKLUT
}{
   Create a Mapping to connect two 1D array of values
}{
   \sstdescription{
      This routine creates a 1D Mapping which translates an X into a Y
      value on the basis of supplied tables of corresponding X and Y.
      This is like an AST LutMap except that the LutMap class requires Y
      to be tabulated at equal X intervals, whereas this routine allows
      Y to be tabulated at arbitrary X intervals.
   }
   \sstinvocation{
      CALL KPG1\_MKLUT( IX, IY, NPNT, NVAR, FRM, TABLE, MAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IX = INTEGER (Given)
      }{
         The index of the X values within the TABLE array.
      }
      \sstsubsection{
         IY = INTEGER (Given)
      }{
         The index of the Y values within the TABLE array.
      }
      \sstsubsection{
         NPNT = INTEGER (Given)
      }{
         The number of values supplied for each variable in the TABLE
         array.
      }
      \sstsubsection{
         NVAR = INTEGER (Given)
      }{
         The number of variables described in the table. This will be at
         least 2 (for X and Y) but may be more.
      }
      \sstsubsection{
         FRM = INTEGER (Given)
      }{
         If not AST\_\_NULL, then this should be an AST pointer to a Frame
         with NVAR axes which will be used to normalise the axis values
         before creating the LutMap. No normalisation occurs if a value of
         AST\_\_NULL is supplied.
      }
      \sstsubsection{
         TABLE( NPNT, NVAR ) = DOUBLE PRECISION (Given and Returned)
      }{
         The table containing corresponding X and Y values. The table can
         also contain values for other variables, which will be ignored.
         These will be normalised on exit using the AST Frame supplied by
         FRM.
      }
      \sstsubsection{
         MAP = INTEGER (Returned)
      }{
         An AST pointer to the returned Mapping, or AST\_\_NULL if no Mapping
         could be created.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         It is only possible to create the Mapping if the tabluated X values
         are monotonic increasing or decreasing.

         \sstitem
         The returned Mapping will have an inverse Transformation only if Y
         increases or decreases monotonically with X.
      }
   }
}
\sstroutine{
   KPG1\_MKPOS
}{
   Mark a position on a graphics device
}{
   \sstdescription{
      This routine marks a position on a graphics device in various ways.
   }
   \sstinvocation{
      CALL KPG1\_MKPOS( NAX, POS, IPLOT, CURR, MODE, MARKER, GEO, DONE,
                       CLOSE, TEXT, JUST, REGION, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of co-ordinate values supplied in POS. This should be
         equal to the number of axes in the Frame specified by CURR.
      }
      \sstsubsection{
         POS( NAX ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinates of the position, in the Frame specified by CURR.
         No marker is drawn if a AST\_\_BAD or VAL\_\_BADD value is supplied
         Ignored if DONE is .TRUE., and MODE is {\tt "}POLY{\tt "}, {\tt "}CHAIN{\tt "} or {\tt "}BOX{\tt "}.
      }
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to a Plot. The same Plot should be supplied for
         all points in a polygon, chain, or set of boxes.
      }
      \sstsubsection{
         CURR = LOGICAL (Given)
      }{
         If .TRUE., then position supplied in POS refers to the Current
         Frame in IPLOT. Otherwise it refers to the Base Frame (which
         should be the GRAPHICS Frame).
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The type of marker to produce (case sensitive, no abbreviations):

         \sstitemlist{

            \sstitem
            {\tt "}NONE{\tt "} -- An immediate return is made without any graphics
            being drawn.

            \sstitem
            {\tt "}MARK{\tt "} -- Each position is marked by the symbol specified
            by argument MARKER.

            \sstitem
            {\tt "}POLY{\tt "} -- Causes each position to be joined by a line to the
            previous position marked.  These lines may be geodesic (in the
            Current Frame of the Plot) or straight (on the screen), as specified
            by argument GEO.

            \sstitem
            {\tt "}CHAIN{\tt "} -- This is a combination of {\tt "}Mark{\tt "} and {\tt "}Poly{\tt "}. Each
            position is marked by a symbol and joined by a line to the previous
            position. Arguments MARKER, GEO, and CLOSE are used to specify
            the symbols and lines to use.

            \sstitem
            {\tt "}BOX{\tt "} -- An empty rectangle with edges parallel to the axes is
            drawn extending between the supplied position and the previous
            position.

            \sstitem
            {\tt "}VLINE{\tt "} -- A vertical line is drawn through the position
            covering the entire height of the Plot.

            \sstitem
            {\tt "}HLINE{\tt "} -- A horizontal line is drawn through the position
            covering the entire height of the Plot.

            \sstitem
            {\tt "}CROSS{\tt "} -- A full-screen cross-hair is drawn at the position, i.e.
            a combination of Vline and Hline.

            \sstitem
            {\tt "}TEXT{\tt "} -- The text string specified by argument TEXT is
            displayed, horizontally, and centred on the supplied position.

            \sstitem
            {\tt "}BLANK{\tt "} -- Nothing is drawn.

            \sstitem
            {\tt "}REGION{\tt "} -- The AST Region given by REGION is outlined.
         }
      }
      \sstsubsection{
         MARKER = INTEGER (Given)
      }{
         The PGPLOT marker type to use if MODE is {\tt "}MARKER{\tt "} or {\tt "}CHAIN{\tt "}.
      }
      \sstsubsection{
         GEO = LOGICAL (Given)
      }{
         Should polygon and chain line segments be drawn as geodesic curves
         within the Current Frame of the Plot? If not they are drawn as simple
         straight lines within the Base Frame (GRAPHICS). The same value
         should be supplied for all points in a polygon or chain.
      }
      \sstsubsection{
         DONE = LOGICAL (Given)
      }{
         Should be supplied .TRUE. when a polygon, chain or set of boxes has
         been completed. The contents of POS will be ignored in this case.
         DONE is ignored if MODE is not {\tt "}PLOT{\tt "}, {\tt "}CHAIN{\tt "} or {\tt "}BOX{\tt "}.
      }
      \sstsubsection{
         CLOSE = LOGICAL (Given)
      }{
         If .TRUE., polygons and chains are closed by joining the first
         position to the last position (when DONE is supplied .TRUE.).
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to display if MODE is {\tt "}TEXT{\tt "}. Trailing spaces are
         ignored.
      }
      \sstsubsection{
         JUST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string specifying the justification to be used when displaying
         the text supplied in TEXT (ignored if MODE is not {\tt "}Text{\tt "}). This
         should be a string of two characters; the first should be {\tt "}B{\tt "},
         {\tt "}C{\tt "} or {\tt "}T{\tt "}, meaning bottom, centre or top. The second should be
         {\tt "}L{\tt "}, {\tt "}C{\tt "} or {\tt "}R{\tt "}, meaning left, centre or right. The text is
         displayed so that the position supplied in POS is at the
         specified point within the displayed text string.
      }
      \sstsubsection{
         REGION = INTEGER (Given)
      }{
         A 2-dimensional AST Region pointer. Only used if PLOT is {\tt "}REGION{\tt "}.
         In order to save time calling AST\_CONVERT for every Region, the
         first Region to be plotted using this routine defines the
         co-ordinate frame for all subsequent Regions draw by later
         invocations of this routine. If in fact, later Regions may have a
         different coordinate frame, then this routine should be called
         with MODE=REGION and REGION=AST\_\_NULL. This will cause the
         current Region coordinate frame to be forgotten so that the next
         non-NULL Region to be draw will define a new current coordinate
         frame for subsequent Regions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_MXMNX
}{
   Returns the maximum and minimum values of an array
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.
   }
   \sstinvocation{
      CALL KPG1\_MXMNX( TYPE, BAD, EL, IPNTR, NINVAL, MAXMUM, MINMUM,
                       MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The HDS data type of the array.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the array.  If false
         it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         IPNTR = INTEGER (Given)
      }{
         A pointer to the data array.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = DOUBLE PRECISION (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = DOUBLE PRECISION (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This function simply wraps up the generic KPG1\_MXMN$<$T$>$ routines.
      }
   }
}
\sstroutine{
   KPG1\_NACVT
}{
   Convert an HDS object hierarchy to native data representation
}{
   \sstdescription{
      The routine recursively descends an HDS object hierarchy,
      converting any primitive objects within it to have the
      appropriate native data representation, as provided by the host
      machine. This will minimise subsequent access time for this
      machine.
   }
   \sstinvocation{
      CALL KPG1\_NACVT( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given and Returned)
      }{
         Locator for the object or structure whose contents are to be
         converted. If the object is primitive, then this locator may
         be replaced by a new one on output (as the object may need to
         be erased and re-created).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_NAG2R
}{
   Converts an NAG Hermitian Fourier transform array into an array
   usable by FFTPACK routine KPG1\_RFFTB
}{
   \sstdescription{
      This subroutine modifies the supplied array of Fourier co-efficients
      (as produced by NAG subroutine C06FAE) so that an inverse FFT can be
      performed on them using FFTPACK routine KPG1\_RFFTB. The resulting
      inverse will have the same normalisation as the original data
      transformed using KPG1\_RFFTF.

      This function is equivalent to PDA\_NAG2R except that it uses work
      space for greater speed.
   }
   \sstinvocation{
      CALL KPG1\_NAG2R( NP, R, WORK )
   }
   \sstarguments{
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of the array.
      }
      \sstsubsection{
         R( NP ) = REAL (Given and Returned)
      }{
         The array holding the Fourier co-efficients. Supplied in NAG
         format and returned in FFTPACK format.
      }
      \sstsubsection{
         WORK( NP ) = REAL (Given and Returned)
      }{
         Work space.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A call to KPG1\_R2NAG followed by a call to KPG1\_NAG2R will result in
         the original data being divided by NP.
      }
   }
}
\sstroutine{
   KPG1\_NAGTC
}{
   Swaps argument order when getting a mapped character array from
   an HDS object
}{
   \sstdescription{
      This is just a dummy routine to swap the argument order when
      obtaining the value of a mapped character array from an HDS
      object.  It is needed for Unix systems.
   }
   \sstinvocation{
      CALL KPG1\_NAGTC( CVALUE, LOC, NDIM, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CVALUE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The character value.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ (DAT\_\_SZLOC) (Given)
      }{
         The locator of the object whose value is required.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions.
      }
      \sstsubsection{
         DIM( $*$ ) = INTEGER (Given)
      }{
         The dimensions of the character object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_NAPTC
}{
   Swaps argument order when putting a mapped character array into
   an HDS object
}{
   \sstdescription{
      This is just a dummy routine to swap the argument order when
      putting the value of a mapped character array into HDS object.  It
      is needed for Unix systems.
   }
   \sstinvocation{
      CALL KPG1\_NAPTC( CVALUE, LOC, NDIM, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CVALUE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The character value.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ (DAT\_\_SZLOC) (Given)
      }{
         The locator of the object to have value CVALUE.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions.
      }
      \sstsubsection{
         DIM( $*$ ) = INTEGER (Given)
      }{
         The dimensions of the character object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_NDFNM
}{
   Return the name of an NDF without a directory path (Unix only)
}{
   \sstdescription{
      Gets the full path to the supplied NDF, then removes any directory
      path from the start, and return the resulting string.

      Note, Unix file names are assumed.
   }
   \sstinvocation{
      CALL KPG1\_NDFNM( INDF, NAME, NMLEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The NDF name without directory path.
      }
      \sstsubsection{
         NMLEN = INTEGER (Returned)
      }{
         The used length of NAME.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_NMCOL
}{
   Finds the RGB intensities of a named colour
}{
   \sstdescription{
      Given the name of a colour this routine searches the standard
      colour set for it, and if it exists returns its R-G-B intensities.
      An error is returned if the named colour is not in the colour set.
      All comparisons are performed in uppercase with the blanks
      removed.
   }
   \sstinvocation{
      CALL KPG1\_NMCOL( NAME, R, G, B, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the nearest colour in the named colour set to the
         input RGB colour.  Note at least eighteen characters are
         required to avoid truncation. This string may also be an HTML
         code of the form {\tt "}\#aabbcc{\tt "} (or {\tt "}@aabbcc{\tt "} - for use in contexts
         where {\tt "}\#{\tt "} is a comment character, e.g. kappa style files) where
         a, b and c are hexadecimal digits, and {\tt "}aa{\tt "}, {\tt "}bb{\tt "} and {\tt "}cc{\tt "} give
         red, blue and green intensities normalised to a maximum of {\tt "}ff{\tt "}
         (256).
      }
      \sstsubsection{
         R = REAL (Returned)
      }{
         The red intensity of the named colour to be identified.  It is
         in the range 0.0 to 1.0.
      }
      \sstsubsection{
         G = REAL (Returned)
      }{
         The green intensity of the named colour to be identified.  It
         is in the range 0.0 to 1.0.
      }
      \sstsubsection{
         B = REAL (Returned)
      }{
         The blue intensity of the named colour to be identified.  It is
         in the range 0.0 to 1.0.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_NUMFL
}{
   This counts the number of lines in a text file
}{
   \sstdescription{
      This routine counts the number of non-comment, comment, and blank
      lines in a text file.  Comment lines are those beginning, with
      any of the characters passed in the COMENT argument (normally !
      and \#).  Here {\tt '}beginning{\tt '} means the first non-blank character.
   }
   \sstinvocation{
      CALL KPG1\_NUMFL( FD, COMENT, NLINES, NCOMS, NBLANK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         Fortran file identifier.
      }
      \sstsubsection{
         COMENT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of comment characters.  If any line of
         the file begins with one of these, the line is treated as a
         comment line.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of non-comment lines in the file.
      }
      \sstsubsection{
         NCOMS = INTEGER (Given)
      }{
         The number of comment lines in the file.
      }
      \sstsubsection{
         NCOMS = INTEGER (Given)
      }{
         The number of blank lines in the file.
      }
      \sstsubsection{
         STATUS = INTEGER (\{status\_access\_mode\})
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The file is rewound, but not closed on exit.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The Fortran text file must already be opened.
      }
   }
}
\sstroutine{
   KPG1\_OPGRD
}{
   Gets the parameters of an optimal projection for a given set of
   sky positions
}{
   \sstdescription{
      This routine calculates the parameters of a tangent-plane
      projection that gives an optimal representation of a set of
      supplied sky positions. The projection parameters are the normal
      FITS CRPIX1/2, CRVAL1/2, CDELT1/2 and CROTA2 keywords. They are
      chosen in order to maximise the number of sky positions that fall
      close to the centre of a pixel.
   }
   \sstinvocation{
      CALL KPG1\_OPGRD( NPOS, POS, WEST, PAR, RDIAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPOS = INTEGER (Given)
      }{
         The number of sky positions.
      }
      \sstsubsection{
         POS( 2, NPOS ) = DOUBLE PRECISION (Given)
      }{
         The sky positions. These should be (longitude,latitude) values,
         in radians, in any celestial co-ordinate system.
      }
      \sstsubsection{
         WEST = LOGICAL (Given)
      }{
         If .TRUE., then it is assumed that the X grid axis increases
         westwards (assuming north is parallel to $+$ve Y). This is the
         case for most celestial co-ordinate systems such as (RA,Dec)
         etc.  If .FALSE., then it is assumed that the X grid axis
         increases eastwards (assuming north is parallel to $+$ve Y). This
         is the case for a few systems such as (az,el) and geographic
         (longitude,latitude).
      }
      \sstsubsection{
         PAR( 7 ) = DOUBLE PRECISION (Given and Returned)
      }{
         The projection parameters. Each parameter that is supplied with
         a value of AST\_\_BAD on entry will be replaced on exit with the
         optimal value. Non-bad supplied values will be left unchanged
         on exit. The supplied values will also be left unchanged if
         optimal values cannot be determined. They are stored in the
         order CRPIX1, CRPIX2, CRVAL1, CRVAL2, CDELT1, CDELT2, CROTA2.
         CRPIX1 and CRPIX2 are in units of pixels. All the other
         projection parameters will be in units of radians, and refer to
         the celestial co-ordinate system in which the POS values are
         supplied. CROTA2 is the angle from the Y axis to celestial
         north, measured north through east (no matter the value of
         WEST). Returned pixel sizes are rounded to the nearest tenth of
         an arcsecond.
      }
      \sstsubsection{
         RDIAM = DOUBLE PRECISION (Returned)
      }{
         The diameter of the circle that just encloses all the supplied
         sky positions, in radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ORVAR
}{
   To return the variances and covariances of the order statistics
   from n to 1, assuming an initially normal distribution
}{
   \sstdescription{
      The routine returns the variances and covariances of the order
      statistics, assuming an initial (pre-ordered) normal distribution
      of mean 0 and standard deviation 1. The routine returns all
      variance/covariances in an array with the terms vectorised - that
      is following on after each row. This uses the symmetric nature of
      the matrix to compress the data storage, but remember to double
      the covariance components if summing in quadrature. The variances
      \sstitemlist{

         \sstitem
         covariances are returned for all statistics from n to 1. The
         special case of n = 1 returns the variance of 2/pi (median).
      }
   }
   \sstinvocation{
      CALL KPG1\_ORVAR( NSET, NBIG, PP, VEC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSET = INTEGER (Given)
      }{
         Number of members in ordered set.
      }
      \sstsubsection{
         NBIG = INTEGER (Given)
      }{
         Maximum number of entries in covariance array row.
         equal to NSET$*$(NSET$+$1)/2).
      }
      \sstsubsection{
         PP( NSET ) = DOUBLE PRECISION (Given)
      }{
         Workspace for storing expected values of order statistics.
      }
      \sstsubsection{
         VEC( NBIG, NSET ) = DOUBLE PRECISION (Returned)
      }{
         The upper triangles of the nset by nset variance-covariance
         matrix packed by columns. Each triangle is packed into a
         single row. For each row element Vij is stored in
         VEC(i$+$j$*$(j-1)/2), for 1$<$=i$<$=j$<$=nset.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Data is returned as above to save on repeated calls (which are
         too slow). To get the actual variance of the data of order n you
         need to sum all the variances and twice the covariances and use
         these to modify the actual variance of the (unordered) data.

         \sstitem
         It is assumed that NSET cannot be any larger than MXVAL.
      }
   }
}
\sstroutine{
   KPG1\_PACOL
}{
   Obtain a marker colour
}{
   \sstdescription{
      This routine obtains a colour index. A string is obtained from the
      parameter system.  The interpretation of this string provides a number
      of ways to specify the colour index requested.  The options are:

        {\tt '}MAX{\tt '}          - The maximum (non-reserved) colour index, i.e.
                         the highest colour index used for the display
                         of an image.
        {\tt '}MIN{\tt '}          - The minimum non-reserved colour index, i.e. the
                         lowest colour index used for the display of an
                         image.
        An integer     - The actual colour index. It is constrained
                         between 0 and the highest colour index.
        A named colour - Uses the named colour from the palette, and if
                         it is not present, the nearest colour from the
                         palette is selected.
        An HTML code   - Has the form {\tt "}\#aabbcc{\tt "} (or {\tt "}@aabbcc{\tt "} - for use
                         in contexts where {\tt "}\#{\tt "} is a comment character,
                         e.g. kappa style files) where a, b and c are
                         hexadecimal digits, and {\tt "}aa{\tt "}, {\tt "}bb{\tt "} and {\tt "}cc{\tt "} give
                         red, blue and green intensities normalised to a
                         maximum of {\tt "}ff{\tt "} (256).
   }
   \sstinvocation{
      CALL KPG1\_PACOL( PNCOL, LP, UP, COLIND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNCOL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter to obtain the marker colour.
         It should have type LITERAL.
      }
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The lowest non-reserved colour index.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The highest non-reserved colour index.
      }
      \sstsubsection{
         COLIND = INTEGER (Returned)
      }{
         The colour index of the selected colour.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A PGPLOT image-display workstation must be open and active.
      }
   }
}
\sstroutine{
   KPG1\_PGCLR
}{
   Clear current PGPLOT viewport
}{
   \sstdescription{
      This routine clears the current PGPLOT viewport if possible. If it
      is not possible (eg for a printer) it does nothing.
   }
   \sstinvocation{
      CALL KPG1\_PGCLR( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A PGPLOT image-display workstation must be open and active.
      }
   }
}
\sstroutine{
   KPG1\_PGCLS
}{
   Close down the AGI database and PGPLOT workstation
}{
   \sstdescription{
      This routine closes the graphics data base and PGPLOT workstation
      previously opened by KPG1\_PGOPN.
   }
   \sstinvocation{
      CALL KPG1\_PGCLS( PNAME, SAVCUR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         SAVCUR = LOGICAL (Given)
      }{
         If .TRUE., then the current AGI picture is retained as the
         current picture. If .FALSE., the picture which was current when
         the database was opened is re-instated.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if an error has already
         occurred (but the pallette will not be saved if an error has
         already occurred).
      }
   }
}
\sstroutine{
   KPG1\_PGCOL
}{
   Obtain a marker colour, given a colour specification
}{
   \sstdescription{
      This routine obtains a PGPLOT colour index to be used in an image
      display from a supplied string. The interpretation of this string
      provides a number of ways to specify the colour index requested.
      The options are:

        {\tt '}MAX{\tt '}          - The maximum (non-reserved) colour index, i.e.
                         the highest colour index used for the display
                         of an image.
        {\tt '}MIN{\tt '}          - The minimum non-reserved colour index, i.e. the
                         lowest colour index used for the display of an
                         image.
        An integer     - The actual colour index. It is constrained
                         between 0 and the highest colour index.
        A named colour - Uses the named colour from the palette, and if
                         it is not present, the nearest colour from the
                         palette is selected.

      An error is reported if the string does not conform to any of
      these formats.
   }
   \sstinvocation{
      CALL KPG1\_PGCOL( COL, LP, UP, COLIND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         COL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string specifying the required colour.
      }
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The lowest non-reserved colour index.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The highest non-reserved colour index.
      }
      \sstsubsection{
         COLIND = INTEGER (Returned)
      }{
         The colour index of the selected colour.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A PGPLOT image-display workstation must be open and active.
      }
   }
}
\sstroutine{
   KPG1\_PGCUR
}{
   Uses the cursor to get a set of points
}{
   \sstdescription{
      This routine uses the PGPLOT cursor to get a set of positions in the
      world co-ordinate system of the current PGPLOT window. If a position
      is given outside the box specified by X1, X2, Y1, Y2, then a
      warning is issued and the position is ignored. The allowable box
      can extend outside the PGPLOT viewport (extrapolated world
      co-ordinates are returned for positions outside the viewport).

      The routine returns when any one of the following occurs:

      1) The maximum number of positions have been given (see MAXPNT).
      2) The right mouse button, {\tt "}X{\tt "} or {\tt "}.{\tt "} is pressed (but only if
         KEYS contains {\tt "}X{\tt "} or {\tt "}.{\tt "}). The cursor position is not returned.
      3) The key/button specified by EXACT is pressed. The cursor position
         IS returned.
   }
   \sstinvocation{
      CALL KPG1\_PGCUR( INFO, MESS, NACT, ACTDES, KEYS, X1, X2, Y1, Y2,
                       EXACT, X0, Y0, MAXPNT, RBMODE, LINE, BOX, MARK,
                       IPLOT, X, Y, ACT, NPNT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INFO = LOGICAL (Given)
      }{
         Display information describing the available actions before
         getting the first position?
      }
      \sstsubsection{
         MESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The purpose for using the cursor. Eg {\tt "}select 2 points{\tt "}. May be
         blank.
      }
      \sstsubsection{
         NACT = INTEGER (Given)
      }{
         The number of available actions. Ignored if INFO is .FALSE.
      }
      \sstsubsection{
         ACTDES( NACT ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Short descriptions of each action. Ignored if INFO is .FALSE.
         Examples: {\tt "}select a point{\tt "}, {\tt "}exit{\tt "}, {\tt "}mark a star{\tt "}. etc.
      }
      \sstsubsection{
         KEYS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string of NACT unique characters. These are the keyboard keys
         which must be pressed to select the corresponding action. Note, case
         is insignificant, but trailing spaces are significant. The left,
         middle and right mouse buttons are represented by the upper case
         characters A, D and X respectively (this is imposed by PGPLOT). A
         dot ({\tt "}.{\tt "}) is considered equivalent to an X (i.e. the right mouse
         button). In addition, due to problems in the GKS version of PGPLOT,
         a space ({\tt "} {\tt "}) is considered equivalent to an A (i.e. left mouse
         button).

         The {\tt "}X{\tt "} and {\tt "}.{\tt "} keys (or equivalently the right mouse button) are
         special in that (if they are included in KEYS) they cause the routine
         to exit without adding the cursor position to the list of returned
         positions. If KEYS includes neither {\tt "}X{\tt "} nor {\tt "}.{\tt "}, then presses of
         {\tt "}X{\tt "}, {\tt "}.{\tt "} or the right mouse button are ignored.
      }
      \sstsubsection{
         X1 = REAL (Given)
      }{
         World co-ord X at lower left corner of region in which positons
         may be entered.
      }
      \sstsubsection{
         X2 = REAL (Given)
      }{
         World co-ord X at upper right corner of region in which positons
         may be entered. If X1 and X2 are equal then no restrictions are
         placed on the region in which positions may be given.
      }
      \sstsubsection{
         Y1 = REAL (Given)
      }{
         World co-ord Y at lower left corner of region in which positons
         may be entered.
      }
      \sstsubsection{
         Y2 = REAL (Given)
      }{
         World co-ord Y at upper right corner of region in which positons
         may be entered. If Y1 and Y2 are equal then no restrictions are
         placed on the region in which positions may be given.
      }
      \sstsubsection{
         EXACT = REAL (Given)
      }{
         The index of an exit action. If the corresponding key/button press
         is made, then the cursor position is added to the list of returned
         positions and the routine then exits. Zero can be supplied if this
         facility is not required. Note, if KEYS contains {\tt "}X{\tt "} or {\tt "}.{\tt "} then
         the routine also exits (WITHOUT adding the cursor position to the
         returned list) if {\tt "}X{\tt "}, {\tt "}.{\tt "} or the right mouse button is pressed.
      }
      \sstsubsection{
         X0 = REAL (Given )
      }{
         The X world co-ordinate of the initial cursor position.
         Ignored if VAL\_\_BADR.
      }
      \sstsubsection{
         Y0 = REAL (Given )
      }{
         The Y world co-ordinate of the initial cursor position.
         Ignored if VAL\_\_BADR.
      }
      \sstsubsection{
         MAXPNT = INTEGER (Given)
      }{
         The maximum number of positions which can be given by the user
         before exiting.
      }
      \sstsubsection{
         RBMODE = INTEGER (Given)
      }{
         The form of the rubber band which connects the cursor to the
         previous position. Rubber bands are not available when using the
         GKS version of PGPLOT:
            0 - do not use a rubber band.
            1 - use a straight-line rubber band.
            2 - use a horizontal box rubber band.
      }
      \sstsubsection{
         LINE = INTEGER (Given)
      }{
         Specifies lines to be drawn as follows:
         \sstitemlist{

            \sstitem
               1: Join adjacent points and do not close the polygon.
                0: Do not draw any lines.
                1: Join adjacent points and close the polygon.
                2: Draw a vertical line between y1 and y2 (or the height of
                   the window if y1=y2).
                3: Draw a horizontal line between x1 and x2 (or the width of
                   the window if x1=x2).
            The plotting attributes are specified by the CURVES(...) attributes
            of the supplied Plot (see IPLOT).
         }
      }
      \sstsubsection{
         BOX = INTEGER (Given)
      }{
         If non-zero then a horizontal box is drawn between each position.
         The plotting attributes are specified by the BORDER(...) attributes
         of the supplied Plot (see IPLOT).
      }
      \sstsubsection{
         MARK = INTEGER (Given)
      }{
         If -31 or larger, then a marker is drawn at each position. The
         type of marker is given by the specific value (see PGPLOT routine
         PGPT). The plotting attributes are specified by the MARKERS(...)
         attributes of the supplied Plot (see IPLOT).
      }
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         Defines the plotting styles for any graphics (see LINE, BOX and
         MARK). If AST\_\_NULL is supplied, ther current PGPLOT attributes
         are used for all graphics.
      }
      \sstsubsection{
         X( MAXPNT ) = REAL (Returned)
      }{
         Elements 1 to NPNT hold the selected X positions.
      }
      \sstsubsection{
         Y( MAXPNT ) = REAL (Returned)
      }{
         Elements 1 to NPNT hold the selected X positions.
      }
      \sstsubsection{
         ACT( MAXPNT ) = INTEGER (Returned)
      }{
         Elements 1 to NPNT hold the indices of the actions for each
         selected point. In range 1 to NACT.
      }
      \sstsubsection{
         NPNT = INTEGER (Returned)
      }{
         The number of positions given by the user (this includes the
         position at which the action specified by EXACT was pressed -
         if it was. It does not include the position at which {\tt "}X{\tt "}, {\tt "}.{\tt "} or
         the right mouse button was pressed).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGCUT
}{
   Cut a section out of the current PGPLOT window
}{
   \sstdescription{
      This routine sets the PGPLOT viewport so that it covers a specified
      section of the current PGPLOT window. The world co-ordinate bounds
      of the corresponding window are set to the supplied bounds.
   }
   \sstinvocation{
      CALL  KPG1\_PGCUT( X1, X2, Y1, Y2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X1 = REAL (Given)
      }{
         The X world co-ordinate at the bottom left corner of the section
         of the viewport to be cut.
      }
      \sstsubsection{
         X2 = REAL (Given)
      }{
         The X world co-ordinate at the top right corner of the section
         of the viewport to be cut.
      }
      \sstsubsection{
         Y1 = REAL (Given)
      }{
         The Y world co-ordinate at the bottom left corner of the section
         of the viewport to be cut.
      }
      \sstsubsection{
         Y2 = REAL (Given)
      }{
         The Y world co-ordinate at the top right corner of the section
         of the viewport to be cut.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGESC
}{
   Remove PGPLOT escape sequences from a text string
}{
   \sstdescription{
      This routine removes PGPLOT escape sequences form a text string.
      Any {\tt "}$\backslash${\tt "} characters in the string are removed, together with the
      character following each {\tt "}$\backslash${\tt "}.
   }
   \sstinvocation{
      CALL  KPG1\_PGESC( TEXT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The text string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGHNM
}{
   Return an HDS name describing the current PGPLOT graphics device
}{
   \sstdescription{
      This routine returns a string which can be used as an HDS component
      name. The string describes the current PGPLOT graphics device. It is
      intended for use in identifying resources related to the graphics
      device (such as palette and colour table), stored within HDS files.

      For most devices, the returned name is simply the PGPLOT device type.
      For GWM windows, the returned string includes the name of the gwm
      window (so that each window can have separate resources).
   }
   \sstinvocation{
      CALL KPG1\_PGHNM( NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( DAT\_\_SZNAM ) (Returned)
      }{
         The returned string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_PGLOC
}{
   Locates a component of an HDS structure relating to the currently
   opened PGPLOT device
}{
   \sstdescription{
      LOC1 is an locator for an HDS structure which contains components
      relating to one or more PGPLOT devices. These components, for
      instance, may contain the colour palette or colour table to be used
      with the corresponding PGPLOT device. This routine searches the
      structure for a component relating to the currently opened PGPLOT
      device, and returns a locator for it if found. If not found, and
      if the currently opened PGPLOT device is a GWM window, a search is
      made for a component relating to a GWM window with a different name.
      If no such device is found, (or if an error occurs) DAT\_\_NOLOC is
      returned.

      For instance, if the currently opened graphics device is {\tt "}x2windows{\tt "}
      (i.e. {\tt "}xwindows2/GWM{\tt "}), a search is made first for a component called
      AGI\_3801\_2. If this is not found, a search is made for a component
      with a name corresponding to any /GWM device (e.g. AGI\_3800\_1 which
      corresponds to {\tt "}xwindows/GWM{\tt "}, or one of the other xwindows sevices).

      The component names used are the same as the names uses for the device
      within the AGI database (e.g. {\tt "}AGI\_3801\_2{\tt "}, etc).
   }
   \sstinvocation{
      CALL KPG1\_PGLOC( LOC1, LOC2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A locator for the object to be searched.
      }
      \sstsubsection{
         LOC2 = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         A locator for the found component.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A PGPLOT device must previously have been opened using AGI.
      }
   }
}
\sstroutine{
   KPG1\_PGLUT
}{
   Use an array of colour representations to set up the PGPLOT colour
   table
}{
   \sstdescription{
      This routine stores new colour representations for a range of PGPLOT
      colour indices. A list of NCOL colour representations is supplied.
      These are normalized so that the highest value produces full colour
      intensity. The first colour (1) is assigned to PGPLOT colour index LO,
      and the last (NCOL) is assigned to PGPLOT colour index HI. The colour
      representations for the PGPLOT colour indices between LO and HI
      are formed by interpolation amonst the supplied NCOL colours, using
      either nearest-neighbour or linear interpolation.
   }
   \sstinvocation{
      CALL KPG1\_PGLUT( NCOL, COLS, LO, HI, NN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCOL = INTEGER (Given)
      }{
         The number of colour indices in the supplied colour table.
      }
      \sstsubsection{
         COLS( 3, NCOL ) = REAL (Given)
      }{
         The lookup table.  The first dimension is RGB.  Values
         should lie in the range 0.0--1.0.
      }
      \sstsubsection{
         LO = INTEGER (Given)
      }{
         The lowest PGPLOT colour index to use.
      }
      \sstsubsection{
         HI  = INTEGER (Given)
      }{
         The highest PGPLOT colour index to use.
      }
      \sstsubsection{
         NN = LOGICAL (Given)
      }{
         If true, and the number of input and output colour indices are
         different, the nearest-neighbour method is used for assigning
         values in the output array.  Otherwise linear interpolation
         is used.  Nearest-neighbour preserves sharp edges in the
         lookup; linear interpolation is recommended for smoothly
         varying lookup tables.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_PGOPN
}{
   Opens the AGI database and activate a PGPLOT workstation
}{
   \sstdescription{
      This routine opens the graphics database and activates a PGPLOT
      workstation selected using the specified parameter. The user{\tt '}s
      palette and colour table is then re-instated, over-riding the
      those established by PGPLOT.

      The device should normally be shut down using KPG1\_PGCLS.
   }
   \sstinvocation{
      CALL KPG1\_PGOPN( PNAME, MODE, IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The AGI access mode; {\tt "}WRITE{\tt "} or {\tt "}UPDATE{\tt "}. Write causes the
         current picture to be cleared (the contents of the database are
         unaffected).
      }
      \sstsubsection{
         IPIC = INTEGER (Returned)
      }{
         An AGI identifier for the current picture.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGPIX
}{
   Display an image using PGPLOT
}{
   \sstdescription{
      This routine uses PGPIXL to display an array of colour indices
      as a rectangular image. The area occupied by the array of colour
      indices is specified within a nominated Domain. Two opposite
      corners of this area are transformed into the Base Frame
      of the Plot (which should correspond to the current PGPLOT world
      co-ordinate sysytem), and the array of colour indices is drawn
      between these two transformed positions.
   }
   \sstinvocation{
      CALL  KPG1\_PGPIX( IPLOT, DOMAIN, LBND, UBND, NX, NY, COLI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         A pointer to an AST Plot. The Base Frame in this Plot should
         correspond to the world co-ordinates in the current PGPLOT window.
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain in which the coordinates supplied in BOX are defined.
      }
      \sstsubsection{
         LBND( 2 ) = REAL (Given)
      }{
         The lower bounds of the area covered by the supplied array of
         colour indices, in the Domain given by DOMAIN.
      }
      \sstsubsection{
         UBND( 2 ) = REAL (Given)
      }{
         The upper bounds of the area covered by the supplied array of
         colour indices, in the Domain given by DOMAIN.
      }
      \sstsubsection{
         NX = INTEGER
      }{
         Number of columns in the array of colour indices.
      }
      \sstsubsection{
         NY = INTEGER
      }{
         Number of rows in the array of colour indices.
      }
      \sstsubsection{
         COLI( NX, NY ) = INTEGER (Given)
      }{
         The array of colour indices.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGSHT
}{
   Set the PGPLOT character size in world coordinates
}{
   \sstdescription{
      This routine sets the PGPLOT character size to a specified value in
      world coordinates. It mimics SGS\_SHTX in so far as this is possible.

      Note SGS and PGPLOT behave differently if the scales on the X and Y
      axes are not equal. SGS keeps the character size constant in world
      oordinates, so absolute character size will be different for vertical
      and horizontal text. On the other hand, PGPLOT keeps the absolute
      character size fixed, resulting in the characters size in world
      coordinates varying for horizontal and vertical text. This routine
      sets the size for horizontal text. If the axis scales are not equal,
      vertical text will have have a different size (in world coordinates).
   }
   \sstinvocation{
      CALL  KPG1\_PGSHT( HGT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         HGT = REAL (Given)
      }{
         The required character height, in world coordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGSTY
}{
   Establish values for graphics attributes
}{
   \sstdescription{
      This routine establishes current PGPLOT attributes so that they
      correspond to the values for a named graphics element stored in the
      supplied Plot (see SUN/210). Only attributes which have values
      explicitly set in the Plot are changed. If no value has been set
      for a Plot attribute, the corresponding PGPLOT attribute is left
      unchanged.

      If SET is supplied .TRUE., then the PGPLOT attributes for the
      specified graphics element are extracted from the supplied Plot and
      made active. The previously active values are returned in ATTRS. If
      SET is supplied .FALSE., the values supplied in ATTRS are made current
      (in this case ATTRS is returned unchanged).
   }
   \sstinvocation{
      CALL KPG1\_PGSTY( IPLOT, ELEM, SET, ATTRS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to a Plot.
      }
      \sstsubsection{
         ELEM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of an AST graphics element.
      }
      \sstsubsection{
         SET = LOGICAL (Given)
      }{
         Should the Plot values be made curent? Otherwise the values in
         ATTRS are made current.
      }
      \sstsubsection{
         ATTS( $*$ ) = DOUBLE PRECISION (Given and Returned)
      }{
         On entry, the attribute values to set if SET is .FALSE., These
         should have been obtained from a previous call to this routine.
         On exit, the attribute values current on entry to this routine
         are returned (unless SET is .FALSE. in which case the supplied values
         are returned unchanged). This array should have at least 5 elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGTXT
}{
   Draw text using PGPLOT and return concatenation point
}{
   \sstdescription{
      This routine plots the supplied text at a given angle using
      PGPLOT, putting the bottom left corner of the text at the
      supplied position. The position at which another string must be
      drawn to concatenate it with the string just drawn is returned.
   }
   \sstinvocation{
      CALL KPG1\_PGTXT( ANGLE, TEXT, X, Y, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ANGLE = INTEGER (Given)
      }{
         The angle, in degrees, that the baseline is to make with the
         horizontal, increasing anti-clockwise (0.0 is horizontal).
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to draw. The returned values of X and Y leave room for
         any trailing spaces, UNLESS THE ENTIRE STRING IS BLANK, IN WHICH
      }
   }
   \sstdiytopic{
      $*$       CASE X AND Y ARE RETURNED UNCHANGED.
   }{
         X = REAL (Given and Returned)
            The X position for the bottom left corner of the string.
            On exit, it is the X position at the bottom of the a string
            to be concatenated to the one just drawn.
         Y = REAL (Given and Returned)
            The Y position for the bottom left corner of the string.
            On exit, it is the Y position at the bottom of the a string
            to be concatenated to the one just drawn.
         STATUS = INTEGER (Given and Returned)
            The global status.

      Copyright:
         Copyright (C) 1998 Central Laboratory of the Research Councils.
         All Rights Reserved.

      Licence:
         This program is free software; you can redistribute it and/or
         modify it under the terms of the GNU General Public License as
         published by the Free Software Foundation; either version 2 of
         the License, or (at your option) any later version.

         This program is distributed in the hope that it will be
         useful,but WITHOUT ANY WARRANTY; without even the implied
         warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
         PURPOSE. See the GNU General Public License for more details.

         You should have received a copy of the GNU General Public License
         along with this program; if not, write to the Free Software
         Foundation, Inc., 59 Temple Place,Suite 330, Boston, MA
         02111-1307, USA

      Authors:
         DSB: David S. Berry (STARLINK)

      History:
         17-MAR-1998 (DSB):
            Original version.

      Bugs:
   }
}
\sstroutine{
   KPG1\_PIXSC
}{
   Determines pixel scales at a given grid position
}{
   \sstdescription{
      This routine determines the scales of the WCS axes in the current
      Frame of the supplied FrameSet. For a specified WCS axis, the
      returned scale is the WCS axis increment produced by moving a
      distance of one grid pixel away from the supplied {\tt "}AT{\tt "} position,
      along the WCS axis.
   }
   \sstinvocation{
      CALL KPG1\_PIXSC( IWCS, AT, PIXSC, VALUE, UNIT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         The FrameSet.
      }
      \sstsubsection{
         AT( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The position in GRID co-ordinates at which the pixel scales are
         to be determined. Note, the pixel scales may vary across the data
         array if the WCS Mappings are non-linear. The array should have
         one element for each GRID axis.
      }
      \sstsubsection{
         PIXSC( $*$ ) = DOUBLE PRECISION (Returned)
      }{
         The returned pixel scales. Note, the pixel scale for both celestial
         longitude and latitude axes are returned as an arc-distance in
         radians. The array should have one element for each WCS axis.
      }
      \sstsubsection{
         VALUE( $*$ ) = CHARACTER( $*$ ) (Returned)
      }{
         The formatted pixel scales. Celestial axes are formatted as
         arc-seconds using a {\tt "}G15.6{\tt "} format. Time values are also formatted
         using G15.6 (the Format attribute in the current WCS Frame is
         ignored, since it may produce a calendar date), in what ever
         units are indicated in the current Frame. Other types of
         axes (including spectral axes) are formatted using the axis Format
         attribute in the current WCS Frame. The array should have one
         element for each WCS axis. Each element of the array should be at
         least 15 characters long. The returned text is left justified.
      }
      \sstsubsection{
         UNIT( $*$ ) = CHARACTER( $*$ ) (Returned)
      }{
         Units strings that describe the values returned in VALUES. The
         array should have one element for each WCS axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PL2GE
}{
   Reads two-dimensional polynomial information from a POLYNOMIAL
   structure
}{
   \sstdescription{
      This routine reads information describing a two-dimensional
      polynomial surface from a standard Starlink POLYNOMIAL structure,
      as defined in SGP/38.  All floating-point information within the
      structure is returned as DOUBLE PRECISION.

      It is assumed the calling programme needs a one-dimensional array
      of coefficients, where COEFF( (IX-1)$*$NYPAR $+$ IY ) contains the
      coefficient for the (IX,IY)th term (with NYPAR being the total
      number of Y terms).  Such a one-dimensional array is used by the
      NAG routines and defined in the NAG manual (see Chapter E02 on
      {\tt "}Curve and Surface fitting{\tt "}).

      This routine will convert read the two-dimensional coefficient
      array from the POLYNOMIAL structure (in the format described in
      SGP/38) and load a flipped version of this into the required
      one-dimensional array.  If there is a variance array present, the
      VARPRE flag is set .TRUE., and the variances returned in VARIAN.

      The routine will also read the TMIN and TMAX arrays from the
      structure and return XMIN, XMAX, YMIN and YMAX.  Note that these
      items are compulsory when VARNT={\tt '}CHEBYSHEV{\tt '} but optional when
      VARNT={\tt '}SIMPLE{\tt '}.  In the latter case an attempt will be made to
      read TMIN and TMAX from the structure, but their absence will not
      be regarded as an error.  The returned parameter LIMITS will
      indicate if these items have been read successfully.
   }
   \sstinvocation{
      CALL KPG1\_PL2GE( LOC, MXPAR, VARNT, NXPAR, NYPAR, LIMITS, XMIN,
                       XMAX, YMIN, YMAX, COEFF, VARPRE, VARIAN, WORK,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER$*$( DAT\_\_SZLOC ) (Given)
      }{
         Locator to the existing POLYNOMIAL structure.
      }
      \sstsubsection{
         MXPAR = INTEGER (Given)
      }{
         The maximum number of parameters in either x or y.  The
         declared size of the coefficient arrays given to this routine
         is assumed to be MXPAR $*$ MXPAR (see below).
      }
      \sstsubsection{
         VARNT = CHARACTER$*$($*$) (Returned)
      }{
         Variant of the polynomial ({\tt '}CHEBYSHEV{\tt '} or {\tt '}SIMPLE{\tt '}).  This
         item should be at least CHARACTER$*$9.
      }
      \sstsubsection{
         NXPAR = INTEGER (Returned)
      }{
         Number of x parameters (= order of polynomial in x direction $+$
         1).
      }
      \sstsubsection{
         NYPAR = INTEGER (Returned)
      }{
         Number of y parameters (= order of polynomial in Y direction $+$
         1).
      }
      \sstsubsection{
         LIMITS = LOGICAL (Returned)
      }{
         When VARNT={\tt '}SIMPLE{\tt '} this logical flag indicates whether any
         TMIN and TMAX limits have been read from the polynomial
         structure and returned in the next four arguments (in which
         case LIMITS will be .TRUE.).
      }
      \sstsubsection{
         XMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum value along x axis for which polynomial is valid.
      }
      \sstsubsection{
         XMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum value along x axis for which polynomial is valid.
      }
      \sstsubsection{
         YMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum value along y axis for which polynomial is valid.
      }
      \sstsubsection{
         YMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum value along y axis for which polynomial is valid.
      }
      \sstsubsection{
         COEFF( MXPAR $*$ MXPAR ) = DOUBLE PRECISION (Returned)
      }{
         Array of polynomial coefficients, in the format used by NAG
         routines (see KPS1\_FSPF2).
      }
      \sstsubsection{
         VARPRE = LOGICAL (Returned)
      }{
         Whether or not there are coefficient variances present in the
         POLYNOMIAL structure.
      }
      \sstsubsection{
         VARIAN( MXPAR $*$ MXPAR ) = DOUBLE PRECISION (Returned)
      }{
         Array of polynomial coefficient variances, in the format used
         by NAG routines.  The values are only assigned when VARPRE is
         .TRUE..
      }
      \sstsubsection{
         WORK( MXPAR, MXPAR ) = DOUBLE PRECISION (Returned)
      }{
         Work array containing the two-dimensional array of
         coefficients as read from the POLYNOMIAL structure.
      }
      \sstsubsection{
         STATUS =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Uses the magic-value method for bad or undefined pixels.
      }
   }
}
\sstroutine{
   KPG1\_PL2PU
}{
   Writes 2-dimensional polynomial information to a POLYNOMIAL
   structure
}{
   \sstdescription{
      This routine writes information describing a two-dimensional
      polynomial surface to a standard Starlink POLYNOMIAL structure,
      as defined in SGP/38.  An empty POLYNOMIAL structure should
      already have been created.  All floating point components within
      the structure are written as DOUBLE PRECISION.

      It is assumed the calling programme has a one-dimensional array of
      coefficients, where COEFF( ( IX - 1 ) $*$ NYPAR $+$ IY ) contains the
      coefficient for the (IX,IY)th term (with NYPAR being the total
      number of Y terms).  Such a one-dimensional array is used by the
      NAG routines and defined in the NAG manual (see Chapter E02 on
      {\tt "}Curve and Surface fitting{\tt "}).

      This routine will convert the coefficient array to
      two-dimensional, flip it around and store it in the POLYNOMIAL
      structure so that DATA\_ARRAY(IX,IY) contains the coefficient for
      the (IX,IY)th term (see SGP/38).

      The routine will also load the TMIN and TMAX arrays with XMIN,
      XMAX, YMIN and YMAX.  Note that these are compulsory when
      VARNT={\tt '}CHEBYSHEV{\tt '} but optional when VARNT={\tt '}SIMPLE{\tt '}.  In the latter
      case the logical parameter LIMITS will be used to decide whether
      to write the limits.  All the components have type \_DOUBLE.
   }
   \sstinvocation{
      CALL KPG1\_PL2PU( LOC, VARNT, NXPAR, NYPAR, LIMITS, XMIN, XMAX,
                       YMIN, YMAX, COEFF, VARIAN, WORK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given)
      }{
         Locator to existing but empty POLYNOMIAL structure.
      }
      \sstsubsection{
         VARNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Variant of the polynomial ({\tt '}CHEBYSHEV{\tt '} or {\tt '}SIMPLE{\tt '}).  (This is
         written but not checked).
      }
      \sstsubsection{
         NXPAR = INTEGER (Given)
      }{
         Number of x parameters (= order of polynomial in x direction $+$
         1)
      }
      \sstsubsection{
         NYPAR  = INTEGER (Given)
      }{
         Number of y parameters (= order of polynomial in y direction $+$
         1)
      }
      \sstsubsection{
         LIMITS = LOGICAL (Given)
      }{
         When VARNT={\tt '}SIMPLE{\tt '} this logical flag may be used to control
         whether the TMIN and TMAX limits are written to the polynomial
         structure (based on the next 4 arguments).  Setting
         LIMITS=.TRUE. will cause the limits to be written.  This
         parameter is ignored when VARNT={\tt '}CHEBYSHEV{\tt '}, as the limits
         then are compulsory.
      }
      \sstsubsection{
         XMIN = DOUBLE PRECISION (Given)
      }{
         Minimum value along x axis for which polynomial is valid.
      }
      \sstsubsection{
         XMAX = DOUBLE PRECISION (Given)
      }{
         Maximum value along x axis for which polynomial is valid.
      }
      \sstsubsection{
         YMIN = DOUBLE PRECISION (Given)
      }{
         Minimum value along y axis for which polynomial is valid.
      }
      \sstsubsection{
         YMAX = DOUBLE PRECISION (Given)
      }{
         Maximum value along y axis for which polynomial is valid.
      }
      \sstsubsection{
         COEFF( NXPAR $*$ NYPAR ) = DOUBLE PRECISION (Given)
      }{
         Array of polynomial coefficients, in the format used by NAG
         routines.
      }
      \sstsubsection{
         VARIAN( NXPAR $*$ NYPAR ) = DOUBLE PRECISION (Given)
      }{
         Array of variances of polynomial coefficients, in the format
         used by NAG routines.
      }
      \sstsubsection{
         WORK( NXPAR, NYPAR ) = DOUBLE PRECISION (Returned)
      }{
         Work array used to flip the polynomial coefficients.  On exit
         it will contain the two-dimensional array of coefficients
         written to the POLYNOMIAL structure.
      }
      \sstsubsection{
         STATUS =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Uses the magic-value method for bad or undefined pixels.
      }
   }
}
\sstroutine{
   KPG1\_PLCIP
}{
   Finds the nearest colour in the palette to a named colour
   (PGPLOT version of KPG1\_PALCI)
}{
   \sstdescription{
      This routine finds the PGPLOT colour index within the palette of a
      named colour.  The required colour must be in the standard colour
      set, and SAI\_\_ERROR status is returned if it is not.  If the
      named colour is not present the index of the colour nearest to
      the requested colour is returned.  A city-block metric is used.

      A close colour is only accepted if the close colour is not equal
      to the background colour.  This avoids pens becoming invisible.
   }
   \sstinvocation{
      CALL KPG1\_PLCIP( COLOUR, COLIND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         COLOUR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the colour whose colour index is required.
         Note at least eighteen characters are required to avoid
         truncation.  The name may be abbreviated.  If there is any
         ambiguity, the first match (in alphabetical order) is selected.
      }
      \sstsubsection{
         COLIND = INTEGER (Returned)
      }{
         The colour index within the palette of the colour or its
         nearest equivalent.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A PGPLOT image-display workstation must be open and active.
      }
   }
}
\sstroutine{
   KPG1\_PLGET
}{
   Get the colour palette for the currently open graphics device from
   a supplied array
}{
   \sstdescription{
      This routine gets the colour palette from a supplied array and
      loads it into the colour table of the currently open graphics device.
   }
   \sstinvocation{
      CALL KPG1\_PLGET( CI1, CI2, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI1 = INTEGER (Given)
      }{
         The lowest colour index to change.
      }
      \sstsubsection{
         CI2 = INTEGER (Given)
      }{
         The highest colour index to change.
      }
      \sstsubsection{
         ARRAY( 3, 0 : CI2 ) = REAL (Given)
      }{
         The array containing the colour palette to load.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_PLLOD
}{
   Load the colour palette for the currently open graphics device
}{
   \sstdescription{
      This routine loads the colour palette for the currently open graphics
      device from an HDS container file in the users ADAM directory. The
      file is called {\tt "}kappa.palette.sdf{\tt "} and contains a palette for
      different devices. The file should have been created by KPG1\_PLSAV.
      If the file does not exist, the current colour table is left unchanged.

      Each palette in the file is a \_REAL array of shape (3,n) where
      n is the number of colours in the palette. The first colour (index 1
      in the array) is the background colour and is usually refered to as
      colour index zero. Therefore the highest colour index in the array is
      (n-1). Each array has a name which identifies the graphics device
      to which it refers. Each array has a name which identifies the
      graphics device to which it refers.
   }
   \sstinvocation{
      CALL KPG1\_PLLOD( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_PLOTA
}{
   Opens the graphics device and see if there is an existing DATA
   picture with which the new DATA picture could be aligned
}{
   \sstdescription{
      This routine opens a graphics device, clearing it or not as
      specified by the user. If it is not cleared an attempt is made to
      find a DATA picture within the current picture. If found it
      becomes the current AGI picture, the corresponding PGPLOT viewport
      is established as the current PGPLOT viewport, and an AST Plot is
      returned for it in which the Base (GRAPHICS) Frame corresponds to
      PGPLOT world co-ordinates. If no DATA picture is found, or if the
      device was not cleared on opening, the current AGI picture and
      PGPLOT viewport are unchanged on exit and no Plot is returned.

      Various environment parameters are used to obtain options, etc.
      The names of these parameters are hard-wired into this subroutine
      in order to ensure conformity between applications.
   }
   \sstinvocation{
      CALL KPG1\_PLOTA( IWCS, STAT, DOMAIN, IPIC0, IPICD, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer to a FrameSet. This may be AST\_\_NULL. The
         Current and Base Frames are unchanged on exit. If an existing
         DATA picture was created by a non-AST application it will not
         have a Plot stored with it. A default Plot will be created in
         this case, containing two Frames; a GRAPHICS Frame
         corresponding to millimetres from the bottom-left corner of the
         view surface, and a Frame corresponding to AGI world
         co-ordinates. The AGI database does not contain any information
         describing world co-ordinates and so such information must be
         supplied by the calling application, on some assumption such as
         {\tt "}AGI world co-ordinates are PIXEL co-ordinates{\tt "}. This
         information is provided through a FrameSet (IWCS) and a Domain
         name (DOMAIN). DOMAIN specifies the Domain in which AGI world
         co-ordinates are assumed to live. A FrameSet may then be
         supplied using argument IWCS containing a Frame with the same
         Domain which will be used to describe AGI world co-ordinates in
         the returned Plot (a default two-dimensional Frame with the
         specified Domain is used if no FrameSet is supplied or if it
         does not contain a Frame with the specified Domain). If DOMAIN
         is supplied Blank, a default two-dimensional Frame with Domain
         AGI\_WORLD will be used to describe AGI world co-ordinates.

         If the existing DATA picture was created by an AST application,
         it will have a Plot stored with it which means that AGI world
         co-ordinates will be ignored. Consequently, the values supplied
         for IWCS and DOMAIN will also be ignored.
      }
      \sstsubsection{
         STAT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Determines whether or not the new DATA picture creted by the
         calling application is to be aligned with an existing DATA
         picture.

         \sstitemlist{

            \sstitem
            {\tt "}NEW{\tt "} -- no attempt is made to align the new DATA picture
            with an existing DATA picture, even if the CLEAR parameter is
            given a FALSE value.

            \sstitem
            {\tt "}OLD{\tt "} -- the new DATA picture is always aligned with an
            existing DATA picture. The CLEAR parameter is not accessed (it
            is assumed to have a FALSE value) and an error is reported if
            no DATA picture is available.

            \sstitem
            {\tt "}UNKNOWN{\tt "} -- If CLEAR is given a FALSE value then the new
            DATA picture is aligned with any existing DATA picture, but no
            error is reported if no DATA picture exists.
         }
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain for AGI world co-ordinates. Only used if a FrameSet
         is supplied (IWCS). If a blank value is supplied then
         {\tt "}AGI\_WORLD{\tt "} will be used. See description of argument IWCS
         above for more details.
      }
      \sstsubsection{
         IPIC0 = INTEGER (Returned)
      }{
         An AGI identifier for the original current picture.
      }
      \sstsubsection{
         IPICD = INTEGER (Returned)
      }{
         An AGI identifier for the existing DATA picture. Returned equal
         to -1 if there is no existing DATA picture or if the device was
         cleared on opening.
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         An AST pointer to a Plot associated with an existing DATA
         picture. Returned equal to AST\_\_NULL if an error occurs, or if
         there is no existing DATA picture, or if the device was
         cleared on opening.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Close down AGI and PGPLOT using KPG1\_PGCLS.
      }
   }
   \sstdiylist{
      Environment Parameters
   }{
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         TRUE if the graphics device is to be cleared on opening. See
         argument STAT.
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device.
      }
   }
}
\sstroutine{
   KPG1\_PLOT
}{
   Prepares for graphics output
}{
   \sstdescription{
      This routine opens a graphics device and prepares for graphical
      output using PGPLOT within a new DATA picture. Optional ancillary
      pictures around the DATA picture may also be created. A FRAME
      picture enclosing the DATA picture and any ancillary pictures is
      created if any ancillary pictures or non-zero margins were
      requested.

      An AST Plot is returned which allows plotting within the DATA
      picture. The Base (GRAPHICS) Frame in this Plot corresponds to
      millimetres from the botttom left corner of the view surface.
      The Current Frame in the Plot is inherited from the supplied
      FrameSet (IWCS).

      If there is an existing DATA picture on the device, then the new
      DATA picture can optionally be aligned with the existing DATA
      picture. In this case, the returned Plot is formed by adding any
      supplied FrameSet (IWCS) into the Plot stored with the existing
      DATA picture in the AGI database (a default Plot is used if the
      database does not contain a Plot). The FrameSet is added into the
      Plot by aligning them in the Current Frame of the FrameSet if
      possible. If this is not possible, they are aligned in the world
      co-ordinate system of the picture (stored in the AGI database).
      The Domain of the AGI world co-ordinate system is not stored in
      the database and must be supplied by the calling application using
      argument DOMAIN (this will usually be {\tt "}PIXEL{\tt "}). If alignment is
      not possible in AGI world co-ordinates, then they are aligned in
      the GRID domain. If this is also not possible, they are aligned in
      any suitable Frame.

      On exit, the current PGPLOT viewport corresponds to area occupied
      by the new DATA picture. The bounds of the PGPLOT window produce a
      world co-ordinate system within the viewport corresponding to the
      Base Frame in the returned Plot (i.e. millimetres from the
      bottom-left corner of the view surface - NOT pixel co-ordinates).
      Note, this is different from the world co-ordinate system stored
      in the AGI database with the new DATA picture.

      If the returned Plot contains an AXIS Frame in which the axes are
      scaled and shifted versions of the axes of the AGI world
      co-ordinate Frame (specified by argument DOMAIN), then a
      TRANSFORM structure is stored with the new DATA picture that
      defines AGI Data co-ordinates. This is purely for the benefit of
      non-AST based applications which may use AGI Data co-ordinates
      (AST-based applications should always use the Plot stored with the
      picture in preference to the TRANSFORM structure stored in the AGI
      database).

      Various environment parameters are used to obtain options, etc.
      The names of these parameters are hard-wired into this subroutine
      in order to ensure conformity between applications.
   }
   \sstinvocation{
      CALL KPG1\_PLOT( IWCS, STAT, APP, DATREF, MARGIN, NP, PNAME, PSIDE,
                      PSIZE, ASPECT, DOMAIN, BOX, IPICD, IPICF, IPIC,
                      IPLOT, NFRM, ALIGN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer to a FrameSet. This may be AST\_\_NULL. The
         Current and Base Frames are unchanged on exit.
      }
      \sstsubsection{
         STAT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Determines whether or not the new DATA picture should be
         aligned with an existing DATA picture.

         \sstitemlist{

            \sstitem
            {\tt "}NEW{\tt "} -- no attempt is made to align the new DATA picture
            with an existing DATA picture, even if the CLEAR parameter is
            given a FALSE value.

            \sstitem
            {\tt "}OLD{\tt "} -- the new DATA picture is always aligned with an
            existing DATA picture. The CLEAR parameter is not accessed (it
            is assumed to have a FALSE value) and an error is reported if
            no DATA picture is available.

            \sstitem
            {\tt "}UNKNOWN{\tt "} -- If CLEAR is given a FALSE value then the new
            DATA picture is aligned with any existing DATA picture, but no
            error is reported if no DATA picture exists.
         }
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the calling application, in the form
         $<$package$>$\_$<$application$>$ (e.g. {\tt "}KAPPA\_DISPLAY{\tt "},
         {\tt "}POLPACK\_POLPLOT{\tt "}, etc.). The supplied string is stored as a
         comment with all new AGI pictures.
      }
      \sstsubsection{
         DATREF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string describing the source of the data being displayed,
         which will be stored in the AGI database with the new DATA
         picture. It is ignore if blank.
      }
      \sstsubsection{
         MARGIN( 4 ) = REAL (Given)
      }{
         The width of the borders to leave around the new DATA picture,
         given as fractions of the corresponding dimension of the DATA
         picture. These should be supplied in the order bottom, right,
         top, left.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The number of extra pictures to be included in the FRAME
         pictures (the DATA picture itself is not included in this
         list). Margins are left around the DATA picture with widths
         given by MARGIN. Any extra pictures are placed outside these
         margins, in positions described by PSIDE and PSIZE.
      }
      \sstsubsection{
         PNAME( NP ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names to store in the AGI database with the NP extra
         pictures.
      }
      \sstsubsection{
         PSIDE( NP ) = CHARACTER $*$ 1 (Given)
      }{
         Each element of this array should be one of L, R, T or B. It
         indicates which side of the FRAME picture an extra picture is
         to be placed. For Left and Right, the extra picture occupies
         the full height of the DATA picture, margins, and any
         previously created extra pictures. The picture is placed at the
         far Left or Right of all previously created pictures. For Top
         or Bottom, the extra picture occupies the full width of the
         DATA picture, margins, and any previously created extra
         pictures. The picture is placed at the top or bottom of all
         previously created pictures. Ignored if NP is zero.
      }
      \sstsubsection{
         PSIZE( NP ) = REAL (Given)
      }{
         The size of each extra picture. For Left and Right pictures,
         this is the width of the picture, and the value is given as a
         fraction of the width of the DATA picture. For Top and Bottom
         pictures, it is the height of the picture, and it is given as a
         fraction of the height of the DATA picture. Ignored if NP is
         zero.
      }
      \sstsubsection{
         ASPECT = REAL (Given)
      }{
         The aspect ratio for the DATA picture. This is the height of
         the DATA picture (in millimetres) divided by the width of the
         DATA picture (also in millimetres). The new DATA picture is
         created with this aspect ratio unless the FILL parameter is
         given a TRUE value, in which case the aspect ratio is adjusted
         to get the largest DATA picture that can be created within the
         current picture. If a value of zero is supplied, then the
         largest DATA picture is used irrespective of FILL (which is
         then not accessed).
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain name corresponding to the AGI world co-ordinates. If
         a blank value is supplied then {\tt "}AGI\_WORLD{\tt "} will be used.
      }
      \sstsubsection{
         BOX( 4 ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinates to be assigned to the bottom-left, and
         top-right corners of the DATA picture in the AGI database (the
         co-ordinate system in defined by argument DOMAIN). Only used if
         the new DATA picture is NOT being aligned with an existing DATA
         picture. Supplied in the order XLEFT, YBOTTOM, XRIGHT, YTOP.
         Note, the supplied bounds are stored in the AGI database, but
         do not effect the PGPLOT window on exit, which always has a
         world co-ordinate system of millimetres from the bottom-left
         corner of the view surface. If the supplied box has zero area,
         then world co-ordinates for the DATA picture in the AGI
         database will be centimetres from the bottom-left corner of
         the DATA picture.
      }
      \sstsubsection{
         IPICD = INTEGER (Returned)
      }{
         An AGI identifier for the new DATA picture.
      }
      \sstsubsection{
         IPICF = INTEGER (Returned)
      }{
         An AGI identifier for the new FRAME picture. World co-ordinate
         system is inherited from the current picture on entry. If no
         FRAME picture is created then an identifier for the current
         picture on entry is returned.
      }
      \sstsubsection{
         IPIC( NP ) = INTEGER (Returned)
      }{
         An array of AGI identifiers corresponding to the extra pictures
         requested in PSIDE and PSIZE. The world co-ordinate system for
         each picture is inherited from the FRAME picture. The actual
         size of a picture may be less than the requested size if there
         is insufficient room left in the FRAME picture to give it its
         requested size. Identifiers for pictures which would have zero
         size (i.e. fall completely outside the FRAME picture) are
         returned equal to -1, but no error is reported.
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         An AST pointer to the new Plot. Returned equal to AST\_\_NULL if
         an error occurs.
      }
      \sstsubsection{
         NFRM = INTEGER (Returned)
      }{
         A  Frame with index I in the supplied FrameSet (IWCS) will have
         index ( I $+$ NFRM ) in the returned Plot (IPLOT). Returned equal
         to zero if an error occurs.
      }
      \sstsubsection{
         ALIGN = LOGICAL (Returned)
      }{
         Was the new DATA picture aligned with an existing DATA picture?
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Picture identifiers are returned equal to -1 if an error
         occurs, or if any pictures cannot be created.

         \sstitem
         Close down AGI and PGPLOT using:
               CALL KPG1\_PGCLS( {\tt '}DEVICE{\tt '}, .FALSE., STATUS )
      }
   }
   \sstdiylist{
      Environment Parameters
   }{
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         TRUE if the graphics device is to be cleared on opening. See
         argument STAT.
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device.
      }
      \sstsubsection{
         FILL = \_LOGICAL (Read)
      }{
         TRUE if the supplied aspect ratio is to be ignored, creating
         the largest possible DATA picture within the current picture.
         When FILL is FALSE, the DATA picture is created with the
         supplied aspect ratio. Only used when creating a new DATA
         picture.
      }
      \sstsubsection{
         STYLE = GROUP (Read)
      }{
         A description of the plotting style required. This the name of
         a text file containing an AST attribute setting on each line,
         of the form {\tt "}name=value{\tt "}, where {\tt "}name{\tt "} is an AST Plot
         attribute name (or synonym recognised by this application--see
         KPG1\_ASPSY), and {\tt "}value{\tt "} is the value to assign to the
         attribute.
      }
   }
}
\sstroutine{
   KPG1\_PLOTN
}{
   Create a new DATA picture and ensure there is an AST Plot for it
}{
   \sstdescription{
      This routine createa an AST Plot describing a given DATA picture.
      If a FrameSet is supplied (IWCS), then it is merged with the
      Plot. An error is reported if the FrameSet and Plot cannot be
      aligned.

      On exit, the current PGPLOT viewport corresponds to area occupied by
      the DATA picture. The bounds of the PGPLOT window produce a world
      co-ordinate system within the viewport corresponding to the Base
      Frame in the returned Plot (i.e. millimetres from the bottom left
      corner of the view surface - NOT pixel coordinates). Note, this is
      different to the world co-ordinate system stored in the AGI database
      with the DATA picture.
   }
   \sstinvocation{
      CALL KPG1\_PLOTN( IWCS, DOMAIN, IPICD, IPLOT, NFRM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer to a FrameSet. This may be AST\_\_NULL. The Current
         and Base Frames are unchanged on exit.
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain in which AGI world co-ordinates within the specified
         DATA picture live. Alignment of the Plot and FrameSet will be
         attampted in this Domain if it is not possible in the Current
         Frame of the FrameSet.
      }
      \sstsubsection{
         IPICD = INTEGER (Given)
      }{
         An AGI identifier for the DATA picture.
      }
      \sstsubsection{
         QUIET = LOGICAL (Given)
      }{
         Suppress message identifying the Domain in which alignment occurs?
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         An AST pointer to the new Plot. Returned equal to AST\_\_NULL if
         an error occurs.
      }
      \sstsubsection{
         NFRM = INTEGER (Returned)
      }{
         A  Frame with index I in the supplied FrameSet (IWCS) will have index
         ( I $+$ NFRM ) in the returned Plot (IPLOT). Returned equal to zero
         if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PLOTP
}{
   Creates a new DATA picture, with optionally ancillary pictures
}{
   \sstdescription{
      This routine createa a new DATA picture, together with optional
      ancillary pictures around the DATA picture. The new DATA picture
      can be aligned with an existing DATA picture. A FRAME picture
      enclosing the DATA picture and any ancillary pictures is created
      if any ancillary pictures or non-zero margins were requested.

      On exit, the current PGPLOT viewport corresponds to area occupied
      by the new DATA picture. The bounds of the PGPLOT window produce a
      world co-ordinate system within the viewport corresponding to
      millimetres from the bottom-left corner of the view surface. Note,
      this is different to the world co-ordinate system stored in the AGI
      database with the new DATA picture.

      Various environment parameters are used to obtain options, etc. The
      names of these parameters are hard-wired into this subroutine in
      order to ensure conformity between applications.
   }
   \sstinvocation{
      CALL KPG1\_PLOTP( IPICD, APP, MARGIN, NP, PNAME, PSIDE, PSIZE,
                       ASPECT, BOX, IPICD0, IPICF, IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPICD = INTEGER (Given)
      }{
         The AGI identifier for an existing DATA picture. If this is
         supplied equal to -1, the size and extent of the new DATA picture
         are determined by BOX. Otherwise, the size and extent of the new
         DATA picture are set equal to the existing DATA picture.
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the calling application in the form
         $<$package$>$\_$<$application$>$ (eg {\tt "}KAPPA\_DISPLAY{\tt "}).
      }
      \sstsubsection{
         MARGIN( 4 ) = REAL (Given)
      }{
         The width of the borders to leave round the new DATA picture, given
         as fractions of the corresponding dimension of the DATA picture.
         These should be supplied in the order bottom, right, top, left.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The number of extra pictures to be included in the FRAME pictures
         (the DATA picture itself is not included in this list). Margins are
         left round the DATA picture with widths given by MARGIN. Any extra
         pictures are placed outside these margins, in positions described by
         PSIDE and PSIZE.
      }
      \sstsubsection{
         PNAME( NP ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names to store in the AGI database with the NP extra pictures.
      }
      \sstsubsection{
         PSIDE( NP ) = CHARACTER $*$ 1 (Given)
      }{
         Each element of this array should be one of L, R, T or B. It
         indicates which side of the FRAME picture an extra picture is to be
         placed. For Left and Right, the extra picture occupies the full
         height of the DATA picture, margins, and any previously created
         extra pictures. The picture is placed at the far Left or Right of
         all previously created pictures. For Top or Bottom, the extra picture
         occupies the full width of the DATA picture, margins, and any
         previously created extra pictures. The picture is placed at the top or
         bottom of all previously created pictures. Ignored if NP is zero.
      }
      \sstsubsection{
         PSIZE( NP ) = REAL (Given)
      }{
         The size of each extra picture. For Left and Right pictures, this is
         the width of the picture, and the value is given as a fraction
         of the width of the DATA picture. For Top and Bottom pictures, it is
         the height of the picture, and it is given as a fraction of the
         height of the DATA picture. Ignored if NP is zero.
      }
      \sstsubsection{
         ASPECT = REAL (Given)
      }{
         The aspect ratio for the DATA picture. This is the height of the
         DATA picture (in millimetres)  divided by the width of the DATA
         picture (also in millimetres). The new DATA picture is created with
         this aspect ratio unless the FILL parameter is given a TRUE value,
         in which case the aspect ratio is adjusted to get the largest DATA
         picture which can be created within the current picture. If a value
         of zero is supplied, then the largest DATA picture is used
         irrespective of FILL (which is then not accessed).
      }
      \sstsubsection{
         BOX( 4 ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinates to be assigned to the bottom-left, and top-right
         corners of the DATA picture in the AGI database (the co-ordinate
         system in defined by argument DOMAIN). Only used if the new DATA
         picture is NOT being aligned with an existing DATA picture. Supplied
         in the order XLEFT, YBOTTOM, XRIGHT, YTOP. Note, the supplied
         bounds are stored in the AGI database, but do not effect the PGPLOT
         window on exit, which always has a world co-ordinate system of
         millimetres from the bottom-left corner of the view surface. If
         the supplied box has zero area, then world co-ordinates for the
         DATA picture in the AGI database will be centimetres from the
         bottom-left corner of the DATA picture.
      }
      \sstsubsection{
         IPICD0 = INTEGER (Returned)
      }{
         An AGI identifier for the new DATA picture.
      }
      \sstsubsection{
         IPICF = INTEGER (Returned)
      }{
         An AGI identifier for the new FRAME picture. World co-ordinate system
         is inherited from the current picture on entry. If no FRAME picture
         is created then an identifier for the current picture on entry is
         returned.
      }
      \sstsubsection{
         IPIC( NP ) = INTEGER (Returned)
      }{
         An array of AGI identifiers corresponding to the extra pictures
         requested in ZSIDE and PSIZE. The world co-ordinate system for each
         picture is inherited from the FRAME picture. The actual size of a
         picture may be less than the requested size if there is insufficient
         room left in the FRAME picture to give it its requested size.
         Identifiers for pictures which would have zero size (i.e. fall
         completely outside the FRAME picture) are returned equal to -1, but
         no error is reported.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Picture identifiers are returned equal to -1 if the picture cannot
         be created (eg due to lack of room within the current picture).
      }
   }
   \sstdiylist{
      Environment Parameters
   }{
      \sstsubsection{
         FILL = \_LOGICAL (Read)
      }{
         TRUE if the supplied aspect ratio is to be ignored, creating the
         largest possible DATA picture within the current picture.  When
         FILL is FALSE, the DATA picture is created with the supplied
         aspect ratio. Only used when creating a new DATA picture.
      }
   }
}
\sstroutine{
   KPG1\_PLOTS
}{
   Save an AST Plot with an AGI DATA picture
}{
   \sstdescription{
      This routine saves a specified Plot and data reference in the AGI
      database with a specified DATA picture. A specified Frame can be
      made current before saving the Plot.

      If the supplied Plot contains a {\tt "}AGI Data{\tt "} Frame with the
      Domain given by DDOM in which the axes are scaled and shifted
      versions of the axes of the AGI world co-ordinate Frame
      (specified by argument WDOM), then a TRANSFORM structure defining
      AGI Data co-ordinates is stored with the DATA picture. This is purely
      for the benefit of non-AST based applications which may use AGI Data
      co-ordinates (AST-based applications should always use the Plot
      stored with the picture in preference to the TRANSFORM structure
      stored in the AGI database).
   }
   \sstinvocation{
      CALL KPG1\_PLOTS( IPLOT, IPICD, DATREF, ICURR, WDOM, DDOM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to the Plot. The current Frame is unchanged on
         exit (even if a Frame is specified using ICURR).
      }
      \sstsubsection{
         IPICD = INTEGER (Given)
      }{
         An AGI identifier for the DATA picture.
      }
      \sstsubsection{
         DATREF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A data reference to store with the picture.
      }
      \sstsubsection{
         ICURR = INTEGER (Returned)
      }{
         The index of a Frame to make current before storing the Plot. The
         supplied current Frame is used if ICURR is AST\_\_NOFRAME.
      }
      \sstsubsection{
         WDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain name of the Frame correspondoing to AGI world
         co-ordinates.
      }
      \sstsubsection{
         DDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Domain name of the co-ordinate Frame within IPLOT corresponding
         to AGI data co-ordinates. {\tt "}AXIS{\tt "} is used if a blank value
         is supplied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PLPUT
}{
   Put a section of the current colour palette into the supplied array
}{
   \sstdescription{
      This routine puts a specified section of the colour palette for the
      currently opened graphics device into the supplied array. Other
      elements of the array are left unchanged.
   }
   \sstinvocation{
      CALL KPG1\_PLPUT( CI1, CI2, LBND, UBND, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI1 = INTEGER (Given)
      }{
         The lowest colour index to change in the array.
      }
      \sstsubsection{
         CI2 = INTEGER (Given)
      }{
         The highest colour index to change in the array.
      }
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the second axis of ARRAY.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the second axis of ARRAY.
      }
      \sstsubsection{
         ARRAY( 3, LBND : UBND ) = REAL (Given and Returned)
      }{
         The array to recieved the palette.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_PLSAV
}{
   Save the colour palette for the currently open graphics device
}{
   \sstdescription{
      This routine saves a section of the colour palette for the currently
      open graphics device in an HDS container file in the users ADAM
      directory. The file is called {\tt "}kappa\_palette.sdf{\tt "} and contains
      palettes for different devices. Each palette is a \_REAL array of
      shape (3,n) where n is the number of colours in the palette. The
      first colour (i.e. the first element in the array) is the background
      colour and is refered to as colour index zero. Therefore the highest
      colour index in the array is (n-1). Each array has a name which
      identifies the graphics device to which it refers.

      If a palette already exists for the device in the HDS container file,
      then the values stored in the HDS palette for the range of colour
      indices specified by CI1 and CI2 are modified to reflect the current
      colour table, and values in the HDS palette for other colour
      indices are left unchanged. If no HDS palette already exists, then an
      entire palette array is created and initally filled with values of
      \sstitemlist{

         \sstitem
         1. These indicate that no value has yet been specified for the
         colour index, and allows the default value to be used. This default
         may depend on the graphics device. For instance, the default for
         pen 1 will be white on an Xwindow but black on a printer.
      }
   }
   \sstinvocation{
      CALL KPG1\_PLSAV( CI1, CI2, RESET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI1 = INTEGER (Given)
      }{
         The lowest colour index to save. Greater than or equal to zero.
         Zero is the background colour.
      }
      \sstsubsection{
         CI2 = INTEGER (Given)
      }{
         The highest colour index to save. If a value less than CI1 is given,
         then the highest available colour index is used.
      }
      \sstsubsection{
         RESET = LOGICAL (Given)
      }{
         Should all pens outside the range given by CI1 and CI2 be reset to
         their default (unspecified) values in the HDS palette? If not, their
         current values are retained.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The HDS container file is created if it does not already exist.

         \sstitem
         A graphics device must previously have been opened using SGS/GKS.
      }
   }
}
\sstroutine{
   KPG1\_PLTLN
}{
   Produces a graphical representation of a set of points in 2-D
}{
   \sstdescription{
      This routine produces a graphical representation of a set of
      points in two-dimensional space (e.g. a data value and a position,
      or two data values).  Errors in both data values may be
      represented by error bars. No annotated axes are drawn. The
      calling routine should do this if required by passing the supplied
      Plot (IPLOT) to routine KPG1\_ASGRD.

      PGPLOT should be active, and the viewport should correspond to the
      DATA picture in which the plot is to be drawn. PGPLOT world co-ordinates
      within the viewport should be GRAPHICS co-ordinates (millimetres from the
      bottom-left corner of the view surface).

      The Plotting style is accessed using one or more environment parameters
      specified by PARAM, and may include the following synonyms for graphical
      elements:
         {\tt "}Err(Bars){\tt "} - Specifies colour, etc for error bars. Size(errbars)
                       scales the size of the serifs used if ERSHAP=1 (i.e.
                       a size value of 1.0 produces a default size).
         {\tt "}Sym(bols){\tt "} - Specifies colour, etc for markers (used in Modes 3
                       and 5).
         {\tt "}Lin(es){\tt "} - Specifies colour, etc. for lines (used in Modes 1, 2,
                     4 and 5).
   }
   \sstinvocation{
      CALL KPG1\_PLTLN( N, ILO, IHI, X, Y, XERROR, YERROR, XBAR, YBAR,
                       XSTEP, PARAM, IPLOT, MODE, MTYPE, ERSHAP, FREQ,
                       APP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of points to be plotted.
      }
      \sstsubsection{
         ILO = INTEGER (Given)
      }{
         The index of the first grid point to be used.
      }
      \sstsubsection{
         IHI = INTEGER (Given)
      }{
         The index of the last grid point to be used.
      }
      \sstsubsection{
         X( N ) = DOUBLE PRECISION (Given)
      }{
         The X value at each point, in PGPLOT world co-ordinate (i.e.
         millimetres from the bottom-left corner of the view surface).
      }
      \sstsubsection{
         Y( N ) = DOUBLE PRECISION (Given)
      }{
         The Y value at each point, in PGPLOT world co-ordinate (i.e.
         millimetres from the bottom-left corner of the view surface).
      }
      \sstsubsection{
         XERROR = LOGICAL (Given)
      }{
         Display X error bars?
      }
      \sstsubsection{
         YERROR = LOGICAL (Given)
      }{
         Display Y error bars?
      }
      \sstsubsection{
         XBAR( N, 2 ) = DOUBLE PRECISION (Given)
      }{
         Row 1 contains the lower limit and Row 2 contains the upper limit
         for each horizontal error bar, in PGPLOT world co-ordinate (i.e.
         millimetres from the bottom left corner of the view surface). Only
         accessed if XERROR is .TRUE.
      }
      \sstsubsection{
         YBAR( N, 2 ) = DOUBLE PRECISION (Given)
      }{
         Row 1 contains the lower limit and Row 2 contains the upper limit
         for each vertical error bar, in PGPLOT world co-ordinate (i.e.
         millimetres from the bottom-left corner of the view surface). Only
         accessed if YERROR is .TRUE.
      }
      \sstsubsection{
         XSTEP( N, 2 ) = DOUBLE PRECISION (Given)
      }{
         Row 1 contains the lower limit and Row 2 contains the upper limit
         for each horizontal step, in PGPLOT world co-ordinate (i.e.
         millimetres from the bottom-left corner of the view surface). Only
         accessed if MODE is 4.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names of one or more style parameters to be used when obtaining
         the plotting style. If more than one parameter is supplied, the
         list should be separated by commas. The supplied parameters will
         be used in the order supplied, with later parameters allowing
         attributes obtained via earlier parameters to be assigned new values.
      }
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST Plot which can be used to do the drawing. The Base Frame
         should be GRAPHICS co-ordinates (millimetres from the bottom-
         left corner of the PGPLOT view surface). The Current Frame should
         be the Frame in which annotation is required.
      }
      \sstsubsection{
         MODE = INTEGER (Given)
      }{
         Determines the way in which the data points are represented.
         The options are as follows.
            1 - A {\tt "}staircase{\tt "} histogram, in which each horizontal line is
                centred on the X position. Bad values are flanked by vertical
                lines drawn down to the lower edge of the viewport.
            2 - The points are joined by straight lines.
            3 - A marker is placed at each point (see MTYPE).
            4 - Mark each point with a horizontal line of width given by
                XW.
            5 - A {\tt "}chain{\tt "} in which each point is marker by a marker and also
                join by straight lines to its neighbouring points.
            6 - The same as Mode 1, except that bad values are not
                flanked by vertical lines drawn down to the lower edge
                of the viewport (a simple gap is left instead).
      }
      \sstsubsection{
         MTYPE = INTEGER (Given)
      }{
         The PGPLOT marker type to use if MODE is 3 or 5.
      }
      \sstsubsection{
         ERSHAP = INTEGER (Given)
      }{
         Determines the way in which error bars are drawn:
            1 - X and Y errors are represented by horizontal and vertical
                lines respectively. Serifs are drawn at the ends of each
                line. The size of these sreifs is controlled by the
                size(errbar) plotting attribute.
            2 - A cross is drawn joining the corners of the box
                encompassing the X and Y errors.
            3 - A Diamond is drawn joining the ends of the horizontal and
                vertical error bars which would have been drawn if ERSHAP
                had been 1.
         These will all produce the same result (i.e. a single straight
         line) if errors are available only on one axis (see XERROR and
         YERROR). Not accessed if XERROR and YERROR are both .FALSE.
      }
      \sstsubsection{
         FREQ = INTEGER (Given)
      }{
         The frequency at which errors are to be plotted. A value of 1
         means {\tt "}plot errors for every point{\tt "}, 2 means {\tt "}plot errors for
         every second point{\tt "}, etc. Not accessed if XERROR and YERROR are
         both .FALSE.
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the calling application in the form
         $<$package$>$\_$<$application$>$ (eg {\tt "}KAPPA\_DISPLAY{\tt "}).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PQVID
}{
   Tests whether the current graphics device has suitable
   image-display characteristics
}{
   \sstdescription{
      This routine determines whether the current graphics device is an
      image display with suitable characteristics.  The checks are
      performed in the following order: the class of the device is
      checked against a supplied list of acceptable classes; the
      presence of certain attributes, given in a supplied list are
      checked in the order colour, input and open with reset; and
      finally a minimum number of colour indices must be exceeded.
   }
   \sstinvocation{
      CALL KPG1\_PQVID( PNDEV, CLASS, CRITER, MININT, UP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNDEV = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter associated with the current graphics
         workstation.  It is used to generate error messages.
      }
      \sstsubsection{
         CLASS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A list of acceptable workstation classes as defined by GNS,
         each separated by a comma.  See SUN/57 for a list. Note, as
         GNS does not yet support PGPLOT, no checks are mode on GNS
         class when using PGPLOT. Class checks are ignored if a blank
         string is supplied.
      }
      \sstsubsection{
         CRITER = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A list of criteria that the workstation must pass in order to
         be an acceptable image display.  The options are: {\tt '}COLOUR{\tt '} if
         colour must be available, {\tt '}CURSOR{\tt '} if a cursor must be
         available on the workstation. Non-standard criteria will be
         ignored.
      }
      \sstsubsection{
         MININT = INTEGER (Given)
      }{
         Minimum number of intensities or colour indices required.  The
         routine ensures that there are at least the specified number.
      }
      \sstsubsection{
         UP = INTEGER (Returned)
      }{
         The highest available colour index available.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A PGPLOT workstation must be open.
      }
   }
}
\sstroutine{
   KPG1\_PRCVT
}{
   Convert an HDS primitive to a native data representation
}{
   \sstdescription{
      The routine converts a primitive HDS object so that it is stored
      using the appropriate native data representation provided by the
      host machine.
   }
   \sstinvocation{
      CALL KPG1\_PRCVT( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given and Returned)
      }{
         Locator for the object to be converted. This may be modified
         on exit (as the original object may have to be erased and
         re-created).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine returns without action if the object supplied is not
      primitive, or if it does not need conversion (i.e. if it has
      already been converted or was created on the current machine). In
      this case the LOC argument will be returned unchanged.
   }
}
\sstroutine{
   KPG1\_PRNTH
}{
   Locates the outer-most pair of parenthesis in a string
}{
   \sstdescription{
      The routine returns the indices of the first opening parenthesis and
      the last closing parenthesis in the supplied string. Both are
      returned equal to zero if either parenthesis is not found.
   }
   \sstinvocation{
      CALL KPG1\_PRNTH( STRING, OP, CL STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         String to be searched.
      }
      \sstsubsection{
         OP = INTEGER (Returned)
      }{
         Position within STRING at which the first occurence of {\tt "}({\tt "} is
         located.
      }
      \sstsubsection{
         CL = INTEGER (Returned)
      }{
         Position within STRING at which the last occurence of {\tt "}){\tt "} is
         located.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PSEED
}{
   Set the PDA Random number seed
}{
   \sstdescription{
      This routine sets the seed for the PDA random number routines to a
      non-repeatable value, and must be called prior to using any PDA
      random number routine. The seed is only set once in each process,
      and is set to a number which combines the process id and the
      current time.

      The process id is included because the {\tt "}time{\tt "} system call
      (implemented by PSX\_TIME) returns the time in seconds. On modern
      machines it is possible for an application to be called several times
      each second, resulting in the same seed being used each time if the
      seed is based only on the time.
   }
   \sstinvocation{
      CALL KPG1\_PSEED( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PVERS
}{
   Parse a package version string
}{
   \sstdescription{
      This routine splits the supplied package version string (e.g.
      {\tt "}V0.13-6{\tt "}) into 3 integers corresponding to the major version
      number, minor version number and revision number. The leading {\tt "}V{\tt "}
      can be omitted, and trailing fields can be ommitted (they default
      to zero).
   }
   \sstinvocation{
      CALL KPG1\_PVERS( TEXT, MAJ, MIN, REV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The version string. Blanks are removed and it is converted to
         upper case on exit.
      }
      \sstsubsection{
         MAJ = INTEGER (Returned)
      }{
         The major version number.
      }
      \sstsubsection{
         MIN = INTEGER (Returned)
      }{
         The minor version number.
      }
      \sstsubsection{
         REV = INTEGER (Returned)
      }{
         The revision number.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PX2AX
}{
   Convert a pixel{\tt '}s indices into WCS or axis coordinates
}{
   \sstdescription{
      This routine converts the pixel indices of an NDF pixel into the
      WCS coordinate values of the pixel{\tt '}s centre. If a WCS FrameSet is
      not available, then the pixel indices are converted into the axis
      coordinate system. If an axis coordinate system is not defined for
      the NDF, then the pixel coordinate system will be used instead.
   }
   \sstinvocation{
      CALL KPG1\_PX2AX( NDIM, PX, INDF, AX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         PX( NDIM ) = INTEGER (Given)
      }{
         Indices of the NDF{\tt '}s pixel.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         AX( $*$ ) = DOUBLE PRECISION (Returned)
      }{
         WCS or axis coordinate values for the pixel{\tt '}s centre.
         There should be enough elements in this array for all the
         current frame WCS axes (which need not be the same as NDIM).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is simplified by handling only a single pixel. It
      will not be efficient enough to handle arrays of pixels.
   }
}
\sstroutine{
   KPG1\_R2NAG
}{
   Converts an FFTPACK Hermitian Fourier transform array into
   the equivalent NAG array
}{
   \sstdescription{
      This subroutine re-orders and normalises the supplied array of
      Fourier co-efficients (as produced by FFTPACK subroutine KPG1\_RFFTF)
      so that the returned array looks like the equivalent array returned
      by NAG routine C06FAE.

      This function is equivalent to PDA\_R2NAG except that it uses work
      space for greater speed.

      The real and imaginary co-efficients produced by KPG1\_RFFTF are numerically
      larger than the corresponding C06FAE co-efficients by a factor of
      SQRT( NP ), and are ordered differently. Both routines return A0
      (the zeroth real term, i.e. the DC level in the array) in element 1.
      KPG1\_RFFTF then has corresponding real and imaginary terms in adjacent
      elements, whereas C06FAE has all the real terms together, followed by
      all the imaginary terms (in reverse order):

         KPG1\_RFFTF :  A0,    A1, B1,     A2, B2,     A3, B3,   ...
         C06FAE:       A0,    A1, A2, A3, ...,        ..., B3, B2, B1

      The zeroth imaginary term (B0) always has the value zero and so is
      not stored in the array. Care has to be taken about the parity of the
      array size. If it is even, then there is one more real term than
      there is imaginary terms (excluding A0), i.e. if NP = 10, then the
      co-efficients are stored as follows:

         KPG1\_RFFTF :  A0, A1, B1, A2, B2, A3, B3, A4, B4, A5
         C06FAE:       A0, A1, A2, A3, A4, A5, B4, B3, B2, B1

      If NP = 9, then the co-efficients are stored as follows:

         KPG1\_RFFTF :  A0, A1, B1, A2, B2, A3, B3, A4, B4
         C06FAE:       A0, A1, A2, A3, A4, B4, B3, B2, B1
   }
   \sstinvocation{
      CALL KPG1\_R2NAG( NP, R, WORK )
   }
   \sstarguments{
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of the array.
      }
      \sstsubsection{
         R( NP ) = REAL (Given and Returned)
      }{
         The array holding the Fourier co-efficients. Supplied in FFTPACK
         format, returned in NAG format.
      }
      \sstsubsection{
         WORK( NP ) = REAL (Given and Returned)
      }{
         Work space.
      }
   }
}
\sstroutine{
   KPG1\_RCATW
}{
   Attempt to read an AST Object from a catalogue
}{
   \sstdescription{
      This routine attempts to read an AST Object from the textual
      information stored with the supplied catalogue (see SUN/181).
      Reading of the textual information in the catalogue commences
      at the current line (i.e. access to the textual information is not
      reset before reading commences).

      AST Objects can be written to a catalogue using routine KPG1\_WCATW.
   }
   \sstinvocation{
      CALL KPG1\_RCATW( CI, IAST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI = INTEGER (Given)
      }{
         A CAT identifier (see SUN/181) for the supplied catalogue.
      }
      \sstsubsection{
         IAST = INTEGER (Returned)
      }{
         An AST pointer to the returned Object. AST\_\_NULL is returned if
         an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_RDAST
}{
   Read AST\_ data as text from an HDS object
}{
   \sstdescription{
      This is a service routine to be provided as a {\tt "}source{\tt "} routine
      for the AST\_CHANNEL function. It reads data from an HDS object
      (in response to reading from an AST\_ Channel) and delivers it to
      the AST\_ library for interpretation.

      This routine has only a STATUS argument, so it communicates with
      other KPG routines via global variables stored in the KPG\_AST common
      blocks. These are described below under {\tt "}Global Variables used as
      Arguments{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_RDAST
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Global Variables used as Arguments
   }{
      ASTLC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given)
         A locator for the HDS object which holds the data. This must
         be a 1-dimensional \_CHAR array, whose size and character
         string length will be determined via this locator.
      ASTLN = INTEGER (Given and Returned)
         This must initially be set to the value 1, to indicate that
         data will be read starting at the first element of the HDS
         array (note the routine will not operate correctly unless 1 is
         the initial value - you cannot start reading at another point
         in the array if you have previously read from a different
         array). On exit it will be incremented by the number of
         elements used to obtain data, so that it identifies the first
         element to be used on the next invocation.
      ASTPT = INTEGER (Given)
         A pointer to the contents of the HDS object, mapped in {\tt '}READ{\tt '}
         mode.
   }
}
\sstroutine{
   KPG1\_RDCAT
}{
   Reads a set of positions with labels from a CAT catalogue
}{
   \sstdescription{
      This routine is equivalent to KPG1\_RDTAB except that the values of
      an arbitrary set of columns (including character-valued columns)
      can be returned within an AST KeyMap (see KEYMAP).

      See KPG1\_RDTAB for further information.
   }
   \sstinvocation{
      CALL KPG1\_RDCAT( PARAM, CURFRM, KEYMAP, LABS, IWCS, NPOS, NAX,
                       IPPOS, IPID, TITLE, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         CURFRM = LOGICAL (Given)
      }{
         If .TRUE. the positions read from the catalogue are Mapped
         into the Current Frame of the associated FrameSet before being
         returned. Otherwise, they are returned in the Base Frame.
      }
      \sstsubsection{
         KEYMAP = INTEGER (Given)
      }{
         An AST pointer to an existing KeyMap, or AST\_\_NULL. If a KeyMap
         is supplied, it should contain a vector valued entry called
         {\tt "}COLNAMES{\tt "} containing the names of one or more catalogue columns
         to be returned in the KeyMap. On exit, the KeyMap will contain
         the column values within a set of scalar entries. Each such
         entry will have a key of the form {\tt "}$<$colname$>$\_$<$row number$>${\tt "}
         ({\tt "}\_1{\tt "} for the first row). An error will be reported if the
         catalogue does not contain the requested columns.
      }
      \sstsubsection{
         LABS = INTEGER (Given and Returned)
      }{
         A GRP identifier for a group containing the values in the LABEL
         column. If the catalogue contains a LABEL column, then its values
         are appended to the end of the supplied group. If LABS holds
         GRP\_\_NOID on entry, then a new GRP group is created and its
         identifier returned in LABS, but only if the catalogue contains
         a LABEL column (otherwise the supplied value of GRP\_\_NOID is
         retained on exit).
      }
      \sstsubsection{
         IWCS = INTEGER (Returned)
      }{
         An AST pointer to the FrameSet read from the catalogue.
      }
      \sstsubsection{
         NPOS = INTEGER (Returned)
      }{
         The number of positions returned.
      }
      \sstsubsection{
         NAX = INTEGER (Returned)
      }{
         The number of axes in the Frame requested by CURFRM.
      }
      \sstsubsection{
         IPPOS = INTEGER (Returned)
      }{
         A pointer to a 2-dimensional DOUBLE PRECISION array holding the
         returned positions. Element (I,J) of this array gives axis J for
         position I. The first axis will have NPOS elements, and the
         second will have NAX elements. Should be released using PSX\_FREE
         when no longer needed.
      }
      \sstsubsection{
         IPID = INTEGER (Returned)
      }{
         A pointer to a 1-dimensional INTEGER array holding the integer
         identifiers for the returned positions. The array will have NPOS
         elements. Should be released using PSX\_FREE when no longer needed.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The value of the TITLE parameter in the supplied catalogue.
         Returned blank if there is no TITLE parameter.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The file spec of the catalogue containing the positions list.
         Not accessed if the declared length is 1.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_RDLST
}{
   Reads a set of positions from a CAT catalogue
}{
   \sstdescription{
      This routine reads a FrameSet, and a set of positions with
      associated integer identifiers from a CAT catalogue. The FrameSet
      should be stored as an AST Dump in the textual information associated
      with the catalogue. Such catalogues can be created using KPG1\_WRLST.
      If the catalogue does not contain a FrameSet, then a default
      FrameSet will be used if possible. If the catalogue contains
      floating point columns named RA and DEC, then the default FrameSet
      contains a single SkyFrame (Epoch and Equinox are set from the
      EPOCH and EQUINOX catalogue parameters - if they exist). Otherwise,
      if the catalogue contains floating point columns named X and Y, then
      the default FrameSet contains a single 2D Frame with axis symbols X
      and Y, and Domain GRID. If there is also a column named Z, then
      the Frame will be 3D, with a Z axis.

      However the FrameSet is obtained, it is assumed that the columns
      containing the axis values have CAT names equal to the Symbol
      attribute of the corresponding AST Axis. The catalogue columns from
      which to read the axis values are chosen by matching column names
      with Axis Symbols (only columns containing floating point values are
      considered). Frames are checked in the following order: the Base
      Frame, the Current Frame, all other Frames in order of increasing
      Frame index. An error is reported if no Frame has a set of
      corresponding columns.

      It is assumed that position identifiers are stored in an integer column
      with name PIDENT. If no such column is found, the returned position
      identifiers start at 1 and increase monotonically.

      The routine KPG1\_RDTAB is like KPG1\_RDLST, but provides an extra
      option to return a group of position labels read from a LABEL column
      in the catalogue.
   }
   \sstinvocation{
      CALL KPG1\_RDLST( PARAM, CURFRM, IWCS, NPOS, NAX, IPPOS, IPID, TITLE,
                       NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         CURFRM = LOGICAL (Given)
      }{
         If .TRUE. the positions read from the catalogue are Mapped
         into the Current Frame of the associated FrameSet before being
         returned. Otherwise, they are returned in the Base Frame.
      }
      \sstsubsection{
         IWCS = INTEGER (Returned)
      }{
         An AST pointer to the FrameSet read from the catalogue.
      }
      \sstsubsection{
         NPOS = INTEGER (Returned)
      }{
         The number of positions returned.
      }
      \sstsubsection{
         NAX = INTEGER (Returned)
      }{
         The number of axes in the Frame requested by CURFRM.
      }
      \sstsubsection{
         IPPOS = INTEGER (Returned)
      }{
         A pointer to a 2-dimensional DOUBLE PRECISION array holding the
         returned positions. Element (I,J) of this array gives axis J for
         position I. The first axis will have NPOS elements, and the
         second will have NAX elements. Should be released using PSX\_FREE
         when no longer needed.
      }
      \sstsubsection{
         IPID = INTEGER (Returned)
      }{
         A pointer to a 1-dimensional INTEGER array holding the integer
         identifiers for the returned positions. The array will have NPOS
         elements. Should be released using PSX\_FREE when no longer needed.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The value of the TITLE parameter in the supplied catalogue.
         Returned blank if there is no TITLE parameter.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The file spec of the catalogue containing the positions list.
         Not accessed if the declared length is 1.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_RDTAB
}{
   Reads a set of positions with labels from a CAT catalogue
}{
   \sstdescription{
      This routine is equivalent to KPG1\_RDLST except that any labels
      stored with the positions in the catalogue are returned in a GRP
      group (see LABS). The labels must be stored in a column called
      {\tt "}LABEL{\tt "}. Catalogues containing such labels are written by KPG1\_WRTAB.

      See KPG1\_RDLST for further information.
   }
   \sstinvocation{
      CALL KPG1\_RDTAB( PARAM, CURFRM, LABS, IWCS, NPOS, NAX, IPPOS,
                       IPID, TITLE, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         CURFRM = LOGICAL (Given)
      }{
         If .TRUE. the positions read from the catalogue are Mapped
         into the Current Frame of the associated FrameSet before being
         returned. Otherwise, they are returned in the Base Frame.
      }
      \sstsubsection{
         LABS = INTEGER (Given and Returned)
      }{
         A GRP identifier for a group containing the values in the LABEL
         column. If the catalogue contains a LABEL column, then its values
         are appended to the end of the supplied group. If LABS holds
         GRP\_\_NOID on entry, then a new GRP group is created and its
         identifier returned in LABS, but only if the catalogue contains
         a LABEL column (otherwise the supplied value of GRP\_\_NOID is
         retained on exit).
      }
      \sstsubsection{
         IWCS = INTEGER (Returned)
      }{
         An AST pointer to the FrameSet read from the catalogue.
      }
      \sstsubsection{
         NPOS = INTEGER (Returned)
      }{
         The number of positions returned.
      }
      \sstsubsection{
         NAX = INTEGER (Returned)
      }{
         The number of axes in the Frame requested by CURFRM.
      }
      \sstsubsection{
         IPPOS = INTEGER (Returned)
      }{
         A pointer to a 2-dimensional DOUBLE PRECISION array holding the
         returned positions. Element (I,J) of this array gives axis J for
         position I. The first axis will have NPOS elements, and the
         second will have NAX elements. Should be released using PSX\_FREE
         when no longer needed.
      }
      \sstsubsection{
         IPID = INTEGER (Returned)
      }{
         A pointer to a 1-dimensional INTEGER array holding the integer
         identifiers for the returned positions. The array will have NPOS
         elements. Should be released using PSX\_FREE when no longer needed.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The value of the TITLE parameter in the supplied catalogue.
         Returned blank if there is no TITLE parameter.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The file spec of the catalogue containing the positions list.
         Not accessed if the declared length is 1.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_REPRT
}{
   Reports a MSG message to user and also optionally write it to a file
}{
   \sstdescription{
      This routine dislays the supplied message using MSG\_OUT (unless
      QUIET is .TRUE), and (if LOG is .TRUE.) writes out the same text
      to the file identified by FD.
   }
   \sstinvocation{
      CALL KPG1\_REPRT( MESS, QUIET, LOG, FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message, which may contain MSG tokens.
      }
      \sstsubsection{
         QUIET = LOGICAL (Given)
      }{
         Supress screen output?
      }
      \sstsubsection{
         LOG = LOGICAL (Given)
      }{
         Write the text to  a file?
      }
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         An FIO identifier for a file. If LOG is .TRUE., then the message
         is written to this file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_RGLMT
}{
   Get the range limits of a range specification
}{
   \sstdescription{
      This routine returns begin and end limits of a range specified by
      a range word.
   }
   \sstinvocation{
      CALL KPG1\_RGLMT( SCT, RNGWRD, BERNG, BELG, EDRNG, EDLG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCT = CHARACTER$*$($*$) (Given)
      }{
         String which specifies a range with the range word specified
         by argument RNGWRD.
      }
      \sstsubsection{
         RNAWRD = CHARACTER$*$($*$) (Given)
      }{
         Gives a range word, such as {\tt "}TO{\tt "}, {\tt "}-{\tt "}, etc, which is used in
         range specification.
      }
      \sstsubsection{
         BERNG = INTEGER (Returned)
      }{
         Begin limit of the range.
      }
      \sstsubsection{
         BELG = LOGICAL (Returned)
      }{
         If the begin limit of the range has been omitted. it equals
         true, otherwise, false.
      }
      \sstsubsection{
         EDRNG = INTEGER (Returned)
      }{
         End limit of the range.
      }
      \sstsubsection{
         EDLG = LOGINCAL (Returned)
      }{
         If the end limit of the range has been omitted, it equals true,
         otherwise, false.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_RGNDF
}{
   Get a group of existing NDFs
}{
   \sstdescription{
      The supplied parameter is used to get a GRP group expression (see
      SUN/150 ) holding a list of existing NDFs (the syntax of the
      group expression is defined by the current default GRP control
      characters).  If the group expression is flagged, then the
      current parameter value is cancelled, the string supplied in TEXT
      is displayed (if it is not blank) and another group expression is
      obtained. The NDFs specified by the second group expression are
      added to the group holding the NDFs specified by the first group
      expression. The group continues to be expanded in this way until
      a group expression is obtained which is not flagged, or a null
      value is given, or the limit on the number of NDFs (MAXSIZ) is
      reached. If any of the specified NDFs do not exist, the user is
      warned, and re-prompted. If the final group contains more than
      MAXSIZ NDFs, then all but the first MAXSIZ NDFs are removed from
      the group. The user is warned if this happens. If MAXSIZ is
      supplied with the value zero no limit is imposed on the number of
      NDFs within the group.  If the final group contains less than the
      minimum no. of NDFs specified by argument MINSIZ, then the user is
      asked to supply more NDFs. All messages issued by this routine
      have a priority level of MSG\_\_NORM.
   }
   \sstinvocation{
      CALL KPG1\_RGNDF( PARAM, MAXSIZ, MINSIZ, TEXT, IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter (of type LITERAL).
      }
      \sstsubsection{
         MAXSIZ = INTEGER (Given)
      }{
         The maximum number of NDFs which can be allowed in the
         returned group. If zero is supplied, no limit is imposed.
      }
      \sstsubsection{
         MINSIZ = INTEGER (Given)
      }{
         The minimum number of NDFs which can be allowed in the
         returned group. If zero is supplied, then the returned group
         may contain no NDFs.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to display between issuing prompts for successive
         group expressions. If blank then no text is displayed.
      }
      \sstsubsection{
         IGRP = INTEGER (Returned)
      }{
         The GRP identifier for the returned group holding all the
         specified NDFs. The group should be deleted using GRP\_DELET
         when it is no longer needed. If an error occurs, the value
         GRP\_\_NOID is returned.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The number of files in the output group. SIZE is returned equal
         to 1 if STATUS is returned not equal to SAI\_\_OK.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SATKC
}{
   Substitutes alphabetic (TRANSFORM) character tokens into a string
}{
   \sstdescription{
      This routine parses the expression in EXPRES looking for
      tokens of the name PREFIX//[A-Z].  If one is located an attempt
      to access a value for this tokens if made using the ADAM
      parameter PREFIX//[A-Z].  If a value is obtained then it is
      substituted into the string EXPRES.

      New character tokens (functions) may contain references to
      other character tokens which will be either prompted for, or,
      if it is a token which has already been given a value this will
      be substituted.
   }
   \sstinvocation{
      CALL KPG1\_SATKC( PREFIX, EXPRES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PREFIX = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The prefix of the tokens.  Valid tokens are ones with any
         trailing single alphabetic character.
      }
      \sstsubsection{
         EXPRES = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry this contains a TRANSFORM algebraic-like expression
         which may contain tokens which need to be substituted by other
         expressions (functions).  References to other functions within
         functions are allowed and prompts will be made until all
         tokens are absent from the expression, however, later uses of
         the same tokens will be replaced with the same value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SATKD
}{
   Substitutes alphabetic (TRANSFORM) numeric tokens into a string
}{
   \sstdescription{
      This routine parses the expression in EXPRES looking for
      tokens of the name PREFIX//[A-Z].  If one is located an attempt
      to access a value for this tokens if made using the ADAM
      parameter PREFIX//[A-Z].  If a value is obtained then it is
      substituted into the string EXPRES.
   }
   \sstinvocation{
      CALL KPG1\_SATKD( PREFIX, EXPRES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PREFIX = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The prefix of the tokens. Valid tokens are ones with any
         trailing single alphabetic character.
      }
      \sstsubsection{
         EXPRES = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry this contains a TRANSFORM algebraic-like expression
         which may contain tokens which need to be substituted either
         for values (constants).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SAXAT
}{
   Set attributes of a Frame axis to describe an NDF array component
}{
   \sstdescription{
      This routine sets the Symbol, Units and Label attributes of a
      specified axis in an AST Frame so that they describe the values
      in a specified array component of an NDF. The Symbol is set to
      the name of the NDF array component (note, this is short and has
      no spaces so that it can be used as a column name in a catalogue),
      the Label is set to the NDF Label component, and Units is set to
      the NDF Units component.
   }
   \sstinvocation{
      CALL KPG1\_SAXAT( INDF, COMP, AXIS, LOG, FRAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the NDF being described.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the NDF array component being described.
      }
      \sstsubsection{
         AXIS = INTEGER (Given)
      }{
         The index of the Frame axis to be modified.
      }
      \sstsubsection{
         LOG = LOGICAL (Given)
      }{
         If .TRUE., then the attribute values are modified so that they
         are appropriate for a logarithmic axis. The modified attribute
         values are of the form {\tt "}Log10(...){\tt "} where {\tt "}...{\tt "} is the
         attribute value used for non-logarithmic axes. PGPLOT escape
         characters are included in the attribute values to produce a
         sub-scripted {\tt "}10{\tt "}.
      }
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         The identifier for the AST Frame to be modified.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SCALX
}{
   Copies array values into another array, scaling them in the process
}{
   \sstdescription{
      This routine copies values from one array to another, applying a
      linear scaling in the process. The input and output arrays can be
      of different data types.
   }
   \sstinvocation{
      CALL KPG1\_SCALX( SCALE, ZERO, BAD, EL, ITYPE, IP1, OTYPE,
                       IP2, BADOUT, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE = DOUBLE PRECISION (Given)
      }{
         The scale factor.
      }
      \sstsubsection{
         ZERO = DOUBLE PRECISION (Given)
      }{
         The zero offset.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the input array. If
         false it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the input array.
      }
      \sstsubsection{
         ITYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The HDS data type of the input array. All primitive HDS data types
         are supported.
      }
      \sstsubsection{
         IP1 = INTEGER (Given)
      }{
         Pointer to the input array.
      }
      \sstsubsection{
         OTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The HDS data type of the output array. Must be an integer type
         (i.e. one of \_INTEGER, \_WORD, \_UWORD, \_BYTE  or \_UBYTE ).
      }
      \sstsubsection{
         IP2 = INTEGER (Given)
      }{
         Pointer to the output array.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         True if there are any bad pixels in the output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of good input pixels that could not be accomodated
         within the dynamic range of the output data type, and were
         consequently set bad in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This function simply wraps up the generic KPG1\_SCL$<$T$>$$<$T$>$ routines.
      }
   }
}
\sstroutine{
   KPG1\_SCLOF
}{
   Applies a simple scaling and base-line shift to the values
   contained in the input vector
}{
   \sstdescription{
      The input data values are multiplied by the given factor and
      the given offset is then added on, to form the output data.
   }
   \sstinvocation{
      CALL KPG1\_SCLOF( EL, IN, FACTOR, OFFSET, OUT, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the input and output vectors.
      }
      \sstsubsection{
         IN( EL ) = REAL (Given)
      }{
         The input data vector.
      }
      \sstsubsection{
         FACTOR = DOUBLE PRECISION (Given)
      }{
         The factor by which the input valus are scaled.
      }
      \sstsubsection{
         OFFSET = DOUBLE PRECISION (Given)
      }{
         The offset by which the data values are shifted.
      }
      \sstsubsection{
         OUT( EL ) = REAL (Given)
      }{
         The output data vector.
      }
      \sstsubsection{
         BAD = LOGICAL (Returned)
      }{
         True if any bad pixels found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SDIMP
}{
   Obtains up to a number of significant dimensions of an NDF
}{
   \sstdescription{
      This routine finds the dimensions which are significant in an
      NDF, i.e. those with greater than one element.  The significant
      dimensions are recorded and returned.  If the number of
      significant dimensions found is less than a specified value, the
      insignificant dimensions pad out the array of dimension indices
      returned; and all the dimensions are returned in order of
      increasing dimensionality.  However, should the number of
      significant dimensions exceed the required number a bad status,
      SAI\_ERROR, is returned.  Likewise there is an error when there
      are no significant dimensions.
   }
   \sstinvocation{
      CALL KPG1\_SDIMP( NDF, NDIM, DIMV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The desired number of dimensions.
      }
      \sstsubsection{
         DIMV( NDIM ) = INTEGER (Returned)
      }{
         The significant dimensions i.e. the ones that are greater than
         one.  There is an execption when there are fewer than NDIM
         present in the NDF, whereupon this array includes in dimension
         order those that are insignificant too.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The NDF must exist.
      }
   }
}
\sstroutine{
   KPG1\_SECSH
}{
   Shifts bounds of upper dimensions that have one element to index
   one
}{
   \sstdescription{
      This routine shifts the origin to the default of one of each
      dimension of an NDF greater than a nominated dimension and whose
      size is one.

      The routine is required in applications that require NDFs of a
      specific dimensionality and which also call NDF\_SECT.  This is
      because a user-defined section may be from an NDF of higher
      dimensionality, and a subsequent call to NDF\_SECT can result in
      an array of bad data, when the bounds of higher dimensions are
      not one.  It is intended to be used alongside KPG1\_SGDIM.
   }
   \sstinvocation{
      CALL KPG1\_SECSH( NDF, MXDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         MXDIM = INTEGER (Given)
      }{
         The dimension above which the shifts are to be made.  This
         should be the last significant bound for the required
         dimensionality of NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SEED
}{
   Obtain a semi-random seed for random-number generation
}{
   \sstdescription{
      This function uses the computer time from an arbitrary date, plus
      the current process id., to generate a non-repeatable seed.
   }
   \sstinvocation{
      RESULT = KPG1\_SEED( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         KPG1\_SEED = REAL
      }{
         The non-repeatable seed for use in SLA\_RANDOM.  Note that
         it is not necessarily in the range 0 to 1.
      }
   }
}
\sstroutine{
   KPG1\_SGDIG
}{
   Determines the number of significant digits in a number
}{
   \sstdescription{
      This routine takes a string containing a numerical value, and
      counts the number of significant digits in the value.  Thus
      leading and trailing zeroes are excluded.
   }
   \sstinvocation{
      CALL KPG1\_SGDIG( STRING, NSDIG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the numerical value.  An error is
         returned if the value cannot be converted to a double-precision
         value without error.
      }
      \sstsubsection{
         NSDIG = INTEGER (Returned)
      }{
         The number of significant digits in the string if it is treated
         as a numerical value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SGDIM
}{
   Determines the number of significant dimensions in an NDF
}{
   \sstdescription{
      This routine finds the number of significant dimensions, i.e.
      those with greater than one element, in an NDF.  If the number
      found is not equal to a specified number a bad status, SAI\_ERROR,
      is returned.  Likewise should there be no significant dimensions.
      The significant dimensions are recorded and returned.
   }
   \sstinvocation{
      CALL KPG1\_SGDIM( NDF, NDIM, DIMV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The desired number of dimensions.
      }
      \sstsubsection{
         DIMV( NDIM ) = INTEGER (Returned)
      }{
         The significant dimensions i.e. the ones that are greater than
         one.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The NDF must exist.
      }
   }
}
\sstroutine{
   KPG1\_SHORT
}{
   Check whether a string matches a supplied abbreviation template
}{
   \sstdescription{
      This routine returns .TRUE. if the supplied test string matches
      the supplied abbreviation template. All characters in the template
      must be matched by the corresponding characters in the test string,
      with the exception that it is permissable for the test string to end
      anywhere following the first occurrence of the mark string (the
      mark string itself should not be matched in the test string). The
      template sub-string in front of the first mark string thus gives
      the minimum abbreviation which the test string can use.

      For instance, if MARK={\tt '}$*${\tt '} and TEMPLT={\tt '}VECT$*$ORS{\tt '}, then the test string
      matches if the first 4 characters are {\tt '}VECT{\tt '} and any remaining
      characters match {\tt '}ORS{\tt '}.
   }
   \sstinvocation{
      RESULT = KPG1\_SHORT( TEMPLT, TEST, MARK, CASE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TEMPLT = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The abbreviation template. Trailing blanks are ignored.
      }
      \sstsubsection{
         TEST = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The test string. Trailing blanks are ignored.
      }
      \sstsubsection{
         MARK = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The string which marks the end of the minimum abbreviation in
         TEMPLT. Trailing blanks are ignored.
      }
      \sstsubsection{
         CASE = LOGICAL (Given)
      }{
         Should the match be case sensitive?
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      KPG1\_SHORT = LOGICAL
         Returned .TRUE. if and only if the supplied test string matches the
         template.
   }
}
\sstroutine{
   KPG1\_SLICE
}{
   Find and remove any NDF slice specification from a name
}{
   \sstdescription{
      A slice specification is taken to be anything between the first
      opening and the first closing parenthesis, so long as the closing
      parentheis is the last character in the name.
   }
   \sstinvocation{
      CALL KPG1\_SLICE( NAME, SLICE, START, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER (Given and Returtned)
      }{
         The name to be checked.  On exit, any NDF slice specification
         contained in the name on entry, is removed.
      }
      \sstsubsection{
         SLICE = CHARACTER (Returned)
      }{
         The slice specification including opening and closing
         parenthesise.  If the input name contains no slice
         specification, then SLICE is returned blank.
      }
      \sstsubsection{
         START = INTEGER (Returned)
      }{
         The position (within the original name) of the opening
         parethesis.  If the name does not containa slice specification,
         then START is returned pointing to the first character beyond
         the end of the name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SNKTA
}{
   Write AST\_ data as text to a GRP group
}{
   \sstdescription{
      This is a service routine to be provided as a {\tt "}sink{\tt "} routine for
      the AST\_CHANNEL function. It takes data in the form of text (in
      response to writing an AST\_ object to a Channel) and delivers it
      to a GRP group for storage.

      This routine has only a STATUS argument, so it communicates with
      other KPG routines via global variables stored in the KPG\_AST
      common blocks. These are described below under {\tt "}Global Variables
      used as Arguments{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_SNKTA( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Global Variables used as Arguments
   }{
      ASTGRP = INTEGER (Given)
         A GRP identifier for the group which is to store the data.
      ASTTSZ = INTEGER (Given)
         The maximum length of text which should be stored in a single
         element of the group. This should be less than or equal to
         GRP\_\_SZNAM.
      ASTLN = INTEGER (Given and Returned)
         This must initially be set to the value 1, to indicate that
         data will be written starting at the first element of the
         group (note the routine will not operate correctly unless 1 is
         the initial value - you cannot start writing at another point
         in the group if you have previously written to a different
         group). On exit it will be incremented by the number of
         elements used to store data, so that it identifies the first
         element to be used on the next invocation.
   }
}
\sstroutine{
   KPG1\_SRCTA
}{
   Reads AST\_ data as text from a GRP group
}{
   \sstdescription{
      This is a service routine to be provided as a {\tt "}source{\tt "} routine
      for the AST\_CHANNEL function. It reads data from a GRP group
      (in response to reading from an AST\_ Channel) and delivers it to
      the AST\_ library for interpretation.

      This routine has only a STATUS argument, so it communicates with
      other KPG routines via global variables stored in the KPG\_AST common
      blocks. These are described below under {\tt "}Global Variables used as
      Arguments{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_SRCTA( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Global Variables used as Arguments
   }{
      ASTGRP = INTEGER (Given)
         A GRP identifier for the group which holds the data.
      ASTLN = INTEGER (Given and Returned)
         This must initially be set to the value 1, to indicate that
         data will be read starting at the first element of the group
         (note the routine will not operate correctly unless 1 is
         the initial value - you cannot start reading at another point
         in the group if you have previously read from a different
         group). On exit it will be incremented by the number of
         elements used to obtain data, so that it identifies the first
         element to be used on the next invocation.
      ASTTSZ = INTEGER (Given)
         The number of characters to use from each GRP element.
   }
}
\sstroutine{
   KPG1\_SSCOF
}{
   Applies a simple scaling and base-line shift to create the
   output vector
}{
   \sstdescription{
      Pixel indices are multiplied by the given factor and
      the given offset is then added on, to form the output data.
      The first pixel has value equal to the offset.
   }
   \sstinvocation{
      CALL KPG1\_SSCOF( EL, FACTOR, OFFSET, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number elements in the returned array.
      }
      \sstsubsection{
         FACTOR = DOUBLE PRECISION (Given)
      }{
         The factor by which the array indices are scaled.
      }
      \sstsubsection{
         OFFSET = DOUBLE PRECISION (Given)
      }{
         The offset by which the array indices are shifted.
      }
      \sstsubsection{
         OUT( EL ) = REAL (Given)
      }{
         The output data vector.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is no exception handler if the evaluated value exceeds the
      machine floating-pint range.
   }
}
\sstroutine{
   KPG1\_VEC2N
}{
   Convert vectorised array indices into N-dimensional form
}{
   \sstdescription{
      This routine converts pixel indices which refer to a pixel in a
      vectorised array into sets of indices which identify the same
      pixel when the array is regarded as N-dimensional, with specified
      lower and upper pixel-index bounds for each dimension.
   }
   \sstinvocation{
      CALL KPG1\_VEC2N( NVEC, VEC, NDIM, LBND, UBND, IDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NVEC = INTEGER (Given)
      }{
         Number of vectorised array indices to convert.
      }
      \sstsubsection{
         VEC( NVEC ) = INTEGER (Given)
      }{
         Array of vectorised pixel indices to be converted.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds for each array dimension.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds for each array dimension.
      }
      \sstsubsection{
         IDIM( NDIM, NVEC ) = INTEGER (Returned)
      }{
         Returns a set of NDIM pixel-indices for each vectorised index
         supplied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The maximum number of dimensions which can be handled by this
      routine is equal to the symbolic constant NDF\_\_MXDIM.
   }
}
\sstroutine{
   KPG1\_VERB
}{
   Should the speified package report verbose messages?
}{
   \sstdescription{
      This routine returns a logical flag indicating if a specified
      applications package should report verbose information. This is the
      case if the environment variable $<$PACK$>$\_VERBOSE is defined (the value
      assigned to the environment variable is immaterial).
   }
   \sstinvocation{
      CALL KPG1\_VERB( VERB, PACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VERB = LOGICAL (Returned)
      }{
         Should the package run in verbose mode? Returned .FALSE, if an
         error has already occurred, or if this routine should fail for
         any reason.
      }
      \sstsubsection{
         PACK = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the package (eg {\tt "}KAPPA{\tt "}, {\tt "}POLPACK{\tt "}, etc).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set to an
         error on entry.
      }
   }
}
\sstroutine{
   KPG1\_MKCAT
}{
   Write an AST Object to a catalogue
}{
   \sstdescription{
      This routine stores a textual representation of the supplied AST Object
      within the supplied catalogue. The information is stored within COMMENT
      strings which are appended to the supplied catalogue{\tt '}s textual
      information. Lines of AST information which are too long to fit in a
      single COMMENT are split into several lines. Continuation lines are
      marked by having a {\tt "}$+${\tt "} in the first column. Each line of AST
      information is preceeded with the string {\tt "}!!{\tt "}, which is used to
      mark the end of any leading blanks etc added by AST when the string is
      read back.

      Note, at the moment CAT reports errors if textual information is
      added to a catalogue which contains no rows of data. For this reason,
      this routine should normally be called just before closing the
      catalogue, since this will normally ensure that the catalogue
      contains some data.
   }
   \sstinvocation{
      RESULT = KPG1\_WCATW( IAST, CI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IAST = INTEGER (Given)
      }{
         An AST pointer to the Object.
      }
      \sstsubsection{
         CI = INTEGER (Given)
      }{
         A CAT identifier for the catalogue.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      KPG1\_WCATW = INTEGER
         Returned equal to 1 if an Object was written to the catalogue,
         and zero otherwise.
   }
}
\sstroutine{
   KPG1\_WCAXC
}{
   Obtains co-ordinates for an axis from a WCS component FrameSet
}{
   \sstdescription{
      This routine returns an array of world co-ordinates along a
      nominated axis, that are derived from the Current Frame in the
      supplied FrameSet.
   }
   \sstinvocation{
      CALL KPG1\_WCAXC( INDF, FS, AXIS, EL, CENTRE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         FS = INTEGER (Given)
      }{
         An AST pointer for a FrameSet.
      }
      \sstsubsection{
         AXIS = INTEGER (Given)
      }{
         The number of the axes array to obtain.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The number of elements in the centre array.
      }
      \sstsubsection{
         CENTRE( EL ) = DOUBLE PRECISION (Returned)
      }{
         The axis centres.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WCFAX
}{
   Obtains the co-ordinate of an axis in the current WCS Frame at
   every pixel centre in an NDF
}{
   \sstdescription{
      This routine returns the world co-ordinate along a nominated WCS
      axis for each pixel centre of an NDF.  The co-ordinates are defined
      within the current Frame in the supplied FrameSet. It is assumed
      that the nominated axis is independent of the other axes.
   }
   \sstinvocation{
      CALL KPG1\_WCFAX( LBND, UBND, MAP, JAXIS, IAXIS, CENTRE, WORK,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND( $*$ ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the NDF. This array should have
         one element for each NDF pixel axis.
      }
      \sstsubsection{
         UBND( $*$ ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the NDF. This array should have
         one element for each NDF pixel axis.
      }
      \sstsubsection{
         MAP = INTEGER (Given)
      }{
         Mapping from PIXEL coords in the NDF to current WCS coords.
      }
      \sstsubsection{
         JAXIS = INTEGER (Given)
      }{
         The number of the pixel axis which is varied.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         The number of the WCS axis whose values are returned.
      }
      \sstsubsection{
         CENTRE( $*$ ) = DOUBLE PRECISION (Returned)
      }{
         The current-Frame co-ordinate along the nominated axis at each
         pixel centre. The size and shape of this array should be the
         same as the NDF.
      }
      \sstsubsection{
         WORK( $*$ ) = DOUBLE PRECISION (Returned)
      }{
         A work array with the same length as the requested pixel axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WGNDF
}{
   Get a group of output NDF names
}{
   \sstdescription{
      The supplied parameter is used to get a GRP group expression (see
      SUN/150 ) holding a list of NDFs which are to be created by the
      calling application (the syntax of the group expression is
      defined by the current default GRP control characters).
      Modification elements within the group expression are based on
      the group identified by IGRP0. If the group expression is flagged,
      then the current parameter value is cancelled, the string
      supplied in TEXT is displayed (if it is not blank) and another
      group expression is obtained. The NDFs specified by the second
      group expression are added to the group holding the NDFs
      specified by the first group expression. The group continues to
      be expanded in this way until a group expression is obtained
      which is not flagged, or a null value is given, or the limit on
      the number of NDFs (MAXSIZ) is reached.  If the final group
      contains more than MAXSIZ NDFs, then all but the first MAXSIZ
      NDFs are removed from the group. The user is warned if this
      happens. If MAXSIZ is supplied with the value zero no limit is
      imposed on the number of NDFs within the group.  If the final
      group contains less than MINSIZ NDFs then the user is told to
      supply more, and is re-prompted for further NDF names. All
      messages issued by this routine have a priority level of
      MSG\_\_NORM.
   }
   \sstinvocation{
      CALL KPG1\_WGNDF( PARAM, IGRP0, MAXSIZ, MINSIZ, TEXT, IGRP, SIZE,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter (of type LITERAL).
      }
      \sstsubsection{
         IGRP0 = INTEGER (Given)
      }{
         The NDG identifier for a group containing a set of NDF names
         to be used as the basis for any modification elements contained
         within the group expressions. If this is supplied equal to
         GRP\_\_NOID then modification elements are left un-expanded.
      }
      \sstsubsection{
         MAXSIZ = INTEGER (Given)
      }{
         The maximum number of NDFs which can be allowed in the
         returned group. If zero is supplied, no limit is imposed.
      }
      \sstsubsection{
         MINSIZ = INTEGER (Given)
      }{
         The minimum number of NDFs which can be allowed in the
         returned group. If zero is supplied, then the returned group
         may contain no NDFs.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to display between issuing prompts for successive
         group expressions. If blank then no text is displayed.
      }
      \sstsubsection{
         IGRP = INTEGER (Returned)
      }{
         The NDG identifier for the returned group holding all the
         specified NDFs.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The number of files in the output group. Returned equal to 1 if
         STATUS is not equal to SAI\_\_OK.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WRAST
}{
   Write AST\_ data as text to an HDS object
}{
   \sstdescription{
      This is a service routine to be provided as a {\tt "}sink{\tt "} routine for
      the AST\_CHANNEL function. It takes data in the form of text (in
      response to writing an AST\_ object to a Channel) and delivers it
      to an HDS object for storage.

      This routine has only a STATUS argument, so it communicates with
      other KPG routines via global variables stored in the KPG\_AST
      common blocks. These are described below under {\tt "}Global Variables
      used as Arguments{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_WRAST
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Global Variables used as Arguments
   }{
      ASTLC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given)
         A locator for the HDS object which is to store the data. This
         must be a 1-dimensional \_CHAR array, whose initial size and
         character string length will be determined via this locator.
         Write access to the object must be available via this locator,
         but the locator itself is not altered by this routine.
      ASTLN = INTEGER (Given and Returned)
         This must initially be set to the value 1, to indicate that
         data will be written starting at the first element of the HDS
         array (note the routine will not operate correctly unless 1 is
         the initial value - you cannot start writing at another point
         in the array if you have previously written to a different
         array). On exit it will be incremented by the number of
         elements used to store data, so that it identifies the first
         element to be used on the next invocation.
      ASTPT = INTEGER (Given and Returned)
         A pointer to the contents of the HDS object, initially mapped
         in {\tt '}WRITE{\tt '} mode. This pointer may be modified by the routine
         (and re-mapped in {\tt '}UPDATE{\tt '} mode) if it needs to extend the
         size of the object to accommodate the data written.
   }
}
\sstroutine{
   KPG1\_WRCAT
}{
   Writes a set of positions to a text file as a CAT catalogue
}{
   \sstdescription{
      This routine is equivalent to KPG1\_WRLST, except that it provides
      the option of storing a textual label with each position, via
      the extra argument LABS, and extra arbitrary columns via the extra
      argument KEYMAP.
   }
   \sstinvocation{
      CALL KPG1\_WRCAT( PARAM, ARRDIM, NPOS, NAX, POS, IFRM, IWCS, TITLE,
                       ID0, IDENTS, KEYMAP, LABS, HIST, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         ARRDIM = INTEGER (Given)
      }{
         The size of the first dimension of the positions array. This must
         be larger than or equal to NPOS.
      }
      \sstsubsection{
         NPOS = INTEGER (Given)
      }{
         The number of positions to store in the file.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame specified by IFRM.
      }
      \sstsubsection{
         POS( ARRDIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         The positions to store in the file. POS( I, J ) should give the
         axis J value for position I.
      }
      \sstsubsection{
         IFRM = INTEGER (Given)
      }{
         The index of the Frame within IWCS to which the supplied
         positions relate. Can be AST\_\_BASE or AST\_\_CURRENT.
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         A pointer to an AST FrameSet to store with the positions.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A title to store at the top of the text file. Ignored if blank.
      }
      \sstsubsection{
         ID0 = INTEGER (Given)
      }{
         The integer identifier value to associate with the first
         supplied position. Identifiers for subsequent positions increase
         by 1 for each position. If this is supplied less than or equal
         to zero, then its value is ignored and the identifiers supplied
         in array IDENTS are used instead.
      }
      \sstsubsection{
         IDENTS( NPOS ) = INTEGER (Given)
      }{
         The individual integer identifiers to associate with each
         position. Only accessed if ID0 is less than or equal to zero.
      }
      \sstsubsection{
         KEYMAP = INTEGER (Given)
      }{
         An optional AST KeyMap containing data for extra columns to
         add to the catalogue. It can be used (for instance) to add
         character columns to the catalogue. If a value of AST\_\_NULL
         is supplied, no extra columns are added to the catalogue.
         Otherwise, the column names and values can be specified using
         either of the following two schemes:

         \sstitemlist{

            \sstitem
            If the KeyMap contains an entry called {\tt "}COLNAMES{\tt "}, it is
            assumed to be a vector entry holding the names of the columns.
            For each of these column names, the value to store in a
            particular row of the catalogue is assumed to be held in a
            scalar KeyMap entry with key {\tt "}$<$colname$>$\_$<$row number$>${\tt "} ( {\tt "}\_1{\tt "}
            for the first row). If no such entry exists for a particular
            row, then the value is marked as bad in the catalogue. The data
            type of the column is determined from the first row value found
            for the column.

            \sstitem
            If the KeyMap does not contain an entry called {\tt "}COLNAMES{\tt "},
            it is assumed that each entry in the KeyMap contains a vector
            holding all the values for a single column, in row order. The
            entry key is used as the column name, and the column data type
            is determined from the entry data type.
         }
      }
      \sstsubsection{
         LABS = INTEGER (Given)
      }{
         A GRP group identifier containing the labels to be associated
         with the positions. The number of elements in this group should
         be equal to NPOS. If GRP\_\_NOID is supplied, no label column will
         be created.
      }
      \sstsubsection{
         HIST = INTEGER (Given)
      }{
         A GRP group identifier containing history text to store with the
         catalogue.  If GRP\_\_NOID is supplied, no history information
         will be stored with the catalogue.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         Is the user allowed to supply a null value? If so, the error
         status will be annulled before returning.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WREAD
}{
   Read an AST Object from an HDS object
}{
   \sstdescription{
      This routine reads an AST Object from a component of the supplied
      HDS object. The component name is specified by the caller. The
      component must have a type of WCS, must be scalar, and must contain
      a single 1-D array component with name DATA and type \_CHAR.
      AST\_\_NULL is returned in IAST, and no error is reported if the
      named component does not exist.
   }
   \sstinvocation{
      CALL KPG1\_WREAD( LOC, NAME, IAST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The locator to the HDS object.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the component within the HDS object to read.
         If a blank name is supplied, the object itself is used.
      }
      \sstsubsection{
         IAST = INTEGER (Returned)
      }{
         Pointer to the AST Object returned. Returned equal to AST\_\_NULL
         if no Object can be read.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WRLST
}{
   Writes a set of positions to a text file as a CAT catalogue
}{
   \sstdescription{
      This routine saves a set of positions in a text file as a CAT
      catalogue (see SUN/181). Information describing associated co-ordinate
      Frames can also be stored in the file as textual information, allowing
      subsequent applications to interpret the positions. Files written with
      this routine can be read using KPG1\_RDLST (and also XCATVIEW etc).

      The positions are stored in the file in a Frame selected by the
      user using hardwired parameters CATFRAME and CATEPOCH. This Frame
      defaults to a SKY Frame if present, otherwise a PIXEL Frame if present,
      otherwise the original Base Frame within the supplied FrameSet. The
      positions can be supplied within any of the Frames in the FrameSet
      and will be Mapped into the required Frame if necessary.

      If the ID atttribute of the FrameSet is set to {\tt "}FIXED\_BASE{\tt "}, then
      the user is not allowed to change the base Frame using parameters
      CATFRAME and CATEPOCH.

      See also KPG1\_WRTAB, which is like this routine but allows a
      textual label to be associated with each position.
   }
   \sstinvocation{
      CALL KPG1\_WRLST( PARAM, ARRDIM, NPOS, NAX, POS, IFRM, IWCS, TITLE,
                       ID0, IDENTS, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         ARRDIM = INTEGER (Given)
      }{
         The size of the first dimension of the positions array. This must
         be larger than or equal to NPOS.
      }
      \sstsubsection{
         NPOS = INTEGER (Given)
      }{
         The number of positions to store in the file.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame specified by IFRM.
      }
      \sstsubsection{
         POS( ARRDIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         The positions to store in the file. POS( I, J ) should give the
         axis J value for position I.
      }
      \sstsubsection{
         IFRM = INTEGER (Given)
      }{
         The index of the Frame within IWCS to which the supplied
         positions relate. Can be AST\_\_BASE or AST\_\_CURRENT.
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         A pointer to an AST FrameSet to store with the positions.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A title to store at the top of the text file. Ignored if blank.
      }
      \sstsubsection{
         ID0 = INTEGER (Given)
      }{
         The integer identifier value to associate with the first
         supplied position. Identifiers for subsequent positions increase
         by 1 for each position. If this is supplied less than or equal
         to zero, then its value is ignored and the identifiers supplied
         in array IDENTS are used instead.
      }
      \sstsubsection{
         IDENTS( NPOS ) = INTEGER (Given)
      }{
         The individual integer identifiers to associate with each
         position. Only accessed if ID0 is less than or equal to zero.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         Is the user allowed to supply a null value? If so, the error
         status will be annulled before returning.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WRTA2
}{
   Puts a set of positions into a text file as a CAT catalogue
}{
   \sstdescription{
      This routine writes the supplied positions to a CAT catalogue
      (see SUN/181). A dump of the supplied FrameSet (if any) is included
      in the text file as a set of {\tt "}text{\tt "} lines. A column is created
      with name {\tt "}PIDENT{\tt "} to contain the integer identifiers. A column is
      also created for each axis of the Base Frame, with a name equal to
      the Symbol attribute of the Axis (AXIS\_$<$n$>$ is used if the Symbol is
      blank). The catalogue can be read using KPG1\_RDLST (and also XCATVIEW
      etc).
   }
   \sstinvocation{
      CALL KPG1\_WRTA2( PARAM, ARRDIM, NPOS, NAX, POS, IWCS, TITLE,
                       ID0, IDENTS, KEYMAP, LABS, HIST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         ARRDIM = INTEGER (Given)
      }{
         The size of the first dimension of the positions array. This must
         be larger than or equal to NPOS.
      }
      \sstsubsection{
         NPOS = INTEGER (Given)
      }{
         The number of positions to store in the file.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes for each position.
      }
      \sstsubsection{
         POS( ARRDIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         The positions to store in the file. POS( I, J ) should give the
         axis J value for position I. The positions should be in the Base
         Frame of the FrameSet supplied using argument IWCS.
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         A pointer to an AST FrameSet to store with the positions.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A title to store at the top of the text file.
      }
      \sstsubsection{
         ID0 = INTEGER (Given)
      }{
         The integer identifier value to associate with the first
         supplied position. Identifiers for subsequent positions increase
         by 1 for each position. If this is supplied less than or equal
         to zero, then its value is ignored and the identifiers supplied
         in array IDENTS are used instead.
      }
      \sstsubsection{
         IDENTS( NPOS ) = INTEGER (Given)
      }{
         The individual integer identifiers to associate with each
         position. Only accessed if ID0 is less than or equal to zero.
      }
      \sstsubsection{
         KEYMAP = INTEGER (Given)
      }{
         An optional AST KeyMap containing data for extra columns to
         add to the catalogue. It can be used (for instance) to add
         character columns to the catalogue. If a value of AST\_\_NULL
         is supplied, no extra columns are added to the catalogue.
         Otherwise, the column names and values can be specified using
         either of the following two schemes:

         \sstitemlist{

            \sstitem
            If the KeyMap contains an entry called {\tt "}COLNAMES{\tt "}, it is
            assumed to be a vector entry holding the names of the columns.
            For each of these column names, the value to store in a
            particular row of the catalogue is assumed to be held in a
            scalar KeyMap entry with key {\tt "}$<$colname$>$\_$<$row number$>${\tt "} ( {\tt "}\_1{\tt "}
            for the first row). If no such entry exists for a particular
            row, then the value is marked as bad in the catalogue. The data
            type of the column is determined from the first row value found
            for the column.

            \sstitem
            If the KeyMap does not contain an entry called {\tt "}COLNAMES{\tt "},
            it is assumed that each entry in the KeyMap contains a vector
            holding all the values for a single column, in row order. The
            entry key is used as the column name, and the column data type
            is determined from the entry data type.
         }
      }
      \sstsubsection{
         LABS = INTEGER (Given)
      }{
         A GRP group identifier containing the labels to be associated
         with the positions. The number of elements in this group should
         be equal to NPOS. If GRP\_\_NOID is supplied, no label column will
         be created.
      }
      \sstsubsection{
         HIST = INTEGER (Given)
      }{
         A GRP group identifier containing history text to store with the
         catalogue.  If GRP\_\_NOID is supplied, no history information
         will be stored with the catalogue.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WRTAB
}{
   Writes a set of positions to a text file as a CAT catalogue
}{
   \sstdescription{
      This routine is equivalent to KPG1\_WRLST, except that it provides
      the option of storing a textual label with each position, via
      the extra argument LABS.
   }
   \sstinvocation{
      CALL KPG1\_WRTAB( PARAM, ARRDIM, NPOS, NAX, POS, IFRM, IWCS, TITLE,
                       ID0, IDENTS, LABS, HIST, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         ARRDIM = INTEGER (Given)
      }{
         The size of the first dimension of the positions array. This must
         be larger than or equal to NPOS.
      }
      \sstsubsection{
         NPOS = INTEGER (Given)
      }{
         The number of positions to store in the file.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame specified by IFRM.
      }
      \sstsubsection{
         POS( ARRDIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         The positions to store in the file. POS( I, J ) should give the
         axis J value for position I.
      }
      \sstsubsection{
         IFRM = INTEGER (Given)
      }{
         The index of the Frame within IWCS to which the supplied
         positions relate. Can be AST\_\_BASE or AST\_\_CURRENT.
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         A pointer to an AST FrameSet to store with the positions.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A title to store at the top of the text file. Ignored if blank.
      }
      \sstsubsection{
         ID0 = INTEGER (Given)
      }{
         The integer identifier value to associate with the first
         supplied position. Identifiers for subsequent positions increase
         by 1 for each position. If this is supplied less than or equal
         to zero, then its value is ignored and the identifiers supplied
         in array IDENTS are used instead.
      }
      \sstsubsection{
         IDENTS( NPOS ) = INTEGER (Given)
      }{
         The individual integer identifiers to associate with each
         position. Only accessed if ID0 is less than or equal to zero.
      }
      \sstsubsection{
         LABS = INTEGER (Given)
      }{
         A GRP group identifier containing the labels to be associated
         with the positions. The number of elements in this group should
         be equal to NPOS. If GRP\_\_NOID is supplied, no label column will
         be created.
      }
      \sstsubsection{
         HIST = INTEGER (Given)
      }{
         A GRP group identifier containing history text to store with the
         catalogue.  If GRP\_\_NOID is supplied, no history information
         will be stored with the catalogue.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         Is the user allowed to supply a null value? If so, the error
         status will be annulled before returning.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WTM3D
}{
   To form the weighted median of a list of ordered data values.
   Incrementing the contributing pixel buffers and estimating the
   variance change
}{
   \sstdescription{
      This routine finds a value which can be associated with the half-
      weight value. It sums all weights then finds a value for the
      half-weight. The comparison with the half-weight value proceeds
      in halves of the weights for each data point (half of the first
      weight, then the second half of the first weight and the first
      half of the second weight etc.) until the half weight is
      exceeded. The data values around this half weight position are
      then found and a linear interpolation of these values is the
      weighted median. This routine also uses the order statistic
      covariance array (for a population NENT big) to estimate the
      change in the variance from a optimal measurement from the
      given population, returning the adjusted variance.
   }
   \sstinvocation{
      CALL KPG1\_WTM3D( ORDDAT, WEIGHT, VAR, NENT, COVAR,
                       RESULT, RESVAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ARR( NENT ) = DOUBLE PRECISION (Given)
      }{
         The list of ordered data for which the weighted median is
         required
      }
      \sstsubsection{
         WEIGHT( NENT ) = DOUBLE PRECISION (Given)
      }{
         The weights of the values.
      }
      \sstsubsection{
         VAR( NSET ) = DOUBLE PRECISION (Given)
      }{
         The variance of the unordered sample now ordered in ARR.
      }
      \sstsubsection{
         NENT = INTEGER (Given)
      }{
         The number of entries in the data array.
      }
      \sstsubsection{
         COVAR( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of size NENT.
      }
      \sstsubsection{
         RESULT = DOUBLE PRECISION (Returned)
      }{
         The weighted median
      }
      \sstsubsection{
         RESVAR = DOUBLE PRECISION (Returned)
      }{
         The variance of result.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         the routine should only be used at real or better precisions.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The input data must be ordered increasing. No BAD values may be
         present.
      }
   }
}
\sstroutine{
   KPG1\_WTM3R
}{
   To form the weighted median of a list of ordered data values
}{
   \sstdescription{
      This routine finds a value which can be associated with the half-
      weight value. It sums all weights then finds a value for the
      half-weight. The comparison with the half-weight value proceeds
      in halves of the weights for each data point (half of the first
      weight, then the second half of the first weight and the first
      half of the second weight etc.) until the half weight is
      exceeded. The data values around this half weight position are
      then found and a linear interpolation of these values is the
      weighted median. This routine also uses the order statistic
      covariance array (for a population NENT big) to estimate the
      change in the variance from a optimal measurement from the
      given population, returning the adjusted variance.
   }
   \sstinvocation{
      CALL KPG1\_WTM3R( ORDDAT, WEIGHT, VAR, NENT, COVAR, RESULT, RESVAR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ORDDAT( NENT ) = REAL (Given)
      }{
         The list of ordered data for which the weighted median is
         required
      }
      \sstsubsection{
         WEIGHT( NENT ) = REAL (Given)
      }{
         The weights of the values.
      }
      \sstsubsection{
         VAR( NSET ) = REAL (Given)
      }{
         The variance of the unordered sample now ordered in ARR.
      }
      \sstsubsection{
         NENT = INTEGER (Given)
      }{
         The number of entries in the data array.
      }
      \sstsubsection{
         COVAR( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of size NENT.
      }
      \sstsubsection{
         RESULT = REAL (Returned)
      }{
         The weighted median
      }
      \sstsubsection{
         RESVAR = REAL (Returned)
      }{
         The variance of result.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         the routine should only be used at real or better precisions.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The input data must be ordered increasing. No BAD values may be
         present.
      }
   }
}
\sstroutine{
   KPG1\_WWRT
}{
   Write WCS information to an HDS object
}{
   \sstdescription{
      This routine stores a supplied AST Object in a new component of
      a supplied HDS object. The new component has type WCS and contains
      a single component named DATA, of type \_CHAR. DATA is a 1-D array
      holding lines of text which can be interpreted by a simple AST
      Channel.
   }
   \sstinvocation{
      CALL KPG1\_WWRT( IAST, NAME, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IAST = INTEGER (Given)
      }{
         A pointer to an AST Object.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the WCS component to add into the supplied HDS object.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A locator for an HDS structure object. This object is modified by
         adding a component of type WCS, with name given by NAME.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_XYD2W
}{
   Converts linear data co-ordinates to world co-ordinates
}{
   \sstdescription{
      The co-efficients of the linear transformation from world
      co-ordinates to data co-ordinates are supplied in arguments SCALE
      and OFFSET.  The inverse of this transformation is used to
      transform each supplied position from data to world co-ordinates.
   }
   \sstinvocation{
      CALL KPG1\_XYD2W( SCALE, OFFSET, NPOINT, XP, YP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE( 2 ) = DOUBLE PRECISION (Given)
      }{
         The scale factors in the linear relationships between axis
         co-ordinates and pixel co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = DOUBLE PRECISION (Given)
      }{
         The offsets in the linear relationships between axis
         co-ordinates and pixel co-ordinates.
      }
      \sstsubsection{
         NPOINT = INTEGER (Given)
      }{
         The number of points specified.
      }
      \sstsubsection{
         XP( NPOINT ) = REAL (Given and Returned)
      }{
         Array holding the x co-ordinate of each point.
      }
      \sstsubsection{
         YP( NPOINT ) = REAL (Given and Returned)
      }{
         Array holding the y co-ordinate of each point.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The supplied values of SCALE and OFFSET are such that:

      }
         DATA = SCALE( I ) $*$ PIXEL $+$ OFFSET( I )

      where PIXEL is a pixel co-ordinate for the I{\tt '}th dimension, and
      DATA is the corresponding axis co-ordinate.
   }
}
\sstroutine{
   KPG\_ENV0C
}{
   Reads a string value from an environment variable, using a
   default value if the variable is undefined
}{
   \sstdescription{
      This routine reads a string value of up to forty characters from
      a specified environment variable.  No error occurs should the
      environment variable not be defined, and the supplied value is
      returned unchanged.
   }
   \sstinvocation{
      CALL KPG\_ENV0C( VARNAM, CVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The environment variable to check.
      }
      \sstsubsection{
         CVAL = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG\_NXWRD
}{
   To find the next word in a string
}{
   \sstdescription{
      The routine looks for the start of the next word, after OFFSET
      characters, in the given string. Words are assumed to be
      delimetered by spaces, commas or tabs. The routine is really a
      wrap round calls to CHR\_FIWE and CHR\_FIWS trapping any status
      returns.
   }
   \sstinvocation{
      CALL KPG\_NXWRD( STRING, OFFSET, FIRST, LAST, NOTFND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string to be searched for a {\tt '}word{\tt '}. The word is looked for
         in STRING(OFFSET:).
      }
      \sstsubsection{
         OFFSET = INTEGER (Given)
      }{
         The offset into the given string after which the word is to
         located.
      }
      \sstsubsection{
         FIRST = INTEGER (Returned)
      }{
         First character of the located word. Offset into STRING.
      }
      \sstsubsection{
         LAST = INTEGER (Returned)
      }{
         Last character of the located word. Offset into STRING.
      }
      \sstsubsection{
         NOTFND = LOGICAL (Returned)
      }{
         If a next word is not located then this is set true, otherwise
         it is set false.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If an error has already occurred, or if an error occurs during this
         routine, NOTFND is returned .FALSE., and FIRST and LAST are returned
         equal to one.
      }
   }
}
\sstroutine{
   LD2AR
}{
   Converts a sparse form of a 2-D array stored in DOUBLE PRECISION
   into its REAL 2-D counterpart
}{
   \sstdescription{
      A list of x-y positions and values are converted to a complete
      2-d array.  Missing elements take the bad value.
   }
   \sstinvocation{
      CALL LD2AR( NX, NY, SX, SY, NBIN, X, Y, Z, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The first dimension of the 2-d array.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         The second dimension of the 2-d array.
      }
      \sstsubsection{
         SX = REAL (Given)
      }{
         The co-ordinate scale factor (i.e. the length of a pixel) in
         the x direction.  It is used to determine which pixel a given
         x-y position lies.  Normally, it will have the value 1.
      }
      \sstsubsection{
         SY = REAL (Given)
      }{
         The co-ordinate scale factor (i.e. the length of a pixel) in
         the y direction.  It is used to determine which pixel a given
         x-y position lies.  Normally, it will have the value 1.
      }
      \sstsubsection{
         NBIN = INTEGER (Given)
      }{
         The number of bins in the pixel list.
      }
      \sstsubsection{
         X( NBIN ) = DOUBLE PRECISION (Given)
      }{
         The x position of the pixel in the list.
      }
      \sstsubsection{
         Y( NBIN ) = DOUBLE PRECISION (Given)
      }{
         The y position of the pixel in the list.
      }
      \sstsubsection{
         Z( NBIN ) = DOUBLE PRECISION (Given)
      }{
         The value of the pixel in the list.
      }
      \sstsubsection{
         ARRAY( NX, NY ) = REAL (Returned)
      }{
         The expanded 2-d array formed from the list.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \{routine\_notes\}...
   }
}
\sstroutine{
   LOGARR
}{
   take the logarithm of an array, pixel by pixel
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the logarithm of the pixels of the input array
      to the base specified, i.e. New value = Log    ( Old value ).
                                                 Base
      If the input pixel is negative, then a bad pixel value is
      used for the output value.
      To find the logarithm to any base, the following algorithm
      is used, providing the base is positive and not equal to one :
       New Value  =  Log ( Old Value ) / Log ( Base )
                        e                   e
   }
   \sstinvocation{
      CALL LOGARR( INARR, DIMS, BASE, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INARR( DIMS )  =  REAL( READ )
      }{
         Array containing input image data
      }
      \sstsubsection{
         DIMS  =  INTEGER( READ )
      }{
         Dimensions of input and output arrays
      }
      \sstsubsection{
         BASE  =  REAL( READ )
      }{
         Base of logarithm to be used - must be a positive number
      }
      \sstsubsection{
         OUTARR( DIMS )  =  REAL( WRITE )
      }{
         Array containing results of processing input data
      }
      \sstsubsection{
         STATUS  =  INTEGER( READ )
      }{
         Global status value
      }
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   NORMAL
}{
   takes a value and returns a normally distributed noisy
}{
   \sstdescription{
      This routine takes as input a number and returns a number
      which is the input number plus or minus a random amount
      of normally distributed noise. Uses a Box-Mueller algorithm
      to generate a fairly good normal distribution.
   }
   \sstinvocation{
      CALL NORMAL( INVAL, SIGMA, SEED, OUTVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INVAL  =  REAL( READ )
      }{
         Input value to which noise is to be added
      }
      \sstsubsection{
         SIGMA  =  REAL ( READ )
      }{
         Standard deviation of  normal distribution
      }
      \sstsubsection{
         SEED  =  REAL ( READ, WRITE )
      }{
         Seed for random number generator.
      }
      \sstsubsection{
         OUTVAL  =  REAL ( WRITE )
      }{
         Output value which has random noise added
      }
      \sstsubsection{
         STATUS = INTEGER ( READ )
      }{
         Global status value
      }
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   NXTNAM
}{
   increments Fnnnn type filename by one
}{
   \sstdescription{
      This routine takes the input string CURNAM which should end with
      an IRCAM type filename Fnnnn (where nnnn is four integers), and
      returns the string NEXTNM containing the next filename in
      numerical sequence, i.e. it adds one to the integer nnnn.
   }
   \sstinvocation{
      CALL NXTNAM( CURNAM, NEXTNM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CURNAM  =  CHAR$*$($*$)
      }{
         Current filename of IRCAM type ending in Fnnnn
      }
      \sstsubsection{
         NEXTNM  =  CHAR$*$($*$)
      }{
         Next filename in numerical sequence
      }
      \sstsubsection{
         STATUS  =  INTEGER( READ,WRITE )
      }{
         Global status value
      }
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   POWARR
}{
   raise an array, pixel by pixel, to a given power
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of raising the pixels of the input array to the power
      specified, i.e. New value = Old value $*$$*$ Power.
      If the result is bigger than the maximum allowed Vax real,
      then a bad pixel value is used. If the result is smaller than
      minimum allowed real set output pixel to be zero. (This underflow
      check is not necessary on some machines, e.g. Vax.)
      Negative input values are also converted to a bad pixel value
      in the output.
   }
   \sstinvocation{
      CALL POWARR( INARR, DIMS, POWER, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INARR( DIMS )  =  REAL( READ )
      }{
         Array containing input image data
      }
      \sstsubsection{
         DIMS  =  INTEGER( READ )
      }{
         Dimension of input and output arrays
      }
      \sstsubsection{
         POWER  =  REAL( READ )
      }{
         Power to be used
      }
      \sstsubsection{
         OUTARR( DIMS )  =  REAL( WRITE )
      }{
         Array containing results of raising input data to the given power
      }
      \sstsubsection{
         STATUS  =  INTEGER( READ, WRITE )
      }{
         Global status value
      }
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   ZERO1D
}{
   sets all elements of the 1-dimensional array to zero
}{
   \sstdescription{
      All elements of the 1-dimensional array, ARRAY, are set equal to
      zero. An immediate return will occur if STATUS has an error value
      on entry.
   }
   \sstinvocation{
      CALL ZERO1D( SIZE, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SIZE   = INTEGER( READ )
      }{
         Number of elements in the array to be set to all zeros.
      }
      \sstsubsection{
         ARRAY( SIZE ) = REAL( UPDATE )
      }{
         All elements of this array will be set to zero.
      }
      \sstsubsection{
         STATUS = INTEGER( READ )
      }{
         This is the global status, if this variable has an error
         value on entry then an immediate return will occur.
      }
   }
}
\sstroutine{
   ZERO2D
}{
   sets all elements of a 2-dimensional array to zero
}{
   \sstdescription{
      All elements of the 2-dimensional array, ARRAY, are set equal to
      zero. An immediate return will occur if STATUS has an error value
      on entry.
   }
   \sstinvocation{
      CALL ZERO2D( DIM1, DIM2, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM1 = INTEGER( READ )
      }{
         The first dimension of the 2-d array to be set to all zeros.
      }
      \sstsubsection{
         DIM2 = INTEGER( READ )
      }{
         The second dimension of the 2-d array to be set to all zeros.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = REAL( UPDATE )
      }{
         All elements of this array will be set to zero.
      }
      \sstsubsection{
         STATUS = INTEGER( READ )
      }{
         This is the global status, if this variable has an error
         value on entry then an immediate return will occur.
      }
   }
}
\sstroutine{
   BAD2D$<$T$>$
}{
   Substitutes the bad value in a defined sub-section of a 2-d array
}{
   \sstdescription{
      \{routine\_description\}
   }
   \sstinvocation{
      CALL BAD2D$<$T$>$( DIM1, DIM2, LBND, UBND, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the array to be edited.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the array to be edited.
      }
      \sstsubsection{
         LBND( 2 ) = INTEGER (Given)
      }{
         Lower bounds of the region to be made bad.
      }
      \sstsubsection{
         UBND( 2 ) = INTEGER (Given)
      }{
         Upper bounds of the region to be made bad.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = $<$HTYPE$>$ (Given and Returned)
      }{
         The array to be edited.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CHVAL$<$T$>$
}{
   Replaces a specified pixel value
}{
   \sstdescription{
      This routine replaces a specified pixel with an input
      value and returns the old value of the pixel.
   }
   \sstinvocation{
      CALL CHVAL$<$T$>$( DIM, INARR, OLDVAL, NEWVAL, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM = INTEGER( READ )
      }{
         The dimension of the input array
      }
      \sstsubsection{
         INARR( DIM ) = $<$TYPE$>$ ( READ )
      }{
         The input data array
      }
      \sstsubsection{
         OLDVAL = $<$TYPE$>$ ( READ )
      }{
         Value to be replaced
      }
      \sstsubsection{
         NEWVAL = $<$TYPE$>$ ( READ )
      }{
         New value to be substituted for the \%OLDVAL.
      }
      \sstsubsection{
         OUTARR( DIM ) = $<$TYPE$>$ ( READ )
      }{
         The output data array containing the modified pixel values
      }
      \sstsubsection{
         STATUS  =  INTEGER( READ )
      }{
         Global status value
      }
   }
   \sstdiytopic{
      Method
   }{
      If global status is ok. then
      For all pixels
         If pixel value is the value to be removed then
            Replace old value in data array with the new value
         Endif
      Endfor
      End
   }
   \sstbugs{
      None are known at this time.
   }
}
\sstroutine{
   COPA$<$T$>$
}{
   Copy a one-dimensional array
}{
   \sstdescription{
      The input one-dimensional array, ARRIN, of dimension DIM, is
      copied into the output one-dimensional array, ARROUT, of the same
      dimension.  An immediate return will occur if STATUS has an error
      value on entry.
   }
   \sstinvocation{
      CALL COPA$<$T$>$( DIM, ARRIN, ARROUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM = INTEGER ( READ )
      }{
         Dimension of the input and output arrays.
      }
      \sstsubsection{
         ARRIN( DIM ) = $<$TYPE$>$ ( READ )
      }{
         1-D array to be copied.
      }
      \sstsubsection{
         ARROUT( DIM ) = $<$TYPE$>$ ( WRITE )
      }{
         Output array is returned as a copy of the input array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ELNMB$<$T$>$
}{
   Write a range of element numbers into an array
}{
   \sstdescription{
      This routine writes numbers sequentially to a $<$COMM$>$ 1-d
      array, where the numbers are between defined integer limits and
      are stepped by 1 (or -1) from one pixel to the next.  In other
      words the array value takes the element number plus an offset.
      Only the first \%ODIM elements can be accommodated in the output
      array, should the section be larger than this.
   }
   \sstinvocation{
      CALL KPG1\_ELNMBx( X1, X2, ODIM, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X1 = INTEGER (Given)
      }{
         The first value to be written to the output array.  If this
         is larger than \%X2 the values will decrease by 1 for each
         element.
      }
      \sstsubsection{
         X2 = INTEGER (Given)
      }{
         The last value to be written to the output array, provided
         there are sufficient elements to accommodate it.  If not
         only \%ODIM values will be stored.
      }
      \sstsubsection{
         ODIM = INTEGER (Given)
      }{
         The number of elements in the output array.
      }
      \sstsubsection{
         OUTARR( ODIM ) = ? (Returned)
      }{
         The array into which the sub-array is copied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The status value on entry to this routine.
      }
   }
}
\sstroutine{
   KPG1\_AINBx
}{
   Obtains for an axis the equivalent index co-ordinates given axis
   values
}{
   \sstdescription{
      This routine determines the indices within an axis array for a
      series of axis values.  It assumes that the array is
      monotonically increasing or decreasing, and is approximately
      linear.  This routine may be used for arbitrary 1-d arrays
      in addition to axes, provided these criteria are met.

      A Newton{\tt '}s approximation method is used comparing the actual value
      with a linear approximation.  The upper and lower bounds used to
      define the increment are adjusted given the deviation from the
      linear axis.  Once the value lies between adjacent array elements
      the nearer (by linear interpolation) becomes the required index.
   }
   \sstinvocation{
      CALL KPG1\_AINBx( LBND, UBND, AXIS, EL, VALUE, INDEX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values whose indices in the axis are to be found.
      }
      \sstsubsection{
         VALUE( EL ) = ? (Given)
      }{
         The axis-array values.
      }
      \sstsubsection{
         INDEX( EL ) = ? (Returned)
      }{
         The pixel indices of the values in the axis array.
         Notice that this is floating as fractional positions may be
         required. An index is set to the bad value when its input
         co-ordinate lies outside the range of co-ordinates in the
         axis or when the input co-ordinate is bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and values, and the returned indices
         should have this data type as well.

         \sstitem
         No error report is made and bad status is not set should any
         input co-ordinate lie outside the range of co-ordinates of
         the axis.  Processing will continue through the list.
      }
   }
}
\sstroutine{
   KPG1\_AINDx
}{
   Obtains for an axis the equivalent index co-ordinates given axis
   values
}{
   \sstdescription{
      This routine determines the indices within an axis array for a
      series of axis values.  It assumes that the array is
      monotonically increasing or decreasing, and is approximately
      linear.  This routine may be used for arbitrary 1-d arrays
      in addition to axes, provided these criteria are met.

      A Newton{\tt '}s approximation method is used comparing the actual value
      with a linear approximation.  The upper and lower bounds used to
      define the increment are adjusted given the deviation from the
      linear axis.  Once the value lies between adjacent array elements
      the nearer (by linear interpolation) becomes the required index.
   }
   \sstinvocation{
      CALL KPG1\_AINDx( LBND, UBND, AXIS, EL, VALUE, INDEX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values whose indices in the axis are to be found.
      }
      \sstsubsection{
         VALUE( EL ) = ? (Given)
      }{
         The axis-array values.
      }
      \sstsubsection{
         INDEX( EL ) = ? (Returned)
      }{
         The pixel indices of the values in the axis array.
         Notice that this is floating as fractional positions may be
         required.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and values, and the returned indices
         should have this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_AKERx
}{
   Smooth a 2-dimensional array using an arbitrary rectangular
   kernel
}{
   \sstdescription{
      The routine smooths the array A using an arbitrary smoothing
      kernel, and returns the result in the array B.
   }
   \sstinvocation{
      CALL KPG1\_AKERx( IBOX, JBOX, WEIGHT, SAMBAD, WLIM, NX, NY,
                       BAD, VAR, A, B, BADOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IBOX = INTEGER (Given)
      }{
         Half-size, in pixels along the x axis, of the box over which
         the smoothing will be applied (the actual box used has an edge
         which is 2$*$IBOX$+$1 pixels long). This defines the region within
         which the smoothing function is non-zero.
      }
      \sstsubsection{
         JBOX = INTEGER (Given)
      }{
         Half-size, in pixels along the y axis, of the box over which
         the smoothing will be applied (the actual box used has an edge
         which is 2$*$JBOX$+$1 pixels long). This defines the region within
         which the smoothing function is non-zero.
      }
      \sstsubsection{
         WEIGHT( 2 $*$ IBOX $+$ 1, 2 $*$ JBOX $+$ 1 ) = ? (Given)
      }{
         The weighting kernel.  It need not be normalised to one, but
         this is strongly preferred since it reduces the chance of
         overflows.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given, then any {\tt "}bad{\tt "} pixels in the input
         array A will be propagated to the output array B (output
         values will be calculated for all other output pixels). If a
         .FALSE. value is given, then the WLIM argument is used to
         determine which output pixels will be bad (if any). This
         argument is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         WLIM = ? (Given)
      }{
         The minimum weighting that can be used to compute a smoothed
         output pixel if SAMBAD is .FALSE..  Any output pixels falling
         short of the specified weight will be set to the bad value
         (invalid pixels carry no weight, others have Gaussian weights
         about the central pixel).  The value must be greater than 0.0
         and should be less than or equal to 1.0. This argument is not
         used if SAMBAD is .TRUE. or if BAD is .FALSE..
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         First dimension of the 2-d array A.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Second dimension of the 2-d array A.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad pixels in the input
         array A.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If a .FALSE. value is given for this argument, then smoothing
         will be performed as if the array supplied (A) is an array of
         data and the PSF will be used directly as specified. If a
         .TRUE. value is given, then smoothing will be applied as if
         the array is an array of variance values associated with an
         array of data; in this case, the effective PSF will be reduced
         in width by a factor 2 and the mean output values will be
         reduced to reflect the variance-reducing effect of smoothing.
      }
      \sstsubsection{
         A( NX, NY ) = ? (Given)
      }{
         Array containing the input image to be smoothed.
      }
      \sstsubsection{
         B( NX, NY ) = ? (Returned)
      }{
         Array containing the input image after smoothing.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether there are bad pixel values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There are routines for processing double precision and real
         data.  Replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.
         The data types of the WLIM, A, B, and WEIGHT arguments must match
         the routine used.

         \sstitem
         This routine should not be used for symmetric kernels because
         there are faster algorithms for handling these special cases.
      }
   }
}
\sstroutine{
   KPG1\_AXBNx
}{
   Find the bounds of an NDF{\tt '}s axis centre co-ordinates
}{
   \sstdescription{
      This routine determines the lowest and highest centre
      co-ordinate for an NDF axis array component.  Currently, it
      assumes that these will be the first and last elements.
   }
   \sstinvocation{
      CALL KPG1\_AXBNx( EL, CENTRE, AXLCO, AXUCO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The NDF axis centre co-ordinates.
      }
      \sstsubsection{
         AXLCO = ? (Returned)
      }{
         The lowest centre co-ordinates for the axis.
      }
      \sstsubsection{
         AXUCO = ? (Returned)
      }{
         The highest centre co-ordinate for the axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The centre array and the returned values
         should have this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_AXCOx
}{
   Obtains for an axis the axis indices given their values
}{
   \sstdescription{
      This routine determines floating-point axis indices within an axis
      array for a series of pixel co-ordinates.  It assumes that the
      array is monotonic and approximately linear, since it uses linear
      interpolation to derive the pixel indices.  This routine may be
      used for arbitrary 1-d arrays in addition to axes, provided this
      criterion is met.
   }
   \sstinvocation{
      CALL KPG1\_AXCOx( LBND, UBND, AXIS, EL, VALUE, INDEX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of indices whose values in the axis array are to be
         found.
      }
      \sstsubsection{
         VALUE( EL ) = ? (Given)
      }{
         The axis-array values.
      }
      \sstsubsection{
         INDEX( EL ) = ? (Returned)
      }{
         The pixel co-ordinates of the values in the axis array.
         Notice that this is in floating point as fractional positions
         may be returned.  An index is set to the bad value when its
         input co-ordinate lies outside the range of co-ordinates in
         the axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and co-ordinates, and the returned
         indices should have this data type as well.

         \sstitem
         An error report is made and bad status returned should any
         input co-ordinate lie outside the range of co-ordinates of
         the axis.  Processing will continue through the list.
      }
   }
}
\sstroutine{
   KPG1\_AXEXx
}{
   Calculates the extent of an NDF along an axis
}{
   \sstdescription{
      This routine calculates the starting and ending positions of an
      NDF{\tt '}s pixels along an axis, optionally taking account of the
      axis width and error values.
   }
   \sstinvocation{
      CALL KPG1\_AXEXx( EL, CENTRE, USEERR, ERROR, USEWID, WIDTH,
                       NSIGMA, ASTART, AEND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis arrays.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The centres of the pixels on the axis.
      }
      \sstsubsection{
         USEERR = LOGICAL (Given)
      }{
         Use the error array and NSIGMA in the calculation of the
         extent of the axis.
      }
      \sstsubsection{
         ERROR( EL ) = ? (Given)
      }{
         The errors of the pixel centres on the axis.  It is only
         required (accessed) when USEERR = .TRUE..
      }
      \sstsubsection{
         USEWID = LOGICAL (Given)
      }{
         Use the width array in the calculation of the extent of the
         axis.
      }
      \sstsubsection{
         WIDTH( EL ) = ? (Given)
      }{
         The widths of the pixels on the axis.
      }
      \sstsubsection{
         NSIGMA = ? (Given)
      }{
         Number of multiples of the error to use in the calculation
      }
      \sstsubsection{
         ASTART = ? (Returned)
      }{
         If the axis centre positions increase with NDF pixel index,
         this argument returns the axis position of the edge of the
         first pixel which has the lower co-ordinate. Otherwise it
         returns the axis position of the edge with the higher
         co-ordinate.
      }
      \sstsubsection{
         AEND = ? (Returned)
      }{
         If the axis centre positions increase with NDF pixel index,
         this argument returns the axis position of the edge of the
         last pixel which has the higher co-ordinate. Otherwise it
         returns the axis position of the edge with the lower
         co-ordinate.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AXGVx
}{
   Find the first axis centre co-ordinate of an NDF above a
   threshold
}{
   \sstdescription{
      This routine determines the element number and value of the first
      axis centre co-ordinate of an NDF above a given threshold.
      Currently, it assumes that the centre values increase or decrease
      monotonically from the first to the last elements.

      A SAI\_\_ERROR status is returned when no centre value exceeds the
      threshold.
   }
   \sstinvocation{
      CALL KPG1\_AXGVx( EL, CENTRE, THRESH, ITH, VALTH, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The NDF axis centre co-ordinates.
      }
      \sstsubsection{
         THRESH = ? (Given)
      }{
         The threshold.
      }
      \sstsubsection{
         ITH = INTEGER (Returned)
      }{
         The index number of the element that first exceeds the
         threshold, or its negative when the co-ordinates decrease with
         increasing element number.
      }
      \sstsubsection{
         VALTH = ? (Returned)
      }{
         The centre co-ordinate that first exceeds the threshold.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         array and threshold supplied to the routine plus the co-ordinate
         that first exceeds the threshold must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_AXLIx
}{
   Determines whether an array{\tt '}s values are equally spaced
}{
   \sstdescription{
      This routine determines whether or not adjacent elements of a
      1-d array have values that are equally spaced, i.e. it tests for
      linearity.  It simply checks if the intervals between all
      successive pairs of elements are the same within the machine
      precision.
   }
   \sstinvocation{
      CALL KPG1\_AXLIx( EL, ARRAY, LVAL, UVAL, LINEAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.  It must be at least
         two.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array to be tested.
      }
      \sstsubsection{
         LVAL = ? (Returned)
      }{
         Value of the first array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         UVAL = ? (Returned)
      }{
         Value of the last array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         LINEAR = LOGICAL (Returned)
      }{
         True if the array is linear.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for most numeric data types: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, or UW as appropriate.  The array
         (and the variables for the first and last array elements) supplied
         to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_AXLVx
}{
   Find the first axis centre co-ordinate of an NDF below a
   threshold
}{
   \sstdescription{
      This routine determines the element number and value of the first
      axis centre co-ordinate of an NDF below a given threshold.
      Currently, it assumes that the centre values increase or decrease
      monotonically from the first to the last elements.

      A SAI\_\_ERROR status is returned when no centre value is less than
      the threshold.
   }
   \sstinvocation{
      CALL KPG1\_AXLVx( EL, CENTRE, THRESH, ITH, VALTH, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The NDF axis centre co-ordinates.
      }
      \sstsubsection{
         THRESH = ? (Given)
      }{
         The threshold.
      }
      \sstsubsection{
         ITH = INTEGER (Returned)
      }{
         The index number of the element that first has a value below
         the threshold, or its negative when the co-ordinates decrease
         with increasing element number.
      }
      \sstsubsection{
         VALTH = ? (Returned)
      }{
         The centre co-ordinate that first fails to exceed the
         threshold.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         array and threshold supplied to the routine plus the co-ordinate
         that first fails to exceed the threshold must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_AXVLx
}{
   Obtains the axis-array values given their corresponding pixel
   co-ordinates
}{
   \sstdescription{
      This routine determines values within an axis array for a series
      of non-integer pixel co-ordinates.  It assumes that the array is
      monotonic and approximately linear, since it uses linear
      interpolation to derive the axis values. This routine may be
      used for arbitrary one-dimensional arrays in addition to axes,
      provided this criterion is met.
   }
   \sstinvocation{
      CALL KPG1\_AXVLx( LBND, UBND, AXIS, EL, PIXCO, DATCO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of pixel co-ordinates whose values in the axis
         array are to be found.
      }
      \sstsubsection{
         PIXCO( EL ) = ? (Given)
      }{
         The pixel co-ordinates of the values in the axis array.
      }
      \sstsubsection{
         DATCO( EL ) = ? (Returned)
      }{
         The axis-array values.  A value is set to the bad value when
         its input co-ordinate lies outside the range of co-ordinates
         in the axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and indices, and the returned values
         should have this data type as well.

         \sstitem
         A pixel co-ordinate that lies within the lower-bound or
         upper-bound element of the axis array but not between elements,
         and hence cannot have interpolation (i.e. PIXCO is less than LBND

         \sstitem
         0.5 or greater than UBND $+$ 0.5) return with the centre data
         co-ordinate of the lower-bound or upper-bound pixel respectively.

         \sstitem
         An error report is made and bad status returned should any
         input index lie outside the range of the bounds of the axis.
         Processing will continue through the list.
      }
   }
}
\sstroutine{
   KPG1\_BBOXx
}{
   Determines the bounding box of selected pixels in an n-dimensional
   array
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by summing the array values in a rectangular
      box.  The output may be normalised to take account of any bad
      values that may be present.
   }
   \sstinvocation{
      CALL KPG1\_BBOXx( NDIM, LBND, UBND, ARRAY, VALUE, EQUAL, BLBND,
                       BUBND, NPASS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the input n-dimensional array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the input n-dimensional array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         The data value used to define the box. VAL\_\_BADx is a legal
         value for this argument.
      }
      \sstsubsection{
         EQUAL = LOGICAL (Given)
      }{
         If .TRUE., then the returned box encloses all pixels with value
         equal to VALUE. If .FALSE., then the returned box encloses all
         pixels with value not equal to VALUE.
      }
      \sstsubsection{
         BLBND( NDIM ) = INTEGER (Returned)
      }{
         The lower pixel index bounds of the required box.
      }
      \sstsubsection{
         BUBND( NDIM ) = INTEGER (Returned)
      }{
         The upper pixel index bounds of the required box.
      }
      \sstsubsection{
         NPASS = INTEGER (Returned)
      }{
         The number of array elements that pass the test specified by
         VALUE and EQUAL. In general, the number of elements in the
         returned bounding box will be greater than NPASS.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output data arrays plus a work space must have the
         data type specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_BL1Dx
}{
   Smooth a 1D vector using a block average filter
}{
   \sstdescription{
      This routine smooths a 1D vector using a block average filter.
      Output pixels are set bad if all input pixels in the block are
      bad, or if the output pixel is in the first or last half block.
   }
   \sstinvocation{
      CALL KPG1\_BL1Dx( N, IN, SIZE, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of elements of the array to be smoothed.
      }
      \sstsubsection{
         IN( N ) = $<$TYPE$>$ (Given)
      }{
         The input array.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The size of the filter (in pixels).
      }
      \sstsubsection{
         OUT( N ) = $<$TYPE$>$ (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_BLOCx
}{
   Smooth a 2-dimensional image using a rectangular box filter
}{
   \sstdescription{
      The routine smooths a 2-dimensional image using a rectangular box
      filter; each pixel is replaced by the mean of those good
      neighbours which lie within a box of specified size.
   }
   \sstinvocation{
      CALL KPG1\_BLOCx( BAD, SAMBAD, VAR, NX, NY, A, IBOXX,
                       IBOXY, NLIM, B, BADOUT, ASUM, NSUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad pixels in the input
         image.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given for this argument, then bad input
         pixels will be propagated to the output image unchanged (a
         smoothed output value will be calculated for all other
         pixels). If a .FALSE. value is given, then the NLIM argument
         determines whether an output pixel is good or bad.  The value
         of SAMBAD is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If a .FALSE. value is given for this argument, then the
         smoothing applied will be appropriate to a data image. If a
         .TRUE. value is given, then the smoothing will be appropriate
         to an image containing variance values. In the latter case the
         output values will be (on average) smaller than the input
         values to take account of the variance-reducing effect which
         smoothing produces.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         First dimension of the image to be smoothed.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Second dimension of the image to be smoothed.
      }
      \sstsubsection{
         A( NX, NY ) = ? (Given)
      }{
         Input image to be smoothed.
      }
      \sstsubsection{
         IBOXX = INTEGER (Given)
      }{
         Half-size of the smoothing box in pixels in the X direction
         (the actual size of the box used will be 2$*$IBOXX$+$1 pixels).
      }
      \sstsubsection{
         IBOXY = INTEGER (Given)
      }{
         Half-size of the smoothing box in pixels in the Y direction
         (the actual size of the box used will be 2$*$IBOXY$+$1 pixels).
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         Minimum number of good pixels which must be present in the
         smoothing box in order to calculate a smoothed output pixel.
         If this minimum number is not satisfied, then a bad output
         pixel will result. A value between 1 and the total number of
         pixels in the smoothing box should be supplied.
      }
      \sstsubsection{
         B( NX, NY ) = ? (Returned)
      }{
         The smoothed output image.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether bad pixels are present in the output image.
      }
      \sstsubsection{
         ASUM( NX ) = ? (Returned)
      }{
         Workspace for the pixel sums.
      }
      \sstsubsection{
         NSUM( NX ) = INTEGER (Returned)
      }{
         Workspace for counting good pixels.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the A, B and ASUM arguments must match the
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_BOR2x
}{
   Places a border of constant values at the edges of a
   two-dimensional array
}{
   \sstdescription{
      This routine assigns a constant value to the edge pixels of a
      two-dimensional array.  The width of the edge is adjustable along
      each axis, but it is the same for the leading and trailing edges
      along a given dimension.  If the border is wider than the array
      a SAI\_\_ERROR status is returned.
   }
   \sstinvocation{
      CALL KPG1\_BOR2x( VALUE, BORWID, DIM1, DIM2, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be assigned to the borders of the array.
      }
      \sstsubsection{
         BORWID( 2 ) = INTEGER (Given)
      }{
         The width in pixels of the borders in each dimension, x then y.
         Each must be less than its corresponding dimension.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = ? (Given and Returned)
      }{
         The array to have its borders set to a constant.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         array and value to be substituted that are supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_CADDx
}{
   Add a constant to each element of a vectorised array
}{
   \sstdescription{
      The routine adds a constant to each element of a vectorised array
      to produce a new array. Bad value checking is performed if
      required.
   }
   \sstinvocation{
      CALL KPG1\_CADDx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be added to each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CHAXx
}{
   Check for usable AXIS structures
}{
   \sstdescription{
      This routine looks for monotonic AXIS structures within the
      specified axes of the supplied NDF.  If all axes have such AXIS
      structures, then a flag (DATAVL) is returned .TRUE..  If any axis
      is non-monotonic, a warning message is issued, DATAVL is returned
      .FALSE., and a scale of 1.0 and offset of 0.0 are returned.

      Each axis is then checked for linearity.  If the axis is linear,
      then the corresponding scale and offset of the linear mapping from
      pixel to data co-ordinates are returned.  Otherwise a warning
      message is issued and the returned scale and offset refer to a
      linear approximation to the axis co-ordinate system.
   }
   \sstinvocation{
      CALL KPG1\_CHAXx( INDF, NDIM, DIM, DATAVL, SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         The indices of the axes to be checked, in increasing order.
      }
      \sstsubsection{
         DATAVL = LOGICAL (Returned)
      }{
         Returned .TRUE. if the NDF contains monotonic AXIS structures
         for all requested axes.  Returned .FALSE. otherwise.
      }
      \sstsubsection{
         SCALE( NDIM ) = ? (Returned)
      }{
         The scale factors in the linear relationships between axis
         co-ordinates and pixel co-ordinates.  Returned equal to 1.0 if
         DATVAL is returned .FALSE..
      }
      \sstsubsection{
         OFFSET( NDIM ) = ? (Returned)
      }{
         The offsets in the linear relationships between axis
         co-ordinates and pixel co-ordinates.  Returned equal to 0.0 if
         DATVAL is returned .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the real and double-precision
         data types: replace {\tt "}x{\tt "} in the routine name by D or R as
         appropriate.  The SCALE and OFFSET arrays supplied to the routine
         must have the data type specified.

         \sstitem
         The returned values of SCALE and OFFSET are such that:

      }
         DATA = SCALE( I ) $*$ PIXEL $+$ OFFSET( I )

      where PIXEL is a pixel co-ordinate for the I{\tt '}th dimension listed
      in array DIM (i.e. dimension DIM( I ) ), and DATA is the
      corresponding axis co-ordinate.
   }
}
\sstroutine{
   KPG1\_CHE2X
}{
   Evaluates a 2-dimensional Chebyshev polynomial
}{
   \sstdescription{
      This routine evaluates a two-dimensional Chebyshev polynomial for
      one or more arguments.  It uses Clenshaw{\tt '}s recurrence
      relationship twice.
   }
   \sstinvocation{
      CALL KPG1\_CHE2X( NPTS, XMIN, XMAX, X, YMIN, YMAX, Y, XDEG,
                       YDEG, NCOEF, CC, NW, WORK, EVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NPTS = INTEGER (Given)
      }{
         The number of evaluations to perform at constant Y position.
      }
      \sstsubsection{
         XMIN = ? (Given)
      }{
         The lower endpoint of the range of the fit along the first
         dimension.  The Chebyshev series representation is in terms of
         a normalised variable, evaluated as (2x - (XMAX $+$ XMIN) ) /
         (XMAX - XMIN), where x is the original variable.  XMIN must be
         less than XMAX.
      }
      \sstsubsection{
         XMAX = ? (Given)
      }{
         The upper endpoint of the range of the fit along the second
         dimension.  See XMIN.
      }
      \sstsubsection{
         X( NPTS ) = ? (Given)
      }{
         The co-ordinates along the first dimension for which the
         Chebyshev polynomial is to be evaluated.
      }
      \sstsubsection{
         YMIN = ? (Given)
      }{
         The lower endpoint of the range of the fit along the first
         dimension.  The Chebyshev series representation is in terms of
         a normalised variable, evaluated as (2y - (YMAX $+$ YMIN) ) /
         (YMAX - YMIN), where y is the original variable.  YMIN must be
         less than YMAX.
      }
      \sstsubsection{
         YMAX = ? (Given)
      }{
         The upper endpoint of the range of the fit along the second
         dimension.  See YMIN.
      }
      \sstsubsection{
         Y = ? (Given)
      }{
         The co-ordinate along the second dimension for which the
         Chebyshev polynomial is to be evaluated.
      }
      \sstsubsection{
         XDEG = INTEGER (Given)
      }{
         The degree of the polynomial along the first dimension.
      }
      \sstsubsection{
         YDEG = INTEGER (Given)
      }{
         The degree of the polynomial along the second dimension.
      }
      \sstsubsection{
         MCOEF = INTEGER (Given)
      }{
         The number of coefficients.  This must be at least the product
         of (XDEG$+$1) $*$ (YDEG$+$1).
      }
      \sstsubsection{
         CC( MCOEF ) = ? (Given)
      }{
         The Chebyshev coefficients.  These should be the order such
         that CCij is in CC( i$*$(YDEG$+$1)$+$j$+$1 ) for i=0,XDEG; j=0,YDEG.
         In other words the opposite order to Fortran standard.
      }
      \sstsubsection{
         NW = INTEGER (Given)
      }{
         The number of elements in the work array.  It must be at least
         XDEG $+$ 1.
      }
      \sstsubsection{
         WORK( NW ) = ? (Returned)
      }{
         Workspace.
      }
      \sstsubsection{
         EVAL( NPTS ) = ? (Returned)
      }{
         The evaluated polynomial for the supplied arguments.  Should an
         argument lie beyond the range ([XMIN,XMAX], [YMIN,YMAX] the
         bad value is returned in the corresponding element of EVAL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for the real and double precision data types:
      replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
      XMIN, XMAX, X, YMIN, YMAX, Y, CC, WORK, and EVAL arguments
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_CHELx
}{
   Replaces the value of an array element with a specified value
}{
   \sstdescription{
      This routine replaces a specified element of a vectorised array
      with a supplied value and returns the former value of the
      element.
   }
   \sstinvocation{
      CALL KPG1\_CHELx( EL, CHEL, NEWVAL, ARRAY, OLDVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array.
      }
      \sstsubsection{
         CHEL = INTEGER (Given)
      }{
         The element number to be replaced.  It must lie between 1 and
         EL, otherwise an error report is made.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         The new value of the element.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Replaced)
      }{
         The array whose value is to be replaced.
      }
      \sstsubsection{
         OLDVAL = ? (Returned)
      }{
         The former value of the array element.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by I, R, or D as appropriate.  Arguments ARRAY,
         NEWVAL and OLDVAL must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_CHEPx
}{
   Evaluates a Chebyshev polynomial
}{
   \sstdescription{
      This evaluates a Chebyshev polynomial for orders zero to NTERM-1
      at a given normalised [-1,$+$1] co-ordinate.   It uses a recurrence
      relationship to evaluate beyond the second term.
   }
   \sstinvocation{
      CALL KPG1\_CHEPx( X, NTERM, T, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X = ? (Given)
      }{
         The normalised co-ordinate for which the Chebyshev polynomial
         is to be evaluated.  It is assumed to lie in the range
         [-1,$+$1] having been normalised using the limits that created
         the coefficients.
      }
      \sstsubsection{
         NTERM = INTEGER (Given)
      }{
         The number of terms in the Chebyshev polynomial.  It equals the
         order plus one.
      }
      \sstsubsection{
         T( NTERM ) = ? (Returned)
      }{
         The evaluated Chebyshev polynomial for each term.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         T. Hopkins \& C.Phillips, 1988, {\tt "}Numerical Methods in Practice{\tt "},
         Addison-Wesley, p.190-191.
         [routine\_references]...
      }
   }
}
\sstroutine{
   KPG1\_CHEVx
}{
   Evaluates a one-dimensional Chebyshev polynomial
}{
   \sstdescription{
      This routine evaluates a one-dimensional Chebyshev polynomial for
      one or more arguments.  It uses Clenshaw{\tt '}s recurrence
      relationship.
   }
   \sstinvocation{
      CALL KPG1\_CHEVx( XMIN, XMAX, NCOEF, CHCOEF, NPTS, X, EVAL,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XMIN = ? (Given)
      }{
         The lower endpoint of the range of the fit.  The Chebyshev
         series representation is in terms of a normalised variable,
         evaluated as ( 2x - (XMAX $+$ XMIN) ) / (XMAX - XMIN), where x
         is the original variable.  XMIN must be less than XMAX.
      }
      \sstsubsection{
         XMAX = ? (Given)
      }{
         The upper endpoint of the range of the fit.  See XMIN.
      }
      \sstsubsection{
         NCOEF = INTEGER (Given)
      }{
         The number of coefficients.  This must be at least the
         polynomial order plus one.
      }
      \sstsubsection{
         CC( NCOEF ) = ? (Given)
      }{
         The Chebyshev coefficients.
      }
      \sstsubsection{
         NPTS = INTEGER (Given)
      }{
         The number of arguments for which the Chebyshev polynomial is
         to be evaluated.
      }
      \sstsubsection{
         X( NPTS ) = ? (Given)
      }{
         The arguments for which the Chebyshev polynomial is to be
         evaluated.
      }
      \sstsubsection{
         EVAL( NPTS ) = ? (Returned)
      }{
         The evaluated polynomial for the supplied arguments.  Should an
         argument lie beyond the range [XMIN,XMAX], the bad value is
         returned in the corresponding element of EVAL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for the real and double precision data types:
      replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
      XMIN, XMAX, CC, X, and EVAL arguments supplied to the routine
      must have the data type specified.
   }
}
\sstroutine{
   KPG1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL KPG1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CMADx
}{
   Compresses an n-dimensional array by summing in `rectangular{\tt '}
   boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by summing the array values in a rectangular
      box.  The output may be normalised to take account of any bad
      values that may be present.
   }
   \sstinvocation{
      CALL KPG1\_CMADx( NDIM, DIMS, INARR, COMPRS, NLIM, NORMAL, OUTARR,
                       SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.  It must be
         greater than one.  To handle a one-dimensional array, give it
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         NORMAL = LOGICAL (Given)
      }{
         If true, the summation is normalised to allow for bad data,
         i.e. the sum with each box is multiplied by the ratio of the
         total number of pixels in the box to the actual number
         included to yield the output pixel value.  If false, the output
         array element just equates to the sum of good pixels within
         each box.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         NUM( $*$ ) = INTEGER (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output data arrays plus a work space must have the
         data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMAVx
}{
   Compresses an n-dimensional array by averaging in `rectangular{\tt '}
   boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by averaging the array values in a
      rectangular box.
   }
   \sstinvocation{
      CALL KPG1\_CMAVx( NDIM, DIMS, INARR, COMPRS, NLIM, OUTARR,
                       SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.  It must be
         greater than one.  To handle a one-dimensional array, give it
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         NUM( $*$ ) = INTEGER (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output data arrays plus a work space must have the
         data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMPKx
}{
   Compresses an n-dimensional array by picking value at equally
   spaced intervals
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by selecting the array values at equal
      intervals along each dimension.  The intervals may be different
      in each dimension.  The starting point may be defined.  Bad
      values will just be copied like any other array value.
   }
   \sstinvocation{
      CALL KPG1\_CMPKx( NDIM, DIMS, INARR, COMPRS, OFFSET, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         OFFSET( NDIM ) = REAL (Given)
      }{
         The pixel indices of the first input-array element that is to
         be put into the output array.  Subsequent selections are
         COMPRS pixels along, so these can be regarded as offsets of the
         selections.  The Ith offset must lie in the range 1 to
         COMPRS( I ).
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by ( DIMS( I ) - OFFSET( I ) ) / COMPRS( I ) $+$ 1.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the all numeric data types: replace {\tt "}x{\tt "}
         in the routine name by B, D, I, R, UB, UW, or W as appropriate.
         The input and output data arrays must have the data type
         specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMULx
}{
   Multiply each element of a vectorised array by a constant
}{
   \sstdescription{
      The routine multiplies each element of a vectorised array by a
      constant to produce a new array. Bad value checking is performed
      if required.
   }
   \sstinvocation{
      CALL KPG1\_CMULx( BAD, EL, A, CONST, B, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant by which each array element is to be multiplied.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of bad values in the output array B.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric type except double
         precision: replace {\tt "}x{\tt "} in the routine name by R, I, W, UW, B or
         UB as appropriate. The arrays supplied to the routine must have
         the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements.
      }
   }
}
\sstroutine{
   KPG1\_CMVDx
}{
   Compresses n-dimensional data and variance arrays by summing in
   `rectangular{\tt '} boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional data array and its
      associated variance array by integer factors along each dimension
      by summing the arrays{\tt '} values in a rectangular box.  The output
      data array may be normalised to take account of any bad values
      that may be present.
   }
   \sstinvocation{
      CALL KPG1\_CMVDx( NDIM, DIMS, INARR, INVAR, COMPRS, NLIM, NORMAL,
                       OUTARR, OUTVAR, SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional arrays.  It must be
         greater than one.  To handle one-dimensional arrays, give them
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-dimensional variance array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         NORMAL = LOGICAL (Given)
      }{
         If .TRUE., the summation is normalised to allow for bad data,
         i.e. the sum with each box is multiplied by the ratio of the
         total number of pixels in the box to the actual number
         included to yield the output pixel value.  If .FALSE., the
         output array element just equates to the sum of good pixels
         within each box.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional data array.  Its dimension I must
         be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional variance array.  Its dimension I
         must be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ) $*$ 2.
      }
      \sstsubsection{
         NUM( $*$ ) = INTEGER (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 )
         $*$ 2.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output arrays plus a work space must have the data type
         specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMVVx
}{
   Compresses n-dimensional data and variance arrays by averaging in
   `rectangular{\tt '} boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional data array and its
      associated variance array by integer factors along each dimension
      by averaging the arrays{\tt '} values in a rectangular box.  The output
      data array may be variance-weighted average.
   }
   \sstinvocation{
      CALL KPG1\_CMVVx( NDIM, DIMS, INARR, INVAR, COMPRS, NLIM, WEIGHT,
                       OUTARR, OUTVAR, SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional arrays.  It must be
         greater than one.  To handle one-dimensional arrays, give them
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-dimensional variance array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         WEIGHT = LOGICAL (Given)
      }{
         If true, the summation is weighted by the corresponding
         variance.  If false all the input good elements are given equal
         weight when forming the output data-array value.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional data array.  Its dimension I must
         be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional variance array.  Its dimension I
         must be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ) $*$ 2.
      }
      \sstsubsection{
         NUM( $*$ ) = ? (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 )
         $*$ 2.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output arrays plus a work space must have the data type
         specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.

         \sstitem
         If the sum of variances in the weighted average is zero, the
         output element is bad.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CPBDx
}{
   Copies bad pixels
}{
   \sstdescription{
      This routine copies the bad pixels from one array into another.
   }
   \sstinvocation{
      CALL KPG1\_CPBDx( N, D1, D2, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of points.
      }
      \sstsubsection{
         D1( N ) = ? (Given)
      }{
         The original data values.
      }
      \sstsubsection{
         D2( N ) = ? (Given)
      }{
         An associated mask array.
      }
      \sstsubsection{
         OUT( N ) = ? (Given)
      }{
         The returned array. Equal to D1 if both D1 and D2 are good (bad
         if either D1 or D2 is bad).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         input and output data arrays plus the mask array must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_CPNDx
}{
   Copies a section of an n-dimensional array
}{
   \sstdescription{
      This routine copies a specified section of the supplied
      n-dimensional array (IN) to an output array (OUT).
   }
   \sstinvocation{
      CALL KPG1\_CPNDx( NDIM, LBNDI, UBNDI, IN, LBNDO, UBNDO, OUT, EL,
                         STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         LBNDI( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the IN array.
      }
      \sstsubsection{
         UBNDI( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the IN array.
      }
      \sstsubsection{
         IN( $*$ ) = ? (Given)
      }{
         The input array. Bounds given by LBNDI and UBNDI.
      }
      \sstsubsection{
         LBNDO( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         UBNDO( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         OUT( $*$ ) = ? (Returned)
      }{
         The output array. Bounds given by LBNDO and UBNDO.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The number of elements in the output array. Derived from LBNDO
         and UBNDO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
          There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
          the routine name by B, D, I, R, W, UB or UW as appropriate.  The
          IN and OUT arrays supplied to the routine must have the data type
          specified.

         \sstitem
         If the output array is not completely contained within the input
         array, then the sections of the output array which fall outside the
         input arrays will be filled with bad values.
      }
   }
}
\sstroutine{
   KPG1\_CPNTx
}{
   Creates a primitive NDF with a title via the parameter system
}{
   \sstdescription{
      This routine packages a common series of NDF calls when creating
      a primitive NDF, whose name is obtained from the parameter system,
      and also obtaining its title from the parameter system.  The need
      to handle an optional output file via the null character is
      catered.  The data type of the NDF data array is the same as the
      supplied array.  An NDF context is started and ended within this
      routine.
   }
   \sstinvocation{
      CALL KPG1\_CPNTx( PNNDF, PNTIT, NDIM, DIMS, ARRAY, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the name of the output NDF.
      }
      \sstsubsection{
         PNTIT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the title of the output NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in the NDF{\tt '}s data array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF{\tt '}s data array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = ? (Given)
      }{
         The array to be placed in the primitive NDF{\tt '}s data array.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If true a null value returned by either parameter GET is
         annulled.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         data array supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CSUBx
}{
   Subtract a constant from each element of a vectorised array
}{
   \sstdescription{
      The routine subtracts a constant from each element of a
      vectorised array to produce a new array. Bad value checking is
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_CSUBx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be subtracted from each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CTCPx
}{
   Copies values from catalogue columns to an array
}{
   \sstdescription{
      This routine gets NEL values for a set of given CAT (see SUN/181)
      columns, derived from rows 1 to NEL of a given catalogue,
      selection, or index, and stores them in array OUT.
   }
   \sstinvocation{
      CALL KPG1\_CTCPx( CI, NAX, GI, NEL, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI = INTEGER (Given)
      }{
         The CAT identifier for the catalogue, selection or index
         containing the required data.
      }
      \sstsubsection{
         NAX= INTEGER (Given)
      }{
         The number of columns from which values are to be read.
      }
      \sstsubsection{
         GI( NAX ) = INTEGER (Given)
      }{
         The CAT identifiers for the column, expressions or parameters
         to be evaluated for rows 1 to NEL of the component identified
         by CI. If any elements of this array are CAT\_\_NOID, then the
         corresponding elements of OUT are filled with the row number.
      }
      \sstsubsection{
         NEL = INTEGER (Given)
      }{
         The number of rows to copy.
      }
      \sstsubsection{
         OUT( NEL, NAX ) = ? (Returned)
      }{
         The returned values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, and
         double precision: replace {\tt "}x{\tt "} in the routine name by I, or D as
         appropriate.  The output array from this routine should have the
         specified data type.
      }
   }
}
\sstroutine{
   KPG1\_D2W2x
}{
   Converts linear data co-ordinates to world co-ordinates
}{
   \sstdescription{
      The co-efficients of the linear transformation from world
      co-ordinates to data co-ordinates are supplied in arguments SCALE
      and OFFSET.  The inverse of this transformation is used to
      transform each supplied position from data to world co-ordinates.
   }
   \sstinvocation{
      CALL KPG1\_D2W2x( SCALE, OFFSET, NPOINT, XP, YP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE( 2 ) = ? (Given)
      }{
         The scale factors in the linear relationships between axis
         co-ordinates and pixel co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = ? (Given)
      }{
         The offsets in the linear relationships between axis
         co-ordinates and pixel co-ordinates.
      }
      \sstsubsection{
         NPOINT = INTEGER (Given)
      }{
         The number of points specified.
      }
      \sstsubsection{
         XP( NPOINT ) = ? (Given and Returned)
      }{
         On input the x data co-ordinate of each point.  On return the
         x world co-ordinate of each point.
      }
      \sstsubsection{
         YP( NPOINT ) = ? (Given and Returned)
      }{
         On input the y data co-ordinate of each point.  On return the
         y world co-ordinate of each point.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the real and double-precision
         data types: replace {\tt "}x{\tt "} in the routine name by D or R as
         appropriate.  The SCALE, OFFSET, XP and YP  arrays must have the
         data type specified.

         \sstitem
         The supplied values of SCALE and OFFSET are such that:

      }
         DATA = SCALE( I ) $*$ PIXEL $+$ OFFSET( I )

      where PIXEL is a pixel co-ordinate for the I{\tt '}th dimension, and
      DATA is the corresponding axis co-ordinate.
   }
}
\sstroutine{
   KPG1\_DARA$<$T$>$
}{
   Determine the data limits for an array using a variety of methods
}{
   \sstdescription{
      This routine derives a data range applicable to the supplied
      array.  It is intended to be used to specify the data limits for
      histogram plots and scaling data for image display.  There is a
      variety of methods available to derive the limits, of which a
      subset of appropriate methods can be defined by argument METHOD.

      The method is selected by the user through the literal parameter
      specified by PARAM.  The supplied string should consist of up to
      three sub-strings or elements, separated by commas.  In all but
      one method, the first element must specify the method to use.  If
      supplied, the other two elements should be numerical values as
      described below (default values will be used if these elements are
      not provided).  The following options are available.

      \sstitemlist{

         \sstitem
            {\tt "}Extended{\tt "} -- LOWER and UPPER are returned equal to the
            lowest and highest supplied data values, extended to give a
            margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the
            second and third elements of the array.  These values are
            percentages of the total data range.  So, {\tt "}Extended,10,5{\tt "}
            includes a margin of 10\% of the total data range in LOWER, and
            5\% in UPPER.  If only one numerical value is given, the same
            value is used for both limits.  If no value is given, both
            limits default to 2.5.  {\tt "}Range{\tt "} is equivalent to
            {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Faint{\tt "} -- The scaling is between the mean data value minus
            one standard deviation and the mean data value plus seven
            standard deviations.  This is retained for historical reasons.

         \sstitem
            {\tt "}Limit{\tt "} --  Allows user to supply explicit lower and upper
            limiting values.  For example, {\tt "}Limit,10,20{\tt "} would set the
            lower limit to 10 and its upper limit to 20.  For compatibility
            reasons and for ease of use, this routine permits the omission
            of the method.  Thus {\tt "}10,20{\tt "} is equivalent to the previous
            example.  The upper limit may be numerically smaller than the
            lower limit, as might be needed for display scaling.  If fewer
            than two numerical values are supplied, the {\tt "}Range{\tt "} method is
            adopted.  The limits must be within the allowed range for the
            data type of the ARRAY argument.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the
            array are interpreted as percentiles.  For instance,
            {\tt "}Perc,5,95{\tt "} causes 5\% of the data points to be below LOWER, and
            10\% to be above the UPPER.  If only 1 value (p1) is supplied,
            the other one, p2, defaults to (100 - p1).  If no values are
            supplied, p1 and p2 default to 5 and 95 respectively.  Values
            must be in the range 0 to 100.

         \sstitem
            {\tt "}Range{\tt "} -- LOWER and UPPER are returned equal to the lowest
            and highest supplied array values.

         \sstitem
            {\tt "}Sigmas,2,3{\tt "} -- The second and third elements of the array
            are interpreted as multiples of the standard deviation of the
            data values.  For instance, {\tt "}S,2,3{\tt "} causes the LOWER to be the
            mean of the data values, minus two sigma, and UPPER to be the
            mean plus three sigma.  If only 1 value is supplied, the same
            value is used for both limits.  If no values are supplied, both
            values default to 3.0.

      }
      The above method names can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Range{\tt "} is
      assumed (i.e. LOWER and UPPER are chosen so that the
      encompasses the entire data range).

      The extreme values are reported unless the limits parameter PARAM
      is specified on the command line.  In this case extreme values
      are only calculated where necessary for the chosen method.
   }
   \sstinvocation{
      CALL KPG1\_DARA$<$T$>$( PARAM, EL, ARRAY, METHDS, BAD, LOWER,
                       UPPER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = $<$TYPE$>$ (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         METHDS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of methods by which the data limits may
         be specified.  Different tasks may require only a subset of
         the methods available.  The allowed methods are {\tt "}Faint{\tt "},
         {\tt "}Extended{\tt "}, {\tt "}Limit{\tt "}, {\tt "}Percentiles{\tt "}, {\tt "}Range{\tt "}, and {\tt "}Sigmas{\tt "}.
         See the description for details of these methods.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         LOWER = DOUBLE PRECISION (Returned)
      }{
         The lower limit.
      }
      \sstsubsection{
         UPPER = DOUBLE PRECISION (Returned)
      }{
         The upper limit.
      }
      \sstsubsection{
         STATUS = INTEGER( Given \& Returned )
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_DCLIx
}{
   Determines a linear transformation from pixel to NDF-axis
   co-ordinates
}{
   \sstdescription{
      This routine obtains a data co-ordinate system from the NDF
      axes, and determines whether all the axes are linear.  If they
      are linear transformations between pixel co-ordinates and
      data co-ordinates are derived.  A warning message is reported
      for each individual non-linear axis.
   }
   \sstinvocation{
      CALL KPG1\_DCLIx( NDIM, NDF, DALBND, DAUBND, SCALE, OFFSET, LINEAR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of contiguous axes.  If it is negative, it indicates
         that not all the dimensions need be significant.
      }
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The identifier of the NDF whose axes are to provide the data
         co-ordinates.  It must have at least NDIM dimensions, though
         this is not checked.
      }
      \sstsubsection{
         DALBND( NDIM ) = ? (Returned)
      }{
         The lower bounds of the data co-ordinates obtained from the
         NDF{\tt '}s axes.  Note that this gives the data co-ordinate at the
         lower side of the array element, and not at its centre.
      }
      \sstsubsection{
         DAUBND( NDIM ) = ?  (Returned)
      }{
         The upper bounds of the data co-ordinates obtained from the
         NDF{\tt '}s axes.   Note that this gives the data co-ordinate at the
         upper side of the array element, and not at its centre.
      }
      \sstsubsection{
         SCALE( NDIM ) = ? (Returned)
      }{
         The scale factors in the linear transformations from world
         to data co-ordinates.  They should be ignored if LINEAR is
         false.
      }
      \sstsubsection{
         OFFSET( NDIM ) = ? (Returned)
      }{
         The offsets in the linear transformations from world
         to data co-ordinates.  They should be ignored if LINEAR is
         false.
      }
      \sstsubsection{
         LINEAR = LOGICAL (Returned)
      }{
         If true the NDF axes are all linear and different from world
         co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The scale
         and offset, and the bounds returned by the routine must have
         the data type specified.

         \sstitem
         This routine assumes monotonic axes.
      }
   }
}
\sstroutine{
   KPG1\_DIVx
}{
   Divide two vectorised arrays with optional variance information
}{
   \sstdescription{
      The routine divides one vectorised array by another, with
      optional variance information.  Bad value checking is also
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_DIVx( BAD, VAR, EL, A, VA, B, VB, C, VC, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad values in the input
         arrays.  The routine will execute more rapidly if this checking
         can be omitted.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Whether associated variance information is to be processed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         First array of data, to be divided by the second array.
      }
      \sstsubsection{
         VA( EL ) = ? (Given)
      }{
         Variance values associated with the array A.  Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         B( EL ) = ? (Given)
      }{
         Second array of data, to be divided into the first array.
      }
      \sstsubsection{
         VB( EL ) = ? (Given)
      }{
         Variance values associated with the array B.  Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         C( EL ) = ? (Returned)
      }{
         Result of dividing array A by array B.
      }
      \sstsubsection{
         VC( EL ) = ? (Returned)
      }{
         Variance values associated with the array C.  Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of VAL\_\_BADx values in the returned results array (C).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types real and double
         precision: replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate.  The arrays passed to this routine should all have
         the specified data type.

         \sstitem
         This routine will NOT handle numerical overflow.
      }
   }
}
\sstroutine{
   KPG1\_DWSOx
}{
   Obtains for the scale and offset for a linear transformation from
   world to data co-ordinates
}{
   \sstdescription{
      This routine determines a linear transformation between world
      (pixel) co-ordinates and data co-ordinates obtained from the axis
      structure.  A linear equation is solved using the two boundary
      conditions for the lower and upper bounds in world and data
      co-ordinates.
   }
   \sstinvocation{
      CALL KPG1\_DWSOx( LBND, UBND, AXIS, SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         SCALE = ? (Returned)
      }{
         The scale factor of the linear axis to transform from world
         co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         OFFSET = ? (Returned)
      }{
         The offset of the linear axis at pixel 0 to transform from
         world co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array, and the returned scale and offset
         should have this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_ELNMx
}{
   Writes a range of element numbers into an array
}{
   \sstdescription{
      This routine writes numbers sequentially to a 1-dimensional
      array, where the numbers are between defined integer limits and
      are stepped by 1 (or -1) from one pixel to the next.  In other
      words the array value takes the element number plus an offset.
      Only the first EL elements can be accommodated in the output
      array, should the section be larger than this.
   }
   \sstinvocation{
      CALL KPG1\_ELNMBx( LBND, UBND, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The first value to be written to the output array.  If this is
         larger than argument UBND, the values will decrease by 1 for
         each element.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The last value to be written to the output array, provided
         there are sufficient elements to accommodate it.  If not
         only EL values will be stored.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the output array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The array into which the sub-array is copied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY argument must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_EXPOx
}{
   Takes the exponential to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the exponential of the pixels of the input array
      to the base specified, i.e. New\_value = Base $*$$*$ Old\_value.
      If the result is bigger than the maximum-allowed value
      then a bad pixel value is substituted in the output array.

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance $*$ ( New\_value $*$ log Base )
   }
   \sstinvocation{
      CALL KPG1\_EXPOx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of exponential to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_FFRx
}{
   Reads free-format floating-point data from a string
}{
   \sstdescription{
      A buffer containing free-format values separated by spaces
      or commas is decoded and the numerical values extracted.
      It packages up the equivalent SLALIB calls (SLA\_FLOTIN and
      SLA\_DFLTIN) in order to obtain an array of values with a single
      line of code, and provides standard error handling.  See SUN/67
      for more details of the parsing technique and limitations.

      If the desired number of values cannot be decoded from the string
      an error status SAI\_\_ERROR is set.
   }
   \sstinvocation{
      CALL KPG1\_FFRx( STRING, NVAL, ORIGIN, VALUES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the values to be decoded and extracted.
      }
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The number of values to extract from the string.
      }
      \sstsubsection{
         ORIGIN = INTEGER (Given and Returned)
      }{
         On input this is the column or pointer in the string from
         where the decoding commences.  On output it is advanced to the
         next number or the end of the buffer if there are no more
         numbers.
      }
      \sstsubsection{
         VALUES( NVAL ) = ? (Returned)
      }{
         The decoded values.  These are initialised to zero before
         decoiding commences.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for floating-point numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         array returned from the routine must have the data type specified.
         [routine\_notes]...
      }
   }
}
\sstroutine{
   KPG1\_FFTF$<$T$>$
}{
   Takes the forward FFT of a real image
}{
   \sstdescription{
      The Fourier transform of the input (purely real) image is taken
      and returned in OUT.  The returned FT is stored in Hermitian
      format, in which the real and imaginary parts of the FT are
      combined into a single array.  The FT can be inverted using
      KPG1\_FFTB$<$T$>$, and two Hermitian FTs can be multipled together
      using routine KPG1\_HMLT$<$T$>$.
   }
   \sstinvocation{
      CALL KPG1\_FFTF$<$T$>$( M, N, IN, WORK, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input image.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows in the input image.
      }
      \sstsubsection{
         IN( M, N ) = $<$COMM$>$ (Given)
      }{
         The input image.
      }
      \sstsubsection{
         WORK( $*$ ) = $<$COMM$>$ (Given)
      }{
         Work space.  This must be at least ( 3$*$MAX( M, N ) $+$ 15 )
         elements long.
      }
      \sstsubsection{
         OUT( M, N ) = $<$COMM$>$ (Returned)
      }{
         The FFT in Hermitian form.  Note, the same array can be used
         for both input and output, in which case the supplied values
         will be over-written.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The input and output data arrays plus a work space
         must have the data type specified.
      }
   }
   \sstimplementationstatus{
      Some of the generated code looks a bit odd because the names of
      the PDA subroutines do not match the standard type naming
      conventions required by GENERIC.  Explicit IF statements are
      included but since these compare constants (after generic is run)
      the compiler will optimize the checks out of the final runtime.
      The real fix is to fix the names of the PDA routines (and
      associated KPG routine).
   }
}
\sstroutine{
   KPG1\_FIGRx
}{
   Sets each element in a N-dimensional array to its grid
   co-ordinate
}{
   \sstdescription{
      This routine sets each pixel in an N-dimensional array to its grid
      co-ordinate.
   }
   \sstinvocation{
      CALL KPG1\_FIGRx( NDIMS, DIMS, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         Array of dimension sizes for each array dimension.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         First dimension of the array of grid co-ordinates.  It must be
         at least the total number of elements, i.e. the product of the
         DIMS dimensions.
      }
      \sstsubsection{
         ARRAY( EL, NDIM ) = ? (Returned)
      }{
         The array containing the grid co-ordinates of each element
         given by the supplied dimensions.  The values are stored such
         that the first co-ordinate for all pixels is then followed
         by second co-ordinate for all pixels and so on.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for double precision, real, and integer:
         replace {\tt "}x{\tt "} in the routine name by D, R, or I as appropriate.  The
         ARRAY argument must have the data type specified.

         \sstitem
         The maximum number of dimensions which can be handled by this
         routine is equal to the symbolic constant NDF\_\_MXDIM.

         \sstitem
         The ordering of the ARRAY elements is counterintuitive, but
         that{\tt '}s what AST\_TRANN uses.
      }
   }
}
\sstroutine{
   KPG1\_FILLx
}{
   Sets all elements in a vectorised array to a specified value
}{
   \sstdescription{
      This routine sets all the pixels in a 1-dimensional array to a
      specified value.
   }
   \sstinvocation{
      CALL KPG1\_FILL$<$T$>$( VALUE, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be substituted in every pixel.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array to be filled with a constant.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The output array containing a single value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B, or UB as appropriate.  The
         VALUE and ARRAY arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_FLASx
}{
   Flashes image into a cell array
}{
   \sstdescription{
      This subroutine converts a $<$COMM$>$ 2-d array into an
      integer cell array without scaling it.  However, the cell array
      is computed by modulo arithmetic between the lowest and highest
      colour indices, or the complement of this should a negative
      scaling be required. The image is normally inverted for output on
      an image display, though this can be overridden.
   }
   \sstinvocation{
       CALL KPG1\_FLASx( BAD, DIM1, DIM2, INARR, LOWPEN, HIPEN, INVERT,
      :                 POSTIV, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad pixels will be processed.  This should not be set
         to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d array.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The array of data to be flashed.
      }
      \sstsubsection{
         LOWPEN = INTEGER (Given)
      }{
         The lowest colour index to be used in case smaller values have
         been reserved for annotation.
      }
      \sstsubsection{
         HIPEN = INTEGER (Given)
      }{
         The highest colour index to be used.  Normally this is the
         number of greyscale intensities available on the chosen device.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if the display of the image is to be positive.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The cell array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for five numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, or W as appropriate.  The array
         supplied to the routine must have the data type specified.

         \sstitem
         The array is normally inverted so that the image will appear
         the correct way round when displayed as the GKS routine
         to display the image inverts it.
      }
   }
}
\sstroutine{
   KPG1\_FLCOx
}{
   Obtains a list of co-ordinates from a text file
}{
   \sstdescription{
      This routine obtains a list of n-dimensional co-ordinates for a
      series of positions.  The text file should contain on each line
      a set of free-format co-ordinates that defines a position, except
      for comment lines denoted by a hash or shriek in column 1.
      The file is opened using the supplied parameter.  A pass is made
      through the file to see how many records it contains.  Dynamic
      workspace is reserved to contain the co-ordinates, and the file
      is then rewound.  Another pass is made through the file to read
      the co-ordinate values which are then stored in the workspace.
      Pointers to the workspace are returned.  This workspace should be
      released by calling PSX\_FREE when it is no longer needed.
   }
   \sstinvocation{
      CALL KPG1\_FLCOx( PNAME, NDIM, POSCOD, NPOINT, IPCO, LBND, UBND,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter with which to associate the text file.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of co-ordinate dimensions to read from the text
         file.
      }
      \sstsubsection{
         POSCOD( NDIM ) = INTEGER (Given)
      }{
         The column numbers of the co-ordinate information in order
         x, y, z, etc.  These must be positive.
      }
      \sstsubsection{
         NPOINT = INTEGER (Returned)
      }{
         The number of co-ordinate sets specified in the text file.
      }
      \sstsubsection{
         IPCO = INTEGER (Returned)
      }{
         A pointer to workspace of type $<$HTYPE$>$ and size NDIM by NPOINT
         holding the NDIM co-ordinates of each point.
      }
      \sstsubsection{
         LBND( NDIM ) = ? (Returned)
      }{
         The lower bounds of the input data, i.e. the minimum value for
         each co-ordinate.
      }
      \sstsubsection{
         UBND( NDIM ) = ? (Returned)
      }{
         The upper bounds of the input data, i.e. the maximum value for
         each co-ordinate.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the real or double-precision
         data types: replace {\tt "}x{\tt "} in the routine name by R or D
         respectively, as appropriate.  The returned co-ordinate array
         will have this type, and the supplied bounds arrays should also
         have the specified data type.

         \sstitem
         The number of points read from the file is reported at the
         normal reporting level.
      }
   }
}
\sstroutine{
   KPG1\_FLIPx
}{
   Reverse the pixels in an N-dimensional array along a specified
   dimension
}{
   \sstdescription{
      This routine reverses the order of the pixels in an N-dimensional
      array along a specified dimension. The pixel values are
      unchanged. The array may have any number of dimensions.
   }
   \sstinvocation{
      CALL KPG1\_FLIPx( NDIM, DIM, DATIN, IDIM, DATOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         Array of dimension sizes for each array dimension.
      }
      \sstsubsection{
         DATIN( $*$ ) = ? (Given)
      }{
         The input NDIM-dimensional array.
      }
      \sstsubsection{
         IDIM = INTEGER (Given)
      }{
         Number of the array dimension along which the pixel values are
         to be reversed (in the range 1 to NDIM).
      }
      \sstsubsection{
         DATOUT( $*$ ) = ? (Returned)
      }{
         Output array, with the pixels reversed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each standard numeric type; replace {\tt "}x{\tt "}
         in the array name by D, R, I, W, UW, B or UB as appropriate. The
         data type of the arrays supplied must match the particular
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_FRACx
}{
   Finds values corresponding to specified fractions of an array{\tt '}s
   ordered distribution
}{
   \sstdescription{
      This routine finds the values at defined fractions of an array{\tt '}s
      ordered distribution, such as percentiles.  Thus to find the
      upper-quartile value, the fraction would be 0.75.  Since it uses
      an histogram technique rather than sorting the whole array, for
      efficiency, the result may not be exactly correct.  However,
      the histogram has a large number of bins (10000), combined with
      linear interpolation between bins in the routine reduce the error.
      The histogram extends between the minimum and maximum data values.

      The routine also has an iterative method, whereby outliers, which
      compress the vast majority of data values into a few bins, are
      excluded from the histogram.  Clipping occurs from both ends.
      A contiguous series of bins are removed until the largest
      or smallest fraction is encountered.  Where the rejection of bins
      end, defines new limits, encompassing the vast majority of values.
      A new histogram is calculated using these revised limits.  The
      excluded outliers are still counted in the evaluation of the
      fractions.  The criterion for iteration may need tuning in the
      light of experience.  At present it is when there are fewer than
      4\% non-zero bins.

      The iteration can still fail to find accurate fractional values if
      smallest and largest fractions are close to 0 or 1 and correspond
      to extreme outliers.  The routine recognises this state and
      determines the values for each outlier fraction separately, and
      then uses the next interior fraction as the limit.  Then the
      routine proceeds with the clipping described above.
   }
   \sstinvocation{
      CALL KPG1\_FRACx( EL, ARRAY, NFRAC, FRAC, BAD, CLFRAC, VALUES,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = $<$TYPE$>$ (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         NFRAC = INTEGER (Given)
      }{
         Number of fractional positions.
      }
      \sstsubsection{
         FRAC( NFRAC ) = REAL (Given and Returned)
      }{
         Fractional positions in the histogram in the range 0.0--1.0.
         On exit they are arranged into ascending order.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         CLFRAC( NFRAC ) = REAL (Returned)
      }{
         The clipped fractional positions in the histogram in the range
         0.0--1.0 after iterative clipping of the histogram.
      }
      \sstsubsection{
         VALUES( NFRAC ) = DOUBLE PRECISION (Returned)
      }{
         Values corresponding to the ordered fractional positions in
         the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, W, UB or UW as appropriate.  The
         array supplied to the routine must have the data type specified.

         \sstitem
         For integer types the number of bins does not exceed the
         data range.  The number of bins is reduced as clipping occurs.
      }
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         The iterative algorithm is not especially efficient; for data
         with a very wide range the iterations can be numerous.  A
         sigma-clipping approach to remove the outliers might be better.

         \sstitem
         The adjustment of the limiting fractions is done for each
         limit separately, thus involving a further pass through the
         array.  At present it finds the more extreme outlier first by
         comparing the bin number of the limits with respect to the mean
         bin number.
      }
   }
}
\sstroutine{
   KPG1\_GAUFx
}{
   To fit a Gaussian to a one-dimensional array of data
}{
   \sstdescription{
      This routine fits a Gaussian to a 1-d array of data.  It finds
      the amplitude, centre, sigma and background levels by an
      iterative method.
   }
   \sstinvocation{
       CALL KPG1\_GAUFx( DATA, LBND, UBND, NITER, TOLL, AMP, X0,
      :                  SIGMA, BACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( LBND:UBND ) = ? (Given)
      }{
         The data array to be fitted by a Gaussian.
      }
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the data array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the data array.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of refining iterations.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The accuracy criterion: absolute for the centre and relative
         for the amplitude and width.  The accuracy of back is assessed
         as a fraction of the Gaussian amplitude.
      }
      \sstsubsection{
         AMP = REAL (Returned)
      }{
         The Gaussian amplitude.
      }
      \sstsubsection{
         X0 = REAL (Returned)
      }{
         The Gaussian centre.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         The {\tt '}sigma{\tt '} of the Gaussian.
      }
      \sstsubsection{
         BACK = REAL (Returned)
      }{
         The background signal level.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_GAUSx
}{
   Smooths a two-dimensional array using a symmetrical Gaussian PSF
}{
   \sstdescription{
      The routine smooths the array A using a symmetrical Gaussian
      point-spread function and returns the result in the array B.
   }
   \sstinvocation{
      CALL KPG1\_GAUSx( SIGMA, IBOX, SAMBAD, WLIM, NX, NY, BAD,
                       VAR, A, B, BADOUT, WEIGHT, AMAR, WMAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SIGMA = REAL (Given)
      }{
         Standard deviation of the Gaussian to be used for smoothing.
      }
      \sstsubsection{
         IBOX = INTEGER (Given)
      }{
         Half-size, in pixels, of the box over which the Gaussian
         smoothing profile will be applied (the actual box used has an
         edge which is 2$*$IBOX$+$1 pixels long).  This defines the region
         within which the point spread function is non-zero.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given, then any {\tt "}bad{\tt "} pixels in the input
         array A will be propagated to the output array B (output
         values will be calculated for all other output pixels).  If a
         .FALSE. value is given, then the WLIM argument is used to
         determine which output pixels will be bad (if any). This
         argument is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         WLIM = ? (Given)
      }{
         The minimum weighting that can be used to compute a smoothed
         output pixel if SAMBAD is .FALSE..  Any output pixels falling
         short of the specified weight will be set to the bad value
         (invalid pixels carry no weight, others have Gaussian weights
         about the central pixel).  The value must be greater than 0.0
         and should be less than or equal to 1.0. This argument is not
         used if SAMBAD is .TRUE. or if BAD is .FALSE..
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         First dimension of the two-dimensional array A.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Second dimension of the two-dimensional array A.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether or not it is necessary to check for bad pixels in the
         input array A.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If a .FALSE. value is given for this argument, then smoothing
         will be performed as if the array supplied (A) is an array of
         data and the PSF will be used directly as specified.  If a
         .TRUE. value is given, then smoothing will be applied as if
         the array is an array of variance values associated with an
         array of data; in this case, the effective PSF will be reduced
         in width by a factor 2 and the mean output values will be
         reduced to reflect the variance-reducing effect of smoothing.
      }
      \sstsubsection{
         A( NX, NY ) = ? (Given)
      }{
         Array containing the input image to be smoothed.
      }
      \sstsubsection{
         B( NX, NY ) = ? (Returned)
      }{
         Array to receive the smoothed output image.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether there are bad pixel values in the output array.
      }
      \sstsubsection{
         WEIGHT( 2 $*$ IBOX $+$ 1 ) = ? (Returned)
      }{
         Workspace for the Gaussian weighting function.
      }
      \sstsubsection{
         AMAR( NX ) = ? (Returned)
      }{
         Workspace for the weighted sum of array values.
      }
      \sstsubsection{
         WMAR( NX ) = ? (Returned)
      }{
         Workspace for the sum of pixel weights.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There are routines for processing double precision and real data.
      Replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
      data types of the WLIM, A, B, WEIGHT, AMAR, and WMAR arguments
      must match the routine used.
   }
}
\sstroutine{
   KPG1\_GHSTx
}{
   Calculates the histogram of an array of data
}{
   \sstdescription{
      This routine calculates the truncated histogram of an array of
      data between defined limits and in a defined number of bins.
   }
   \sstinvocation{
       CALL KPG1\_GHSTx( BAD, SIZE, ARRAY, NUMBIN, CUMUL, VALMAX, VALMIN,
      :                 HIST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., bad pixels will be processed.  This should not be
         set to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The dimension of the array whose histogram is required.
      }
      \sstsubsection{
         ARRAY( SIZE ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in the histogram.  For integer data types
         this should result in a bin width of at least one unit.  So for
         example, byte data should never have more than 256 bins.
      }
      \sstsubsection{
         CUMUL = LOGICAL (Given)
      }{
         Is a cumulative histogram required?
      }
      \sstsubsection{
         VALMAX = ? (Given and Returned)
      }{
         Maximum data value included in the array.  If this is supplied
         as VAL\_\_BAD$<$T$>$, then the actual maximum value in the ARRAY is
         found and used, and returned on exit.
      }
      \sstsubsection{
         VALMIN = ? (Given and Returned)
      }{
         Minimum data value included in the array.  If this is supplied
         as VAL\_\_BAD$<$T$>$, then the actual minimum value in the ARRAY is
         found and used, and returned on exit.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Returned)
      }{
         Array containing the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If VALMAX or VALMIN is supplied equal to VAL\_\_BAD$<$T$>$, then the
         actual maximum and minimum values will be found (by searching the
         ARRAY), and used.

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, R, I, UB, UW, or W as appropriate.  The
         arguments ARRAY, VALMAX, and VALMIN must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_HCONx
}{
   Take the complex conjugate of an Hermitian image
}{
   \sstdescription{
      The complex conjugate of the supplied Hermitian image is returned.
      See routine KPG1\_HMLTx for more information on Hermitian images.
   }
   \sstinvocation{
      CALL KPG1\_HCONx( M, N, IN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows.
      }
      \sstsubsection{
         IN( N, M ) =? (Given and Returned)
      }{
         On input it is the Hermitian image.  On exit it holds the
         complex conjugate of the supplied array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the IN argument must match the routine used.
      }
   }
}
\sstroutine{
   KPG1\_HMLTx
}{
   Multiply two Hermitian images
}{
   \sstdescription{
      Each input Hermitian image represents a COMPLEX image in which
      certain symmetries exist.  These symmetries allow all the
      information stored in the COMPLEX image to be compressed into a
      single REAL image.  This routine effectively unpacks the two REAL
      images given as input into two COMPLEX images, multiplies them
      together pixel-by-pixel to produce another COMPLEX image, and
      then packs the COMPLEX image back into a single Hermitian REAL
      image.  In fact it is not necessary to do the actual unpacking
      and packing of these Hermitian images; this algorithm generates
      the output Hermitian image directly and thus saves time.

      See the Notes for more details of Hermitian images and how they
      are multiplied.
   }
   \sstinvocation{
      CALL KPG1\_HMLTx( M, N, IN1, IN2, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows.
      }
      \sstsubsection{
         IN1( N, M ) = ? (Given)
      }{
         The first input Hermitian image.
      }
      \sstsubsection{
         IN2( N, M ) = ? (Given)
      }{
         The second input Hermitian image.
      }
      \sstsubsection{
         OUT( N, M ) = ? (Returned)
      }{
         The product of the two input images, in Hermitian form.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the IN1, IN2, and OUT arguments must match the
         routine used.

         \sstitem
         Fourier transforms supplied in Hermitian form can be thought of
         as being derived as follows (see the NAG manual, introduction to
         Chapter C06 for more information on the storage of Hermitian
         FFTs):

      }
      1) Take the one-dimensional FFT of each row of the original image.
      2) Stack all these one-dimensional FFTs into a pair of
         2-dimensional images the same size as the original image. One
         2-dimensional image ({\tt "}A{\tt "}) holds the real part and the other
         ({\tt "}B{\tt "}) holds the imaginary part.  Each row of image A will have
         symmetry such that A(J,row) = A(M-J,row) (J goes from 0 to
         M-1), while each row of image B will have symmetry such that
         B(J,row) = -B(M-J,row).
      3) Take the one-dimensional FFT of each column of image A.
      4) Stack all these one-dimensional FFTs into a pair of 2D images,
         image AA holds the real part of each FFT, and image BA holds
         the imaginary part.  Each column of AA will have symmetry such
         that AA(column,K) = AA(column,N-K) (K goes from 0 to N-1),
         each column of BA will have symmetry such that BA(column,K) =
      \sstitemlist{

         \sstitem
            BA(column,N-K).
         5) Take the one-dimensional FFT of each column of image B.
         6) Stack all these one-dimensional FFTs into a pair of
            2-dimensional images, image AB holds the real part of each
            FFT, and image BB holds the imaginary part.  Each column of AB
            will have symmetry such that AB(column,K) = AB(column,N-K) (K
            goes from 0 to N), each column of BB will have symmetry such
            that BB(column,K) = -BB(column,N-K).
         7) The resulting four images all have either positive or negative
            symmetry in both axes.  The Hermitian FFT images supplied to
            this routine are made up of one quadrant from each image.  The
            bottom-left quadrant is taken from AA, the bottom-right
            quadrant is taken from AB, the top-left quadrant is taken from
            BA and the top-right quadrant is taken from BB.

      }
      The product of two Hermitian FFTs is itself Hermitian and so can
      be described in a similar manner.  If the first input FFT
      corresponds to the four images AA1, AB1, BA1 and BB1, and the
      second input FFT corresponds to the four images AA2, AB2, BA2,
      BB2, then the output is described by the four images AA, AB, BA
      and BB where:

      AA =  AA1$*$AA2 $+$ BB1$*$BB2 - BA1$*$BA2 - AB1$*$AB2
      BB =  AA1$*$BB2 $+$ BB1$*$AA2 $+$ BA1$*$AB2 $+$ AB1$*$BA2
      BA =  BA1$*$AA2 - AB1$*$BB2 $+$ AA1$*$BA2 - BB1$*$AB2
      AB = -BA1$*$BB2 $+$ AB1$*$AA2 $+$ AA1$*$AB2 - BB1$*$BA1
   }
}
\sstroutine{
   KPG1\_HSDSx
}{
   Tabulates an histogram
}{
   \sstdescription{
      This routine reports an histogram to the user.
   }
   \sstinvocation{
      CALL KPG1\_HSDSx( NUMBIN, HIST, HRMIN, HRMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         The number of bins in the histogram.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Given)
      }{
         The array holding the histogram.
      }
      \sstsubsection{
         HRMIN = ? (Given)
      }{
         The minimum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         HRMAX = ? (Given)
      }{
         The maximum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         extreme values of the histogram must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_HSFLx
}{
   Writes an histogram to a Fortran formatted file
}{
   \sstdescription{
      This routine writes an histogram to a Fortran ASCII file.
   }
   \sstinvocation{
      CALL KPG1\_HSFLx( FD, NUMBIN, HIST, HRMIN, HRMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         Fortran file descriptor as provided by FIO.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         The number of bins in the histogram.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Given)
      }{
         The array holding the histogram.
      }
      \sstsubsection{
         HRMIN = ? (Given)
      }{
         The minimum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         HRMAX = ? (Given)
      }{
         The maximum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         extreme values of the histogram must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The Fortran file must all ready be opened and should have a record
      length of at least 52 characters.
   }
}
\sstroutine{
   KPG1\_HSTAx
}{
   Compute simple ordered statistics for an array via an histogram
}{
   \sstdescription{
      This routine computes simple ordered statistics for an array,
      namely: the number of valid pixels, the minimum and maximum pixel
      values (and their positions), the pixel sum, the mean, the mode,
      the median, and selected percentiles.  For efficiency reasons
      the routine computes an histogram, rather than completely
      sorting the data.  The accuracy of the statistics therefore
      depends inversely on the number of bins.
   }
   \sstinvocation{
      CALL KPG1\_HSTAX( BAD, EL, DATA, NUMPER, PERCNT, NGOOD, IMIN,
                       DMIN, IMAX, DMAX, SUM, MEAN, MEDIAN, MODE,
                       PERVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles to evaluate.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given and Returned)
      }{
         The array of percentiles to evaluate.  They must in the range
         0.0 to 100.0.  If there are none to calculate, set NUMPER to 1
         and pass the bad value in PERCNT( 1 ).  On exit these are
         placed in ascending order.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         Median of the valid pixels.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Returned)
      }{
         Mode of the valid pixels.
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Returned)
      }{
         Percentile values of the valid pixels.  These correspond to the
         ordered fractions returned in PERCNT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate.  The data type of the array being analysed must match
         the particular routine used.

         \sstitem
         If NGOOD is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).

         \sstitem
         The median and percentiles are derived by linear interpolation
         within histogram bins, after clipping of outliers if the
         histogram is sparse.  The mode is estimated from 3$*$median -
         2$*$mean, which is only valid for moderately skew distributions.
      }
   }
   \sstdiytopic{
      References
   }{
      Moroney, M.J., 1957, {\tt "}Facts from Figures{\tt "} (Pelican)
      Goad, L.E. 1980, in {\tt "}Applications of Digital Image Processing to
        Astronomy{\tt "}, SPIE 264, 139.
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         Does not compute the median and any percentiles in a single
         invocation of KPG1\_FRACx.
      }
   }
}
\sstroutine{
   KPG1\_HSTFx
}{
   Finds values corresponding to specified fractions of an histogram
}{
   \sstdescription{
      This routine finds the values at defined fractions of an
      histogram.  Thus to find the lower-quartile value, the fraction
      would be 0.25.  Since an histogram technique is used rather than
      sorting the whole array, the result may not be exactly correct.
      An histogram with a large number of bins, and the use of linear
      interpolation between bins in the routine reduce the error.
   }
   \sstinvocation{
      CALL KPG1\_HSTFx( NUMBIN, HISTOG, MAXMUM, MINMUM, NFRAC, FRAC,
                       VALUES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         The number of histogram bins.  The larger the number of bins
         the greater the accuracy of the results.  1000 to 10000 is
         recommended.
      }
      \sstsubsection{
         HISTOG( NUMBIN ) = INTEGER (Given)
      }{
         The histogram.
      }
      \sstsubsection{
         MAXMUM = ? (Given)
      }{
         The maximum value used to evaluate the histogram.
      }
      \sstsubsection{
         MINMUM = ? (Given)
      }{
         The minimum value used to evaluate the histogram.
      }
      \sstsubsection{
         NFRAC = INTEGER (Given)
      }{
         Number of fractional positions.
      }
      \sstsubsection{
         FRAC( NFRAC ) = REAL (Given and Returned)
      }{
         Fractional positions in the histogram in the range 0.0--1.0.
         On exit they are arranged into ascending order.
      }
      \sstsubsection{
         VALUES( NFRAC ) = ? (Returned)
      }{
         Values corresponding to the ordered fractional positions in
         the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.  The
         arguments MAXMUM, MINMUM, and VALUES must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_HSTQx
}{
   Equalises the histogram of an array
}{
   \sstdescription{
      This routine equalises (linearises) the histogram of an array.
      Thus approximately equal numbers of different values appear in
      output equalised version of the input array.
   }
   \sstinvocation{
      CALL KPG1\_HSTQx( BAD, EL, INARR, NUMBIN, OLDHST, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad values within the input array.  If
         false there are no bad values.  It is used as an efficiency
         mechanism.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be equalised.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         OLDHST( NUMBIN ) = INTEGER (Returned)
      }{
         The histogram of the input array, i.e. before equalisation.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Returned)
      }{
         Key to transform the input histogram{\tt '}s bin number to the
         equalised bin number after histogram mapping.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the equalised values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to and returned from this routine must have the
         data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_INCOx
}{
   Obtains a list of co-ordinates from the environment
}{
   \sstdescription{
      The supplied parameter is used to get a list of co-ordinates from
      the environment.  These co-ordinates are stored in dynamic
      workspace which is expanded as necessary so that any number of
      points can be given.  The user indicates the end of the list of
      points by a null value.  Pointers to the workspace arrays holding
      the co-ordinates are returned, and should be annulled when no
      longer needed by calling PSX\_FREE.
   }
   \sstinvocation{
      CALL KPG1\_INCOx( PNAME, NDIM, NPOINT, IPCO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter with which to associate the co-ordinates.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         The number of co-ordinate dimensions.  It must be positive and
         no more than DAT\_\_MXDIM.
      }
      \sstsubsection{
         NPOINT = INTEGER (Returned)
      }{
         The number of points specified.
      }
      \sstsubsection{
         IPCO = INTEGER (Returned)
      }{
         A pointer to workspace of type $<$HTYPE$>$ and size NDIM by NPOINT
         holding the co-ordinates of each point.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real or double-precision numeric data
         types: replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.
         The returned co-ordinate array will have the specified data type.
      }
   }
}
\sstroutine{
   KPG1\_IS3x
}{
   Sorts an array of data into increasing order, also shuffling
   two ancillary arrays correspondingly
}{
   \sstdescription{
      The routine uses an insert sort method. This has proven itself
      the quickest for sorting small sets of data lots of times, as in
      image stacking using ordered statistics. The method looks at the
      second value, compares this with the first if swaps if necessary,
      then it looks at the third, looks at the previous values swaps
      with the lowest (or not at all) and so on until all values have
      been passed. It is fast (for the case above ) simply because of
      the very few lines of operation. The sort is extended to the
      ancillary data DDAT, and PDAT these maintain their
      correspondence with the ORDDAT dataset on exit.
   }
   \sstinvocation{
      CALL KPG1\_IS3x( ORDDAT, DDAT, PDAT, NENT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ORDDAT( NENT ) = ? (Given and Returned)
      }{
         The data to order. On output it contains the data in increasing
         order.
      }
      \sstsubsection{
         DDAT( NENT ) = ? (Given and Returned)
      }{
         A list of data associated with ORDDAT which needs to retain its
         correspondence with the items in ORDDAT.
      }
      \sstsubsection{
         PDAT( NENT ) = INTEGER (Given and Returned)
      }{
         A list of data associated with ORDDAT which needs to retain its
         correspondence with the items in ORDDAT (probably pointers).
      }
      \sstsubsection{
         NENT = INTEGER (Given)
      }{
         The number of entries in ORDDAT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the double-precision and real
         floating-point data types: replace {\tt "}x{\tt "} in the routine name by
         D or R as appropriate.  The ORDDAT and DDAT arrays must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ISCLx
}{
   Scale image between limits
}{
   \sstdescription{
      The input two-dimensional array is scaled between lower and upper
      limits such that the lower limit and all values below it are set
      to a minimum value, the upper limit and all values above are set
      to a maximum value, and all valid values in between are assigned
      values using linear interpolation between the limits.  The image
      may or may not be inverted.  The sign of the scaling can be
      reversed.  The scaled data are written to an integer output array.
   }
   \sstinvocation{
       CALL KPG1\_ISCLx( BAD, DIM1, DIM2, INARR, INVERT, LOWER, UPPER,
      :                 LOWLIM, UPPLIM, BADVAL, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there will be no checking for bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the two-dimensional arrays.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the two-dimensional arrays.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The original, unscaled image data.
      }
      \sstsubsection{
         LOWER = ? (Given)
      }{
         The data value that specifies the lower image-scaling limit.
         This may be smaller than \%UPPER to provide a negative scale
         factor.
      }
      \sstsubsection{
         UPPER = ? (Given)
      }{
         The data value that specifies the upper image-scaling limit.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         LOWLIM = INTEGER (Given)
      }{
         The lowest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         UPPLIM = INTEGER (Given)
      }{
         The highest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         BADVAL = INTEGER (Given)
      }{
         The value to be assigned to bad pixels in the scaled array.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The scaled version of the image.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         array supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_KER1x
}{
   Smooths an N-dimensional array using a specified 1D kernel
}{
   \sstdescription{
      The routine smooths the array IN using a specified 1-dimensional
      kernel and returns the result in the array OUT. The 1D kernel can
      be used to smooth either a single axis or mutiple axes. If multiple
      axes are smoothed, the total smoothing kernel is equivalent to the
      product of the kernels used to smooth each individual axis.

      Any output pixel that is contributed to by a bad pixel, or a pixel
      that is over the edge of the input data array, is set bad in the
      output.
   }
   \sstinvocation{
      CALL KPG1\_KER1$<$T$>$( NDIM, DIMS, IN, NAX, AXES, SIZE, CENTRE, KERNEL,
                         WORK, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of pixel axes in the IN and OUT arrays.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The length, in pixels, of each dimension of the IN and OUT arrays.
      }
      \sstsubsection{
         IN( $*$ ) = ? (Given)
      }{
         The input array, accessed as a 1D vector.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes along which smoothing should be performed.
      }
      \sstsubsection{
         AXES( NAX ) = INTEGER (Given)
      }{
         The indices of the pixel axes along which smoothing should be
         performed. The first axis is axis 1.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The number of values in the kernel.
      }
      \sstsubsection{
         CENTRE = INTEGER (Given)
      }{
         The index of the element within KERNEL that corresponds to the
         centre of the kernel.
      }
      \sstsubsection{
         KERNEL( SIZE ) = ? (Given)
      }{
         The kernel array. The values in this array are used as supplied
         \sstitemlist{

            \sstitem
            they are not normalised to a total sum of unity.
         }
      }
      \sstsubsection{
         WORK( SIZE ) = ? (Given and Returned)
      }{
         A work array.
      }
      \sstsubsection{
         OUT( $*$ ) = ? (Returned)
      }{
         The output array, accessed as a 1D vector.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine can be used to smooth either DATA or VARIANCE
         arrays. If a DATA array is smoothed with a given kernel, the
         corresponding VARIANCE array should be smoothed with a kernel
         containing the squares of the values in the original kernel.

         \sstitem
         There are routines for processing double precision and real data.
         Replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         data types of the IN, KERNEL and OUT arguments must match the
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_LITNx
}{
   Creates linear transformation expressions between two
   n-dimensional co-ordinate systems
}{
   \sstdescription{
      This routine evaluates linear transformations between each of the
      dimensions of two co-ordinate systems of the same dimensionality.
      It substitutes the scale factors and offsets into chartacter
      expressions suitable for creating a TRANSFORM structure.
   }
   \sstinvocation{
      CALL KPG1\_LITNx( NDIM, ILBND, IUBND, OLBND, OUBND, ITOO, OTOI,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in each co-ordinate system.
      }
      \sstsubsection{
         ILBND( NDIM ) = ? (Given)
      }{
         The lower bounds of the input co-ordinate system corresponding
         to points OLBND in the output co-ordinate system.
      }
      \sstsubsection{
         IUBND( NDIM ) = ? (Given)
      }{
         The upper bounds of the input co-ordinate system corresponding
         to points OUBND in the output co-ordinate system.
      }
      \sstsubsection{
         OLBND( NDIM ) = ? (Given)
      }{
         The lower bounds of the output co-ordinate system corresponding
         to points ILBND in the input co-ordinate system.
      }
      \sstsubsection{
         OUBND( NDIM ) = ? (Given)
      }{
         The upper bounds of the output co-ordinate system corresponding
         to points IUBND in the input co-ordinate system.
      }
      \sstsubsection{
         ITOO( NDIM ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The transformation expressions to convert from the input to
         the output co-ordinate system.  It should have a length at
         least of 26 $+$ 2 $*$ VAL\_\_SZ$<$T$>$ characters.
      }
      \sstsubsection{
         OTOI( NDIM ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The transformation expressions to convert from the output to
         the input co-ordinate system.  It should have a length at
         least of 26 $+$ 2 $*$ VAL\_\_SZ$<$T$>$ characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         bounds of the co-ordinate systems supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LITRx
}{
   Saves a transformation for a linear plot in the AGI database
}{
   \sstdescription{
      This routine defines the transformations between world and a
      linear data co-ordinate system that has eithe, neither or both
      axes with reversed polarity (increasing right to left or top to
      bottom), and saves the transformation in the AGI database with
      the current picture.
   }
   \sstinvocation{
      CALL KPG1\_LITRx( SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE( 2 ) = ? (Given)
      }{
         The scale factors of each linear axis to transform from world
         co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = ? (Given)
      }{
         The offsets of each linear axis at pixel 0 to transform from
         world co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The scale
         and offset supplied to the routine must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         There must be a current AGI picture.
      }
   }
}
\sstroutine{
   KPG1\_LLTRx
}{
   Saves a transformation for a data co-ordinate linear or
   logarithmic plot in the AGI database
}{
   \sstdescription{
      This routine defines the transformations between world and a
      log10-log10 or log10-linear data co-ordinate system, that has
      either, neither or both axes with reversed polarity (increasing
      right to left or top to bottom), and saves the transformation in
      the AGI database with the current picture.
   }
   \sstinvocation{
      CALL KPG1\_LLTRx( XLOG, YLOG, SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XLOG = LOGICAL (Given)
      }{
         If true the x-axis is logarithmic in data co-ordinates,
         otherwise it is linear.
      }
      \sstsubsection{
         YLOG = LOGICAL (Given)
      }{
         If true the y-axis is logarithmic in data co-ordinates,
         otherwise it is linear.
      }
      \sstsubsection{
         SCALE( 2 ) = ? (Given)
      }{
         The scale factors of each linear axis to transform from world
         co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = ? (Given)
      }{
         The offsets of each linear axis at pixel 0 to transform from
         world co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The scale
         and offset supplied to the routine must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         There must be a current AGI picture.
      }
   }
}
\sstroutine{
   KPG1\_LOCTx
}{
   Locates the centroid of a blob image feature in an n-dimensional
   array
}{
   \sstdescription{
      This routine locates the centroid of a blob feature within
      a defined search area in an n-dimensional array about suggested
      starting co-ordinates, and returns the final centroid position.
      A blob is a series of connected pixels above or below the value
      of the surrounding background.

      The routine forms marginal profiles within a search square.  A
      separate background estimate is subtracted from each sample in
      each of the profiles, in order to ensure that he profiles have
      a roughly flat background.  The background estimate used for each
      profile sample is the lower quartile of the array values which
      were included in the sample.  If this quartile cannot be
      calculated (in the case of a one-dimensional array, for instance,
      each sample will have only one contribution and so the quartile
      cannot be found), the background estimate is taken from a straight
      line passing through the first and last points of the profile.

      A background value for each whole profile is then found, and the
      centroid of all data above this background level is found.  The
      whole process is repeated a number of times, using the previous
      centroid position as the new initial guess position.  Iterations
      continue until the maximum number of iterations is reached, or
      the requested accuracy is met, or until one of several error
      conditions is met.
   }
   \sstinvocation{
      CALL KPG1\_LOCTx( NDIM, LBND, UBND, ARRAY, INIT, SEARCH, POSTIV,
                       MXSHFT, MAXITE, TOLER, FINAL, SEL, WORK1,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-d array.  It must be greater than
         1.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower bounds of the n-d array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper bounds of the n-d array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         INIT( NDIM ) = REAL (Given)
      }{
         The co-ordinates of the initial estimate position.
      }
      \sstsubsection{
         SEARCH( NDIM ) = INTEGER (Given)
      }{
         Size of the search region to be used in pixels along each
         dimension.  Each value must be odd and lie in the range 3--51.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if image features are positive above the background.
      }
      \sstsubsection{
         MXSHFT( NDIM ) = REAL (Given)
      }{
         Maximum shifts allowable from the initial position along each
         dimension.
      }
      \sstsubsection{
         MAXITE = INTEGER  (Given)
      }{
         Maximum number of iterations to be used.  At least one
         iteration will be performed even if this is less than one.
      }
      \sstsubsection{
         TOLER = REAL (Given)
      }{
         Accuracy required in the centroid position.
      }
      \sstsubsection{
         SEL = INTEGER (Given)
      }{
         The number of elements in a search box (i.e. the product of the
         values in SEARCH).
      }
      \sstsubsection{
         FINAL( NDIM ) = REAL (Returned)
      }{
         The final co-ordinates of the centroid position.
      }
      \sstsubsection{
         WORK1( 51, SEL, NDIM ) = REAL (Returned)
      }{
         A work array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the numeric data types: replace
         {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.

         \sstitem
         The lower and upper bounds must correspond to the dimension
         of the array which is passed by assumed size, and therefore the
         routine does not check for this.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_LOGAx
}{
   Takes the logarithm to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the logarithm of the pixels of the input array
      to the base specified, i.e. New\_value = Log    Old\_value.
                                                 Base
      If the input pixel is negative, then a bad pixel value is
      used for the output value.

      To find the logarithm to any base, the following algorithm
      is used, providing the base is positive and not equal to one:

          New\_Value  =  Log Old\_Value / Log Base
                           e               e

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance / ( Old\_value $*$ log Base )
                                                         e
   }
   \sstinvocation{
      CALL KPG1\_LOGAx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of logarithm to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LUDCx
}{
   Performs an LU decomposition of a square matrix
}{
   \sstdescription{
      This routine performs a decomposition of a square matrix into
      lower and upper triangular matrices using Crout{\tt '}s method with
      partial pivoting.  Implicit pivoting is also used to select
      the pivots.
   }
   \sstinvocation{
      CALL KPG1\_LUDCx( N, EL, ARRAY, PINDEX, SCALE, EVEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of rows and columns in the matrix to be decomposed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the first dimension of the array as declared in the
         calling routine.  This should be at least equal to N.
      }
      \sstsubsection{
         ARRAY( EL, N ) = ? (Given and Returned)
      }{
         On input this is the array to be decomposed into LU form.
         On exit it is the LU decomposed form of the rowwise-permuted
         input ARRAY, with the diagonals being part of the upper
         triangular matrix.  The permutation is given by PINDEX.
      }
      \sstsubsection{
         SCALE( N ) = ? (Returned)
      }{
         Workspace to store the implicit scaling used to normalise the
         rows during implicit pivoting.
      }
      \sstsubsection{
         PINDEX( N ) = INTEGER (Returned)
      }{
         An index of the row permutations caused by the partial
         pivoting.
      }
      \sstsubsection{
         EVEN = LOGICAL (Returned)
      }{
         If EVEN is .TRUE., there was an even number of row
         interchanges during the decomposition.  If EVEN is .FALSE.,
         there was an odd number.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The matrix and the workspace should have this data
         type as well.
      }
   }
}
\sstroutine{
   KPG1\_MANI$<$T$>$
}{
   Copy a data array with axis permutation and expansion
}{
   \sstdescription{
      An input array is copied to an output array under control of a
      supplied AXES vector.  Axes of the output array may be in a
      different order to those of the input array, and it may be
      required to expand along a new dimension or collapse along
      an existing combination (being replaced by the mean of all
      non-bad values).
   }
   \sstinvocation{
      CALL KPG1\_MANI$<$T$>$( NDIMI, DIMI, IN, NDIMO, DIMO, AXES, COLOFF,
                         EXPOFF, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         DIMI( NDIMI ) = INTEGER (Given)
      }{
         The shape of the input array.
      }
      \sstsubsection{
         IN( $*$ ) = $<$TYPE$>$ (Given)
      }{
         The input data array, vectorised.  The number of elements is
         given by the product of the elements of DIMI.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array (the number of elements
         in AXES).
      }
      \sstsubsection{
         DIMO( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output array.  Information about the
         extent of the expanded dimesions, as well as information
         implicit in DIMI and AXES, is held here.
      }
      \sstsubsection{
         AXES( NDIMO ) = INTEGER (Given)
      }{
         An array determining how the output array is copied from the
         input array.  The I{\tt '}th element determines the source of the
         I{\tt '}th dimension of the output array.  If it is zero, a new
         dimension will grow there.  Otherwise, it gives the index of
         a dimension of the input array to copy.
      }
      \sstsubsection{
         COLOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the dimensions of the input array along
         which it is to be collapsed; that is the product of each
         element of DIMI whose index does not appear in AXES.
      }
      \sstsubsection{
         EXPOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the newly expanded dimensions in the
         output array; that is the product of each element of DIMO
         for which the corresponding element of AXES is zero.
      }
      \sstsubsection{
         OUT( $*$ ) = $<$TYPE$>$ (Returned)
      }{
         The output array, vectorised.  The number of elements written
         is given by the product of the elements of NDIMO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The assumption that NDF\_\_MXDIM = 7 is hard coded into this
         routine.

         \sstitem
         A few arithmetic operations could be saved, at the expense of
         the code{\tt '}s clarity,  by calculating the various array offsets
         at the same time as the next position vectors at various places
         in this routine.  Since this routine is unlikely to be a
         computational bottleneck I have favoured clarity over optimal
         performance.
      }
   }
}
\sstroutine{
   KPG1\_MDETx
}{
   Computes the determinant of a matrix
}{
   \sstdescription{
      This routine calculates the determinant of an arbitrary n-by-n
      matrix.  It LU decomposes the matrix and then forms the product
      of the diagonals by summing their logarithms to base 10.
      Logarithmic calculations are used to prevent overflows. A bad
      status is returned when the matrix is singular or the determinant
      is too large to store in a $<$COMM$>$-number representation.
   }
   \sstinvocation{
      CALL KPG1\_MDETX( N, EL, ARRAY, WORK1, WORK2, DET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of rows and columns in the matrix whose determinant
         is to be derived.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the first dimension of the array as declared in the
         calling routine.  This should be at least equal to N.
      }
      \sstsubsection{
         ARRAY( EL, N ) = ? (Given and Returned)
      }{
         On input this is the matrix whose determinant is to be found.
         Since the LU decomposition is performed in situ, the input
         values are lost.  (On exit it is the LU decomposed form of the
         rowwise-permuted input ARRAY, with the diagonals being part of
         the upper triangular matrix.)
      }
      \sstsubsection{
         WORK1( N ) = INTEGER (Returned)
      }{
         Workspace for the LU decomposition.
      }
      \sstsubsection{
         WORK2( N ) = ? (Returned)
      }{
         Workspace for the LU decomposition.
      }
      \sstsubsection{
         DET = ? (Returned)
      }{
         The determinant of matrix ARRAY.  It is set to 1.0 when the
         matrix is singular.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The matrix and the SECOND workspace should have
         this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_MEANx
}{
   Finds the mean of the good data values in an array
}{
   \sstdescription{
      Finds the mean of the good data values in an array.
   }
   \sstinvocation{
      CALL KPG1\_MEANx( N, DATA, MEAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of elements in the array.
      }
      \sstsubsection{
         DATA( N ) = ? (Given)
      }{
         The data array.
      }
      \sstsubsection{
         MEAN = ? (Returned)
      }{
         The mean value.  Set to VAL\_\_BAD$<$T$>$ if no good data are found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate.    The array and mean arguments supplied to the
         routine must have the data type specified.

         \sstitem
         The summation is carried out in double precision.
      }
   }
}
\sstroutine{
   KPG1\_MEDUx
}{
   Derives the unweighted median of a vector
}{
   \sstdescription{
      This routine derives the unweighted median of an array.  If there
      are an even number of elements, the median is computed from the
      mean of the two elements that straddle the median.
   }
   \sstinvocation{
      CALL KPG1\_MEDUx( BAD, EL, ARRAY, MEDIAN, NELUSE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If BAD is .TRUE. there may be bad pixels present in the vector
         and so should be tested.  If BAD is .FALSE. there is no testing
         for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements within the array to sort.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The array whose median is to be found.  On exit the array is
         partially sorted.
      }
      \sstsubsection{
         MEDIAN = ? (Returned)
      }{
         The median of the array.
      }
      \sstsubsection{
         NELUSE = INTEGER (Returned)
      }{
         The number of elements actually used after bad values have been
         excluded.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         array and MEDIAN arguments supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MIXVx
}{
   Obtains from a parameter character values from either a menu of
   options or within a numeric range
}{
   \sstdescription{
      This routine obtains a group of character values from a
      parameter.  Each value must be either:

         o  one of a supplied list of acceptable values, with
            unambiguous abbreviations accepted; or

         o  a numeric character string equivalent to a number, and the
            number must lie within a supplied range of acceptable
            values.
   }
   \sstinvocation{
      CALL KPG1\_MIXVx( PARAM, MAXVAL, VMIN, VMAX, OPTS, VALUES, ACTVAL,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter. A GRP group expression should be
         supplied for the parameter.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values required.  A PAR\_\_ERROR status is
         returned when the number of values requested is fewer than one.
      }
      \sstsubsection{
         VMIN = $<$TYPE$>$ (Given)
      }{
         The value immediately above a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMIN is the minimum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         VMAX = $<$TYPE$>$ (Given)
      }{
         The value immediately below a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMAX is the maximum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The list of acceptable options for each value obtained from the
         parameter.  Items should be separated by commas.  The list is
         case-insensitive.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The selected values that are either options from the list or
         the character form of numeric values that satisfy the range
         constraint.  The former values are in uppercase and in full,
         even if an abbreviation has been given for the actual
         parameter.  Note that all values must satisfy the constraints.
         The values will only be valid if STATUS is not set to an error
         value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The data range
         arguments supplied to the routine must have the data type
         specified.

         \sstitem
         There are two stages to identify or validate each character
         value obtained from the parameter. In the first the value is
         converted to the required data type. If this is successful, the
         derived numeric value is compared with the range of acceptable
         values defined by VMIN and VMAX.  A value satisfying these
         constraints is returned in the VALUES. The second stage searches
         for a match of the character value with an item in the menu.

         \sstitem
         This routine adheres to the following rules.
            o  All comparisons are performed in uppercase.  Leading blanks
            are ignored.
            o  A match is found when the value equals the full name of an
            option.  This enables an option to be the prefix of another
            item without it being regarded as ambiguous.  For example,
            {\tt "}10,100,200{\tt "} would be an acceptable list of options.
            o  If there is no exact match, an abbreviation is acceptable.
            A comparison is made of the value with each option for the
            number of characters in the value.  The option that best fits
            the value is declared a match, subject to two provisos.
            Firstly, there must be no more than one character different
            between the value and the start of the option.  (This allows
            for a mistyped character.)  Secondly, there must be only one
            best-fitting option.  Whenever these criteria are not
            satisfied, the user is told of the error, and is presented
            with the list of options, before being prompted for new
            values.  This is not achieved through the MIN/MAX system.
      }
   }
}
\sstroutine{
   KPG1\_MMTHx
}{
   Returns the maximum and minimum values of an array within
   thresholds
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.  The extreme values can be
      constrained to lie between two thresholds, where values outside
      the thresholds are ignored.  So for example this routine might be
      used to find the smallest positive value or the largest negative
      value.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
      CALL KPG1\_MMTHx( BAD, EL, ARRAY, THRESH, NINVAL, MAXMUM,
                       MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx or use routine
         KPG\_MXMNx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, THRESH, MAXMUM, and MINMUM arguments supplied to the
         routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MODEx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_MODEx(  X, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted standard deviation of the data
         points.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_MONOx
}{
   Determines whether an array{\tt '}s values increase or decrease
   monotonically
}{
   \sstdescription{
      This routine determines whether or not a vector of values
      increase or decrease monotonically.  This is most useful
      for axes.
   }
   \sstinvocation{
      CALL KPG1\_MONOx( BAD, EL, ARRAY, MONOTO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If BAD=.TRUE., there may be bad values present in the
         array, and it instructs this routine to test for the
         presence of bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array to be tested.
      }
      \sstsubsection{
         MONOTO = LOGICAL (Returned)
      }{
         If MONOTO is .TRUE., the array values are monotonic.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the each of the numeric data types.
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, W, UB, or UB as
         as appropriate.  The array should have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MTHEx
}{
   Evaluate a mathematical expression for a set of data and variance
   arrays
}{
   \sstdescription{
      The routine evaluates a general mathematical expression giving
      the values in an output data array in terms of values in a set of
      input data arrays, each of the same size. The expression to be
      evaluated is specified by means of a mapping identifier obtained
      from the TRANSFORM system (see SUN/61). A set of input variance
      arrays is also supplied, and this routine uses these to obtain
      estimates of the variance in the evaluated results. These output
      variance estimates are obtained numerically by perturbing the
      input data values by appropriate amounts.
   }
   \sstinvocation{
      CALL KPG1\_MTHEx( BAD, EL, N, DAT, VFLAG, VAR, IMAP, QUICK,
                       MXBAT, WRK, RES, VRES, BADDR, BADVR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad values in the input
         data or variance arrays.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in each input data array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of input data arrays.
      }
      \sstsubsection{
         DAT( EL, N ) = ? (Given)
      }{
         Array containing each separate input data array stored in a
         separate row.
      }
      \sstsubsection{
         VFLAG( N ) = LOGICAL (Given)
      }{
         A set of logical flags indicating which of the input data
         arrays stored in the DAT array have associated variance values
         (stored in the VAR array). If the VFLAG value for a data array
         is .TRUE., then variance values exist, otherwise there is no
         associated variance array so a variance of zero will be
         assumed.
      }
      \sstsubsection{
         VAR( EL, $*$ ) = ? (Given)
      }{
         Array containing variance estimates for the input data arrays.
         These values are stored in the rows of this array in the same
         order as the associated data values, but the total number of
         rows may be smaller than N due to the absence of values for
         those data arrays with a VFLAG value of .FALSE..  The declared
         second dimension size of the VAR array must be at least equal
         to the number of .TRUE. values in the VFLAG array.
      }
      \sstsubsection{
         IMAP = INTEGER (Given)
      }{
         A TRANSFORM system identifier for an \{N--$>$1\} compiled mapping
         which defines the mathematical expression to be evaluated.
      }
      \sstsubsection{
         QUICK = LOGICAL (Given)
      }{
         If this argument is set to .TRUE., then output variance
         estimates will be made by perturbing each input data array in
         turn, but in the positive direction only. If it is set to
         .FALSE., then each input data array will be perturbed in both
         directions and the maximum resulting output perturbation will
         be used to estimate the output variance. The former approach
         has the advantage of speed, but the latter gives more accurate
         results, especially for highly non-linear functions.
      }
      \sstsubsection{
         MXBAT = INTEGER (Given)
      }{
         A positive integer defining the size of workspace supplied.
         The input data arrays will be processed in {\tt "}batches{\tt "}, each of
         which does not contain more than this number of elements. If
         this value is too low, then excessive time will be spent in
         looping and subroutine calls. If it is too high, then
         excessive page faulting may occur. A value of about 256 is
         normally adequate.
      }
      \sstsubsection{
         WRK( MXBAT $*$ ( N $+$ 3 ) ) = ? (Returned)
      }{
         This array must be supplied as workspace.
      }
      \sstsubsection{
         RES( EL ) = ? (Returned)
      }{
         The output data array, containing the results of evaluating the
         mathematical expression.
      }
      \sstsubsection{
         VRES( EL ) = ? (Returned)
      }{
         The output variance estimates to accompany the results held in
         the RES array.
      }
      \sstsubsection{
         BADDR = LOGICAL (Returned)
      }{
         Whether the returned array of results (RES) may contain bad
         values.
      }
      \sstsubsection{
         BADVR = LOGICAL (Returned)
      }{
         Whether the returned array of variance estimates (VRES) may
         contain bad values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing both real and double
         precision data; replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate.  The data types of the DAT, VAR, WRK, RES and RESV
         arrays should match the routine used.

         \sstitem
         The algorithm used to estimate the output variance is
         general-purpose and will cope with any reasonable mathematical
         expression.  However, note that it is likely to be less efficient
         than an algorithm written especially to estimate the variance for
         any particular expression whose form is known in advance.
      }
   }
   \sstdiytopic{
      Timing
   }{
      The time taken is approximately proportional to (i) N$+$1, where N
      is the number of input data arrays which have associated variance
      values, (ii) the size of each array and (iii) the time taken to
      evaluate the mathematical expression for each array element. In
      general, this last value will also tend to increase in
      approximate proportion to the number of input data arrays.
   }
}
\sstroutine{
   KPG1\_MULx
}{
   Multiply two vectorised arrays with optional variance information
}{
   \sstdescription{
      The routine forms the product of two vectorised arrays, with
      optional variance information. Bad value checking is also
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_MULx( BAD, VAR, EL, A, VA, B, VB, C, VC, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad values in the input
         arrays.  The routine will execute more rapidly if this checking
         can be omitted.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Whether associated variance information is to be processed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         First array of data to be multiplied.
      }
      \sstsubsection{
         VA( EL ) = ? (Given)
      }{
         Variance values associated with the array A.  Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         B( EL ) = ? (Given)
      }{
         Second array of data to be multipled.
      }
      \sstsubsection{
         VB( EL ) = ? (Given)
      }{
         Variance values associated with the array B.  Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         C( EL ) = ? (Returned)
      }{
         Result of multiplying arrays A and B.
      }
      \sstsubsection{
         VC( EL ) = ? (Returned)
      }{
         Variance values associated with the array C.  Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors that occurred during the
         calculations.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real
         and double precision: replace {\tt "}x{\tt "} in the routine name by I, R or
         D as appropriate.  The arrays passed to this routine should all
         have the specified data type.

         \sstitem
         This routine will handle numerical overflow.  If overflow
         occurs, then affected output array elements will be set to the
         {\tt "}bad{\tt "} value. A count of the numerical errors which occur is
         returned via the NERR argument.
      }
   }
}
\sstroutine{
   KPG1\_MVBDx
}{
   Move bad data values to the end of an index of array values
}{
   \sstdescription{
      This routine modifies the supplied index array by removing indicies
      of all bad data values and shuffling indicies for good data values
      down to fill the gaps.
   }
   \sstinvocation{
      CALL KPG1\_MVBD$<$T$>$( ELA, ARRAY, ELI, INDX, NGOOD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ELA = INTEGER (Given)
      }{
         The size of the data array.
      }
      \sstsubsection{
         ARRAY( ELA ) = ? (Given)
      }{
         The array containing the data values.
      }
      \sstsubsection{
         ELI = INTEGER (Given)
      }{
         The size of the index array.
      }
      \sstsubsection{
         INDX( ELI ) = INTEGER (Given and Returned)
      }{
         Each element of this array is an index into the ARRAY array. On
         exit, the contents of INDX are re-arranged so that indices that
         refer to bad data values are removed and indices that refer to
         good data values are shuffled down to fill the gaps. Any indicies
         which are outside the bounds of the data array are treated as if
         they referred to bad data values (i.e. they are removed).
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         The number of indices within INDX that refer to good data values.
         On exit, the first NGOOD elements of INDX will contain the
         indices of the good data values within ARRAY. Any remaining
         values of INDX will retain their original values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.
      }
   }
}
\sstroutine{
   KPG1\_MXMEx
}{
   Returns the maximum and minimum values between thresholds of an
   array including its errors
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array when combined with its associated error array.  The extreme
      values can be constrained to lie between two thresholds, where
      values outside the thresholds are ignored.  So for example this
      routine might be used to find the smallest positive value or the
      largest negative value.  The number of multiples of each error
      that should be added to and subtracted from the primary array to
      find the extreme values is adjustable.  The routine also returns
      where it found the maximum and minimum, and the number of elements
      where either or both of the array values is bad.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
      CALL KPG1\_MXMEx( BAD, EL, ARRAY, ERROR, NSIGMA, THRESH, NINVAL,
                       MAXMUM, MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         ERROR( EL ) = ? (Given)
      }{
         Error array associated with the data array.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Number of multiples of the error.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, ERROR, THRESH, MAXMUM, and MINMUM arguments supplied to
         the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.
   }
   \sstinvocation{
      CALL KPG1\_MXMNx( BAD, EL, ARRAY, NINVAL, MAXMUM,
                       MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the array.  If false
         it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, MAXMUM, and MINMUM arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_NBADx
}{
   Finds the number of bad values in an array
}{
   \sstdescription{
      Finds the number of bad values in a one-diimensional array.
   }
   \sstinvocation{
      CALL KPG1\_NBADx( N, DATA, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of elements in the array.
      }
      \sstsubsection{
         DATA( N ) = ? (Given)
      }{
         The data array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the double-precision and real
         floating-point data types: replace {\tt "}x{\tt "} in the routine name by
         D or R as appropriate.  The input data array must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_NOISx
}{
   Adds random Normal noise to a one-dimensional array
}{
   \sstdescription{
      This routine takes a one-dimensional array and adds noise randomly
      to each element in the array.  The random number at each element
      is drawn from a Normal distribution whose spread is given by the
      corresponding variance array at that element.
   }
   \sstinvocation{
      CALL KPG1\_NOISx( BAD, EL, VARNCE, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = INTEGER (Given)
      }{
         If true there may be bad pixels in input arrays, and so there
         will be bad-pixel testing.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the arrays.
      }
      \sstsubsection{
         VARNCE( EL ) = ? (Given)
      }{
         The Normal variance array corresponding to the data array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The data array to which random errors are to be applied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         All arithmetic is performed in double precision.
      }
   }
}
\sstroutine{
   KPG\_NTHMx
}{
   Returns the n smallest values in a $<$COMM$>$ array
}{
   \sstdescription{
      This routine takes an $<$COMM$>$ array and returns a stack
      containing the n smallest values in that array.

      Bad pixels are processed by the magic-value method.
   }
   \sstinvocation{
      CALL KPG1\_NTHM$<$T$>$( BAD, ARRAY, DIMS, N, STACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad-pixel testing will be performed.  It should be true
         if there may be bad pixels present.
      }
      \sstsubsection{
         ARRAY ( DIMS )  =  ? (Given)
      }{
         Input array of data values.
      }
      \sstsubsection{
         DIMS  =  INTEGER  (Given)
      }{
         Dimension of the input array.
      }
      \sstsubsection{
         N  =  INTEGER  (Given)
      }{
         The number of values to be stored in stack, i.e. specifies
         n in {\tt "}n-th smallest value.{\tt "}
      }
      \sstsubsection{
         STACK ( N )  =  ? (Returned)
      }{
         Ordered n smallest values in the input array. The first element
         is the n-th smallest, the second is the (n-1)-th smallest and
         so on until the n-th element is the minimum value.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_NUMBx
}{
   Counts the number of elements with values or absolute values
   above or below a limit
}{
   \sstdescription{
      This routine returns the number of points in the input array
      that have a value or absolute value greater than or less than
      the input value.
   }
   \sstinvocation{
      CALL KPG1\_NUMBx( BAD, VABS, ABOVE, EL, INARR, VALUE, NUMBER,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true testing for bad pixels will be made.  This should not
         be set to false unless there definitely no bad values within
         the input array.
      }
      \sstsubsection{
         VABS = LOGICAL (Given)
      }{
         If true the comparison is performed with the absolute value
         of each array element.
      }
      \sstsubsection{
         ABOVE = LOGICAL (Given)
      }{
         If true the criterion tests for array values greater than the
         limit; if false the criterion tests for array values less than
         the limit.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input data array
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to test each array value against.
      }
      \sstsubsection{
         NUMBER = INTEGER (Returned)
      }{
         The number of elements of the input array greater than the
         specified value when VABS = FALSE, or the number of elements
         of the input array whose absolute values are greater than the
         specified value when VABS = TRUE.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and comparison value supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_PASTx
}{
   Pastes an array on to another
}{
   \sstdescription{
      This routine `pastes{\tt '} an array on to another array.  Values of
      the underlying array are replaced by values in the pasted
      array, except that bad values may also be made transparent,
      in other words the original base array appears through the bad
      values.  Origin information is used to situate the paste
      operation.
   }
   \sstinvocation{
      CALL KPG1\_PASTx( TRANSP, BAD, OFFSET, IDIMS, ELI,
                       INARR, ODIMS, ELO, BASE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TRANSP = LOGICAL (Given)
      }{
         Whether bad pixels are transparent or not.  If true, bad pixels
         in the pasted array will not be pasted into the revised array.
         This is ignored if BAD is false.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true then there may be bad values in the pasted array.  If
         false then there are definitely no bad values in the pasted
         array.
      }
      \sstsubsection{
         OFFSET( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The offset in each dimension of the pasted array{\tt '}s origin with
         respect to the origin of the base array.
      }
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the array to be pasted.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELI = INTEGER (Given)
      }{
         The number of elements in the array to be pasted.
      }
      \sstsubsection{
         INARR( ELI ) = ? (Given)
      }{
         The array that will be pasted on to the base array.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the base array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELO = INTEGER (Given)
      }{
         The number of elements in the base array.
      }
      \sstsubsection{
         BASE( ELO ) = ? (Given and Returned)
      }{
         The base array on to which the input array will be pasted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_POISx
}{
   Takes values and returns them with Poisson noise added
}{
   \sstdescription{
      This routine adds or subtracts pseudo-random Poissonian (shot)
      noise to a series of values.  It uses a Box-Mueller algorithm to
      generate a fairly good normal distribution.
   }
   \sstinvocation{
      CALL KPG1\_POISx( EL, VALUES, SEED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values to which to add Poisson noise.
      }
      \sstsubsection{
         VALUES( EL )  =  ? (Given and Returned)
      }{
         On input these are the value to which noise is to be applied.
         On return the values have the noise applied.
      }
      \sstsubsection{
         SEED  =  REAL (Given \& Returned)
      }{
         The seed for random number generator; updated by the
         random-number generator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.

         \sstitem
         There is no checking for overflows.

         \sstitem
         Bad values remain bad in the returned array.
      }
   }
}
\sstroutine{
   KPG1\_POW$<$T$>$
}{
   Raise each element of a vectorised array to a specified power
}{
   \sstdescription{
      The routine raises each element of a vectorised array to a specified
      power. Any associated variance values are also modified appropriately.
      For general non-integer powers the result is calculated as
      EXP(power$*$LOG(data)). This enables bad output pixels to be detected by
      checking the magnitude of LOG(data). For integer powers, the result
      is calcualted using the Fortran {\tt "}$*$$*${\tt "} operator, which is more
      efficient.
   }
   \sstinvocation{
      CALL KPG1\_POW$<$T$>$( BAD, VAR, POWER, EL, DIN, VIN, DOUT, VOUT, NBAD,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input arrays.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Have associated variances been supplied?
      }
      \sstsubsection{
         POWER = DOUBLE PRECISION (Given)
      }{
         The required power.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         DIN( EL ) = $<$TYPE$>$ (Given)
      }{
         Input data array.
      }
      \sstsubsection{
         VIN( EL ) = $<$TYPE$>$ (Given)
      }{
         Input variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         DOUT( EL ) = $<$TYPE$>$ (Given)
      }{
         Output data array.
      }
      \sstsubsection{
         VOUT( EL ) = $<$TYPE$>$ (Given)
      }{
         Output variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         NBAD( 2 ) = INTEGER (Returned)
      }{
         Element 1 has the number of bad values stored in DOUT, and element
         2 has the number of bad values stored in VOUT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PROWx
}{
   Put values into a row of a 2-dimensional array
}{
   \sstdescription{
      The routine enters values into a specified row of a 2-dimensional
      array, the values being supplied in a separate 1-dimensional array
      whose size matches the row size.
   }
   \sstinvocation{
      CALL KPG1\_PROWx( EL, ROW, IROW, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in a single row of the 2-d array.
      }
      \sstsubsection{
         ROW( EL ) = ? (Given)
      }{
         Array of values to be inserted into the row.
      }
      \sstsubsection{
         IROW = INTEGER (Given)
      }{
         The row number in the 2-d array into which the values are to be
         inserted.
      }
      \sstsubsection{
         ARRAY( EL, $*$ ) = ? (Given and Returned)
      }{
         The 2-d array which is to recieve the new values. The declared
         second dimension size of this array must not be less than
         IROW. The values in other rows of this array are not altered.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type. Replace {\tt "}x{\tt "} in
         the routine name by B, UB, W, UW, I, R or D as appropriate. The
         data type of the ROW and ARRAY arrays should match the routine
         being used.
      }
   }
}
\sstroutine{
   KPG1\_PRSAx
}{
   Extracts a list of numerical values from a string
}{
   \sstdescription{
      A supplied string is search for words (separated by spaces, tabs
      or commas), which are extracted and converted to the required
      numerical data type.  The numerical values and their number are
      returned.
   }
   \sstinvocation{
      CALL KPG1\_PRSA$<$T$>$( BUFFER, MAXVAL, VALUES, NVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BUFFER = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing a list of numerical values.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values that can be read from the buffer
         and stored.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = ? (Returned)
      }{
         The numeric values extracted from the string.
      }
      \sstsubsection{
         NVAL = INTEGER (Returned)
      }{
         The actual number of values extracted from the string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "}
         in the routine name by D, I, or R as appropriate.  The array
         returned from the routine must have the data type specified.  The
         limitation on other integer types is because there are no
         conversion routines between them and character in the CHR library.
      }
   }
}
\sstroutine{
   KPG1\_PSFSx
}{
   Finds the approximate size of a 2-dimensional PSF
}{
   \sstdescription{
      Marginal profiles are formed of the absolute PSF values along
      both axes.  For each axis the maximum and minimum values in the
      corresponding profile are found.  The first and last point at
      which each profile reaches a specified fraction of its total
      range is found, and the difference returned as the corresponding
      PSF size.  N.B., it is assumed that the input PSF contains no bad
      pixels.
   }
   \sstinvocation{
      CALL KPG1\_PSFSx( PSF, NPIX, NLIN, WORK, NPW, NLW, FRACT, ILEVEL,
                       XSIZE, YSIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PSF( NPIX, NLIN ) = ? (Given)
      }{
         The PSF image.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         Number of pixels per line in the PSF image.
      }
      \sstsubsection{
         NLIN = INTEGER (Given)
      }{
         Number of lines in the PSF image.
      }
      \sstsubsection{
         WORK( NPW, NLW ) = ? (Given)
      }{
         Work space.
      }
      \sstsubsection{
         NPW = INTEGER (Given)
      }{
         Number of elements per line in the work array.  This should be
         at least equal to the maximum of NPIX and NLIN.
      }
      \sstsubsection{
         NLW = INTEGER (Given)
      }{
         Number of lines in the work array.  This should be at least 2.
      }
      \sstsubsection{
         ILEVEL = INTEGER (Given)
      }{
         The user information level.  If ILEVEL is 2 or more, then the
         user is told what the calculated sizes are.
      }
      \sstsubsection{
         FRACT = REAL (Given)
      }{
         The fraction of the PSF peak amplitude at which the PSF size
         is determined.  It should be positive and less than 0.5.  If
         it is outside this range one sixteenth is used.
      }
      \sstsubsection{
         XSIZE = INTEGER (Returned)
      }{
         The width in x of the PSF, in units of pixels.
      }
      \sstsubsection{
         YSIZE = INTEGER (Returned)
      }{
         The width in y of the PSF, in units of lines.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the PSF and WORK arguments must match the
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_PTNDx
}{
   Pastes a section of an n-dimensional array into another array
}{
   \sstdescription{
      This routine pastes a specified section of the supplied
      n-dimensional array (IN) into an output array (OUT).
   }
   \sstinvocation{
      CALL KPG1\_PTNDx( NDIM, LBNDI, UBNDI, IN, LBNDO, UBNDO, BAD,
                       OUT, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         LBNDI( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the IN array.
      }
      \sstsubsection{
         UBNDI( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the IN array.
      }
      \sstsubsection{
         IN( $*$ ) = ? (Given)
      }{
         The input array. Bounds given by LBNDI and UBNDI.
      }
      \sstsubsection{
         LBNDO( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the area of the IN array to be
         pasted into OUT.
      }
      \sstsubsection{
         UBNDO( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the area of the IN array to be
         pasted into OUT.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., then any sections of the output array that fall
         outside the input array are filled with bad values. Otherwise,
         the supplied values in such output array sections are left
         unchanged.
      }
      \sstsubsection{
         OUT( $*$ ) = ? (Given and Returned)
      }{
         The output array. Bounds given by LBNDO and UBNDO.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The number of elements in the output array. Derived from LBNDO
         and UBNDO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, W, UB or UW as appropriate.  The
         IN and OUT arrays supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_PXDPx
}{
   Expands an n-dimensional array by pixel duplication
}{
   \sstdescription{
      This routine expands an input array by pixel duplication along
      each dimension.  The duplication factors may be different for
      each dimension.
   }
   \sstinvocation{
      CALL KPG1\_PXDPx( IDIMS, INARR, EXPAND, USEMSK, MASK, ODIMS,
                       OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the input array.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input data array that is to be enlarged by duplication.
      }
      \sstsubsection{
         EXPAND( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The linear expansion factor applied along each dimension.
         Factors for unused dimensions up to NDF\_\_MXDIM should be set
         to one.
      }
      \sstsubsection{
         USEMSK = LOGICAL (Given)
      }{
         Should the mask array supplied by argument MASK be used?
      }
      \sstsubsection{
         MASK( $*$ ) = REAL (Given)
      }{
         Only accessed if USEMSK is .TRUE.  The MASK array corresponds
         to a single expansion block in the output array, and so should
         have a size equal to the product of the values supplied in the
         EXPAND argument.  If USEMSK is .TRUE., the value stored for
         each output pixel equals the product of the input pixel which
         is being duplicated, and the corresponding mask pixel (that is,
         the mask pixel that is at the same position as the output
         position is within its current block of output pixels).  If
         USEMSK is .FALSE. each output pixel value is simply equal to
         the input pixel value that is being duplicated.  This is
         equivalent to using a mask that is filled with the value 1.0.
         The supplied mask array may contain VAL\_\_BADR values in which
         case the corresponding output pixel will be set to VAL\_\_BAD$<$T$>$.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the expanded array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The expanded array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_QNTLx
}{
   Finds a quantile in a (possibly weighted) set of data
}{
   \sstdescription{
      The routine calculates the value of a specified quantile in a set
      of data values, which may be weighted.  In concept (although not
      in practice) it sorts the supplied data values into ascending
      order along with their associated positive weights, if supplied.
      It then finds a quantile Q such that the sum of the weights
      associated with all data values less than Q is a specified
      fraction FRACT of the sum of all the weights supplied.  If no
      weights are supplied, then each data value is assigned unit
      weight.  There are two main applications of this algorithm:

      a) To find specified quantiles of a distribution of data values
      for statistical purposes.  In this case, the weights may
      optionally be used to represent the number of times each data
      value occurs.  In such cases, it may be useful to regard the
      distribution as continuous, and therefore to interpolate linearly
      between data values when obtaining the result.

      b) Alternatively, the values may represent residuals from some
      fitted function.  In this case, by setting FRACT to 0.5, the
      {\tt "}weighted median residual{\tt "} may be found.  This has the property
      that if it is subtracted from all the original residuals, then
      the weighted sum of the absolute values of the corrected
      residuals will be minimised.  Thus, it may be used as the basis
      for iteratively finding an `L1{\tt '} fit.  In such cases, the required
      result will be equal to one of the data values (or may lie
      mid-way between two of them) and interpolation between values is
      not normally required.
   }
   \sstinvocation{
      CALL KPG1\_QNTLx( USEWT, INTERP, FRACT, EL, X, W, IP, Q, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         USEWT = LOGICAL (Given)
      }{
         Whether or not the data have associated weights.
      }
      \sstsubsection{
         INTERP = LOGICAL (Given)
      }{
         Whether or not interpolation between data values should be
         performed when obtaining the result.
      }
      \sstsubsection{
         FRACT = ? (Given)
      }{
         The fraction specifying the required quantile, in the range
         0.0 to 1.0.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of data values.
      }
      \sstsubsection{
         X( $*$ ) = ? (Given)
      }{
         Array of data values.
      }
      \sstsubsection{
         W( $*$ ) = ? (Given)
      }{
         Array of associated positive weights (if required). This
         argument will only be referenced if USEWT is .TRUE..
      }
      \sstsubsection{
         IP( EL ) = INTEGER (Given and Returned)
      }{
         On entry, an array of pointers identifying which elements of X
         (and W if supplied) are to be considered. On exit, these
         pointers will have been permuted to access the specified data
         elements in an order which is more nearly sorted than before
         (although in general it will not represent a complete sort of
         the data).
      }
      \sstsubsection{
         Q = ? (Returned)
      }{
         The value of the requested quantile.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There are versions of this routine for processing both REAL
         and DOUBLE PRECISION data; replace the {\tt "}x{\tt "} in the routine name by
         R or D as appropriate. The types of the FACT, X, W and Q
         arguments should match the routine being used.

         \sstitem
         This routine is optimised for use when the number of data
         values is large. In general, only a partial sort of the data will
         be performed, so this routine will perform better than most other
         methods of finding quantiles, which typically require a complete
         sort.

         \sstitem
         The order in which the input pointers are supplied in the
         array IP is arbitrary, but there will often be an efficiency
         advantage in supplying them so that they access the data in
         nearly-sorted order. Thus, re-supplying the array of pointers
         generated by a previous invocation of this routine (for the same
         or similar data) may be worthwhile.
      }
   }
   \sstdiytopic{
      Timing
   }{
      Details of the asymptotic time required to execute the original
      SELECT algorithm are not altogether clear from the published
      papers.  It appears that this algorithm may have better average
      performance than other methods and the time required may
      approximate to EL $*$ LOG( MIN( K, EL - K $+$ 1 ) ) where K is the
      rank of the largest data value which is smaller than the quantile
      being sought.  However, Sedgewick (see References) indicates that
      such algorithms should, in general, complete in time proportional
      to EL, so the above formula may be incorrect.  When using
      weighted data, the time will be multiplied by a further factor
      reflecting the non-linearity of the cumulative weight versus rank
      function and the difficulty of inverting it.
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Comm. of the ACM, vol 18, no. 3 (March 1975), p165.

         \sstitem
         Also see page 173.

         \sstitem
         In addition, see the algorithm assessment by T. Brown in
         Collected Algorithms of the ACM, (algorithm no. 489).

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
}
\sstroutine{
   KPG1\_QSRTX
}{
   Sorts a vector via the Quicksort algorithm
}{
   \sstdescription{
      This routine sorts a vector in situ between an upper and lower
      bounds using the Quicksort algorithm.
   }
   \sstinvocation{
      CALL KPG1\_QSRTx( EL, LOW, HIGH, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array that is to be sorted.
      }
      \sstsubsection{
         LOW = INTEGER (Given)
      }{
         The lower bound within the array, below which the array
         elements will not be sorted.  It should be less than the
         upper bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         HIGH = INTEGER (Given)
      }{
         The upper bound within the array, above which the array
         elements will not be sorted.  It should be greater than the
         lower bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The array to be sorted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Timing
   }{
      For N elements to be sorted the timing goes as NlnN.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real,
         double precision, and character: replace {\tt "}x{\tt "} in the routine nam
         by I, R, D, or C respectively as appropriate.

         \sstitem
         If the maximum bound is less than the minimum, the bounds are
         swapped.
      }
   }
}
\sstroutine{
   KPG1\_RETRx
}{
   Retrieves a value from an array
}{
   \sstdescription{
      The value stored at a given index within the supplied array is
      returned.
   }
   \sstinvocation{
      CALL KPG1\_RETRx( EL, INDEX, DATA, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the array of the required value.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The returned value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_RETVx
}{
   Retrieves values specified by index from a vector
}{
   \sstdescription{
      This routine returns values from a vector at supplied indices.
      This is intended for accessing a few values from a mapped array.
   }
   \sstinvocation{
      CALL KPG1\_RETVx( EL, ARRAY, NVAL, INDEX, VALUES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The number of element values to return.
      }
      \sstsubsection{
         INDEX( NVAL ) = INTEGER (Given)
      }{
         The indices of the array elements to be returned.
      }
      \sstsubsection{
         VALUES( NVAL ) = ? (Returned)
      }{
         The value of the Xth array element.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
          There is a routine for each of the numerics data types and
          logical: replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B,
          UB, L as appropriate.  The array supplied to the routine must
          have the data type specified.

         \sstitem
          Bad status is returned if the supplied indices lie beyond
         the array bounds.
      }
   }
}
\sstroutine{
   KPG1\_RFCOx
}{
   Reads co-ordinate data from a text free-format file
}{
   \sstdescription{
      This routine reads co-ordinate information and from a text
      free-format file and converts it to floating-point values.  The
      file is like a relational catalogue with one record per related
      set of co-ordinates, however, exact column alignment is not
      necessary.  The converted input data are copied to an array.  The
      array uses a new line for each record of the file, its columns
      storing the given positional data in the order x, y, z etc.  If
      the end of file is not reached a flag is returned.
   }
   \sstinvocation{
       CALL KPG1\_RFCOx( FD, DIM1, DIM2, POSCOD, COUNT, CODATA, LBND,
      :                 UBND, CMPLET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         Fortran file identifier.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the output array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the output array.
      }
      \sstsubsection{
         POSCOD( DIM1 ) = INTEGER (Given)
      }{
         The column numbers of the co-ordinate information in order
         x, y, z, etc.  These must be positive.
      }
      \sstsubsection{
         COUNT = INTEGER (Given and Returned)
      }{
         The number of the line in the output array to be written first.
         If the file has been completely read this becomes the number
         of data sets stored in the array (i.e. one less).  It should
         be initialised externally the first time this routine is
         called, but not subsequently.
      }
      \sstsubsection{
         CODATA( DIM1, DIM2 ) = ? (Given and Returned)
      }{
         The array to store the co-ordinates read from the text file.
         It should be initialised externally the first time this routine
         is called, but not subsequently.
      }
      \sstsubsection{
         LBND( DIM1 ) = ? (Given and Returned)
      }{
         The lower bounds of the input data, i.e. the minimum value for
         each co-ordinate.  It should be initialised externally the
         first time this routine is called, but not subsequently.
      }
      \sstsubsection{
         UBND( DIM1 ) = ? (Given and Returned)
      }{
         The upper bounds of the input data, i.e. the maximum value for
         each co-ordinate.  It should be initialised externally the
         first time this routine is called, but not subsequently.
      }
      \sstsubsection{
         CMPLET = LOGICAL (Returned)
      }{
         If .TRUE., the text file has been completely read.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         routine arguments CODATA, LBND and UBND must have the data type
         specified.
         \_  The maximum permitted line length in the file is 256
         characters.  A line with a hash or shriek in column one is treated
         as a comment.

         \sstitem
         The file is not closed on exit.

         \sstitem
         The record number is not initialised and so this routine reads
         from the current line in the file.  Hence this routine can be
         called repeatedly as the the output array is expanded to
         accommodate the input data.

         \sstitem
         The numerical values can include embedded spaces following a
         $+$, -, D, or E.  See SLALIB (SUN/67) routines SLA\_DFLTIN and
         SLA\_FLOTIN for details of the conversion from free-format to
         floating-point value.  Missing columns that are not numeric
         cannot have these embedded spaces.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The Fortran text file must already be opened.
      }
   }
}
\sstroutine{
   KPG1\_RMAPx
}{
   Remaps an array{\tt '}s values according to an histogram key
}{
   \sstdescription{
      This routine remaps all the values in an array on to new values,
      according to a key.  The key locates element values with
      respect to an histogram that has been transformed from a linear
      one, i.e. has equal-sized bins.  For example, in histogram
      equalisation the bin width varies so as to give approximately
      equal numbers of values in each bin.
   }
   \sstinvocation{
      CALL KPG1\_RMAPx( EL, INARR, VALMAX, VALMIN, NUMBIN, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be remapped.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum value data value used to form the linear histogram.
         Data values greater than this will be set bad in the output
         array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum value data value used to form the linear histogram.
         Data values less than this will be set bad in the output
         array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Given)
      }{
         The key to the transform of the linear histogram.  MAP stores
         the new bin number for each of the linear bin numbers.  A bin
         number in the linear histogram is defined by the fractional
         position between the minimum and maximum data values times the
         number of bins.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the remapped values.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and the histogram limits supplied to this routine must
         have the data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_SCLBx
}{
   Copy array values into a BYTE array, scaling them in the process
}{
   \sstdescription{
      This routine copies values from one array to another, applying a
      linear scaling in the process. The output array is of type BYTE
      but the input array can be of a different type.
   }
   \sstinvocation{
      CALL KPG1\_SCLB$<$T$>$( SCALE, ZERO, BAD, EL, IN, OUT, BADOUT, NBAD,
                           STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE = DOUBLE PRECISION (Given)
      }{
         The scale factor.
      }
      \sstsubsection{
         ZERO = DOUBLE PRECISION (Given)
      }{
         The zero offset.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the input array. If
         false it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the input array.
      }
      \sstsubsection{
         IN( EL ) = $<$TYPE$>$ (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OUT( EL ) = BYTE (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         True if there are any bad pixels in the output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of good input pixels that could not be accomodated
         within the dynamic range of the output data type, and were
         consequently set bad in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given and Returned)
      }{
         Global status value
      }
   }
}
\sstroutine{
   KPG1\_SCLIx
}{
   Copy array values into a INTEGER array, scaling them in the process
}{
   \sstdescription{
      This routine copies values from one array to another, applying a
      linear scaling in the process. The output array is of type INTEGER
      but the input array can be of a different type.
   }
   \sstinvocation{
      CALL KPG1\_SCLI$<$T$>$( SCALE, ZERO, BAD, EL, IN, OUT, BADOUT, NBAD,
                           STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE = DOUBLE PRECISION (Given)
      }{
         The scale factor.
      }
      \sstsubsection{
         ZERO = DOUBLE PRECISION (Given)
      }{
         The zero offset.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the input array. If
         false it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the input array.
      }
      \sstsubsection{
         IN( EL ) = $<$TYPE$>$ (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OUT( EL ) = INTEGER (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         True if there are any bad pixels in the output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of good input pixels that could not be accomodated
         within the dynamic range of the output data type, and were
         consequently set bad in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given and Returned)
      }{
         Global status value
      }
   }
}
\sstroutine{
   KPG1\_SCLUBx
}{
   Copy array values into a BYTE array, scaling them in the process
}{
   \sstdescription{
      This routine copies values from one array to another, applying a
      linear scaling in the process. The output array is of type BYTE
      but the input array can be of a different type.
   }
   \sstinvocation{
      CALL KPG1\_SCLUB$<$T$>$( SCALE, ZERO, BAD, EL, IN, OUT, BADOUT, NBAD,
                           STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE = DOUBLE PRECISION (Given)
      }{
         The scale factor.
      }
      \sstsubsection{
         ZERO = DOUBLE PRECISION (Given)
      }{
         The zero offset.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the input array. If
         false it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the input array.
      }
      \sstsubsection{
         IN( EL ) = $<$TYPE$>$ (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OUT( EL ) = BYTE (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         True if there are any bad pixels in the output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of good input pixels that could not be accomodated
         within the dynamic range of the output data type, and were
         consequently set bad in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given and Returned)
      }{
         Global status value
      }
   }
}
\sstroutine{
   KPG1\_SCLUWx
}{
   Copy array values into a INTEGER$*$2 array, scaling them in the process
}{
   \sstdescription{
      This routine copies values from one array to another, applying a
      linear scaling in the process. The output array is of type INTEGER$*$2
      but the input array can be of a different type.
   }
   \sstinvocation{
      CALL KPG1\_SCLUW$<$T$>$( SCALE, ZERO, BAD, EL, IN, OUT, BADOUT, NBAD,
                           STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE = DOUBLE PRECISION (Given)
      }{
         The scale factor.
      }
      \sstsubsection{
         ZERO = DOUBLE PRECISION (Given)
      }{
         The zero offset.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the input array. If
         false it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the input array.
      }
      \sstsubsection{
         IN( EL ) = $<$TYPE$>$ (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OUT( EL ) = INTEGER$*$2 (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         True if there are any bad pixels in the output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of good input pixels that could not be accomodated
         within the dynamic range of the output data type, and were
         consequently set bad in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given and Returned)
      }{
         Global status value
      }
   }
}
\sstroutine{
   KPG1\_SCLWx
}{
   Copy array values into a INTEGER$*$2 array, scaling them in the process
}{
   \sstdescription{
      This routine copies values from one array to another, applying a
      linear scaling in the process. The output array is of type INTEGER$*$2
      but the input array can be of a different type.
   }
   \sstinvocation{
      CALL KPG1\_SCLW$<$T$>$( SCALE, ZERO, BAD, EL, IN, OUT, BADOUT, NBAD,
                           STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE = DOUBLE PRECISION (Given)
      }{
         The scale factor.
      }
      \sstsubsection{
         ZERO = DOUBLE PRECISION (Given)
      }{
         The zero offset.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the input array. If
         false it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the input array.
      }
      \sstsubsection{
         IN( EL ) = $<$TYPE$>$ (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OUT( EL ) = INTEGER$*$2 (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         True if there are any bad pixels in the output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of good input pixels that could not be accomodated
         within the dynamic range of the output data type, and were
         consequently set bad in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given and Returned)
      }{
         Global status value
      }
   }
}
\sstroutine{
   KPG1\_SQSUx
}{
   Finds the sum of the squares of an array
}{
   \sstdescription{
      This routine sums the squares of a supplied array and return the
      sum.  This might used to sum the residuals for a minimisation.
      Bad values are ignored.
   }
   \sstinvocation{
      CALL KPG1\_SQSUx( EL, ARRAY, SUMSQ, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array to sum.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array whose sqaured values are to be summed.
      }
      \sstsubsection{
         SUMSQ = ? (Returned)
      }{
         The sum of the squared array values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for integer, real, and double precision data
      types: replace {\tt "}x{\tt "} in the routine name by I, R, or D respectively.
      The ARRAY and SUMSQ arguments supplied to the routine must have
      the data type specified.
   }
}
\sstroutine{
   KPG1\_SSAZx
}{
   Applies a simple scaling and base-line shift to create the
   output vector
}{
   \sstdescription{
      Pixel indices are multiplied by the given factor and
      the given offset is then added on, to form the output data.
      The first pixel has a value equal to the offset.
   }
   \sstinvocation{
      CALL KPG1\_SSAZx( EL, FACTOR, OFFSET, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number elements in the returned array.
      }
      \sstsubsection{
         FACTOR = DOUBLE PRECISION (Given)
      }{
         The factor by which the array indices are scaled.
      }
      \sstsubsection{
         OFFSET = DOUBLE PRECISION (Given)
      }{
         The offset by which the array indices are shifted.
      }
      \sstsubsection{
         OUT( EL ) = ? (Returned)
      }{
         The output data vector.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The returned array should be of the same type.

         \sstitem
         There is no exception handler if the evaluated value exceeds the
         machine floating-point range.
      }
   }
}
\sstroutine{
   KPG1\_STATX
}{
   Compute simple statistics for an array
}{
   \sstdescription{
      This routine computes simple statistics for an array, namely: the
      number of valid pixels, the minimum and maximum pixel values (and
      their positions), the pixel sum, the mean, and the standard
      deviation. Iterative K-sigma clipping may also be optionally
      applied.
   }
   \sstinvocation{
      CALL KPG1\_STATX( BAD, EL, DATA, NCLIP, CLIP, NGOOD, IMIN, DMIN,
                       IMAX, DMAX, SUM, MEAN, STDEV, NGOODC, IMINC,
                       DMINC, IMAXC, DMAXC, SUMC, MEANC, STDEVC,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NCLIP = INTEGER (Given)
      }{
         Number of K-sigma clipping iterations to apply (may be zero).
      }
      \sstsubsection{
         CLIP( NCLIP ) = REAL (Given)
      }{
         Array of clipping limits for successive iterations, expressed
         as standard deviations.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array before clipping.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array before clipping.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array before clipping.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels before clipping.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels before clipping.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels before clipping.
      }
      \sstsubsection{
         NGOODC = INTEGER (Returned)
      }{
         Number of valid pixels in the array after clipping.
      }
      \sstsubsection{
         IMINC = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMINC = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array after clipping.
      }
      \sstsubsection{
         IMAXC = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMAXC = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array after clipping.
      }
      \sstsubsection{
         SUMC = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels after clipping.
      }
      \sstsubsection{
         MEANC = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels after clipping.
      }
      \sstsubsection{
         STDEVC = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels after clipping.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate. The data type of the array being analysed must match
         the particular routine used.

         \sstitem
         If no clipping is performed (i.e. if NCLIP = 0) then the values
         of arguments which return results after clipping will be the same
         as for those returning results before clipping.

         \sstitem
         If NGOOD or NGOODC is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).
      }
   }
}
\sstroutine{
   KPG1\_STDSx
}{
   Displays statistics generated by KPG1\_STATx, KPG\_OSTAx, and
   KPG1\_HSTAx
}{
   \sstdescription{
      This routine diplays the statistics of pixel data as generated by
      the routines KPG1\_STATx, KPG\_OSTAx, and KPG1\_HSTAx.
   }
   \sstinvocation{
      CALL KPG1\_STDSx( IWCS, NDIM, EL, NGOOD, DMIN, MINP, MINC,
                       DMAX, MAXP, MAXC, SUM, MEAN, STDEV, SKEW,
                       KURTOS, MEDIAN, MODE, NUMPER, PERCNT, PERVAL,
                       MAXWCS, MINWCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         Pointer to WCS FrameSet.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions of the array whose statistics are being
         displayed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Total number of pixels in the array.
      }
      \sstsubsection{
         NGOOD = INTEGER (Given)
      }{
         Number of valid pixels which contributed to the statistics.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Given)
      }{
         Minimum pixel value.
      }
      \sstsubsection{
         MINP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the minimum pixel value was (first)
         found.
      }
      \sstsubsection{
         MINC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the minimum pixel.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Given)
      }{
         Maximum pixel value.
      }
      \sstsubsection{
         MAXP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the maximum pixel value was (first)
         found.
      }
      \sstsubsection{
         MAXC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the maximum pixel.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Given)
      }{
         Pixel sum.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Given)
      }{
         Pixel mean value.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Given)
      }{
         Pixel standard deviation value.
      }
      \sstsubsection{
         SKEW = DOUBLE PRECISION (Given)
      }{
         Skewness of the pixel values.
      }
      \sstsubsection{
         KURTOS = DOUBLE PRECISION (Given)
      }{
         Pixel kurtosis.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Given)
      }{
         Median value.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Given)
      }{
         Modal value.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles values to report.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given)
      }{
         The array of percentiles levels corresponding to the values
         given by PERVAL.  They should be in the range 0.0 to 100.0,
         and preferably in ascending order.  If there are none to
         report, set NUMPER to 1 and pass the bad value in PERCNT( 1 ).
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Given)
      }{
         Percentile values corresponding to the percentile fractions
         in PERCNT.
      }
      \sstsubsection{
         MAXWCS = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The formatted WCS co-ordinates at the minimum position.
      }
      \sstsubsection{
         MINWCS = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The formatted WCS co-ordinates at the minimum position.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for both real and double-precision
         statistics: replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate. Note that the two routines have identical argument
         lists (with floating-point qualitities in double precision) but
         differ in the precision with which the results are displayed.

         \sstitem
         If the value of NGOOD is not positive, then this routine will
         assume that all the derived statistics (except for the sum) are
         undefined and will not display them.

         \sstitem
         If a statistic is undefined, i.e. has the bad value, it is
         not reported.  In the case of arrays, the first value is checked.
         For the co-ordinates and pixel indices of the extreme values both
         of the first elements of these must be good to display these
         positions.
      }
   }
}
\sstroutine{
   KPG1\_STFLx
}{
   Write statistics generated by KPG1\_STATx, KPG\_OSTAx, and
   KPG1\_HSTAx to a text file
}{
   \sstdescription{
      This routine writes the statistics of pixel data as generated by
      the routines KPG1\_STATx, KPG\_OSTAx, and KPG1\_HSTAx to a text file.
   }
   \sstinvocation{
      CALL KPG1\_STFLx( IWCS, NDIM, EL, NGOOD, DMIN, MINP, MINC,
                       DMAX, MAXP, MAXC, SUM, MEAN, STDEV, SKEW,
                       KURTOS, MEDIAN, MODE, NUMPER, PERCNT, PERVAL,
                       IFIL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         Pointer to WCS FrameSet.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions of the array whose statistics are being
         displayed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Total number of pixels in the array.
      }
      \sstsubsection{
         NGOOD = INTEGER (Given)
      }{
         Number of valid pixels which contributed to the statistics.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Given)
      }{
         Minimum pixel value.
      }
      \sstsubsection{
         MINP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the minimum pixel value was (first)
         found.
      }
      \sstsubsection{
         MINC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the minimum pixel.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Given)
      }{
         Maximum pixel value.
      }
      \sstsubsection{
         MAXP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the maximum pixel value was (first)
         found.
      }
      \sstsubsection{
         MAXC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the maximum pixel.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Given)
      }{
         Pixel sum.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Given)
      }{
         Pixel mean value.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Given)
      }{
         Pixel standard deviation value.
      }
      \sstsubsection{
         SKEW = DOUBLE PRECISION (Given)
      }{
         Skewness of the pixel values.
      }
      \sstsubsection{
         KURTOS = DOUBLE PRECISION (Given)
      }{
         Pixel kurtosis.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Given)
      }{
         Median value.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Given)
      }{
         Modal value.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles values to report.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given)
      }{
         The array of percentiles levels corresponding to the values
         given by PERVAL.  They should be in the range 0.0 to 100.0,
         and preferably in ascending order.  If there are none to
         report, set NUMPER to 1 and pass the bad value in PERCNT( 1 ).
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Given)
      }{
         Percentile values corresponding to the percentile fractions
         in PERCNT.
      }
      \sstsubsection{
         IFIL = INTEGER (Given)
      }{
         FIO\_ file descriptor for the output file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for both real and double-precision
         statistics: replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate. Note that the two routines have identical argument
         lists (with floating-point qualitities in double precision) but
         differ in the precision with which the results are displayed.

         \sstitem
         If the value of NGOOD is not positive, then this routine will
         assume that all the derived statistics (except for the sum) are
         undefined and will not display them.

         \sstitem
         If a statistic is undefined, i.e. has the bad value, it is
         not reported.  In the case of arrays, the first value is checked.
         For the co-ordinates and pixel indices of the extreme values both
         of the first elements of these must be good to display these
         positions.
      }
   }
}
\sstroutine{
   KPG1\_STORx
}{
   Stores a value in an array
}{
   \sstdescription{
      The supplied value is stored in the array at the given index.
   }
   \sstinvocation{
      CALL KPG1\_STORx( EL, INDEX, VALUE, DATA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index at which to store the supplied value.
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         The value to be stored in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given and Returned)
      }{
         The array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_TDLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This operates with double-precision co-ordinates.  Use KPG1\_TRLIx
      for single precision.
   }
   \sstinvocation{
      CALL KPG1\_TDLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_THRSx
}{
   Sets pixels in array to defined new values outside limits
}{
   \sstdescription{
      This routine takes an array and sets all values above a defined
      upper threshold to a new defined value, and sets all those below a
      defined lower threshold to another defined value.  In practice,
      all values outside the two thresholds may be set to zero or
      the bad value, for example.

      If the lower threshold is greater than or equal to the upper
      threshold, the values between the thresholds are set to the
      supplied lower replacement value, and the upper replacement value
      is ignored. In this case the number of replaced pixels is returned
      in NREPLO, and NREPHI is returned as -1.
   }
   \sstinvocation{
      CALL KPG1\_THRSx( BAD, EL, INARR, THRLO, THRHI, NEWLO, NEWHI,
                       OUTARR, NREPLO, NREPHI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         The bad-pixel flag.  If it is .TRUE., tests are made for bad
         array values.  When .FALSE., no tests are made for bad values,
         and any encountered are treated literally.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Input data to be thresholded.
      }
      \sstsubsection{
         THRLO = ? (Given)
      }{
         Upper threshold level.
      }
      \sstsubsection{
         THRHI = ? (Given)
      }{
         Lower threshold level.
      }
      \sstsubsection{
         NEWLO = ? (Given)
      }{
         Value to which pixels below THRLO will be set.
      }
      \sstsubsection{
         NEWHI = ? (Given)
      }{
         Value to which pixels above THRHI will be set.
      }
      \sstsubsection{
         NREPLO = ? (Returned)
      }{
         The number of values less than the lower threshold and
         substituted.
      }
      \sstsubsection{
         NREPHI = ? (Returned)
      }{
         The number of values greater than the upper threshold and
         substituted.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         Output thresholded data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_TRALx
}{
   Finds the extreme co-ordinates of an n-d array after being
   transformed
}{
   \sstdescription{
      This routine applies a forward mapping to the co-ordinates
      of all pixel corners in an n-dimensional array in order to find
      the limits of the array after a transformation (forward mapping)
      has been applied.  It assumes equally spaced co-ordinates which
      will be true for pixel co-ordinates and many sets of data
      co-ordinates, but should be adequate even for unevenly spaced
      data co-ordinates.  It will only give poor results for strange
      transformations with singularities.
   }
   \sstinvocation{
      CALL KPG1\_TRALx( NDIMI, IDIMS, LBND, UBND, TRID, IEL, NDIMO, COIN,
                       COOUT, COMIN, COMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the associated input n-dimensional data
         array.
      }
      \sstsubsection{
         LBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the lower bounds of the associated input
         n-dimensional array.
      }
      \sstsubsection{
         UBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the upper bounds of the associated input
         n-dimensional array.
      }
      \sstsubsection{
         TRID = INTEGER (Given)
      }{
         The TRANSFORM identifier of the mapping.
      }
      \sstsubsection{
         IEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         IDIMS( 1 ) $+$ 1.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array.
      }
      \sstsubsection{
         COIN( IEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input array.
      }
      \sstsubsection{
         COOUT( IEL, NDIMO ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output array.
      }
      \sstsubsection{
         COMIN( NDIMO ) = ? (Returned)
      }{
         The minimum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         COMAX( NDIMO ) = ? (Returned)
      }{
         The maximum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input co-ordinate work arrays and the output limiting-co-ordinate
         arrays must have the data type specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRBOx
}{
   Finds the extreme co-ordinates of an n-d array after being
   transformed
}{
   \sstdescription{
      This routine applies a forward mapping to the pixel co-ordinates
      of test points in an n-dimensional array in order to find the
      limits of the array after a transformation (forward mapping) has
      been applied.  The test points are the vertices and the midpoints
      between them.
   }
   \sstinvocation{
      CALL KPG1\_TRBOx( NDIMI, LBND, UBND, TRID, NDIMO, COMIN, COMAX,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         LBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the lower bounds of the input n-dimensional
         array.
      }
      \sstsubsection{
         UBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the upper bounds of the input n-dimensional
         array.
      }
      \sstsubsection{
         TRID = INTEGER (Given)
      }{
         The TRANSFORM identifier of the mapping.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array.
      }
      \sstsubsection{
         COMIN( NDIMO ) = ? (Returned)
      }{
         The minimum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         COMAX( NDIMO ) = ? (Returned)
      }{
         The maximum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input co-ordinate bounds and the output limiting-co-ordinate
         arrays must have the data type specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRIG$<$T$>$
}{
   Apply a trig function to each element of a vectorised array
}{
   \sstdescription{
      The routine applied a specified trig function to each element of a
      vectorised array. Any associated variance values are also modified
      appropriately.
   }
   \sstinvocation{
      CALL KPG1\_TRIG$<$T$>$( BAD, VAR, TRIGFN, EL, DIN, VIN, DOUT, VOUT, NBAD,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input arrays.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Have associated variances been supplied?
      }
      \sstsubsection{
         TRIGFN = CHARACTER$*$($*$) (Given)
      }{
         The required trig function. This should be one of SIN, COS, TAN,
         SIND, COSD, TAND, ASIN, ACOS, ATAN, ASIND, ACOSD, ATAND.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         DIN( EL ) = $<$TYPE$>$ (Given)
      }{
         Input data array.
      }
      \sstsubsection{
         VIN( EL ) = $<$TYPE$>$ (Given)
      }{
         Input variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         DOUT( EL ) = $<$TYPE$>$ (Given)
      }{
         Output data array.
      }
      \sstsubsection{
         VOUT( EL ) = $<$TYPE$>$ (Given)
      }{
         Output variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         NBAD( 2 ) = INTEGER (Returned)
      }{
         Element 1 has the number of bad values stored in DOUT, and element
         2 has the number of bad values stored in VOUT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_TRLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This routine operates with single-precision co-ordinates.  Use
      KPG1\_TDLIx for double precision.
   }
   \sstinvocation{
      CALL KPG1\_TRLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = REAL (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRPIx
}{
   Finds vectorised pixel indices after applying a transformation to
   an array{\tt '}s pixel co-ordinates
}{
   \sstdescription{
      This routine applies a transformation to the pixel co-ordinates
      of the elements of an (output) n-dimensional array of a specified
      shape.  It then determines the nearest-neighbour element in the
      transformed (input) m-dimensional array, as a vector index, which
      is returned.  This array of vector indices may then be used by
      another routine to fill the output array with values from the
      input array.
   }
   \sstinvocation{
      CALL KPG1\_TRPIx( NDIMI, IDIMS, TRID, AXES, OEL, NDIMO, OLBND,
                       ODIMS, COIN, COOUT, FRIND, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D array.
      }
      \sstsubsection{
         TRID = INTEGER (Given)
      }{
         The TRANSFORM identifier of the mapping.
      }
      \sstsubsection{
         AXES( $*$ ) = ? (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D array.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D array.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = ? (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input array.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = ? (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output array.
      }
      \sstsubsection{
         FRIND( OEL, NDIMI ) = ? (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input array.
      }
      \sstsubsection{
         INDICE( $*$ ) = INTEGER (Returned)
      }{
         The vector indices of the nearest-array element of the
         transformed positions of the output array.  This array should
         therefore have a dimension at least as large as the product of
         the output array{\tt '}s dimensions.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         workspace and axis arrays must have the data type specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRSPx
}{
   Transposes a two-dimensional array
}{
   \sstdescription{
      This routine creates a new two-dimensional array containing a
      transposed copy the supplied array.
   }
   \sstinvocation{
      CALL KPG1\_TRSPx( M, N, IN, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array and the number of lines
         in the output array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of lines in the input array and the number of columns
         in the output array.
      }
      \sstsubsection{
         IN( M, N ) = ? (Given)
      }{
         The input array to be transposed.
      }
      \sstsubsection{
         OUT( N, M ) = ? (Returned)
      }{
         The transposed array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_UNZ2x
}{
   Unzips a 2-dimensional co-ordinate array into two 1-dimensional
   arrays
}{
   \sstdescription{
      This routine takes an array of dimension 2 by EL elements and
      puts the two columns into separate arrays.
   }
   \sstinvocation{
      CALL KPG1\_UNZ2x( EL, IN, OUT1, OUT2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of lines in the input array, and elements in each of
         the output arrays.
      }
      \sstsubsection{
         IN( 2, EL ) = ? (Given)
      }{
         The array to be `unzipped{\tt '}.
      }
      \sstsubsection{
         OUT1( EL ) = ? (Returned)
      }{
         The vector to contain first column of the input array.
      }
      \sstsubsection{
         OUT2( EL ) = ? (Returned)
      }{
         The vector to contain second column of the input array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         routine arguments IN, OUT1, and OUT2 must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_VASVx
}{
   Assigns values to an output array from an input array using a list
   of indices
}{
   \sstdescription{
      This routine assigns values to an output vector from an input
      vector.  The values are selected using a list of indices
      in the input vector, there being one index per output value.
      A bad value or a value outside the bounds of the array in the
      list of indices causes a bad value to be assigned to the output
      array.
   }
   \sstinvocation{
      CALL KPG1\_VASVx( OEL, INDICE, IEL, INARR, OUTARR, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The dimension of the output vector and also the list of
         indices.
      }
      \sstsubsection{
         INDICE( OEL ) = INTEGER (Given)
      }{
         The indices in the input array that point to the values to be
         assigned to the output vector.
      }
      \sstsubsection{
         IEL = INTEGER (Given)
      }{
         The dimension of the input vector.
      }
      \sstsubsection{
         INARR( IEL ) = ? (Given)
      }{
         The vector containing values to be given to the output vector.
      }
      \sstsubsection{
         OUTARR( OEL ) = ? (Returned)
      }{
         The vector containing values copied from the input vector
         according to the list of indices.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         input and output vectors supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_WMODx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  The data points have weights, to
      allow for different intrinisic errors.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_WMODx( X, W, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         W( NX ) = REAL (Given)
      }{
         An array of data weights for each data value.  The weights are
         inversely proportional to the square of the relative errors on
         each data point.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted normalised standard deviation of
         the data points.  An estimate of the standard deviation of any
         one point is:  SIGMA / SQRT( W ) where W is its weight.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_XYZWx
}{
   Converts a 2-dimensional array into a list of x-y co-ordinates,
   values and weights
}{
   \sstdescription{
      This routine converts a 2-dimensional array into a list of x-y
      coordinates, data values and weights for each of the good pixels
      in the array.  The x-y co-ordinates come from the axis arrays
      supplied.  Bad pixels are ignored if BAD is .TRUE..  If VARWTS is
      .TRUE., weights are calculated from the reciprocal of the
      variance for each pixel, otherwise the weights are returned 1.0.
   }
   \sstinvocation{
      CALL KPG1\_XYZWx( DIM1, DIM2, ARRAY, XAXIS, YAXIS, BAD, VARWTS,
                       VAR, SIZE, X, Y, Z, W, NGOOD, XMIN, XMAX, YMIN,
                       YMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-dimensional array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-dimensional array.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         XAXIS( DIM1 ) = DOUBLE PRECISION (Given)
      }{
         X axis co-ordinates for the input data array.
      }
      \sstsubsection{
         YAXIS( DIM2 ) = DOUBLE PRECISION (Given)
      }{
         Y axis co-ordinates for the input data array.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Flag indicating whether bad values are likely to be present.
      }
      \sstsubsection{
         VARWTS = LOGICAL (Given)
      }{
         Flag indicating if the variance array contains valid data.
      }
      \sstsubsection{
         VAR( DIM1, DIM2 ) = ? (Given)
      }{
         An optional array containing the variance of the values
         in the input data array, used to generate a weight for each
         element.  It is only used if VARWTS is .TRUE..
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The total number of pixels.
      }
      \sstsubsection{
         X( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The mean x positions for each pixel
      }
      \sstsubsection{
         Y( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The mean y positions for each pixel.
      }
      \sstsubsection{
         Z( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The data value for each pixel.
      }
      \sstsubsection{
         W( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The weight for each pixel.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         The number of good pixels.
      }
      \sstsubsection{
         XMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum x co-ordinate.
      }
      \sstsubsection{
         XMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum x co-ordinate.
      }
      \sstsubsection{
         YMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum y co-ordinate.
      }
      \sstsubsection{
         YMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum y co-ordinate.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY and VAR arrays supplied to the routine must have the data
         type specified.

         \sstitem
         Uses the magic-value method for bad or undefined pixels.
      }
   }
}
\sstroutine{
   KPG\_BLONx
}{
   Smooths an n-dimensional image using box filter
}{
   \sstdescription{
      The routine smooths an n-dimensional array using an n-dimensional
      box filter; each pixel is replaced by the mean of those good
      neighbours which lie within a box of specified size.
   }
   \sstinvocation{
      CALL KPG\_BLONx( BAD, SAMBAD, VAR, NDIM, DIMS, A, IBOX,
                      NLIM, WDIM, B, BADOUT, ASUM, NSUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad pixels in the input
         image.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given for this argument, then bad input
         pixels will be propagated to the output image unchanged (a
         smoothed output value will be calculated for all other
         pixels). If a .FALSE. value is given, then the NLIM argument
         determines whether an output pixel is good or bad.  The value
         of SAMBAD is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If a .FALSE. value is given for this argument, then the
         smoothing applied will be appropriate to a data image. If a
         .TRUE. value is given, then the smoothing will be appropriate
         to an image containing variance values. In the latter case the
         output values will be (on average) smaller than the input
         values to take account of the variance-reducing effect which
         smoothing produces.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions of the array to be smoothed.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the array to be smoothed.
      }
      \sstsubsection{
         A( $*$ ) = ? (Given)
      }{
         Input array to be smoothed.  Its dimensions are given by
         argument DIMS.
      }
      \sstsubsection{
         IBOX( NDIM ) = INTEGER (Given)
      }{
         Half-size of the smoothing box in pixels along eeach axis
         (the actual size of the ith axis{\tt '}s box used will be
         2$*$IBOX(i)$+$1 pixels).
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         Minimum number of good pixels which must be present in the
         smoothing box in order to calculate a smoothed output pixel.
         If this minimum number is not satisfied, then a bad output
         pixel will result. A value between 1 and the total number of
         pixels in the smoothing box should be supplied.
      }
      \sstsubsection{
         WDIM = INTEGER (Given)
      }{
         The dimension of the ASUM and NSUM workspaces.  It must be at
         least 1 $+$ DIMS( 1 ) for a two-dimensional array , and at least
         1 $+$ ( DIMS(1) $*$ ... ( 1 $+$ DIMS(NDIM-1) ) ... ) for an
         NDIM-dimensional array.  For example a 20x16x27-element array
         would need WLIM not fewer than 1$+$(20$*$(1$+$16)=341 elements.
      }
      \sstsubsection{
         B( $*$ ) = ? (Returned)
      }{
         The smoothed output array.  It has the same dimensions as A.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether bad pixels are present in the output image.
      }
      \sstsubsection{
         ASUM( $*$ ) = ? (Returned)
      }{
         Workspace for the pixel sums.
      }
      \sstsubsection{
         NSUM( $*$ ) = INTEGER (Returned)
      }{
         Workspace for counting good pixels.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the A, B and ASUM arguments must match the
         routine used.

         \sstitem
         The routine uses recursion of the standard filter algorithm
         for each dimension moving from the highest to lowest. Recursion
         ends when there is only the integrated value and the corresponding
         number of contributing pixels sums used to find the output
         smoothed value for the current element of the input array.  At
         each dimension the filter box is initialised with the required
         number of values for the box width, and then as the routine
         progresses through each position in the current dimension a new
         section is incorporated into the summations, while a section
         leaving the box is subtracted.
      }
   }
}
\sstroutine{
   KPG\_OSTAx
}{
   Compute simple statistics for an array
}{
   \sstdescription{
      This routine computes simple statistics for an array, namely: the
      number of valid pixels; the minimum and maximum pixel values (and
      their positions); the pixel sum; the mean; and the population
      standard deviation, skewness, and excess kurtosis.  Iterative
      K-sigma clipping may also be optionally applied.

      It uses a one-pass recursive algorithm for efficiency using the
      formulae of Terriberry (2007).
   }
   \sstinvocation{
      CALL KPG\_OSTAx( BAD, EL, DATA, NCLIP, CLIP, ISTAT, DSTAT,
                      ISTATC, DSTATC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NCLIP = INTEGER (Given)
      }{
         Number of K-sigma clipping iterations to apply (may be zero).
      }
      \sstsubsection{
         CLIP( NCLIP ) = REAL (Given)
      }{
         Array of clipping limits for successive iterations, expressed
         as standard deviations.
      }
      \sstsubsection{
         ISTAT( 3 ) = INTEGER (Returned)
      }{
         The integer statistics before clipping.  The meanings of the
         elements in order are as follows.
         \sstitemlist{

            \sstitem
            Number of valid pixels

            \sstitem
            Index where the pixel with the lowest value was (first)
            found

            \sstitem
            Index where the pixel with the highest value was (first)
            found
         }
      }
      \sstsubsection{
         DSTAT( 7 ) = DOUBLE PRECISION (Returned)
      }{
         The floating-point statistics before clipping derived from the
         valid pixel values in DATA.  The meanings of the elements in
         order are as follows.
         \sstitemlist{

            \sstitem
            Minimum value

            \sstitem
            Maximum value

            \sstitem
            Sum

            \sstitem
            Mean

            \sstitem
            Population standard deviation

            \sstitem
            Population skewness

            \sstitem
            Population excess kurtosis.  This is zero for a Gaussian.
         }
      }
      \sstsubsection{
         ISTATC( 3 ) = INTEGER (Returned)
      }{
         The integer statistics after clipping derived from the valid
         pixel values in DATA.  The attributions of the elements are
         the same as for argument ISTAT.  If NCLIP is zero, the
         array will contain the same values as ISTAT.
      }
      \sstsubsection{
         DSTATC( 7 ) = DOUBLE PRECISION (Returned)
      }{
         The floating-point statistics after clipping derived from the
         valid pixel values in DATA.  The attributions of the elements
         are the same as for argument DSTAT.  If NCLIP is zero, the
         array will contain the same values as DSTAT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate. The data type of the array being analysed must match
         the particular routine used.

         \sstitem
         If no clipping is performed (i.e. if NCLIP = 0) then the values
         of arguments which return results after clipping will be the same
         as for those returning results before clipping.

         \sstitem
         If ISTAT(1) or ISTATC(1) is zero, then the values of all the
         derived statistics will be undefined and will be set to the {\tt "}bad{\tt "}
         value appropriate to their data type (except for the pixel sum,
         which will be zero).
      }
   }
   \sstdiytopic{
      References
   }{
      Terriberry, T.B., 2007, Computing Higher-order Moments Online,
      http://people.xiph.org/$\sim$tterribe/notes/homs.html.
   }
}
\sstroutine{
   KPG\_STOSx
}{
   Calculates accurate order statistics by sorting an array
}{
   \sstdescription{
      This routine calculates the median and optionally up to
      one-hundred percentiles.  It achieves this by using Quicksort
      to order the good array values, and hence provide correct values
      (unlike the faster histogram approximation used by KPG1\_HSTAx).
   }
   \sstinvocation{
      CALL KPG\_STOSx( EL, ARRAY, NGOOD, NUMPER, PERCNT,
                      MEDIAN, PERVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Total number of pixels in the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The vectorised array of values whose ordered statistics are
         to be calculated.
      }
      \sstsubsection{
         NGOOD = INTEGER (Given)
      }{
         Number of valid pixels which contributed to the statistics.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles values to report.  This should be in
         the range 1 to 100.  Set this to 1 and PERCNT(1) to VAL\_\_BADR
         if percentiles are not required.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given)
      }{
         The percentiles to derive.  Valid percentiles must be in the
         range 0.0 to 100.0, and preferably in ascending order.  If the
         first element is set to the bad value, then no percentiles are
         calculated.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         Median value.  If there is an even number of good values
         present in the array, the median is the average of the middle
         pair.
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Returned)
      }{
         Percentile values corresponding to the percentile fractions
         in PERCNT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for double-precision, integer, and real data
         types: replace {\tt "}x{\tt "} in the routine name by D, I, or R as
         appropriate.  The data type of the ARRAY argument must match the
         particular routine used.

         \sstitem
         If the value of NGOOD is not at least two, then this routine
         will abort.  The median and percentiles will have the bad value.

         \sstitem
         The sorting is recorded in an index leaving the order of the
         supplied array values intact.
      }
   }
}
\sstroutine{
   KPG1\_ASNDF
}{
   Create a FrameSet containing NDF-special Frames with given bounds
}{
   \sstdescription{
      This function creates a FrameSet containing the NDF-special Frames,
      GRID, PIXEL, FRACTION and AXIS, appropriate to an NDF with the
      supplied dimensionality and pixel index bounds. Optionally, AXIS
      information can be propagated from a supplied NDF.
   }
   \sstinvocation{
      CALL KPG1\_ASNDF( INDF, NDIM, LBND, UBND, IWCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An NDF from which to propagate AXIS information. May be NDF\_\_NOID,
         in which case the AXIS Frame in the returned FrameSet will describe
         the default AXIS coordinate system (i.e. pixel coords).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of pixel axes in the modified FrameSet.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds in the modified FrameSet.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds in the modified FrameSet.
      }
      \sstsubsection{
         IWCS = INTEGER (Returned)
      }{
         Pointer to a new FrameSet holding GRID, FRACTION, PIXEL and AXIS
         Frames describing the supplied NDF bounds, plus AXIS information
         from the supplied NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_CH2PM
}{
   Create an AST PolyMap describing a Starlink POLYNOMIAL HDS structure
}{
   \sstdescription{
      This routine creates an AST PolyMap that implements the
      polynomial transformation described by a supplied Starlink
      POLYNOMIAL structure (see SGP/38).
   }
   \sstinvocation{
      CALL KPG1\_CH2PM( LOC, POLYMAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given)
      }{
         An HDS locator for the POLYNOMIAL structure.
      }
      \sstsubsection{
         POLYMAP = INTEGER (Returned)
      }{
         An AST pointer to the new PolyMap.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The returned PolyMap has a defined forward transformation
         (equivalent to the supplied POLYNOMIAL), but no inverse
         transformation.

         \sstitem
         Both CHEBYSHEV and SIMPLE variants of the POLYNOMIAL structure
         are supported. But currently only 1- or 2- dimensional Chebyshev
         polynomials can be handled. An error is reported for Chebyshev
         polynomials of higher dimensionality.
      }
   }
}
\sstroutine{
   KPG1\_HDSKY
}{
   Append a primitive HDS object to an AST KeyMap
}{
   \sstdescription{
      This function stores the vectorised data values in the supplied HDS
      object (which must be primitive) in the supplied KeyMap. The key for
      the KeyMap entry is the name of the HDS object. If the KeyMap already
      contains an entry with this name, then what happens is specified
      by OLD. Likewise, if the KeyMap does not already contain an entry
      with this name, then what happens is specified by NEW.
   }
   \sstinvocation{
      CALL KPG1\_HDSKY( LOC, KEYMAP, OLD, NEW, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given)
      }{
         An HDS locator for a primitive scalar or array object.
      }
      \sstsubsection{
         KEYMAP = INTEGER (Given)
      }{
         An AST pointer to an existing KeyMap.
      }
      \sstsubsection{
         OLD = INTEGER (Given)
      }{
         Specifies what happens if the supplied KeyMap already contains
         an entry with the name of the supplied HDS object.

         1 - Append the new vectorised array values read from the HDS
         object to the end of the values already in the KeyMap. The HDS
         values will be converted to the data type of the values already
         in the KeyMap (an error will be reported if this is not possible).

         2 - Replace the existing KeyMap entry with a new entry holding
         the vectorised array values read from the HDS object.

         3 - Do nothing. The KeyMap is returned unchanged, and no error
         is reported.

         4 - Report an error. The KeyMap is returned unchanged, and an error
         is reported.
      }
      \sstsubsection{
         NEW = INTEGER (Given)
      }{
         Specifies what happens if the supplied KeyMap does not already
         contain an entry with the name of the supplied HDS object.

         1 - Create a new entry holding the vectorised array values read from
         the HDS object.

         2 - Do nothing. The KeyMap is returned unchanged, and no error
         is reported.

         3 - Report an error. The KeyMap is returned unchanged, and an error
         is reported.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         An error is reported if the supplied HDS object is a structure.
      }
   }
}
\sstroutine{
   KPG1\_KY2HD
}{
   Convert an AST KeyMap into an HDS structure
}{
   \sstdescription{
      This routine copies the contents of an AST KeyMap into a supplied
      HDS structure.
   }
   \sstinvocation{
      CALL KPG1\_KY2HD( KEYMAP, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         KEYMAP = INTEGER (Given)
      }{
         The AST KeyMap identifier.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ (DAT\_\_SZLOC) (Given)
      }{
         A locator for the HDS object into which the KeyMap contents
         are to be copied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_KYGRP
}{
   Create an GRP group holding keyword/value pairs read from an AST
   KeyMap
}{
   \sstdescription{
      This function is the inverse of KPG1\_KYMAP. It extracts the values
      from the supplied AST KeyMap and creates a set of {\tt "}name=value{\tt "} strings
      which it appends to a supplied group (or creates a new group). If
      the KeyMap contains nested KeyMaps, then the {\tt "}name{\tt "} associated with
      each primitive value stored in the returned group is a hierarchical
      list of component names separated by dots.
   }
   \sstinvocation{
      CALL KPG1\_KYGRP( KEYMAP, IGRP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         KEYMAP = INTEGER (Given)
      }{
         An AST pointer to the existing KeyMap. Numerical entries which
         have bad values (VAL\_\_BADI for integer entries or VAL\_\_BADD for
         floating point entries) are not copied into the group.
      }
      \sstsubsection{
         IGRP = INTEGER (Returned)
      }{
         A GRP identifier for the group to which to append the {\tt "}name=value{\tt "}
         strings read from the KeyMap. A new group is created if GRP\_\_NOID
         is supplied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_KYHDS
}{
   Copy values from an AST KeyMap to a primitive HDS object
}{
   \sstdescription{
      This function fills a specified HDS object with primitive values
      read from a vector entry in an AST KeyMap. It is the inverse of
      KPG1\_HDSKY. The HDS object must already exist and must be a
      primitive array or scalar. The values to store in the HDS object
      are read from the KeyMap entry that has a key equal to the name
      of the HDS object. The vector read from the KeyMap is interpreted
      as an N-dimension array, where N is the number of dimensions in the
      HDS object. Array slices can be re-arranged as they are copied from
      KeyMap to HDS object. The AXIS argument specifies which axis is
      being re-arranged. Each array slice is perpendicular to this axis.
      The KeyMap array and the HDS array are assumed to have the same
      dimensions on all other axes.
   }
   \sstinvocation{
      CALL KPG1\_KYHDS( KEYMAP, MAP, AXIS, MODE, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         KEYMAP = INTEGER (Given)
      }{
         An AST pointer to the KeyMap.
      }
      \sstsubsection{
         MAP( $*$ ) = INTEGER (Given)
      }{
         An array which indicates how to map slices in the KeyMap array
         onto slices in the HDS array. The length of the supplied array
         should be equal to the HDS array dimension specified by AXIS.
         Element J of this array says where the data for the J{\tt '}th slice
         of the HDS array should come from, where J is the index along
         the axis specified by AXIS. The value of element J is a
         zero-based index along axis AXIS of the array read from the
         KeyMap.
      }
      \sstsubsection{
         AXIS = INTEGER (Given)
      }{
         The index of the axis to be re-arranged. The first axis is axis 1.
      }
      \sstsubsection{
         MODE = INTEGER (Given)
      }{
         Specifies what happens if the supplied KeyMap does not contain
         an entry with the name of the supplied HDS object.

         1 - Report an error.

         2 - Do nothing
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given)
      }{
         An HDS locator for a primitive scalar or array object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         An error is reported if the supplied HDS object is a structure.
      }
   }
}
\sstroutine{
   KPG1\_KYMAP
}{
   Create an AST KeyMap holding keyword/value pairs read from a GRP
   group
}{
   \sstdescription{
      This function checks each non-comment, non-blank line in the supplied
      GRP group. An error is reported if any such lines do not have the
      form {\tt "}keyword = value{\tt "}, where the keyword name can be a hierarchical
      list of component names separated by dots. The returned KeyMap has
      an entry for each component name found at the start of any keyword
      name. The value associated with the entry will either be a
      primitive value (if the keyword name contained no other components)
      or another KeyMap (if the keyword name contained other components).

      For example, consider a group containing the following lines:

      gaussclumps.epsilon = (0.001,0.002)
      gaussclumps.contrast = 2.3
      clumpfind.naxis = 2
      clumpfind.deltat = 2.0
      method = gaussclumps

      The returned KeyMap will contain 3 entries with keys {\tt "}gaussclumps{\tt "},
      {\tt "}clumpfind{\tt "} and {\tt "}method{\tt "}. The value associated with the {\tt "}gaussclumps{\tt "}
      entry will be another KeyMap containing keys {\tt "}epsilon{\tt "} (a primitive
      vector entry containing the values 0.001 and 0.002) and {\tt "}contrast{\tt "}
      (a primitive scalar entry with value {\tt "}2.3{\tt "}). The value associated with
      the {\tt "}clumpfind{\tt "} entry will be another KeyMap containing keys {\tt "}naxis{\tt "}
      and {\tt "}deltat{\tt "}, which will have primitive scalar values {\tt "}2{\tt "} and {\tt "}2.0{\tt "}.
      The value associated with the {\tt "}method{\tt "} entry will be the primitive
      scalar value {\tt "}gaussclumps{\tt "}.

      Assigning the value {\tt "}$<$def$>${\tt "} (case insensitive) to a keyword has the
      effect of removing the keyword from the KeyMap. For example:

      $\wedge$global.lis
      method = $<$def$>$

      reads keyword values from the file {\tt "}global.lis{\tt "}, and then ensures
      that the KeyMap does not contain a value for keyword {\tt "}method{\tt "}. The
      calling application should then usually use a default value for
      {\tt "}method{\tt "}.

      Assigning the value {\tt "}$<$undef$>${\tt "} (case insensitive) to a keyword
      has the effect of forcing the value to be undefined. This can
      be useful in defining defaults where the keymap is locked
      after being populated.
   }
   \sstinvocation{
      CALL KPG1\_KYMAP( IGRP, KEYMAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for the group of text strings to be analysed.
      }
      \sstsubsection{
         KEYMAP = INTEGER (Returned)
      }{
         An AST pointer to the new KeyMap, or AST\_\_NULL if an error occurs.
         A valid pointer to an empty KeyMap will be returned if the supplied
         group contains nothing but comments and blank lines.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Vector elements should be separated by commas and enclosed within
         parentheses (commas and closing parentheses can be included literally
         in a vector element by preceeding them with a backslash).

         \sstitem
         Component names must contain only alphanumerical characters,
         underscores, plus and minus signs [a-zA-Z0-9\_$+$$\backslash$-]. White space
         within keywords is ignored.

         \sstitem
         Any lower case characters contained in a component name will be
         translated to the upper case equivalent.

         \sstitem
         If the last non-blank character in a value is a backslash ({\tt "}$\backslash${\tt "}),
         the backslash will be reomved, together with any white space
         following it, and the entire next line will be appended to the value.
      }
   }
}
\sstroutine{
   kpg1\_memry
}{
   Return memory currently being used by the current process
}{
   \sstdescription{
      This subroutine returns the maximum resident set size for the
      current process.
   }
   \sstinvocation{
      CALL KPG1\_MEMRY( MEM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MEM = INTEGER (Returned)
      }{
         The memory currently being used by the current process, in
         KB.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The inherited global status.
      }
   }
}
\sstroutine{
   KPG\_GTFTS
}{
   Obtain FITS header information from an NDF
}{
   \sstdescription{
      The routine reads the FITS extension from an NDF and returns an
      AST pointer to a FitsChan which contains this information. The
      information may then be accessed using routines from the AST
      library (SUN/211).
   }
   \sstinvocation{
      CALL KPG\_GTFTS( INDF, FCHAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         FCHAN = INTEGER (Returned)
      }{
         An AST pointer to a FitsChan which contains information about
         the FITS headers associated with the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         It is the caller{\tt '}s responsibility to annul the AST pointer
         issued by this routine (e.g. by calling AST\_ANNUL) when it is no
         longer required.

         \sstitem
         If this routine is called with STATUS set, then a value of
         AST\_\_NULL will be returned for the FCHAN argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason.

         \sstitem
         Status is set to KPG\_\_NOFTS if no FITS extension is found.
      }
   }
}
\sstroutine{
   KPG\_PTFTS
}{
   Store FITS header information into an NDF
}{
   \sstdescription{
      The routine stores the contents of an AST FitsChan into an
      NDF by creating (or replacing) the FITS extension in the NDF.
   }
   \sstinvocation{
      CALL KPG\_PTFTS( INDF, FCHAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         Identifier of NDF to receive the .FITS extension.
      }
      \sstsubsection{
         FCHAN = INTEGER (Given)
      }{
         An AST pointer to a FitsChan which contains information about
         the FITS header to be associated with the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a .MORE.FITS extension already exists it will be completely
         replaced by this routine.
      }
   }
}
\newpage
\section{C-only Routine Descriptions}
\sstroutine{
   kpg1Config
}{
   Create an AST KeyMap holding a set of configuration parameter values
}{
   \sstdescription{
      This function first creates a KeyMap by reading the values from a
      specified text file (argument {\tt "}def{\tt "}). This text files specifies the
      complete list of all allowed config parameters and their default
      values. The KeyMap is then locked by setting its MapLocked attribute
      to a true value. A GRP group is then obtained from the environment
      using the specified parameter (argument {\tt "}param{\tt "}). The config
      settings thus obtained are stored in the KeyMap. An error is reported
      if the user-supplied group refers to any config parameters that were
      not read earlier from the default file.

      Both the defaults file and the user-supplied configuration may
      contain several sets of {\tt "}alternate{\tt "} configuration parameter values,
      and the set to use can be specified by the caller via the supplied
      {\tt "}nested{\tt "} keymap. For instance, if a basic configuration contains
      keys {\tt "}par1{\tt "} and {\tt "}par2{\tt "}, the user could supply two alternate sets of
      values for these keys by prepending each key name with the strings
      {\tt "}850{\tt "} and {\tt "}450{\tt "} (say). Thus, the user could supply values for any
      or all of: {\tt "}par1{\tt "}, {\tt "}par2{\tt "}, {\tt "}450.par1{\tt "}, {\tt "}450.par2{\tt "}, {\tt "}850.par1{\tt "},
      {\tt "}850.par2{\tt "}.

      The {\tt "}nested{\tt "} keymap supplied by the caller serves two functions: 1)
      it defines the known alternatives, and 2) it specifies which of the
      aternatives is to be used. Each key in the supplied {\tt "}nested{\tt "} keymap
      should be the name of an allowed alternative. In the above example,
      a KeyMap containing keys {\tt "}850{\tt "} and {\tt "}450{\tt "} could be supplied. No
      error is reported if the user-supplied configuration fails to
      provide values for one or more of the alternatives. The value
      associated with each key in the {\tt "}nested{\tt "} keymap should be an
      integer - the alternative to be used should have a non-zero value,
      and all other should be zero.

      So first, the configuration parameters specified by the supplied
      defaults file are examined. Any parameter that starts with the name
      of the selected alternative (i.e. the key within {\tt "}nested{\tt "} that has
      an associated value of 1) has the name of the alternative removed.
      Any parameter that start with the name of any of the other
      alternatives is simply removed from the configuration. Thus, using
      the above example, if {\tt "}nested{\tt "} contains two entries - one with key
      {\tt "}850{\tt "} and value {\tt "}1{\tt "}, and the other with key {\tt "}450{\tt "} and value {\tt "}0{\tt "} -
      the {\tt "}850.par1{\tt "} and {\tt "}850.par2{\tt "} entries in the defaults file would be
      renamed as {\tt "}par1{\tt "} and {\tt "}par2{\tt "} (over-writing the original values for
      {\tt "}par1{\tt "} and {\tt "}par2{\tt "}), and the {\tt "}450.par1{\tt "} and {\tt "}450.par2{\tt "} entries would
      be deleted.

      Next, the same process is applied to the user-supplied
      configuration obtained via the specified environment parameter.

      Finally, the values in the user-supplied configuration are used to
      replace those in the defaults file.

      The beneifts of using this function are that 1) the user gets to
      know if they mis-spell a config parameter name, and 2) the default
      parameter values can be defined in a single place, rather than
      hard-wiring them into application code at each place where the
      config parameter is used.
   }
   \sstinvocation{
      AstKeyMap $*$kpg1Config( const char $*$param, const char $*$def,
                             AstKeyMap $*$nested, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         paramc = const char $*$ (Given)
      }{
         The name of the environment parameter to use.
      }
      \sstsubsection{
         def = const char $*$ (Given)
      }{
         The path to a file containing the default value for every allowed config
         parameter. For instance, {\tt "}\$SMURF\_DIR/dimmconfig.def{\tt "}.
      }
      \sstsubsection{
         nested = AstKeyMap $*$ (Given)
      }{
         If non-NULL, used to determine which nested keys might be in the config
         and which should be merged with the base keymap. The values in the keymap
         should be non-zero to indicate merging.
      }
      \sstsubsection{
         status = int $*$ (Given \& Returned)
      }{
         The inherited status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         A pointer to the AST KeyMap, or NULL if an error occurrs.
      }{
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The KeyError attribute is set non-zero in the returned KeyMap so that an error
         will be reported by astMapGet$<$X$>$ if the requested key does not exist in the KeyMap.
      }
   }
}
\sstroutine{
   kpg1Kygp1
}{
   Create a GRP group holding keyword/value pairs read from an AST KeyMap
}{
   \sstdescription{
      This function is the inverse of kpg1Kymp1. It extracts the values
      from the supplied AST KeyMap and creates a set of {\tt "}name=value{\tt "} strings
      which it appends to a supplied group (or creates a new group). If
      the KeyMap contains nested KeyMaps, then the {\tt "}name{\tt "} associated with
      each primitive value stored in the returned group is a hierarchical
      list of component names separated by dots.
   }
   \sstinvocation{
      void kpg1Kygp1( AstKeyMap $*$keymap, Grp $*$$*$igrp, const char $*$prefix,
                      int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         keymap
      }{
         A pointer to the KeyMap. Numerical entries which have bad values
         (VAL\_\_BADI for integer entries or VAL\_\_BADD for floating point
         entries) are not copied into the group.
      }
      \sstsubsection{
         igrp
      }{
         A location at which is stored a pointer to the Grp structure
         to which the name=value strings are to be appended. A new group is
         created and a pointer to it is returned if the supplied Grp
         structure is not valid.
      }
      \sstsubsection{
         prefix
      }{
         A string to append to the start of each key extracted from the
         supplied KeyMap. If NULL, no prefix is used.
      }
      \sstsubsection{
         status
      }{
         Pointer to the inherited status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This function provides a private implementation for the public
         KPG1\_KYGRP Fortran routine and kpg1Kygrp C function.

         \sstitem
         Entries will be stored in the group in alphabetical order
      }
   }
}
\sstroutine{
   kpg1Kymp1
}{
   Create an AST KeyMap holding keyword/value pairs read from a GRP
   group
}{
   \sstdescription{
      This function checks each non-comment, non-blank line in the supplied
      GRP group. An error is reported if any such lines do not have the
      form {\tt "}keyword = value{\tt "}, where the keyword name can be a hierarchical
      list of component names separated by dots. The returned KeyMap has
      an entry for each component name found at the start of any keyword
      name. The value associated with the entry will either be a
      primitive value (if the keyword name contained no other components)
      or another KeyMap (if the keyword name contained other components).

      For example, consider a group containing the following lines:

      gaussclumps.epsilon = (0.001,0.002)
      gaussclumps.contrast = 2.3
      clumpfind.naxis = 2
      clumpfind.deltat = 2.0
      method = gaussclumps

      The returned KeyMap will contain 3 entries with keys {\tt "}gaussclumps{\tt "},
      {\tt "}clumpfind{\tt "} and {\tt "}method{\tt "}. The value associated with the {\tt "}gaussclumps{\tt "}
      entry will be another KeyMap containing keys {\tt "}epsilon{\tt "} (a primitive
      vector entry containing the values 0.001 and 0.002) and {\tt "}contrast{\tt "}
      (a primitive scalar entry with value {\tt "}2.3{\tt "}). The value associated with
      the {\tt "}clumpfind{\tt "} entry will be another KeyMap containing keys {\tt "}naxis{\tt "}
      and {\tt "}deltat{\tt "}, which will have primitive scalar values {\tt "}2{\tt "} and {\tt "}2.0{\tt "}.
      The value associated with the {\tt "}method{\tt "} entry will be the primitive
      scalar value {\tt "}gaussclumps{\tt "}.

      Assigning the value {\tt "}$<$def$>${\tt "} (case insensitive) to a keyword has the
      effect of removing the keyword from the KeyMap. For example:

      $\wedge$global.lis
      method = $<$def$>$

      reads keyword values from the file {\tt "}global.lis{\tt "}, and then ensures
      that the KeyMap does not contain a value for keyword {\tt "}method{\tt "}. The
      calling application should then usually use a default value for
      {\tt "}method{\tt "}.

      Assigning the value {\tt "}$<$undef$>${\tt "} (case insensitive) to a keyword
      has the effect of forcing the value to be undefined. This can
      be useful in defining defaults where the keymap is locked
      after being populated.
   }
   \sstinvocation{
      void kpg1Kymp1( const Grp $*$igrp, AstKeyMap $*$$*$keymap, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         igrp
      }{
         A GRP identifier for the group of text strings to be analysed.
      }
      \sstsubsection{
         keymap
      }{
         A location at which to return a pointer to the new KeyMap, or
         NULL if an error occurs. A valid pointer to an empty KeyMap will be
         returned if the supplied group contains nothing but comments and
         blank lines.
      }
      \sstsubsection{
         status
      }{
         Pointer to the global status variable.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Vector elements should be separated by commas and enclosed within
         parentheses (commas and closing parentheses can be included
         literally in a vector element by preceeding them with a backslash).

         \sstitem
         This function provides a private implementation for the public
         KPG1\_KYMAP Fortran routine and kpg1Kymap C function.

         \sstitem
         Component names must contain only alphanumerical characters,
         underscores, plus and minus signs [a-zA-Z0-9\_$+$$\backslash$-],

         \sstitem
         Any lower case characters contained in a component name will be
         translated to the upper case equivalent.

         \sstitem
         If the last non-blank character in a value is a backslash ({\tt "}$\backslash${\tt "}),
         the backslash will be reomved, together with any white space
         following it, and the entire next line will be appended to the value.
      }
   }
}
\sstroutine{
   kpg1Kymp2
}{
   Parse a {\tt "}keyword = value{\tt "} string for kpg1Kymp1 and add to a KeyMap
}{
   \sstdescription{
      This is a service function for kps1Kymp1. It parses the supplied
      {\tt "}keyword = value{\tt "} string into a keyword and value. It then parses the
      keyword into a list of dot-separated component names. It then adds
      the value into the supplied KeyMap at the correct point.
   }
   \sstinvocation{
      void kpg1Kymp2( const char $*$string, AstKeyMap $*$keymap, int $*$status );
   }
   \sstarguments{
      \sstsubsection{
         string
      }{
         The null-terminated {\tt "}keyword=value{\tt "} string to be parsed.
      }
      \sstsubsection{
         keymap
      }{
         A pointer to the KeyMap in which to store the value.
      }
      \sstsubsection{
         status
      }{
         Pointer to the global status variable.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the value is a comma-separated list of values, enclosed in
         parentheses, then a vector entry will be added to the KeyMap.
         Otherwise, a scalar entry will be created.

         \sstitem
         To include a comma or a closing parenthesis literally in a vector
         value, preceed it with a backslash.

         \sstitem
         If the string has the form {\tt "}keyword=$<$def$>${\tt "} (case insensitive), then
         any entry for the specified keyword is removed from the KeyMap.

         \sstitem
         Component names must contain only alphanumerical characters,
         underscores, plus and minus signs [a-zA-Z0-9\_$+$$\backslash$-],

         \sstitem
         Any lower case characters contained in a component name will be
         translated to the upper case equivalent.
      }
   }
}
\sstroutine{
   kpgGtfts
}{
   Obtain FITS header information from an NDF
}{
   \sstdescription{
      The routine reads the FITS extension from an NDF and returns an
      AST pointer to a FitsChan which contains this information. The
      information may then be accessed using routines from the AST
      library (SUN/211).
   }
   \sstinvocation{
      kpgGtfts( int indf, AstFitsChan $*$$*$ fchan, int $*$ status );
   }
   \sstarguments{
      \sstsubsection{
         indf = int (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         fchan = AstFitsChan $*$$*$ (Returned)
      }{
         An AST pointer to a FitsChan which contains information about
         the FITS headers associated with the NDF.
      }
      \sstsubsection{
         status = int $*$ (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         It is the caller{\tt '}s responsibility to annul the AST pointer
         issued by this routine (e.g. by calling AST\_ANNUL) when it is no
         longer required.

         \sstitem
         If this routine is called with STATUS set, then a value of
         AST\_\_NULL will be returned for the FCHAN argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason.

         \sstitem
         Status is set to KPG\_\_NOFTS if no FITS extension is found.
      }
   }
   \sstdiytopic{
      Return Value
   }{
      Returns the status.
   }
}
\sstroutine{
   kpgPtfts
}{
   Store FITS header information into an NDF
}{
   \sstdescription{
      The routine stores the contents of an AST FitsChan into an
      NDF by creating (or replacing) the FITS extension in the NDF.
   }
   \sstinvocation{
      kpgPtfts( int indf, AstFitsChan $*$ fchan, int $*$ status );
   }
   \sstarguments{
      \sstsubsection{
         indf = int (Given)
      }{
         Identifier of NDF to receive the .FITS extension.
      }
      \sstsubsection{
         fchan = const AstFitsChan $*$ (Given)
      }{
         An AST pointer to a FitsChan which contains information about
         the FITS header to be associated with the NDF.
      }
      \sstsubsection{
         status = int $*$ (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a .MORE.FITS extension already exists it will be completely
         replaced by this routine.
      }
   }
   \sstdiytopic{
      Return Value
   }{
      Returns the status.
   }
}

\normalsize

\end{document}
