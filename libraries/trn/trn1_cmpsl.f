      SUBROUTINE TRN1_CMPSL( LOCTR, FORWD, SLOT, CTTI, CTTL, CTTC,
     :                       STATUS )
*+
*  Name:
*     TRN1_CMPSL

*  Purpose:
*     Compile an entry for a slot in the CTT.

*  Language:
*     Starlink Fortran

*  Invocation:
*     CALL TRN1_CMPSL( LOCTR, FORWD, SLOT, CTTI, CTTL, CTTC, STATUS )

*  Description:
*     The routine compiles a transformation passed by HDS locator and
*     containing any number of modules.  Information generated by the
*     compilation is entered into a slot in the compiled transformation
*     table (CTT), where it either extends an existing compiled module
*     list (CML) or creates a new one.

*  Copyright:
*     Copyright (C) 1988, 1992 Science & Engineering Research Council.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful,but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
*     02110-1301, USA

*  Authors:
*     RFWS: R.F. Warren-Smith (STARLINK, RAL)
*     {enter_new_authors_here}

*  History:
*     5-FEB-1988 (RFWS):
*        Original version called TRN1_CMPTR.
*     9-FEB-1988 (RFWS):
*        Changed temporary structure handling.
*     9-FEB-1988 (RFWS):
*        Renamed as TRN1_CMPSL.
*     12-FEB-1988 (RFWS):
*        Added error handling.
*     16-FEB-1988 (RFWS):
*        Removed much of the code to TRN1_EXCML.
*     26-FEB-1988 (RFWS):
*        Revised error handling.
*     9-MAY-1988 (RFWS):
*        Added CTT classification array.
*     13-FEB-1992 (RFWS):
*        Added handling of character string length when passing mapped
*        values (for Unix compatibility).
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-


*  Type Definitions:
      IMPLICIT NONE             ! No implicit typing


*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'CNF_PAR'          ! For CNF_PVAL function
      INCLUDE 'DAT_PAR'          ! DAT_ public constants
      INCLUDE 'TRN_PAR'          ! TRN_ public constants
      INCLUDE 'TRN_CONST'        ! TRN_ private constants


*  Global Variables:
      INCLUDE 'TRN_CMN'         ! TRN_ common blocks

*  Arguments Given:
      CHARACTER * ( * ) LOCTR   ! Locator to transformation structure
      LOGICAL FORWD             ! Select forward/inverse transformation
      INTEGER SLOT              ! Slot to use in CTT


*  Arguments Given and Returned:
      INTEGER CTTI( TRN_CT_NITEM, TRN_SZCTT )
                                ! CTT integer array
      CHARACTER * ( * ) CTTL( TRN_SZCTT )
                                ! CTT locator list
      LOGICAL CTTC( TRN__MXCLS, TRN_SZCTT )
                                ! CTT classification array list


*  Arguments Returned:
*     <declarations and descriptions for exported arguments>


*  Status:
      INTEGER STATUS            ! Error status


*  External References:
*     <declarations for external function references>


*  Local Constants:
*     <local constants defined by PARAMETER>


*  Local Variables:
      INTEGER NMOD              ! Number of modules to be compiled
      INTEGER NEWSIZ            ! Number of modules after compilation
      CHARACTER * ( DAT__SZLOC ) LOCMA
                                ! Locator to MODULE_ARRAY structure


*  Internal References:
*     <declarations for internal functions>


*  Local Data:
*     <any DATA initialisations for local variables>


*.



*  Check status.
      IF( STATUS .NE. SAI__OK ) RETURN


*  Locate the MODULE_ARRAY object within the transformation structure
*  and determine its size, giving the number of modules to be
*  compiled.
      CALL DAT_FIND( LOCTR, 'MODULE_ARRAY', LOCMA, STATUS )
      CALL DAT_SIZE( LOCMA, NMOD, STATUS )
      CALL DAT_ANNUL( LOCMA, STATUS )


*  Calculate the number of modules there will be in the transformation
*  after the compilation and extend the CML in the selected CTT slot to
*  accommodate them (this will create a new CML if its current size is
*  zero).
      NEWSIZ = CTTI( TRN_CT_NMOD, SLOT ) + NMOD
      CALL TRN1_EXCML( NEWSIZ, CTTI( 1, SLOT ), CTTL( SLOT ),
     :                 CTTC( 1, SLOT ), STATUS )


*  Compile the transformation, putting information about the compiled
*  modules into the newly created positions in the CML. Values
*  requiring only a single integer value are held directly in the CTT.
*  (Note we call a dummy routine to permute the argument order to
*  permit the passing of mapped character values with an appropriate
*  trailing length argument for Unix compatibility.)
      CALL TRN1_XCMPTR( %VAL( CNF_PVAL( CTTI( TRN_CT_PLOCM, SLOT ) ) ),
     :                  FORWD, NEWSIZ, CTTI( TRN_CT_NMOD, SLOT ) + 1,
     :                  NMOD, LOCTR,
     :                  %VAL( CNF_PVAL( CTTI( TRN_CT_PPIND, SLOT ) ) ),
     :                  %VAL( CNF_PVAL( CTTI( TRN_CT_PNVAR, SLOT ) ) ),
     :                  %VAL( CNF_PVAL( CTTI( TRN_CT_PIPRC, SLOT ) ) ),
     :                  CTTI( TRN_CT_MXWRK, SLOT ), CTTC( 1, SLOT ),
     :                  STATUS, %VAL( CNF_CVAL( DAT__SZLOC ) ) )

*  If there is no error, increment the CCT entry for the number of
*  modules in the CML.
      IF( STATUS .EQ. SAI__OK ) CTTI( TRN_CT_NMOD, SLOT ) = NEWSIZ


*  If there are still no compiled modules in the CML (because of an
*  error), delete the temporary structure which may have been created
*  to hold the CML.
      IF( CTTI( TRN_CT_NMOD, SLOT ) .EQ. 0 )
     :  CALL TRN1_RELTS( 1, CTTL( SLOT ), STATUS )


*  Exit routine.
      END

*  Dummy routine to permute argument order when passing mapped character
*  values to TRN1_CMPTR.
      SUBROUTINE TRN1_XCMPTR( LOCCM, FORWD, SZCML, IFIRST, NMOD, LOCTR,
     :                        PINDX, NVAR, IPRC, MXWRK, CLASS, STATUS )

      IMPLICIT NONE
      INCLUDE 'TRN_PAR'

      INTEGER SZCML
      CHARACTER * ( * ) LOCCM( SZCML )
      LOGICAL FORWD
      INTEGER IFIRST
      INTEGER NMOD
      CHARACTER * ( * ) LOCTR
      INTEGER PINDX( SZCML )
      INTEGER NVAR( SZCML + 1 )
      INTEGER IPRC( SZCML )
      INTEGER MXWRK
      LOGICAL CLASS( TRN__MXCLS )
      INTEGER STATUS

      CALL TRN1_CMPTR( LOCTR, FORWD, SZCML, IFIRST, NMOD, LOCCM,
     :                 PINDX, NVAR, IPRC, MXWRK, CLASS, STATUS )

      END
