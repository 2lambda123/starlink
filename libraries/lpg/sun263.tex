\documentclass[twoside,11pt]{starlink}

% ? Specify used packages
% ? End of specify used packages

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\stardoccategory    {Starlink User Note}
\stardocinitials    {SUN}
\stardocsource      {sun\stardocnumber}
\stardoccopyright
{Copyright \copyright\ 2009 Science and Technology Facilities Council.}

% Variable part - replace [xxx] as appropriate.
\stardocnumber      {263.1}
\stardocauthors     {Malcolm J. Currie\\D.S.\ Berry}
\stardocdate        {2009 August 16}
\stardoctitle       {LPG --- Loop processing of groups}
\stardocversion     {Version 3.0}
\stardocmanual      {Programmer's Manual}
\stardocabstract  {
This document describes the routines provided within the LPG subroutine
library for looping of monolith tasks to process a group of catalogues or NDFs
in sequence.
}
% ? End of document identification
% -----------------------------------------------------------------------------
% ? Document specific \providecommand or \newenvironment commands.

% Command for displaying routines in routine lists:
% =================================================

\providecommand{\noteroutine}[2]{{\small \textbf{#1}} \\
                              \hspace*{3em} \emph{#2} \\[1.5ex]}

\providecommand{\KAPPA}{{\footnotesize KAPPA}\normalsize}
\providecommand{\KAPPAref}{\xref{{\KAPPA}}{sun95}{}}
% ? End Document specific \providecommand or \newenvironment commands.

\begin{document}
\scfrontmatter

\section {Introduction}

When an application prompts the user for a catalogue or NDF using the
facilities of the CAT (see \xref{SUN/181}{sun181}{}) or NDF (see
\xref{SUN/33}{sun33}{}) libraries, the user may only reply with the
name of a single catalogue or NDF respectively.  If the user has many
files to process in the same fashion, it can prove tedious to repeat
the commands for each input dataset.  Now one solution is to write a
script that loops, executing the various applications for each input
file.  More elegant and convenient to users would be to allow a
\emph{group} of files to be processed in a single command.  This is
what LPG offers.  The group or list is supplied to the relevant ADAM
parameter, possibly defined using wildcards.  Using LPG enhances your
application package to users.

Note the r\^{o}le of LPG is different from \xref{NDG}{sun2}{} or
\xref{CTG}{sun262}{} libraries.  While these supply groups of NDFs and
catalogues, again with wildcards (via the underlying
\xref{GRP}{sun150}{} library) these are processed in the \emph{same
invocation} of an application. Examples of this method include forming
a flat field from a series of CCD image NDFs, and merging catalogues.

\section {Interaction Between LPG and GRP}

LPG uses the facilities of the \xref{GRP}{sun150}{} package and
programmers incorporating LPG should be familiar with the content of
\xref{SUN/150}{sun150}{} which describes the GRP package.
Examples of the GRP wildcards and indirection through text files
are presented in \xref{SUN/95}{sun95}{se_multinvoc}, and in addition
advice for users.

\newpage
\section{Using LPG}

To introduce the looping facility into an applications package
a number of steps are required.  These affect the monolith routine,
individual applications and possibly their interface files, and
documentation.

\subsection{Monolith}

You must modify both the monolith to loop.  The basic arrangement is
shown below.

\begin{small}
\begin{terminalv}
*  External References:
      LOGICAL LPG_AGAIN           ! Invoke the application again?

           :           :           :           :           :

*  Obtain the command from the environment.  This returns uppercase
*  names.
      CALL TASK_GET_NAME( ACTION, STATUS )

*  Initialise the common blocks used to control multiple invocation of
*  applications to process lists of NDFs or catalogues.
      CALL LPG_START( VERB, DELAY, DISAB, STATUS )

*  Loop round invoking the task for each set of NDFS or catalogues
*  specified by the user.
      DO WHILE ( LPG_AGAIN( STATUS ) )

         IF ( ACTION .EQ. 'ADD' ) THEN
            CALL ADD( STATUS )

         ELSE IF ( ACTION .EQ. 'BIND' ) THEN
            CALL BIND( STATUS )

         ELSE IF...
            ...
         END IF
      END DO
\end{terminalv}
\end{small}

LPG\_AGAIN returns \texttt{.TRUE.} value until the list of data files is
exhausted.

The additional code is the \htmlref{LPG\_START}{LPG_START} call, the
testing of \htmlref{LPG\_AGAIN}{LPG_AGAIN} for any further files to
process in a DO WHILE \ldots END DO loop (or use IF .. END IF with a
GOTO if you prefer), and the declaration of LPG\_AGAIN.

\subsection{Tuning}

LPG\_START has three tuning arguments.

\begin{itemize}

\item
VERB set to \texttt{.TRUE.} causes multi-valued parameters (\emph{i.e.}
ones for accessing data files) to report their value at each
invocation; in essence this presents the names of the data file at
each invocation.  Single-valued parameters are not shown.  Set

\item
A pause of DELAY seconds occurs betwen invocations for each NDF or
catalogue.

\item
DISAB set to \texttt{.TRUE.} disables the looping.  Thus LPG\_AGAIN
would only return \texttt{.TRUE.} at the first invocation.  Thus the
package behaves as if LPG looping was not present.
The application corresponding to the required action will always be
invoked at least once.

These tuning options are best controlled through environment variables
accessed in the monolith.  For example, \KAPPAref\ invokes
\xref{KAPLIBS}{sun238}{} calls

\begin{small}
\begin{terminalv}
*  See if NDF names should be reported when looping.
      CALL KPG1_ENVDF( 'KAPPA_REPORT_NAMES', VERB, STATUS )

*  See if looping should be disabled.
      CALL KPG1_ENVDF( 'KAPPA_LOOP_DISABLE', DISAB, STATUS )

*  See if a delay should be included between invocations.
      DELAY = 0.0
      CALL KPG1_ENV0R( 'KAPPA_LOOP_DELAY', DELAY, STATUS )
\end{terminalv}
\end{small}

where \xref{KPG1\_ENVDF}{sun238}{KPG1_ENVDF} inquires whether an environment
variable is defined or not, and \xref{KPG1\_ENV0R}{sun238}{KPG1_ENV0x}
obtains a floating-point value, but using the default of 0.0 seconds
should \texttt{KAPPA\_LOOP\_DELAY} be undefined.

\end{itemize}

There is a further tuning possibility.  Some users like to be able
supply the same data for output as input, although this is potentially
hazardous.  Here is another extract from \KAPPA\ showing how this
is switched using \htmlref{LPG\_REPLA}{LPG_REPLA}.

\begin{small}
\begin{terminalv}
*  See if input NDFs are allowed to be overwritten by output NDFs.
      CALL KPG1_ENVDF( 'KAPPA_REPLACE', REPL, STATUS )
      CALL LPG_REPLA( REPL, STATUS )
\end{terminalv}
\end{small}
Variable REPL is boolean.  The environment variable need just have a
value, any value for this switch to be enabled.


\subsection{Applications}

The applications should use the routines \htmlref{LPG\_ASSOC}{LPG_ASSOC},
\htmlref{LPG\_PROP}{LPG_PROP}, \htmlref{LPG\_CREAT}{LPG\_CREAT},
and \latex{\linebreak}\htmlref{LPG\_CREP}{LPG_CREP} to get identifier for NDFs, in
place of the corresponding routines (\emph{i.e.} replace LPG with NDF in
the names) from the \xref{NDF library}{sun33}{}.

For catalogues, routines \htmlref{LPG\_CATASSOC}{LPG_CATASSOC} and
\htmlref{LPG\_CATCREAT}{LPG_CATCREAT} should be
used in place of \xref{CAT\_ASSOC}{sun181}{CAT_ASSOC} and
\xref{CAT\_CREAT}{sun181}{CAT_CREAT}.

On the first invocation of the application, groups of data files are
obtained whenever one of the above LPG routines is used to get an NDF
or CAT identifier, and an identifier corresponding to the first name in
each group is returned to the application.  On subsequent invocations,
the names in the groups obtained during the first invocation are used
without obtaining new parameter values from the environment.  The
index of the returned data file within each group is incremented by 1
each time the application is invoked.

\subsection{Other Parameters}

If an application is invoked more than once, all other parameters
retain the values they had at the end of the first invocation.
Applications that use this scheme should avoid having parameters with
\texttt{VPATH=DYNAMIC} in the \xref{interface
file}{sun115}{the_vpath_field}\latex{ (described in SUN/115)}, since
the dynamic default calculated on the first invocation will then be
re-used for all subsequent invocations; that may be inappropriate.  A
better scheme is to have \texttt{VPATH=DEFAULT}, \xref{
\texttt{PPATH=DYNAMIC}}{sun115}{the_ppath_field} and \xref{
\texttt{DEFAULT=!}}{sun115}{the_default_field}.  The code should then annul
any \texttt{PAR\_\_NULL} status after accessing the parameter, and use
the previously calculated dynamic default value for the parameter.  In
this scheme, the parameter value is \texttt{!} at the end of the first
invocation, and so retains this value for all subsequent invocations,
resulting in appropriate dynamic defaults being used.

A situation in which the above suggestion does not work is if an
application sometimes sets a dynamic default, and sometimes does not.
In this case, you do not want to have \texttt{VPATH=DEFAULT},
\texttt{DEFAULT=!} because this would require the application to abort in the
cases where there is no dynamic default available.  It is probably
better in these cases to have \texttt{VPATH=PROMPT}, \texttt{PPATH=DYNAMIC}
and accept the fact that the user will be prompted for a parameter
that was previously defaulted.

Some applications test to see if a parameter was specified on the
command line, and vary their behaviour accordingly.  This is achieved
by checking the state of the parameter before accessing it, a state of
\texttt{PAR\_\_ACTIVE} (or \texttt{SUBPAR\_\_ACTIVE}) indicating that the
parameter already has a value.  This is correct on the first
invocation, but not on subsequent invocations because the first
invocation may have set a parameter value, resulting in subsequent
invocations thinking that the parameter was given on the command
line.  To avoid this, applications should call
\htmlref{LPG\_STATE}{LPG_STATE} in place of
\xref{PAR\_STATE}{sun114}{PAR_STATE}.  LPG\_STATE remembers the state of
the parameter on the first invocation, and returns that state, rather
than the current parameter state, on subsequent invocations.  The
arguments are the same.

\subsection{Output Parameters}

One disadvantage of LPG is that any parameters written by the
application, such the results of some analysis or statistics,
will only record the values for the \emph{last} data file processed.

\section {Compiling and Linking with LPG}

This section describes how to compile and link applications that use
LPG subroutines, on UNIX systems. It is assumed that the LPG library
is installed as part of the Starlink Software Collection.

The library only has an ADAM interface to obtain the groups of
catalogues.

\subsection{\label{ss:buildingadamapplications}ADAM Applications}
Users of the \xref{ADAM}{sg4}{} programming environment
(SG/4) should use
the \xref{\textbf{alink}}{sun144}{ADAM_link_scripts} command
(\xref{SUN/144}{sun144}{}) to compile and link applications, and can
access the LPG\_ library by including execution of the command
\texttt{lpg\_link\_adam} on the command line, as follows:

\begin{small}
\begin{terminalv}
% alink prog.f `lpg_link_adam`
\end{terminalv}
\end{small}

where \texttt{prog.f} is the Fortran source file for the A-TASK. Again
note the use of opening apostrophies (`) instead of the more usual
closing apostrophy (') in the above \textbf{alink} command.

To build a program written in C (instead of Fortran), simply name the
source file \texttt{prog.c}, instead of \texttt{prog.f}.

\newpage
\appendix

\section{List of Routines}

\noteroutine{RESULT = LPG\_AGAIN( STATUS )}
   {Decide if the application should be executed again.}
\noteroutine{CALL LPG\_ASSOC( PARAM, MODE, INDF, STATUS )}
   {Obtain an identifier for an existing NDF via the parameter system.}
\noteroutine{CALL LPG\_CATASSOC( PARAM, MODE, CI, STATUS )}
   {Obtain an identifier for an existing catalogue via the parameter system.}
\noteroutine{CALL LPG\_CATCREAT( PARAM, CI, STATUS )}
   {Creat a new catalogue via the parameter system.}
\noteroutine{CALL LPG\_CREA1( PARAM, FTYPE, NDIM, LBND, UBND, INDF, NAME, STATUS~)}
   {Create a single new simple NDF using a specified parameter.}
\noteroutine{CALL LPG\_CREAT( PARAM, FTYPE, NDIM, LBND, UBND, INDF, STATUS )}
   {Create a new simple NDF via the parameter system.}
\noteroutine{CALL LPG\_CREP1( PARAM, FTYPE, NDIM, UBND, INDF, NAME, STATUS )}
   {Create a single new primitive NDF using a specified parameter.}
\noteroutine{CALL LPG\_CREP( PARAM, FTYPE, NDIM, UBND, INDF, STATUS )}
   {Create a new primitive NDF via the parameter system.}
\noteroutine{CALL LPG\_CRPL1( PARAM, PLACE, NAME, STATUS )}
   {Create a single new NDF placeholder using a specified parameter}
\noteroutine{CALL LPG\_PROP1( INDF1, CLIST, PARAM, INDF2, NAME, STATUS )}
   {Create a single new NDF by propagation using a specified parameter.}
\noteroutine{CALL LPG\_PROP( INDF1, CLIST, PARAM, INDF2, STATUS )}
   {Propagate NDF information to create a new NDF via the parameter system.}
\noteroutine{CALL LPG\_REPLA( REPLAC, STATUS )}
   {Indicate if input NDFs can be replaced.}
\noteroutine{CALL LPG\_START( VERBO, DELAYO, DISABO, STATUS )}
   {Initialise the contents of the LPG common blocks.}
\noteroutine{CALL LPG\_STATE( PARAM, STATE, STATUS )}
   {Return the original PAR state of a parameter.}

\newpage
\section{Full Fortran Routine Specifications}
\label {SEC:FULLSPEC}

% Routine descriptions:
% =====================

\sstroutine{
   LPG\_AGAIN
}{
   Decide if the application should be executed again
}{
   \sstdescription{
      This routine is used to allow multiple invocations of an
      application within an Starlink monolith to process a group of data
      files. The initialization routine \htmlref{LPG\_START}{LPG_START}
      should be called prior to this routine.  This routine returns a
      logical flag indicating if the application should be invoked again.
      A typical way to use this routine within a monolith is as follows:

      \texttt{\begin{tabbing}
      ABC\=DEF\=GHI\=                            \kill
         \> CALL LPG\_START( VERB, DELAY, DISAB, STATUS )\\
         \> DO WHILE ( LPG\_AGAIN( STATUS ) ) \\
         \>   \> IF ( ACTION .EQ. 'ADD' ) THEN \\
         \>   \>   \> CALL ADD( STATUS ) \\
         \>   \>   ELSE IF ( ACTION .EQ. 'SUB' ) THEN \\
         \>   \>    \>     CALL SUB( STATUS ) \\
         \>   \>   ELSE IF... \\
         \>   \>    \>   ... \\
         \>   \>   END IF \\
         \> END DO \\
      \end{tabbing}}

      The application corresponding to the required action will always be
      invoked once.  The applications should use the routines
      \htmlref{LPG\_ASSOC}{LPG_ASSOC}, \htmlref{LPG\_PROP}{LPG_PROP},
      \htmlref{LPG\_CREAT}{LPG_CREAT} and \htmlref{LPG\_CREP}{LPG_CREP} to get
      identifiers for NDFs, in place of their equivalent routines from the
      NDF library.

      For catalogues, routines \htmlref{LPG\_CATASSOC}{LPG_CATASSOC} and
      \htmlref{LPG\_CATCREAT}{LPG_CATCREAT} should be used in place of
      \xref{CAT\_ASSOC}{sun181}{CAT_ASSOC} and
      \xref{CAT\_CREAT}{sun181}{CAT_CREAT}.

      LPG\_AGAIN returns a \texttt{.TRUE.} value until a group of data files is
      exhausted, whereupon it deletes all its groups and returns a
      \texttt{.FALSE.} value.

      On the first invocation of the application, groups of data files are
      obtained whenever one of the above LPG routines is used to get an NDF
      or CAT identifier, and an identifier corresponding to the first name in
      each group is returned to the application. On subsequent invocations,
      the names in the groups obtained during the first invocation are used
      without obtaining new parameter values from the environment. The
      index of the returned data file within each group is increment by 1
      each time the application is invoked.

      If an application is invoked more than once, all other
      parameters retain the values they had at the end of the first
      invocation. Applications that use this scheme should avoid
      having parameters with \texttt{"VPATH=DYNAMIC"} in the interace
      file, since the dynamic default calculated on the first
      invocation will then be re-used for all subsequent invocations,
      which may be inappropriate. A better scheme is to have
      \texttt{"VPATH=DEFAULT"}, \texttt{"PPATH=DYNAMIC"} and \texttt{"DEFAULT=!"}.
      The code should then annul any PAR\_\_NULL status after
      accessing the parameter, and use the previously calculated
      dynamic default value for the parameter. With this scheme, the
      parameter value is \texttt{"!"} at the end of the first invocation,
      and so retains this value for all subsequent invocations,
      resulting in appropriate dynamic defaults being used.

      A situation in which the above suggestion does not work is if an
      application sometimes sets a dynamic default, and sometimes
      does not. In this case, you do not want to have
      \texttt{VPATH=DEFAULT}, \texttt{DEFAULT=!} because this would require the
      application to abort in the cases where there is no dynamic default
      available. It is probably better in these cases to have
      \texttt{VPATH=PROMPT},\texttt{PPATH=DYNAMIC} and accept the fact that the user
      will be prompted for a parameter that was previously defaulted.

      Some applications test to see if a parameter was specified on the
      command line, and vary their behaviour accordingly. This is done by
      checking the state of the parameter before accessing it, a state of
      PAR\_\_ACTIVE (or SUBPAR\_\_ACTIVE) indicating that the parameter
      already has a value. This is correct on the first invocation, but not
      on subsequent invocations because the first invocation may have set a
      parameter value, resulting in subsequent invocations thinking that
      the parameter was given on the command line. To avoid this,
      applications should use LPG\_STATE in place of PAR\_STATE.
      LPG\_STATE remembers the state of the parameter on the first
      invocation, and returns that state, rather than the current
      parameter state, on subsequent invocations.
   }
   \sstinvocation{
      RESULT = LPG\_AGAIN( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         LPG\_AGAIN = LOGICAL
      }{
         This is \texttt{.TRUE.} if the application should be executed again.
      }
   }
}
\sstroutine{
   LPG\_ASSOC
}{
   Obtain an identifier for an existing NDF via the parameter system
}{
   \sstdescription{
      This routine should be called in place of \xref{NDF\_ASSOC}{sun33}{NDF_ASSOC}
      within applications that process groups of NDFs.

      On the first invocation of the application, a group of names of
      existing NDFs will be obtained from the environment using the
      specified parameter, and an NDF identifier for the first one
      will be returned. If more than one NDF was supplied for the
      parameter then the application may be invoked again (see
      \htmlref{LPG\_AGAIN}{LPG_AGAIN}), in which case this routine will
      return an identifier for the next NDF in the group supplied on
      the first invocation.

      If an application attempts to get a new NDF by cancelling the
      parameter (\xref{PAR\_CANCL}{sun114}{PAR_CANCL}), the returned NDF
      is \emph{NOT} the next one in the group, but is obtained by prompting
      the user for a single NDF.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its NDF parameters have been
      exhausted (\emph{i.e.} all its values used). See LPG\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_ASSOC( PARAM, MODE, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of NDF access required: \texttt{'READ'}, \texttt{'UPDATE'} or \texttt{'WRITE'}.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CATASSOC
}{
   Obtain an identifier for an existing catalogue via the parameter system
}{
   \sstdescription{
      This routine should be called in place of \xref{CAT\_ASSOC}{sun181}{CAT_ASSOC}
      within applications that process groups of catalogues.

      On the first invocation of the application, a group of names of
      existing catalogues will be obtained from the environment using the
      specified parameter, and a CAT identifier for the first one
      will be returned. If more than one catalogue was supplied for the
      parameter then the application may be invoked again (see
      \htmlref{LPG\_AGAIN}{LPG\_AGAIN}), in which case this routine will
      return an identifier for the next catalogue in the group supplied
      on the first invocation.

      If an application attempts to get a new catalogue by cancelling the
      parameter (\xref{PAR\_CANCL}{sun114}{PAR_CANCL}), the returned
      catalogue is \texttt{NOT} the next one in the group, but is obtained
      by prompting the user for a single catalogue.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its catalogue parameters have been
      exhausted (\emph{i.e.} all its values used). See LPG\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_CATASSOC( PARAM, MODE, CI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of catalogue access required: \texttt{'READ'}, or \texttt{'WRITE'}.
      }
      \sstsubsection{
         CI = INTEGER (Returned)
      }{
         The catalogue identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CATCREAT
}{
   Create a new catalogue via the parameter system
}{
   \sstdescription{
      This routine should be called in place of \xref{CAT\_CREAT}{sun181}{CAT_CREAT} within
      applications that process lists of catalogues.

      On the first invocation of the application, a group of names for
      some new catalogues will be obtained from the environment using the
      specified parameter. The first name will be used to create an
      catalogue with the requested attributes, and an identifier for the
      new catalogue will be returned. If more than one name was supplied
      for the parameter then the application may be invoked again (see
      \htmlref{LPG\_AGAIN}{LPG_AGAIN}), in which case this routine will
      return an identifier for a new catalogue with the next name in the
      group supplied on the first invocation.

      If a modification element is included in the group expression
      supplied for the parameter on the first invocation of the
      application, the new catalogue names are based on the names of the
      first group of existing data files (catalogues or NDFs) to be
      accessed by the application.

      If an application attempts to get a new catalogue by cancelling the
      parameter (\xref{PAR\_CANCL}{sun114}{PAR_CANCL}), the name used to
      create the returned catalogue is \emph{NOT} the next one in the group, but
      is obtained by prompting the user for a single new catalogue.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its catalogue parameters have been
      exhausted (\emph{i.e.} all its values used). See LPG\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_CATCREAT( PARAM, CI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter.
      }
      \sstsubsection{
         CI = INTEGER (Returned)
      }{
         The catalogue identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CREA1
}{
   Create a single new simple NDF using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to \xref{NDF\_CREAT}{sun33}{NDF_CREAT}
      except that it allows the NDF to be specified using a
      \xref{GRP}{sun150}{} group expression (for instance, its name may
      be given within a text file, \emph{etc.}). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Any modification elements in the supplied
      group expression will be treated literally.
   }
   \sstinvocation{
      CALL LPG\_CREA1( PARAM, FTYPE, NDIM, LBND, UBND, INDF, NAME, STATUS~)
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the NDF's DATA component (e.g. \texttt{'\_DOUBLE'} or
         \texttt{'COMPLEX\_REAL'}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CREAT
}{
   Create a new simple NDF via the parameter system
}{
   \sstdescription{
      This routine should be called in place of
      \xref{NDF\_CREAT}{sun33}{NDF_CREAT} within applications which
      process lists of NDFs.

      On the first invocation of the application, a group of names for
      some new NDFs will be obtained from the environment using the
      specified parameter. The first name will be used to create an NDF
      with the requested attributes, and an identifier for the new NDF
      will be returned. If more than one name was supplied for the
      parameter then the application may be invoked again (see
      \htmlref{LPG\_AGAIN}{LPG_AGAIN}), in which case this routine will
      return an identifier for a new NDF with the next name in the group
      supplied on the first invocation.

      If a modification element is included in the group expression
      supplied for the parameter on the first invocation of the
      application, the new NDF names are based on the names of the
      first group of existing data files (NDFs or catalogues) to be
      accessed by the application.

      If an application attempts to get a new NDF by cancelling the
      parameter (\xref{PAR\_CANCL}{sun114}{PAR_CANCL}), the name used to
      create the returned NDF is\emph{NOT} the next one in the group, but is
      obtained by prompting the user for a single new NDF.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its NDF parameters have been
      exhausted (\emph{i.e.} all its values used). See LPG\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_CREAT( PARAM, FTYPE, NDIM, LBND, UBND, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the NDF's DATA component (e.g. \texttt{'\_DOUBLE'} or
         \texttt{'COMPLEX\_REAL'}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CREP1
}{
   Create a single new primitive NDF using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to \xref{NDF\_CREP}{sun33}{NDF_CREP} except
      that it allows the NDF to be specified using a
      \xref{GRP}{sun150}{} group expression (for instance, its
      name may be given within a text file, \emph{etc.}). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Any modification elements in the supplied
      group expression will be treated literally.
   }
   \sstinvocation{
      CALL LPG\_CREP1( PARAM, FTYPE, NDIM, UBND, INDF, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of the NDF's DATA component (e.g. \texttt{'\_REAL'}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CREP
}{
   Create a new primitive NDF via the parameter system
}{
   \sstdescription{
      This routine should be called in place of \xref{NDF\_CREP}{sun33}{NDF_CREP}
      within applications that process lists of NDFs.

      On the first invocation of the applicaton, a group of names for
      some new NDFs will be obtained from the environment using the
      specified parameter. The first name will be used to create an NDF
      with the requested attributes, and an identifier for the new NDF will
      be returned. If more than one name was supplied for the parameter
      then the application may be invoked again (see LPG\_AGAIN), in which
      case this routine will return an identifier for a new NDF with the
      next name in the group supplied on the first invocation.

      If a modification element is included in the group expression
      supplied for the parameter on the first invocation of the
      application, the new NDF names are based on the names of the
      first group of existing data files (NDFs or catalogues) to be
      accessed by the application.

      If an application attempts to get a new NDF by cancelling the
      parameter (PAR\_CANCL), the name used to create the returned NDF is
      NOT the next one in the group, but is obtained by prompting the
      user for a single new NDF.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its NDF parameters have been
      exhausted (i.e. all its values used). See NDF\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_CREP( PARAM, FTYPE, NDIM, UBND, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of the NDF\texttt{'}s DATA component (e.g. \texttt{'}\_REAL\texttt{'}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CREPL
}{
   Create a new NDF placeholder via the parameter system
}{
   \sstdescription{
      This routine should be called in place of NDF\_CREPL within
      applications that process lists of NDFs.

      On the first invocation of the application, a group of names for
      some new NDFs will be obtained from the environment using the
      specified parameter. The first name will be used to create an NDF
      placeholder with the requested attributes, and an identifier for the
      placeholder will be returned. If more than one name was supplied for
      the parameter then the application may be invoked again (see
      LPG\_AGAIN), in which case this routine will return an identifier
      for another placeholder with the next name in the group supplied on
      the first invocation.

      If a modification element is included in the group expression
      supplied for the parameter on the first invocation of the
      application, the placeholder are based on the names of the
      first group of existing data files (NDFs or catalogues) to be
      accessed by the application.

      If an application attempts to get a new NDF by cancelling the
      parameter (PAR\_CANCL), the name used to create the returned NDF is
      NOT the next one in the group, but is obtained by prompting the
      user for a single new placeholder.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its NDF parameters have been
      exhausted (i.e. all its values used). See LPG\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_CREPL( PARAM, PLACE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter.
      }
      \sstsubsection{
         PLACE = INTEGER (Returned)
      }{
         NDF placeholder identifying the nominated position in the
         data system.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_PROP1
}{
   Create a single new NDF by propagation using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to \xref{NDF\_PROP}{sun33}{NDF_PROP}
      except that it allows the NDF to be specified using a
      \xref{GRP}{sun150}{} group expression (for instance, its name
      may be given within a text file, \emph{etc.}). The first NDF in
      the group expression is returned. Any other names in the group
      expression are ignored. Modification elements use the name of
      the supplied NDF as the basis name.
   }
   \sstinvocation{
      CALL LPG\_PROP1( INDF1, CLIST, PARAM, INDF2, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the NDF components which are to be
         propagated to the new data structure. By default, the HISTORY,
         LABEL and TITLE components and all extensions are propagated.
         See \latex{the} \xref{\texttt{"}Component
         Propagation\texttt{"}}{sun33}{ndf_prop_component_propagation}
         \latex{section in the documentation for routine NDF\_PROP within
         SUN/33} for further details.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter for the new NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_PROP
}{
   Propagate NDF information to create a new NDF via the
   parameter system
}{
   \sstdescription{
      This routine should be called in place of \xref{NDF\_PROP}{sun33}{NDF_PROP}
      within applications that process groups of NDFs.

      On the first invocation of the application, a group of names for
      some new NDFs will be obtained from the environment using the
      specified parameter. The first name will be used to create an
      NDF by propagation from INDF1, and an identifier for the new NDF
      will be returned. If more than one name was supplied for the
      parameter then the application may be invoked again (see
      \htmlref{LPG\_AGAIN}{LPG_AGAIN}), in which case this routine
      will return an identifier for a new NDF with the next name in
      the group supplied on the first invocation.

      If a modification element is included in the group expression
      supplied for the parameter on the first invocation of the
      application, the new NDF names are based on the names of the
      first group of existing data files (NDFs or catalogues) to be
      accessed by the application.

      If an application attempts to get a new NDF by cancelling the
      parameter (\xref{PAR\_CANCL}{sun114}{PAR_CANCL}), the name used
      to create the returned NDF is \emph{NOT} the next one in the
      group, but is obtained by prompting the user for a single new
      NDF.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its NDF parameters have been
      exhausted (\emph{i.e.} all its values used). See LPG\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_PROP( INDF1, CLIST, PARAM, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the NDF components which are to be
         propagated to the new data structure. By default, the HISTORY,
         LABEL and TITLE components and all extensions are propagated.
         See \latex{the} \xref{\texttt{"}Component
         Propagation\texttt{"}}{sun33}{ndf_prop_component_propagation}
         \latex{section in the documentation for routine NDF\_PROP within
         SUN/33} for further details.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter for the new NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_REPLA
}{
   Indicate if input NDFs can be replaced
}{
   \sstdescription{
      Sets a flag indicating if LPG applications can use a single NDF as
      both input and output. If so, a temporary NDF is used to store
      the output. This NDF is then used to replace the existing input NDF once
      the application has completed. If REPLAC is \texttt{.FALSE.} (the default), an
      error is reported if an attempt is made to use a single NDF as both input
      and output.
   }
   \sstinvocation{
      CALL LPG\_REPLA( REPLAC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         REPLAC = LOGICAL (Given)
      }{
         If \texttt{.TRUE.}, a single NDF can be used as both input and output
         from an application. If \texttt{.FALSE.}, an error will be reported if this
         is attempted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_START
}{
   Initialise the contents of the LPG common blocks
}{
   \sstdescription{
      Initialises the global variables used by LPG. See
      \htmlref{LPG\_AGAIN}{LPG_AGAIN}.
   }
   \sstinvocation{
      CALL LPG\_START( VERBO, DELAYO, DISABO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VERBO = LOGICAL (Given)
      }{
         If \texttt{.TRUE.} then the name of the data file being used for each
         parameter will be displayed on each invocation of the
         application at the point where the parameter is accessed.
         Parameters which are not multi-valued (\emph{i.e.} that are associated
         with the same data file on all invocations) are not displayed.
         In addition, a blank line will be displayed on the screen
         between each invocation of the application. No text is displayed
         if VERB is \texttt{.FALSE.}.
      }
      \sstsubsection{
         DELAYO = REAL (Given)
      }{
         Put a delay of DELAY seconds between invocations.
      }
      \sstsubsection{
         DISABO = LOGICAL (Given)
      }{
         If \texttt{.TRUE.}, the looping facilities are disabled. LPG\_AGAIN
         returns \texttt{.TRUE.} only on the first invocation, and
         \htmlref{LPG\_ASSOC}{LPG_ASSOC}, \htmlref{LPG\_CREAT}{LPG_CREAT},
         \htmlref{LPG\_PROP}{LPG_PROP}, \htmlref{LPG\_CREP}{LPG_CREP},
         \htmlref{LPG\_CATASSOC}{LPG_CATASSOC} and
         \htmlref{LPG\_CATCREAT}{LPG_CATCREAT} make simple
         calls to the corresponding \xref{NDF}{sun33}{} or
         \xref{CAT}{sun181}{} routine.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CRPL1
}{
   Create a single new NDF placeholder using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_CREPL except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc.). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Any modification elements in the supplied
      group expression will be treated literally.
   }
   \sstinvocation{
      CALL LPG\_CRPL1( PARAM, PLACE, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         PLACE = INTEGER (Returned)
      }{
         NDF placeholder.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_STATE
}{
   Return the original PAR state of a parameter
}{
   \sstdescription{
      On the first invocation of the application, this routine returns
      the current PAR state of specified parameter and stores it in
      common. On subsequent invocations, the stored state is returned
      rather than the current state.
   }
   \sstinvocation{
      CALL LPG\_STATE( PARAM, STATE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name.
      }
      \sstsubsection{
         STATE = INTEGER (Returned)
      }{
         The original PAR state of the parameter.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\newpage
\section{Changes Introduced in LPG Version 3.0}
\begin{itemize}
   \item It has a separate identity.  It was previously bundled into KAPLIBS.
   \item There is preliminary documentation.
\end{itemize}

\end{document}
