\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\usepackage{palatino}
\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {229.1}
\newcommand{\stardocauthors}   {Tim Jenness, Remo Tilanus, \\
Horst Meyerdierks, Jon Fairclough}
\newcommand{\stardocdate}      {16 December 1999}
\newcommand{\stardoctitle}     {The Global Section Datafile (GSD) access
library}
\newcommand{\stardocversion}   {1.0}
\newcommand{\stardocmanual}    {Programmer's Manual}
\newcommand{\stardocabstract}  {%
This document describes the Global Section Datafile (GSD) access library.
This library provides read-only access to GSD files created at the
James Clerk Maxwell Telescope. A description of GSD itself is presented
in addition to descriptions of the library routines.
}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     sun229.tex
%
%  Purpose:
%     Documentation for GSD library.
%
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%     TIMJ: Tim Jenness (JAC, Hawaii)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%        Added picture commands.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%     16-DEC-1999 (TIMJ):
%        Begin GSD document (SUN/229)
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.

%+
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2html. The contents of this file should be included in the
%     source prior to any statements that make of the sst commnds.

%  Notes:
%     The style file html.sty provided with LaTeX2html needs to be used.
%     This must be before this file.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\latex{\newfont{\ssttt}{cmtt10 scaled 1095}}
\html{\newcommand{\ssttt}{\tt}}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{}
\\[1.3ex]{\raggedright \ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy
\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \vspace{1.0ex}
\\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}]
\mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}


%  Define the format of an item.
\newcommand{\sstitem}{\item}

%% Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  sstroutine.
   \newcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  sstdescription
   \newcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstusage
   \newcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstinvocation
   \newcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstarguments
   \newcommand{\sstarguments}[1]{
      \item[Arguments:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstreturnedvalue
   \newcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstparameters
   \newcommand{\sstparameters}[1]{
      \item[Parameters:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstexamples
   \newcommand{\sstexamples}[1]{
      \item[Examples:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstsubsection
   \newcommand{\sstsubsection}[1]{\item[{#1}]}

%  sstexamplesubsection
   \newcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] #2}

%  sstnotes
   \newcommand{\sstnotes}[1]{\item[Notes:] #1 }

%  sstdiytopic
   \newcommand{\sstdiytopic}[2]{\item[{#1}] #2 }

%  sstimplementationstatus
   \newcommand{\sstimplementationstatus}[1]{
      \item[Implementation Status:] #1
   }

%  sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
      \\
   }
%  sstitem
   \newcommand{\sstitem}{\item}

\end{htmlonly}

%  End of "sst.tex" layout definitions.
%.

% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / \textsc{Rutherford Appleton Laboratory} \hfill \textbf{\stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\textbf{\stardoctitle \\ [2.5ex]}}
   {\LARGE\textbf{\stardocversion \\ [4ex]}}
   {\Huge\textbf{\stardocmanual}}
   \end{center}
   \vspace{5mm}

% ? Add picture here if required for the LaTeX version.
%   e.g. \includegraphics[scale=0.3]{filename.ps}
% ? End of picture

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf{Abstract}}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

% ? Add picture here if required for the hypertext version.
%   e.g. \includegraphics[scale=0.7]{filename.ps}
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC / Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents.
%  ================================
%  Add table of contents header and a navigation button to return to this
%  point in the document (this should always go before the abstract \section).
  \label{stardoccontents}
  \begin{rawhtml}
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

% ? Main text

\section{History}

The Global Section Datafile (GSD) subroutine library package was written in
1987 by Jon Fairclough \cite{F89} to permit the fast reading and writing of
data at the James Clerk Maxwell Telescope. Development was stimulated by the
need to provide fast filing of data in the so-called ``General Single Dish
Data'' (GSDD) format developed by MRAO, IRAM and NRAO. The JCMT used the GSD
format for data storage from all instrumentation until the arrival of SCUBA
\cite{scuba} in 1996 (which uses NDF \cite{ndf}) and data files in this format
will continue to be written by the heterodyne system until the delivery of
ACSIS in 2001.

The original GSD I/O library was written in VAX Fortran and has never been
ported to a Unix environment. With the move from VMS to Unix in 1994/1995 it
was clear that a version of the GSD library was required that would be able to
read GSD files (those in the archive as well as new files) without having to
change the existing telescope acquisition system or require the use of a VMS
application to convert the format on demand. A read-only version of the
library was written in C by Remo Tilanus and Horst Meyerdierks in 1994 and was
incorporated into the Starlink releases of JCMTDR \cite{jcmtdr} and SPECX
\cite{specx}.

\section{Introduction}

The JCMT uses the GSD file format for its current heterodyne acquisition
system (via the Dutch Autocorrelation Spectrometer (DAS)) and for its archive
of pre-SCUBA data.  This document describes the C version of the GSD library
(a FORTRAN interface is layered on top), now distributed as a standalone
package and not part of an application. The current library cannot be used for
creating or modifying GSD files.


\section{C interface}

The fundamental calling interface is from C and this is documented in appendix
\ref{app:desc}. Routine prototypes can be found in the \texttt{gsd.h} include
file. An example C program that lists the contents of a GSD file
(\texttt{gsdprint}) is provided in the distribution.

\section{Fortran interface}

A Fortran interface is provided that uses the original names of the
subroutines rather than C function names. For example, the C routine
\texttt{gsdOpenRead} should be called from Fortran as \texttt{gsd\_open\_read}.
The Fortran binding is incomplete (only covering the supplied C routines) and
existing Fortran code may have to be changed before this library can be
used. An example routine (\texttt{gsd\_print.f}) is provided to demonstrate
the interface. Additional changes:

\begin{itemize}
\item The Fortran include file is now called \texttt{GSD\_PAR} to fit in with
the Starlink naming convention (as opposed to \texttt{GSDPARS} in the original
VAX library).

\item \texttt{GSD\_PAR} is incomplete. Prior inclusion of \texttt{PRM\_PAR}
is required before \texttt{GSD\_PAR} can be included.

\item Error status values have changed. Zero is good status, non-zero is
   bad status, but no particular status value can be expected.

\item \texttt{gsd\_inquire\_array} is not implemented. Instead
\texttt{gsd\_inq\_size} must be used, although it was previously labelled
``obsolete''.

\end{itemize}

\section{Perl interface}

A Perl interface to the GSD library is available, but is not part of this
distribution. Please contact Tim Jenness (\texttt{t.jenness@jach.hawaii.edu})
for more information.

\section{Programming Notes}

This section describes some of the basic features of the library in
comparison with the VAX version:

\begin{itemize}
\item The library provides only read access.

\item Only VAX binary GSD files can be read.

\item Bad values in the file are converted to PRIMDAT bad
values\cite{primdat}, which differ from the traditional VAX/GSD bad
values. (This conversion is in memory only, the file itself is unchanged.)

\item Type conversion is possible only between numeric types (including
logical). Numeric to character or character to numeric conversion is not
provided by the library.

\end{itemize}

\section{Programming Tools}

The distribution comes with the following programming tools:

\begin{description}
\item[gsd\_link] \mbox{}

Link script used during the link phase to make sure that the correct
libraries are used:
\begin{quote}
\begin{verbatim}
f77 gsd_print.f -L/star/lib `gsd_link`
\end{verbatim}
\end{quote}

The math library (\texttt{-lm}) is required when using the C interface.

\item[gsd\_dev] \mbox{}

This command creates the correct links to the Fortran include files,
effectively making a link from \texttt{GSD\_PAR} to
\texttt{/star/include/gsd\_par}.
Use the `\texttt{remove}' argument to remove the link.

\end{description}

\section{Release Notes}

This section provides the release notes for the GSD package.

\begin{description}
\item[VAX implementation] \mbox{}

Implemented in VAX Fortran for the JCMT by Jon Fairclough (1997-1989).

\item[SpecxV6.7] \mbox{}

C read-only version released as part of Specx V6.7 in 1995.

\item[V1.0] \mbox{}

First version released to Starlink standalone. Unbundled from the
SPECX and JCMTDR distributions. First release for Linux.

\end{description}

\begin{thebibliography}{}
\addcontentsline{toc}{section}{References}

\bibitem{F89}
Fairclough~J.~H., 1989, {\it GSD -- Global Section Datafile System},
JCMT Note MT/IN/33

\bibitem{scuba}
Holland~W.~S., Robson~E.I., Gear~W.K., Lightfoot~J.~F., Jenness~T.,
Ivison~R.~J., Stevens~J.~A., Cunningham~C.~R., Ade~P.~A.~R.,
Griffin~M.~J., Duncan~W.~D., Murphy~J.~A., Naylor~D.~A., 1999,
\textit{MNRAS}, \textbf{303}, 659

\bibitem{ndf}
Warren-Smith~R.~F., 1998, {\it NDF -- Routines for Accessing the Extensible
N-Dimensional Data Format}, \xref{Starlink User Note 33}{sun33}{}

\bibitem{jcmtdr}
Lightfoot~J.~F., Harrison~P.~A., Meyerdierks~H., 1995,
{\it JCMTDR -- Applications for reducing JCMT data},
\xref{Starlink User Note 132}{sun132}{}

\bibitem{specx}
Prestage~R.~M., Meyerdierks~H., Lightfoot~J.~F., 1995, {\it SPECX -- A
millimetre wave spectral reduction package},
\xref{Starlink User Note 17}{sun17}{}

\bibitem{primdat}
Warren-Smith~R.~F., 1995, {\it PRIMDAT -- processing of primitive numerical
data}, \xref{Starlink User Note 39}{sun39}{}

\end{thebibliography}


\appendix

\section{Technical Overview}

A GSD file has a fairly simple layout. It consists of a `prolog' followed by
`data'. The prolog describes the data and can be used for retrieving it.  The
prolog consists of a single ``file descriptor'' and ``item descriptors'', one
for each data item. The item descriptor locates the required item in the byte
stream. More information on the file structure can be found in \cite{F89}.

The outermost layer of routines is the Fortran binding. This is in
\texttt{gsd\_f77.c}. The routines can only be called from Fortran. They share
static external variables amongst themselves (but with no other routines) to
record references to up to 100 open GSD files. The calling code only needs to
keep the old file identifier returned by \texttt{gsd\_open\_read}. The routine
\texttt{gsd\_inquire\_array} is not implemented, \texttt{gsd\_inq\_size} must
be used instead.

The next inner layer is the external C binding. The C binding is similar to
the Fortran binding in that there is a one-to-one relationship between
routines. The C binding does not use inherited status, but returns a status as
the function value. Also, given scalar arguments are passed by value, not by
reference. An open GSD file is identfied by no less than four pointers, all of
which must be kept by the calling code.  The C binding consists of
\texttt{gsdOpenRead.c}, \texttt{gsdClose.c}, \texttt{gsdFind.c},
\texttt{gsdItem.c}, \texttt{gsdInqSize.c}, \texttt{gsdGet0x.c},
\texttt{gsdGet1x.c}.

The next inner layer contains the \texttt{gsd1\_} routines. There are three
routines used by \texttt{gsdOpenRead} to open the file and read its contents
into memory.  The fourth routine \texttt{gsd1\_getval} returns information
about and values of items to the caller. It retrieves this information from
the memory copy of the file as created by \texttt{gsdOpenRead}.

The innermost layer are the \texttt{gsd2\_} routines. There are the
\texttt{gsd2\_nativx} routines, which are used by the \texttt{gsd1\_}
routines. They convert VAX binary file contents to equivalent numbers in the
format of the local machine.  They also convert VAX/GSD bad values to
local/PRIMDAT bad values\cite{primdat}. Then there is the \texttt{gsd2\_copya}
routine, which is used by \texttt{gsd1\_getval} to convert from the data type
as copied from the file to the data type as required by the calling routine.

\section{Subroutine List}

\begin{description}
\item[\htmlref{gsdClose}{gsdClose}] \mbox{}

Close a GSD file

\item[\htmlref{gsdFind}{gsdFind}] \mbox{}

Find GSD item by name

% The funny htmlref is required because the sstroutine name
% includes < and > symbols
\item[\htmlref{gsdGet0x}{gsdGet0_SPMlt_t_SPMgt_}] \mbox{}

Get a scalar value from a GSD file

% similarly for gsdGet1x
\item[\htmlref{gsdGet1x}{gsdGet1_SPMlt_t_SPMgt_}] \mbox{}

Get an array from a GSD file

\item[\htmlref{gsdInqSize}{gsdInqSize}] \mbox{}

Inquire array size

\item[\htmlref{gsdItem}{gsdItem}] \mbox{}

Get GSD item by number

\item[\htmlref{gsdOpenRead}{gsdOpenRead}] \mbox{}

Open a GSD file for reading and map it

\end{description}


\section{Routine Descriptions\label{app:desc}}

This section describes the library interface available to C programmers.
The Fortran interface is similar, except the routine names are of the
form \texttt{GSD\_XXX} rather than \texttt{gsdXxx}.

\sstroutine{
   gsdClose
}{
   Close a GSD file
}{
   \sstdescription{
      This routine closes a GSD file opened previously with
      \texttt{gsdOpenRead}. It also releases the memory that
      \texttt{gsdOpenRead} allocated in connection to that file. For this
      purpose this routine must be given the standard C file pointer, the
      pointer to the GSD file descriptor, the pointer to the GSD item
      descriptors, and the pointer to the data buffer.
   }
   \sstinvocation{
      int gsdClose( FILE $*$fptr, void $*$file\_dsc, void $*$item\_dsc,
         char $*$data\_ptr);
   }
   \sstarguments{
      \sstsubsection{
         FILE $*$fptr (Given)
      }{
         The file descriptor for the GSD file to be closed.
      }
      \sstsubsection{
         void $*$file\_dsc (Given)
      }{
         The GSD file descriptor related to the file opened on fptr.
      }
      \sstsubsection{
         void $*$item\_dsc (Given)
      }{
         The array of GSD item descriptors related to the file opened on fptr.
      }
      \sstsubsection{
         char $*$data\_ptr (Given)
      }{
         The buffer with all the data from the GSD file opened on fptr.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int gsdClose();
      }{
         Status from fclose.
      }
   }
   \sstdiytopic{
      Prototype
   }{
      available via \#include {\tt "}gsd.h{\tt "}
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1986-1999 Particle Physics and Astronomy Research Council.
      All Rights Reserved.
   }
}
\sstroutine{
   gsdFind
}{
   Find GSD item by name
}{
   \sstdescription{
      This routine looks up the GSD item specified by its name and returns the
      number of the item. This routine also returns the unit string, the type
      specification and the array flag.
   }
   \sstinvocation{
      int gsdFind( void $*$file\_dsc, void $*$item\_dsc, char $*$name, int $*$itemno,
         char $*$unit, char $*$type, char $*$array );
   }
   \sstarguments{
      \sstsubsection{
         void $*$file\_dsc (Given)
      }{
         The GSD file descriptor related to the file opened on fptr.
      }
      \sstsubsection{
         void $*$item\_dsc (Given)
      }{
         The array of GSD item descriptors related to the file opened on fptr.
      }
      \sstsubsection{
         char $*$data\_ptr (Given)
      }{
         The buffer with all the data from the GSD file opened on fptr.
      }
      \sstsubsection{
         char $*$name (Given)
      }{
         The name of the item. This should be an array of 16 characters (char
         name[16]) and a null-terminated string.
      }
      \sstsubsection{
         int $*$itemno (Returned)
      }{
         The number of the item in the GSD file.
      }
      \sstsubsection{
         char $*$unit (Returned)
      }{
         The unit of the item. This should be an array of 11 characters (char
         name[11]) and will be a null-terminated string.
      }
      \sstsubsection{
         char $*$type (Returned)
      }{
         The data type of the item. This is a single character and one of
         B, L, W, I, R, D, C.
      }
      \sstsubsection{
         char $*$array (Returned)
      }{
         The array flag. This is a single character and true (false) if the
         item is (is not) and array.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int gsdFind();
      }{
         Status.
         \sstitemlist{

            \sstitem
             [1:] If the named item cannot be found.

            \sstitem
             [0:] Otherwise.
         }
      }
   }
   \sstdiytopic{
      Prototype
   }{
      available via \#include {\tt "}gsd.h{\tt "}
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1986-1999 Particle Physics and Astronomy Research Council.
      All Rights Reserved.
   }
}
\sstroutine{
   gsdGet0$<$t$>$
}{
   Get a scalar value from a GSD file
}{
   \sstdescription{
      This routine returns the value of a scalar GSD item. The item must be
      specified by the file desciptor, item descriptor array, data array and
      item number.

\begin{center}
\begin{tabular}{clll}
\hline $<$t$>$& $<$type$>$ &    Fortran &      GSD\\ \hline
       b &  char     & byte          &  byte\\
       l &  char     & logical$*$1   &  logical\\
       w &  short    & integer$*$2   &  word\\
       i &  int      & integer$*$4   &  integer\\
       r &  float    & real$*$4      &  real\\
       d &  double   & real$*$8      &  double \\
       c &  char[17] & character$*$16&  char\\ \hline\hline
\end{tabular}
\end{center}

      This routine will convert between numeric types (all but GSD type char).
      That is to say, the calling routine can request, say, an integer value
      by calling \texttt{gsdGet0i}, even if the item in the GSD file has a
      different numeric type, say real. C casting rules are applied, which may
      differ from Fortran truncation rules. No test for conversion errors is
      performed.
   }
   \sstinvocation{
      int gsdGet0\{blwirdc\}( void $*$file\_dsc, void $*$item\_dsc, char $*$data\_ptr,
         int itemno, $<$type$>$ $*$value );
   }
   \sstarguments{
      \sstsubsection{
         void $*$file\_dsc (Given)
      }{
         The GSD file descriptor.
      }
      \sstsubsection{
         void $*$item\_dsc (Given)
      }{
         The array of GSD item descriptors related to the GSD file.
      }
      \sstsubsection{
         char $*$data\_ptr (Given)
      }{
         The buffer with all the data from the GSD file.
      }
      \sstsubsection{
         int itemno (Given)
      }{
         The number of the item in the GSD file.
      }
      \sstsubsection{
         $<$type$>$ $*$value (Returned)
      }{
         The data value. For \texttt{gsdGet0c} value should be declared with length 17
         at least. The returned string is null-terminated in value[16].
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int gsdGet0$<$t$>$();
      }{
         Status.
         \sstitemlist{

            \sstitem
             [1:] Failure to read the item value.

            \sstitem
             [2:] Numbered item cannot be found.

            \sstitem
             [3:] Item is not scalar.

            \sstitem
             [0:] Otherwise.
         }
      }
   }
   \sstdiytopic{
      Prototype
   }{
      available via \#include {\tt "}gsd.h{\tt "}
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1986-1999 Particle Physics and Astronomy Research Council.
      All Rights Reserved.
   }
}
\sstroutine{
   gsdGet1$<$t$>$
}{
   Get an array from a GSD file
}{
   \sstdescription{
      This routine returns the value of a scalar GSD item. The item must be
      specified by the file desciptor, item descriptor array, data array and
      item number.

\begin{center}
\begin{tabular}{clll}
\hline      $<$t$>$& $<$type$>$  &   Fortran &      GSD\\\hline
       b &  char     & byte           & byte\\
       l &  char     & logical$*$1    & logical\\
       w &  short    & integer$*$2    & word\\
       i &  int      & integer$*$4    & integer\\
       r &  float    & real$*$4       & real\\
       d &  double   & real$*$8       & double\\
       c &  char[16] & character$*$16 & char\\ \hline\hline
\end{tabular}
\end{center}

      This routine does not convert between types. If the type of the GSD item
      does not match the type of the routine, then it returns with an error.

      It is possible to get only part of the array. Although the part can be
      specified in terms of an N-dimensional array, this routine does not take
      a proper N-D section of the array. The caller can specify the start
      pixel in N dimensions and the end pixel in N dimensions. These two pixels
      will be converted to memory locations and all memory between the two is
      returned. This emulates the old GSD library. It is useful really only for
      parts of 1-D arrays, parts of rows, or single pixels.
   }
   \sstinvocation{
      int gsdGet1\{blwird\}( void $*$file\_dsc, void $*$item\_dsc, char $*$data\_ptr,
         int itemno, int ndims, int $*$dimvals, int $*$start, int $*$end,
         $<$type$>$ $*$values, int $*$actvals );
   }
   \sstarguments{
      \sstsubsection{
         void $*$file\_dsc (Given)
      }{
         The GSD file descriptor.
      }
      \sstsubsection{
         void $*$item\_dsc (Given)
      }{
         The array of GSD item descriptors related to the GSD file.
      }
      \sstsubsection{
         char $*$data\_ptr (Given)
      }{
         The buffer with all the data from the GSD file.
      }
      \sstsubsection{
         int itemno (Given)
      }{
         The number of the item in the GSD file.
      }
      \sstsubsection{
         int ndims (Given)
      }{
         The dimensionality the calling routine uses to specify the start and
         end elements.
      }
      \sstsubsection{
         int $*$dimvals (Given)
      }{
         The array of ndims dimensions (array sizes along each axis).
      }
      \sstsubsection{
         int $*$start (Given)
      }{
         The array indices for the first element.
      }
      \sstsubsection{
         int $*$end
      }{
         The array indices for the last element.
      }
      \sstsubsection{
         $<$type$>$ $*$value (Returned)
      }{
         The data values. The calling routine must make sure that sufficient
         memory is provided. Thus it must find out the data type and array size
         before calling this routine.
         If the data type is character, then the routine returns a byte
         buffer with all strings concatenated. There are no string
         terminators in the buffer and there is none at the end. Each
         string is 16 byte long and immediately followed by the next string.
      }
      \sstsubsection{
         int $*$actvals (Returned)
      }{
         The number of array values returned. This saves the caller to work out
         how many array elements correspond to start and end given the dimvals.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int gsdGet1$<$t$>$();
      }{
         Status.
         \sstitemlist{

            \sstitem
             [1:] Failure to read the item values.

            \sstitem
             [2:] Numbered item cannot be found.

            \sstitem
             [4:] Given start and end are inconsistent.

            \sstitem
             [0:] Otherwise.
         }
      }
   }
   \sstdiytopic{
      Prototype
   }{
      available via \#include {\tt "}gsd.h{\tt "}
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1986-1999 Particle Physics and Astronomy Research Council.
      All Rights Reserved.
   }
}
\sstroutine{
   gsdInqSize
}{
   Inquire array size
}{
   \sstdescription{
      This routine returns information about the specified array. Returned are
      the names and units of each dimension, the size along each dimension, and
      the overall size.
   }
   \sstinvocation{
      int gsdInqSize( void $*$file\_dsc, void $*$item\_dsc, char $*$data\_ptr,
         int itemno, int maxdims,
         char $*$$*$dimnames, char $*$$*$dimunits, int $*$dimvals,
         int $*$actdims, int $*$size );
   }
   \sstarguments{
      \sstsubsection{
         void $*$file\_dsc (Given)
      }{
         The GSD file descriptor.
      }
      \sstsubsection{
         void $*$item\_dsc (Given)
      }{
         The array of GSD item descriptors related to the GSD file.
      }
      \sstsubsection{
         char $*$data\_ptr (Given)
      }{
         The buffer with all the data from the GSD file.
      }
      \sstsubsection{
         int itemno (Given)
      }{
         The number of the item in the GSD file.
      }
      \sstsubsection{
         int maxdims (Given)
      }{
         The number of dimensions required and accommodated by the calling
         routine.
      }
      \sstsubsection{
         char $*$$*$dimnames (Returned)
      }{
         The names for each dimension. The calling routine must provide maxdims
         pointers to strings. It must also provide the space for the strings,
         16 bytes. See Notes for how to declare and pass dimnames.
      }
      \sstsubsection{
         char $*$$*$dimunits (Returned)
      }{
         The units for each dimension. The calling routine must provide maxdims
         pointers to strings. It must also provide the space for the strings,
         11 bytes. See Notes for how to declare and pass dimunits.
      }
      \sstsubsection{
         int $*$dimvals (Returned)
      }{
         The values for each dimension. The calling routine must provide an
         array of maxdims integers. This would probably be declared as
         int dimvals[MAXDIMS];
      }
      \sstsubsection{
         int $*$actdims (Returned)
      }{
         The actual number of dimensions. If actdims is less than maxdims, then
         only actims elements are returned in dimnames, dimunits, dimvals.
         Further elements declared by the caller are unchanged by this routine.
      }
      \sstsubsection{
         int $*$size (Returned)
      }{
         The total number of elements in the array.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int gsdInqSize();
      }{
         Status.
         \sstitemlist{

            \sstitem
             [1:] Failed to get a dimension value and name.

            \sstitem
             [2:] Numbered item does not exist.

            \sstitem
             [3:] Array has more dimensions than accommodated by calling routine.

            \sstitem
             [0:] Otherwise.
         }
      }
   }
   \sstdiytopic{
      Prototype
   }{
      available via \#include {\tt "}gsd.h{\tt "}
   }
   \sstdiytopic{
      Note
   }{
      The calling routine will probably allocate storage for dimension names by
      declaring a two-dimensional array. That is not suitable for passing to
      this routine though. The pointers to each string must be copied into an
      array of pointers. For example:
\begin{quote}
\texttt{%
         char  actual\_space[MAXDIMS][16]; \\
         char $*$pointr\_array[MAXDIMS];\\
         for ( i = 0; i $<$ MAXDIMS; i$++$ ) pointr\_array[i] = actual\_space[i];\\
         status = gsdInqSize( ..., pointr\_array, ... );
}
\end{quote}

      The reason why this call works but passing actual\_space does not work,
      is that \texttt{gsdInqSize} uses the given value as a char $*$$*$. So in this
      routine given[1] goes forward in memory by the size of a char $*$ or the
      number of bytes needed to store a pointer. actual\_space would need a
      step in memory by 16 bytes, i.e. the distance from one string to the
      next. The main routine knows about this, because it declared
      actual\_space \_and\_ pointr\_array.
} \sstdiytopic{
    Copyright
}{
      Copyright (C) 1986-1999 Particle Physics and Astronomy Research Council.
      All Rights Reserved.
}
}
\sstroutine{
   gsdItem
}{
   Get GSD item by number
}{
   \sstdescription{
      This routine looks up the GSD item specified by its number and returns
      the name of the item. This routine also returns the unit string, the type
      specification and the array flag.
   }
   \sstinvocation{
      int gsdItem( void $*$file\_dsc, void $*$item\_dsc, int itemno, char $*$name,
         char $*$unit, char $*$type, char $*$array );
   }
   \sstarguments{
      \sstsubsection{
         void $*$file\_dsc (Given)
      }{
         The GSD file descriptor related to the file opened on fptr.
      }
      \sstsubsection{
         void $*$item\_dsc (Given)
      }{
         The array of GSD item descriptors related to the file opened on fptr.
      }
      \sstsubsection{
         char $*$data\_ptr (Given)
      }{
         The buffer with all the data from the GSD file opened on fptr.
      }
      \sstsubsection{
         int itemno (Given)
      }{
         The number of the item in the GSD file.
      }
      \sstsubsection{
         char $*$name (Returned)
      }{
         The name of the item. This should be an array of 16 characters (char
         name[16]) and will be a null-terminated string.
      }
      \sstsubsection{
         char $*$unit (Returned)
      }{
         The unit of the item. This should be an array of 11 characters (char
         name[11]) and will be a null-terminated string.
      }
      \sstsubsection{
         char $*$type (Returned)
      }{
         The data type of the item. This is a single character and one of
         B, L, W, I, R, D, C.
      }
      \sstsubsection{
         char $*$array (Returned)
      }{
         The array flag. This is a single character and true (false) if the
         item is (is not) and array.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int gsdFind();
      }{
         Status.
         \sstitemlist{

            \sstitem
             [1:] If the named item cannot be found.

            \sstitem
             [0:] Otherwise.
         }
      }
   }
   \sstdiytopic{
      Prototype
   }{
      available via \#include {\tt "}gsd.h{\tt "}
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1986-1999 Particle Physics and Astronomy Research Council.
      All Rights Reserved.
   }
}
\sstroutine{
   gsdOpenRead
}{
   Open a GSD file for reading and map it
}{
   \sstdescription{
      This routine opens the named GSD file and reads its contents into memory.
      It returns a standard C file descriptor, a GSD file descriptor, a pointer
      to the array of GSD item descriptors, and a pointer to the collective
      data.

      This routine allocates memory to accommodate the GSD file descriptor, the
      GSD item descriptors, and the data from the GSD file. It also leaves the
      GSD file open. Any call to this routine must be matched with a call to
      \texttt{gsdClose} with the information returned by this routine. \texttt{gsdClose} will
      close the file and release the memory allocated by this routine.
   }
   \sstinvocation{
      int gsdOpenRead( char $*$file, float $*$version, char $*$label, int $*$no\_items,
         FILE $*$$*$fptr, void $*$$*$file\_dsc, void $*$$*$item\_dsc, char $*$$*$data\_ptr );
   }
   \sstarguments{
      \sstsubsection{
         char $*$file (Given)
      }{
         The name of the GSD file to be opened.
      }
      \sstsubsection{
         float $*$version (Returned)
      }{
         The GSD file version number.
      }
      \sstsubsection{
         char $*$label (Returned)
      }{
         The GSD file label. This is a null-terminated string. It should be
         declared by the calling routine with length 41.
      }
      \sstsubsection{
         int $*$no\_items (Returned)
      }{
         The number of items in the GSD file.
      }
      \sstsubsection{
         FILE $*$$*$fptr (Returned)
      }{
         The file descriptor for the GSD file opened.
      }
      \sstsubsection{
         void $*$$*$file\_dsc (Returned)
      }{
         The GSD file descriptor. This routine allocates the memory necessary
         and fills it with the relevant information from the GSD file. A call
         to \texttt{gsdClose} will release this memory (given the pointer).
      }
      \sstsubsection{
         void $*$$*$item\_dsc (Returned)
      }{
         The array of GSD item descriptors. This routine allocates the memory
         necessary and fills it with the relevant information from the GSD
         file. A call to \texttt{gsdClose} will release this memory (given the pointer).
         The number of array elements is returned in no\_items.
      }
      \sstsubsection{
         char $*$$*$data\_ptr (Returned)
      }{
         The buffer with all the data from the GSD file. This routine allocates
         the memory necessary and reads the data into it. A call to \texttt{gsdClose}
         will release this memory (given the pointer). The size of this buffer
         does not matter, but it can be calculated in bytes as
            file\_dsc-$>$end\_data - file\_dsc-$>$str\_data $+$ 1
         if you know what a struct file\_descriptor looks like.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int gsdOpenRead();
      }{
         Status. Status is set to
         \sstitemlist{

            \sstitem
             [1:] Failure to open named file,

            \sstitem
             [2:] Failure to read file\_dsc from file,

            \sstitem
             [3:] Failure to allocate memory for item\_dsc,

            \sstitem
             [4:] Failure to read item\_dsc from file,

            \sstitem
             [6:] Failure to read data\_ptr from file,

            \sstitem
             [7:] Failure to allocate memory for data\_ptr,

            \sstitem
             [0:] Otherwise.
         }
      }
   }
   \sstdiytopic{
      Prototype
   }{
      available via \#include {\tt "}gsd.h{\tt "}
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1986-1999 Particle Physics and Astronomy Research Council.
      All Rights Reserved.
   }
}


% ? End of main text
\end{document}
