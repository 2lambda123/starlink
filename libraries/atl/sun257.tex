\documentstyle[11pt]{article}
\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
%------------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun257.0}
\newcommand{\stardocnumber}    {257.0}
\newcommand{\stardocauthors}   {D.S. Berry}
\newcommand{\stardocdate}      {3rd July 2006}
\newcommand{\stardoctitle}     {ATL \\ [1ex]
                                A Library of AST Utility Routines}
\newcommand{\stardocversion}   {Version 1.0}
\newcommand{\stardocmanual}    {Programmer's Manual}
% ? End of document identification
% -----------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %\begin{rawtex} and %\end{rawtex} lines (used by
%  star2html to signify raw TeX that latex2html cannot process).
%\begin{rawtex}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}
%\end{rawtex}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newenvironment{latexonly}{}{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{{\bf LaTeX}{2}{\tt{HTML}}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\newcommand{\latex}[1]{#1}
\newcommand{\setunderscore}{\renewcommand{\_}{{\tt\symbol{95}}}}
\latex{\setunderscore}

%  Redefine the \tableofcontents command. This procrastination is necessary
%  to stop the automatic creation of a second table of contents page
%  by latex2html.
\newcommand{\latexonlytoc}[0]{\tableofcontents}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / {\sc Rutherford Appleton Laboratory} \hfill {\bf \stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\bf  \stardoctitle \\ [2.5ex]}
   {\LARGE\bf \stardocversion \\ [4ex]}
   {\Huge\bf  \stardocmanual}
   \end{center}
   \vspace{5mm}

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\bf Abstract}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> \end{rawhtml}

% ? Add picture here if required.
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC}{http://www.cclrc.ac.uk} /
      \htmladdnormallink{Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk/ral} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://star-www.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://star-www.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents.
%  ================================
%  Add table of contents header and a navigation button to return to this
%  point in the document (this should always go before the abstract \section).
  \label{stardoccontents}
  \begin{rawhtml}
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \renewcommand{\latexonlytoc}[0]{}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}


% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%   ==================

ALT provides high level utility functions for handling WCS and other
AST-related tasks.

% ? End of document
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
 \newpage
 \begin{latexonly}
   \setlength{\parskip}{0mm}
   \latexonlytoc
   \setlength{\parskip}{\medskipamount}
   \markright{\stardocname}
 \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\newpage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\section {Introduction}

This library contains routines that use the AST library to perform various 
higher-level utility tasks.

\appendix
\section{\label{APP:SPEC}Routine Descriptions}


% +
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2HTML. The contents of this file should be included in the
%     source prior to any statements that make use of the SST commands.

%  Notes:
%     The commands defined in the style file html.sty provided with LaTeX2html
%     are used. These should either be made available by using the appropriate
%     sun.tex (with hypertext extensions) or by putting the file html.sty
%     on your TEXINPUTS path (and including the name as part of the
%     documentstyle declaration).

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

% -

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\newfont{\ssttt}{cmtt10 scaled 1095}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}


%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy
\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  Re-define \ssttt.
   \newcommand{\ssttt}{\tt}

%  \sstroutine.
   \renewcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  \sstdescription
   \renewcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstusage
   \renewcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
   }

%  \sstinvocation
   \renewcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
   }

%  \sstarguments
   \renewcommand{\sstarguments}[1]{
      \item[Arguments:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstreturnedvalue
   \renewcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstparameters
   \renewcommand{\sstparameters}[1]{
      \item[Parameters:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstexamples
   \renewcommand{\sstexamples}[1]{
      \item[Examples:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstsubsection
   \renewcommand{\sstsubsection}[1]{\item[{#1}]}

%  \sstexamplesubsection
   \renewcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] \\ #2}

%  \sstnotes
   \renewcommand{\sstnotes}[1]{\item[Notes:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstdiytopic
   \renewcommand{\sstdiytopic}[2]{\item[{#1}]
      \begin{description}
         #2
      \end{description}
   }

%  \sstimplementationstatus
   \renewcommand{\sstimplementationstatus}[1]{\item[Implementation Status:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
   }
\end{htmlonly}

%  End of "sst.tex" layout definitions.
% .
% @(#)sst.tex   1.4   95/06/06 11:46:41   95/06/06 11:49:58

% Routine descriptions:
% =====================
\small
\sstroutine{
   ATL\_AXTRM
}{
   Trim axes from the current Frame of a FrameSet
}{
   \sstdescription{
      This routine ensures that the number of axes in the current
      Frame of the supplied FrameSet is the same as the number in
      the base Frame. If this is not the case on entry, one or more
      new Frames with the required number of axes are created and
      added into the FrameSet, one of which becomes the new current
      Frame. The only case in which more than one new Frame is added
      is if the current Frame has too many axes, and the FrameSet
      contains more than one {\tt "}ROI{\tt "} Frame (that is, Frames which are
      Regions and which have a Domain name beginning with {\tt "}ROI{\tt "}). If
      the FrameSet contains zero or one ROI Frame, then only a single
      new Frame is added into the FrameSet.

      If the original current Frame has too few axes, the new Frame
      is a copy of the original current Frame with extra simple axes
      added to the end. These extra axes are supplied a value of
      AST\_\_BAD by the Mapping which connects the original current
      Frame to the new current Frame.

      If the original current Frame has too many axes, one or more
      new Frames will be created by picking the specified axes from
      the original current Frame. Each of these Frames is added into
      the FrameSet using a Mapping which has a forward transformation
      which simply drops the values for the unselected axes. The
      inverse transformation (from new to old Frame) attempts to
      assign usable values for the dropped axes if possible. If this
      is not possible, then AST\_\_BAD is assigned to the dropped axes.

      Two methods are used for finding suitable values to assign to
      dropped axes. The first is only possible if the value for a
      dropped axis can be determined uniquely from the value of one
      of the retained axes. This may be the case for instance in a
      situation where (RA,wavelength) axes were selected from the
      (RA,Dec,Wavelength) axes describing a 2D longslit spectrum. The
      missing Dec value can probably be determined from the RA value
      because the relationship between RA and Dec is determined by the
      position and orientation of the slit on the sky.

      If it is not possible to determine the value for a dropped axis
      in this way, then a search is made for Frames that are Regions
      having a Domain name beginning with {\tt "}ROI{\tt "}. If any are found,
      then a new Frame is added into the FrameSet for each ROI Region
      found, connected to the original current Frame via a PermMap.
      The values to be assigned to the dropped axes by the inverse
      PermMap transformation are determined by transforming the
      bounding box of the corresponding ROI Region into the original
      current Frame. The assigned axis values are the mean values of
      the transformed bounding box on each dropped axis. The Domain
      name of the corresponding ROI Region is stored in the Ident
      attribute of each new Frame so that later code can identify the
      corresponding ROI Region, and is also appended to the end of the
      Frame{\tt '}s Domain. The new Frame corresponding to the first ROI
      Region found in the FrameSet is left as the current Frame on exit.
   }
   \sstinvocation{
      CALL ATL\_AXTRM( IWCS, AXES, LBND, UBND, WORK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         The FrameSet to use. A new current Frame may be added to the
         FrameSet by this routine.
      }
      \sstsubsection{
         AXES( $*$ ) = INTEGER (Given)
      }{
         The one-based indices of the axes to be retained in the event
         of there being too many axes in the original current Frame
         of IWCS. The number of values in the array should be equal to
         the number of axes in the base Frame of IWCS (i.e the number
         of pixel axes).
      }
      \sstsubsection{
         LBND( $*$ ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the NDF from which the
         FrameSet was obtained. The number of values in the array
         should be equal to the number of axes in the base Frame of
         IWCS (i.e the number of pixel axes).
      }
      \sstsubsection{
         UBND( $*$ ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the NDF from which the
         FrameSet was obtained. The number of values in the array
         should be equal to the number of axes in the base Frame of
         IWCS (i.e the number of pixel axes).
      }
      \sstsubsection{
         WORK( $*$ ) = INTEGER (Given)
      }{
         Work space. It{\tt '}s length should be at least twice as large as
         the largest pixel dimension implied by LBND and UBND.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_CPPLA
}{
   Copy attributes from one Plot to another
}{
   \sstdescription{
      This routine copies all public attribute values from one AST Plot to
      another AST Plot. The attributes copied are those that affect the
      visual appearance of the Plot.
   }
   \sstinvocation{
      CALL ATL\_CPPLA( IPLOT1, IPLOT2, FIXATE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT1 = INTEGER (Given)
      }{
         The source Plot.
      }
      \sstsubsection{
         IPLOT2 = INTEGER (Given)
      }{
         The destination Plot.
      }
      \sstsubsection{
         FIXATE = LOGICAL (Given)
      }{
         If .FALSE., then attribute values are only set in IPLOT2 if they
         have been assigned an explicit value (i.e. are not defaulted) in
         IPLOT1. If .TRUE., then values are set explicitly in IPLOT2 whether
         they are default values or not.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_CREAT
}{
   Write an AST Object to a text file or NDF specified using an environment
   parameter
}{
   \sstdescription{
      Write an AST Object to a text file or NDF specified using an environment
      parameter.
   }
   \sstinvocation{
      CALL ATL\_CREAT( PARAM, IAST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name.
      }
      \sstsubsection{
         IAST = INTEGER (Given)
      }{
         The AST Object, or AST\_\_NULL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_CUTPL
}{
   Create a Plot covering a sub-region of another Plot
}{
   \sstdescription{
      This routine creates a new Plot with the same attributes as a
      supplied Plot, but covering a sub-region within the world
      coordinate system and graphics viewport.
   }
   \sstinvocation{
      CALL ATL\_CUTPL( IPLOT1, IFRM, DLBND, DUBND, IPLOT2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT1 = INTEGER (Given)
      }{
         The source Plot.
      }
      \sstsubsection{
         IFRM = INTEGER (Given)
      }{
         Index of the Frame within IPLOT1 in which the bounds are supplied.
      }
      \sstsubsection{
         DLBND( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The axis values at the lower left corner of the region to be
         covered by the new Plot. The number of axis values supplied should
         equal the number of axes in the Frame identified by IFRM.
      }
      \sstsubsection{
         DUBND( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The axis values at the upper right corner of the region to be
         covered by the new Plot. The number of axis values supplied should
         equal the number of axes in the Frame identified by IFRM.
      }
      \sstsubsection{
         IPLOT2 = INTEGER (Returned)
      }{
         The new Plot.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_FSPEC
}{
   Locate a SpecFrame within a CmpFrame
}{
   \sstdescription{
      This routine searches the supplied CmpFrame for an axis that is a
      SpecFrame. It returns the axis index of the SpecFrame within the
      CmpFrame, and also returns a pointer to the SpecFrame itself.

      No error is reported if the CmpFrame does not contain a SpecFrame.
      If the CmpFrame contains more than one SpecFrame, the first (i.e.
      the lowest index) is returned.
   }
   \sstinvocation{
      CALL ATL\_FSPEC( FRM, SPAX, SPFRM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRM= INTEGER (Given)
      }{
         The CmpFrame pointer.
      }
      \sstsubsection{
         SPAX = INTEGER (Returned)
      }{
         The index of the spectral axis within the CmpFrame. Returned
         equal to zero if no spectral axis is found.
      }
      \sstsubsection{
         SPFRM = INTEGER (Returned)
      }{
         A pointer to the SpecFrame. Returned equal to AST\_\_NULL if no
         spectral axis is found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_GTGRP
}{
   Obtain lines of text from a parameter, and store them in a GRP group
}{
   \sstdescription{
      Currently this routine expects the parameter to be associated with:

      1 - a text file (the returned group contains the lines of the file).
      2 - a FITS file (the returned group contains the FITS headers).

      In future it may be possible to add other ways of using the
      parameter (i.e. by associating it with objects other than text
      files).
   }
   \sstinvocation{
      CALL ATL\_GTGRP( PARAM, IGRP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name.
      }
      \sstsubsection{
         IGRP = INTEGER (Returned)
      }{
         The AST Object, or AST\_\_NULL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_MGFTS
}{
   Merge two FITS headers
}{
   \sstdescription{
      This routine merges two FITS headers, each supplied in an AST
      FitsChan, in one of several different ways. The resulting merged
      list of headers is returned in a new FitsChan.
   }
   \sstinvocation{
      CALL ATL\_MGFTS( METHOD, FC1, FC2, FC3, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         METHOD = INTEGER (Given)
      }{
         Indicates how the two FITS headers should be merged:

         1 - Concatenation. Store the contents of FC1 in the returned
             FitsChan, and then append the contents of FC2 to the end of
             the returned FitsChan. No checks are made for multiple
             occurences of the same keyword.

         2 - Union (with priority given to FC2): For every header in FC1, see
             if FC2 contains the same keyword. If it does not, copy the FC1
             header to the returned FitsChan. Then append the contents of FC2
             to the end of the returned FitsChan.

         3 - Overlap: For every header in FC1, see if FC2 contains the same
             keyword. If it does, and if the keyword value is the same in
             both FitsChans, copy the FC1 header to the returned FitsChan.
      }
      \sstsubsection{
         FC1 = INTEGER (Given)
      }{
         Pointer to the first FitsChan.
      }
      \sstsubsection{
         FC2 = INTEGER (Given)
      }{
         Pointer to the second FitsChan.
      }
      \sstsubsection{
         FC3 = INTEGER (Returned)
      }{
         Pointer to the returned FitsChan.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The contents of FC1 and FC2 are unchanged on exit.

         \sstitem
         For METHOD 3 (overlap), floating point values are compared
         by formatting into a string (using the accuracy specified by the
         FitsDigits attributes of the two supplied FitsChans) and then
         comparing the formatted strings for exact equality.
      }
   }
}
\sstroutine{
   ATL\_MKLUT
}{
   Create a Mapping to connect two 1D array of values
}{
   \sstdescription{
      This routine creates a 1D Mapping which translates an X into a Y
      value on the basis of supplied tables of corresponding X and Y.
      This is like an AST LutMap except that the LutMap class requires Y
      to be tabulated at equal X intervals, whereas this routine allows
      Y to be tabulated at arbitrary X intervals.
   }
   \sstinvocation{
      CALL ATL\_MKLUT( IX, IY, NPNT, NVAR, FRM, TABLE, MAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IX = INTEGER (Given)
      }{
         The index of the X values within the TABLE array.
      }
      \sstsubsection{
         IY = INTEGER (Given)
      }{
         The index of the Y values within the TABLE array.
      }
      \sstsubsection{
         NPNT = INTEGER (Given)
      }{
         The number of values supplied for each variable in the TABLE
         array.
      }
      \sstsubsection{
         NVAR = INTEGER (Given)
      }{
         The number of variables described in the table. This will be at
         least 2 (for X and Y) but may be more.
      }
      \sstsubsection{
         FRM = INTEGER (Given)
      }{
         If not AST\_\_NULL, then this should be an AST pointer to a Frame
         with NVAR axes which will be used to normalise the axis values
         before creating the LutMap. No normalisation occurs if a value of
         AST\_\_NULL is supplied.
      }
      \sstsubsection{
         TABLE( NPNT, NVAR ) = DOUBLE PRECISION (Given and Returned)
      }{
         The table containing corresponding X and Y values. The table can
         also contain values for other variables, which will be ignored.
         These will be normalised on exit using the AST Frame supplied by
         FRM.
      }
      \sstsubsection{
         MAP = INTEGER (Returned)
      }{
         An AST pointer to the returned Mapping, or AST\_\_NULL if no Mapping
         could be created.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         It is only possible to create the Mapping if the tabluated X values
         are monotonic increasing or decreasing.

         \sstitem
         The returned Mapping will have an inverse Transformation only if Y
         increases or decreases monotonically with X.
      }
   }
}
\sstroutine{
   ATL\_NOTIF
}{
   Print a message to the screen if ATOOLS\_VERBOSE is set
}{
   \sstdescription{
      Print a message to the screen if ATOOLS\_VERBOSE is set.
   }
   \sstinvocation{
      CALL ATL\_NOTIF( MSG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MSG = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_PLROI
}{
   Create a set of Plots associated with each ROI in a given Plot
}{
   \sstdescription{
      This routine searches the supplied Plot for ROI Frames (see
      ATL\_AXTRM). For each ROI Frame found, it creates a new Plot
      that covers just the region of graphics coords occupied by the
      ROI. These new Plots are returned in an AST KeyMap.
   }
   \sstinvocation{
      CALL ATL\_PLROI( IPLOT, RPLOTS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         The supplied Plot to search for ROI Frames.
      }
      \sstsubsection{
         RPLOTS = INTEGER (Returned)
      }{
         An AST KeyMap holding the Plots associated with the ROI Frames.
         The key used to identify each Plot within the KeyMap is the Domain
         name of the corresponding ROI Frame.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_PTFTR
}{
   Store a keyword value in a FitsChan, replacing any existing value
}{
   \sstdescription{
      This routine stores a value for a FITS keyword in a FitsChan. If
      the keyword already has a value in the FitsChan, the existing value
      is replaced with the new value. Otherwise, the new keyword is
      added to the end of the FitsChan. On exit, the current Card in
      the FitsChan is the card following the new keyword value (or
      end-of-file if the new card is the last one in the FitsChan).
   }
   \sstinvocation{
      CALL ATL\_PTFTR( THIS, NAME, VALUE, COMMNT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         THIS = INTEGER (Given)
      }{
         Pointer to the FitsChan to use.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The FITS keyword name. This may be a complete FITS header card,
         in which case the keyword to use is extracted from it. No more
         than 80 characters are read from this string.
      }
      \sstsubsection{
         VALUE = REAL (Given)
      }{
         The new keyword value. If this is VAL\_\_BADR, then an UNDEF value
         will be stored in ther FitsChan.
      }
      \sstsubsection{
         COMMNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A new comment for the keyword. If this is blank, any comment in
         the NAME string is used. If the NAME string contains no comment,
         any existing comment for the keyword in the FitsChan is retained.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine is not processed using GENERIC because the names of
         the required AST routines do not use standard data type codes.
      }
   }
}
\sstroutine{
   ATL\_PXDUP
}{
   Ensure the number of WCS axes is no less than the number of pixel
   axes
}{
   \sstdescription{
      This routine ensures that the number of axes in the current Frame
      (WCS Frame) of a FrameSet is at least equal to the number of axes
      in the base Frame (PIXEL or GRID Frame). If the initial number of
      current Frame axes is too small, extra axes are added to the
      current Frame by duplicating selected pixel axes.
   }
   \sstinvocation{
      CALL ATL\_PXDUP( IWCS, POS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         The supplied FrameSet.
      }
      \sstsubsection{
         POS( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The base Frame coords of a position which has good current Frame
         coords.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_RDCH
}{
   Read an AST Object from a GRP group using a Channel
}{
   \sstdescription{
      Read an AST Object from a GRP group using a Channel.
   }
   \sstinvocation{
      CALL ATL\_RDCH( IGRP, IAST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         An identifier for the group holding the text.
      }
      \sstsubsection{
         IAST = INTEGER (Returned)
      }{
         The AST Object, or AST\_\_NULL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_RDFCH
}{
   Read an AST Object from a GRP group using a FitsChan
}{
   \sstdescription{
      Read an AST Object from a GRP group using a FitsChan.
   }
   \sstinvocation{
      CALL ATL\_RDFCH( IGRP, IAST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         An identifier for the group holding the text.
      }
      \sstsubsection{
         IAST = INTEGER (Returned)
      }{
         The AST Object, or AST\_\_NULL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_RDGRP
}{
   Read an AST Object from a GRP group
}{
   \sstdescription{
      Read an AST Object from a GRP group.
   }
   \sstinvocation{
      CALL ATL\_RDGRP( IGRP, IAST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         An identifier for the group holding the text.
      }
      \sstsubsection{
         IAST = INTEGER (Returned)
      }{
         The AST Object, or AST\_\_NULL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ATL\_RM
}{
   Remove a file
}{
   \sstdescription{
      This subroutine calls the {\tt "}PSX\_REMOVE{\tt "} RTL function to remove a
      specified file. No error occurs if the file cannot be removed for
      any reason.
   }
   \sstinvocation{
      CALL ATL\_RM( FILE, STATUS )
   }
   \sstdiytopic{
      Parameters
   }{
      FILE = CHARACTER $*$ ( $*$ ) (Given)
         The path to the file.
      STATUS = INTEGER (Given and Returned)
         The inherited global status.
   }
}
\sstroutine{
   ATL\_TTLPL
}{
   Display a Plot Title without using AST\_GRID
}{
   \sstdescription{
      This routine display the Plot Title at the top of the area covered
      by the Plot, but does not draw anything else (e.g. axes, tick
      marks, borders, labels, etc). It does not need the inverse
      transformation from current to base Frame to be defined in the Plot.
   }
   \sstinvocation{
      CALL ATL\_TTLPL( IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         The Plot.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status value.
      }
   }
}
\normalsize

\end{document}
