\documentstyle[11pt]{article} 
\pagestyle{myheadings}

%------------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink System Note}
\newcommand{\stardocinitials}  {SSN}
\newcommand{\stardocnumber}    {4.4}
\newcommand{\stardocauthors}   {P C T Rees}
\newcommand{\stardocdate}      {15 January 1992}
\newcommand{\stardoctitle}     {EMS \\ [1ex]
                                Error Message Service}
\newcommand{\stardocversion}   {Version 1.2}
\newcommand{\stardocmanual}    {Programmer's Manual}

%------------------------------------------------------------------------------
\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\renewcommand{\_}{{\tt\char'137}}     % re-centres the underscore
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

%------------------------------------------------------------------------------
% Add any \newcommand or \newenvironment commands here
\renewcommand{\thepage}{\roman{page}}

%+
%  Name:
%     LAYOUT.TEX

%  Purpose:
%     Define Latex commands for laying out documentation produced by PROLAT.

%  Language:
%     Latex

%  Type of Module:
%     Data file for use by the PROLAT application.

%  Description:
%     This file defines Latex commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by Latex. The
%     contents of this file should be included in the source presented to
%     Latex in front of any output from PROLAT. By default, this is done
%     automatically by PROLAT.

%  Notes:
%     The definitions in this file should be included explicitly in any file
%     which requires them. The \include directive should not be used, as it
%     may not then be possible to process the resulting document with Latex
%     at a later date if changes to this definitions file become necessary.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}

%  Define a \tt font of the required size.
\font\ssttt=cmtt10 scaled 1095

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.45pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{\item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[1]{\item[{\ssttt #1}] \mbox{} \\}

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  End of LAYOUT.TEX layout definitions.
%.

%------------------------------------------------------------------------------

\begin{document}

\thispagestyle{empty}
SCIENCE \& ENGINEERING RESEARCH COUNCIL \hfill \stardocname\\
RUTHERFORD APPLETON LABORATORY\\
{\large\bf Starlink Project\\}
{\large\bf \stardoccategory\ \stardocnumber}
\begin{flushright}
\stardocauthors\\
\stardocdate
\end{flushright}
\vspace{-4mm}
\rule{\textwidth}{0.5mm}
\vspace{5mm}
\begin{center}
{\Huge\bf  \stardoctitle \\ [2.5ex]}
{\LARGE\bf \stardocversion \\ [4ex]}
{\Huge\bf  \stardocmanual}
\end{center}
\vspace{20mm}

%------------------------------------------------------------------------------
%  Package Description
\begin{center}
{\Large\bf Description}
\end{center}

This document describes the Error Message Service, EMS, and its use in 
system software.
The purpose of EMS is to provide facilities for constructing and storing 
error messages for future delivery to the user via the Error Reporting
System (ERR, SUN/104).
EMS can be regarded as a simplified version of ERR without the binding to
any software environment ({\em e.g.} for message output or access to the
parameter and data systems).
The routines in this library conform to the error reporting conventions
described in SUN/104. 
A knowledge of these conventions, and of the ADAM system ({\em i.e.} SG/4), is 
assumed in what follows.

This document is intended for Starlink systems programmers and can safely be
ignored by applications programmers and users.

%------------------------------------------------------------------------------
%  Add this part if you want a table of contents
\newpage
\markright{\stardocname}
\null\vspace {5mm}
\begin {center}
\rule{80mm}{0.5mm} \\ [1ex]
{\Large\bf \stardoctitle \\ [2.5ex]
           \stardocversion} \\ [2ex]
\rule{80mm}{0.5mm}
\end{center}
\vspace{30mm}

\setlength{\parskip}{0mm}
\tableofcontents
\setlength{\parskip}{\medskipamount}

%------------------------------------------------------------------------------
%  Introduction page
\newpage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\null\vspace {5mm}
\begin {center}
\rule{80mm}{0.5mm} \\ [1ex]
{\Large\bf \stardoctitle \\ [2.5ex]
           \stardocversion} \\ [2ex]
\rule{80mm}{0.5mm}
\end{center}
\vspace{30mm}

\section {Introduction}

The purpose of the Error Message Service is to provide facilities for
constructing and storing reported  error messages without the facility for
delivering these messages to the user, in order to allow error reporting from 
environment system software.
The hierarchical structure of an application within a software environment 
is illustrated in {\em Figure 1}.
It can be seen from {\em Figure 1} that between an application and the
operating system any environment is realised as a number of subroutine
libraries, providing a set of documented facilities for the applications
programmer to use.
Between the user and an application, the environment will normally also 
provide a user interface which controls the loading of specific applications,
the I/O to the user and the parameter system.

The Error Message Service is an implementation of the error reporting 
conventions discussed in SUN/104 which is not dependent on any particular 
software environment.
Its purpose is to provide facilities for constructing and storing reported 
error messages without the facility for delivering these messages to the user.
The exclusion of any user-callable message delivery mechanism from the Error
Message Service allows EMS to be used for error reporting within software
environment system routines without the danger of recursion on error.
Conversely, the Error and Message Reporting Systems, ERR and MSG (SUN/104), 
have bindings to specific software environments and thus the ability to 
deliver error and informational messages to the user via the user interface 
of that environment.
The binding of ERR and MSG to a given software environment precludes their use
for error reporting from within the environment system software because the
error reporting would rely to some (probably unpredictable) extent upon the 
working state of that environment.
Thus, ERR and MSG act as interfaces for a given environment with EMS, to be 
used only within applications software.

As an example, the ADAM versions of ERR and MSG are able to obtain the message
text associated with a given message parameter from the ADAM interface file 
and are also able to include ADAM parameter keywords and references ({\em i.e.}
file names, HDS object names or device names) in the message text.
These features are useful when reporting error and informational messages 
from ADAM applications software. 
However, in order to provide these facilities, MSG and ERR make calls to the
ADAM parameter system, data system and user interface and so depend
upon the working state of these parts of the ADAM environment.
These features preclude the use of MSG and ERR in the development of any 
subroutine library used by the parameter system, data system or user interface.

The hierarchical relationship between MSG, ERR and EMS is illustrated in 
{\em Figure 2}.

\begin {figure}
\begin {footnotesize}
\begin {center}
\begin {picture}(160,59)
\put (65.5,45){\framebox(29,7){\bf APPLICATION}}
\put (2,21){\framebox(34.5,7){\bf Parameter System}}
\put (38.5,21){\framebox(24.5,7){\bf Data System}}
\put (65,21){\framebox(17.5,7){\bf File I/O}}
\put (84.5,21){\framebox(30.5,7){\bf Magnetic Tapes}}
\put (117,21){\framebox(18.5,7){\bf Graphics}}
\put (137.5,21){\framebox(20.5,7){\bf Data Base}}
\put (0,14){\framebox(160,24){}}
\put (2,34){\bf Environment Subroutine Libraries}
\put (59,0){\framebox(42,7){\bf OPERATING SYSTEM}}
\put (80,45){\line(0,-1){7}}
\put (80,14){\line(0,-1){7}}
\end {picture}
\end {center}
\end {footnotesize}
\caption {Overview of an application}
\end {figure}

\section {When to Use the Error Message Service}

At the level of applications code the Error Reporting System, ERR, should be 
used for error reporting exclusively.
Within environment subroutine libraries the rule is to use calls to EMS unless
it is necessary to deliver error messages to the user ({\em i.e.} by 
calls to ERR\_FLUSH).
A subroutine library {\em must} use one or other of these error reporting
libraries exclusively: {\em i.e.} if EMS calls are used within a subroutine 
library, they must be used exclusively throughout the library -- no calls to 
ERR routines are allowed.
Furthermore, if ERR calls are used to report errors within a subroutine
library, say because calls to ERR\_FLUSH are required during interaction with
the user, then it must be understood that this subroutine library exists at a
hierarchical level above the environment system software.
This subroutine library cannot then be called from other libraries purporting
to exist at lower levels within the subroutine hierarchy --
to do so could result in unpredictable behaviour when an error occurs.

\begin {figure}
\begin {footnotesize}
\begin {center}
\begin {tabular}{|cccc|} \hline
& & & \\
\hspace{8em} & \hspace{8em} & \hspace{8em} & \hspace{8em} \\
\multicolumn{2}{|c}{\fbox{\bf Message Reporting System}} 
   & \multicolumn{2}{c|}{\fbox{\bf Error Reporting System}} \\
& \multicolumn{2}{|c|}{} & \\ \cline{2-3}
\multicolumn{2}{|c|}{} & \multicolumn{2}{c|}{} \\
& \multicolumn{2}{c}{\fbox{\bf Error Message Service}} & \\
& & & \\
\hline
\end {tabular}
\end {center}
\end {footnotesize}
\caption {The relationship between MSG, ERR and EMS}
\end {figure}


\section {Reporting Errors}

The subroutine used to report errors is EMS\_REP. 
It has a calling sequence analogous to that of ERR\_REP, {\em i.e.}

\begin{verbatim}
      CALL EMS_REP( PARAM, TEXT, STATUS )
\end{verbatim}

The argument PARAM is the error message name, TEXT is the error message text and
STATUS is the inherited status.
These arguments are the same as those used in calls to ERR\_REP and are
discussed fully in SUN/104.

On exit from EMS\_REP the status argument remains the unchanged, with two
exceptions:

\begin {itemize}
\item if EMS\_REP is called with STATUS set to SAI\_\_OK;
\item if an internal EMS fault occurs ({\em i.e.} context stack overflow or
error stack overflow).
\end {itemize}

Appendix \ref{incl_sect} lists the symbolic constants for all the possible
EMS errors.

The deferral of error reporting can be controlled within EMS: EMS\_MARK 
and EMS\_RLSE respectively mark and release error reporting contexts;
EMS\_ANNUL annuls all error reports pending output in a given error context;
EMS\_BEGIN and EMS\_END respectively begin and end error reporting
environments.
The behaviour of these subroutines is analogous to ERR\_MARK, ERR\_RLSE, 
ERR\_ANNUL, ERR\_BEGIN and ERR\_END provided by the Error Reporting System (see
SUN/104).
EMS does not provide an analogue to ERR\_FLUSH.


\section {Message Tokens}

The facility to use message tokens to embed the values of Fortran variables
within the message text is available in EMS.
As in MSG and ERR, these message tokens are  indicated by prefixing the token
name with an up-arrow, ``$^\wedge$'', escape character within message text, 
{\em e.g.}

\begin{verbatim}
      CALL EMS_REP( 'EMS_ROUTN_TOKEN', 'Error text: ^TOKEN', STATUS )
\end{verbatim}

Message tokens can be set using the most concise form of a given Fortran 77
variable with the routines EMS\_SETx, {\em e.g.}

\begin{verbatim}
      CALL EMS_SETC( 'TOKEN', 'A token' )
\end{verbatim}

Message tokens can also be set using a given Fortran 77 FORMAT specifier with 
the routines EMS\_FMTx, {\em e.g.}

\begin{verbatim}
      CALL EMS_FMTI( 'TOKEN', '1X, I10', VALUE )
\end{verbatim}

For the EMS\_SETx and the EMS\_FMTx routines, {\em x} corresponds to one of 
five standard Fortran 77 data types:

\begin {center}
\begin {tabular}{||c|c||}
\hline
{\em x} & {\em Fortran Type}\\
\hline
D & DOUBLE PRECISION\\
R & REAL\\
I & INTEGER\\
L & LOGICAL\\
C & CHARACTER\\
\hline
\end {tabular}
\end {center}

These routines are analogous to the subroutines MSG\_SETx and MSG\_FMTx,
provided by the Message Reporting System (see SUN/104). 
All defined message tokens are annulled by a call to EMS\_ANNUL, EMS\_ELOAD,
EMS\_MLOAD or EMS\_REP.
They may be renewed to their previous defined values by a call to EMS\_RENEW.


\section {Reporting Fortran I/O and Operating System Errors}

Two subroutines are provided by the Error Message Service to enable a message
token to be built from the error flag value returned from either Fortran I/O
operations or operating system routines.
These subroutines are

\begin {quote}
\begin{verbatim}
EMS_FIOER( TOKEN, IOSTAT )
\end{verbatim}
\end {quote}

and

\begin {quote}
\begin{verbatim}
EMS_SYSER( TOKEN, SYSTAT )
\end{verbatim}
\end {quote}

The subroutine EMS\_FIOER will associate the given message token with the 
message derived from the Fortran I/O status code IOSTAT.
The behaviour of this subroutine is the same as ERR\_FIOER (see SUN/104).
The subroutine EMS\_SYSER may be used to associate the given message token
with the operating system message associated with a system status flag SYSTAT.
The behaviour of this subroutine is the same as ERR\_SYSER (see SUN/104).
On completion, each of these subroutines returns its second argument
unchanged. 

It should be noted that the messages returned using these subroutines 
will depend on the operating system upon which EMS has been implemented. 
The error messages returned by operating systems vary considerably in their
clarity and so should not be solely relied upon to provide informative error 
reports.


\section {Message Output}

\subsection {No EMS\_FLUSH}

At the risk of belabouring the point, the Error Message Service provides no 
callable facility for delivering messages to the user, {\em i.e.} there is 
no analogue to ERR\_FLUSH provided by EMS for the programmer.
This is a direct result of the binding of ERR to the particular 
software environment being used.
In the Error Message Service no such binding can be used reliably.
EMS is only able to stack and annul error messages and to
control error deferral using the same error table as the ERR subroutine
library. 
Responsibility for the delivery of error messages to the user therefore rests
with the ERR library.

Clearly, this strategy can only work if ERR\_FLUSH is called at some point, 
since errors may be reported using EMS\_REP, but they have no controllable 
mechanism for reaching the user except ERR\_FLUSH.
To overcome this shortcoming, EMS has two features: one for when 
EMS is used without an environment present (stand-alone EMS) and one for when
EMS is used from within an environment.


\subsection {EMS without an environment}

Outside any environment EMS has to have some reliable mechanism for ultimately
delivering any reported error messages to the user, since it cannot be
guaranteed that the ERR library is being used at the level of the application.
This is achieved by the having the initial error context level of EMS deliver 
any reported error message immediately to the user using a Fortran WRITE 
statement: {\em i.e.} if all an application does is call EMS\_REP, then all
error messages are immediately delivered to the user when they are reported.
Any higher error context level, set with a call to EMS\_MARK or EMS\_BEGIN,
will have the effect of deferring message output until the error reporting 
context is returned to its initial level with calls to EMS\_RLSE 
or EMS\_END.
Any deferred error messages will then be delivered to the user, any reported
error messages in this context will again be delivered immediately to the user.

The behaviour of EMS without an environment present means that it is essential
for error reporting contexts to be properly nested within a package and for a
subroutine library using EMS not to exit at a context level other than the
one at which it was invoked.
If context levels are incorrectly nested within a package it can lead to 
EMS failing to deliver reported error messages when an application goes wrong.
Because the nested use of EMS\_MARK and EMS\_RLSE (or EMS\_BEGIN and 
EMS\_END) is normally confined within the same routine, incorrect nesting 
of context levels will normally result from simple programming errors which can
be easily traced.
However, there is no simple safeguard against the incorrect nesting of error
context levels provided by EMS: thorough testing is the most effective
approach.


\subsection {EMS within an environment}

When using EMS from within an environment, there are three ERR routines 
which respectively start up, clear and stop the Error Reporting System within
the environment: ERR\_START, ERR\_CLEAR and ERR\_STOP.
They ensure that the delivery of any reported error messages within the 
environment is deferred and that any undelivered messages are output to the
user when the application has finished.
These subroutines are discussed in Appendix \ref{ADAM_sect}.


\section {Intercepting Messages}

Although there is no callable provision for message output directly from the
EMS, the  output of messages at this level in the ADAM subroutine hierarchy is
still possible. 
It can be done by intercepting any pending error messages within the current
error context (or informational messages) using a character variable, and then 
using a private package-related mechanism for the output of the message. 
Here, the mechanism used to output the message, {\em e.g.} to a log file, and
its resilience to failure must be the responsibility of the subroutine library
calling EMS.
The use of private package equivalents to MSG\_OUT or ERR\_FLUSH must be fully
justified and the justification presented in the documentation for the
subroutine library concerned.

\begin {sloppypar}
The Error Message Service provides two subroutines to access messages via a
character variable: EMS\_MLOAD and EMS\_ELOAD.
EMS\_MLOAD has the calling sequence
\end {sloppypar}

\begin{verbatim}
      CALL EMS_MLOAD( PARAM, TEXT, OPSTR, OPLEN, STATUS )
\end{verbatim}

The argument PARAM is the message name, TEXT is the message text, OPSTR is the
returned message text, OPLEN is the
length of the message in OPSTR and STATUS is the inherited status. 
These arguments are the same as those for MSG\_LOAD (see SUN/104).
The behaviour of EMS\_MLOAD is to expand any message tokens in the message text
and return it through the character variable OPSTR.
If the message text is longer than the declared length of OPSTR, then the
message is truncated with an ellipsis, {\em i.e.} ``\ldots'', but no error 
results.

EMS\_ELOAD has the calling sequence

\begin{verbatim}
      CALL EMS_ELOAD( PARSTR, PARLEN, OPSTR, OPLEN, STATUS )
\end{verbatim}

The argument PARSTR is the returned message name, PARLEN the length of the
message name in PARSTR.
OPSTR is the returned error message text, OPLEN is the length of
the error message in OPSTR.
STATUS is the status value associated with the {\em next} error message stacked
for output.
These arguments are the same as those for ERR\_LOAD (see SUN/104).
The behaviour of EMS\_ELOAD is to return messages from the current error
context, one by one in a series of calls to EMS\_ELOAD, through the character
variable OPSTR. 
EMS\_ELOAD returns the status value SAI\_\_OK when the last message has been 
returned.
If the message text is longer than the declared length of OPSTR, then the
message is truncated with an ellipsis, {\em i.e.} ``\ldots'', but no error 
results.

The symbolic constants EMS\_\_SZPAR and EMS\_\_SZMSG are provided for declaring
the lengths of character variables which are to receive message names and 
error messages in this way.
These constants are defined in the include file EMS\_PAR 
(Appendix \ref{incl_sect}).


\section {C Language Interface}

Because a significant amount of environment software may be written in the C
programming language, a C language interface exists for EMS.
A C function equivalent exists for each of the Fortran EMS routines except
EMS\_FIOER: since this routine is specific to the Fortran language it has been
omitted.
A list of the C interface function prototypes is provided in Appendix
\ref{C_sect}.

The functions {\bf ems\_fmtc\_c} and {\bf ems\_set\_c} have the argument 
{\bf maxchar}, not found in their equivalent Fortran call sequences.
This argument represents the maximum allowable string length for the character
value and is necessary for the use of C character strings  which are not
terminated in the standard way ({\em e.g.} because they have resulted from
packages written in another language).
Normally, the argument {\bf maxchar} is given the global constant EMS\_\_SZTOK.

The correspondence between ANSI Fortran 77 data types and ANSI C data types
is not defined: {\em i.e. it is implementation dependent}.
However, the most likely correspondence can be assumed and this has been coded
into the C language interface.
This correspondence is apparent from the C interface function prologues
provided in Appendix \ref{C_sect} and is summarised in the following table:

\begin {center}
\begin {tabular}{||c|c||}
\hline
{\em C Type} & {\em Fortran Type}\\
\hline
double & DOUBLE PRECISION\\
float & REAL\\
int & INTEGER\\
int & LOGICAL\\
char & CHARACTER\\
\hline
\end {tabular}
\end {center}

Note that the interpretation of the {\bf int lvalue} argument presented to 
the functions {\bf ems\_setl\_c} and {\bf ems\_fmtl\_c} is that defined
by the ANSI C language.
These two functions ensure the correct Fortran 77 LOGICAL value  will be used
in the corresponding Fortran subroutine call.


\section {Compiling and Linking with the Error Message Service}

\subsection {Use with the VAX/VMS operating system}


Three include files are available for use with the Error Message Service.
These files have the logical names SAE\_PAR, EMS\_PAR and EMS\_ERR.
SAE\_PAR is included to define the global constants SAI\_\_OK, SAI\_\_ERROR 
and other global constants.
EMS\_PAR is included to define constants associated with the EMS routines and
EMS\_ERR is included to define the EMS error values.
The logical names required for the use of the stand-alone EMS library are
defined by executing the procedure EMS\_DEV, {\em e.g.}

\begin {quote}
\begin{verbatim}
$ EMS_DEV
\end{verbatim}
\end {quote}

All the logical names required during the compilation of ADAM system software
using EMS are defined by the ADAM development start-up procedures.

To link the EMS library with stand-alone software the linker input specifier

\begin {quote}
\begin{verbatim}
EMG_LINK/OPT
\end{verbatim}
\end {quote}

is used. 
For example, a typical link operation would be

\begin {quote}
\begin{verbatim}
$ LINK PROGRAM, EMG_LINK/OPT
\end{verbatim}
\end {quote}
To link a library with the ADAM version of EMS, say when building a shareable
image, the linker input specifier 

\begin {quote}
\begin{verbatim}
EMG_LINK_ADAM/OPT
\end{verbatim}
\end {quote}

is used.

To use the C language interface to EMS it is necessary to include the file
{\bf ems.h}.
This file contains the function prototypes for each of the C interface
functions.
Also, the files {\bf ems\_err.h} and {\bf ems\_par.h} respectively define the 
EMS error codes and global constants for use within the C language.
Finally, the file {\bf sae\_par.h} provides the standard Starlink global 
constants.
(See Appendix \ref{incl_sect} for details of the symbolic constants defined in
these files.)
The syntax

\begin{verbatim}
# include "sae_par.h"
# include "ems.h"
\end{verbatim}

should be used within the C code.

Again, all the logical names required for compiling ADAM system software using
EMS are defined by the ADAM development start-up procedures, and the logical
names required for using the stand-alone version of EMS are defined by
executing the procedure EMS\_DEV.
To link the EMS library with stand-alone or ADAM software the command lines
are the same as those for Fortran.


\subsection {Use with the UNIX operating system}

The three include files available for use with the Error Message Service
are named {\bf sae\_par}, {\bf ems\_par} and {\bf ems\_err} on UNIX
machines, and reside in the directory {\bf /star/include}.
UNIX does not have an equivalent to the VAX/VMS logical name and its nearest
analogue, the soft link, is not used in the include file conventions.
When including these files within Fortran code, the full path name is required,
{\em e.g.}

\begin{verbatim}
*  Global Constants:
      INCLUDE '/star/include/sae_par'
\end{verbatim}

\begin {sloppypar}
Assuming all Starlink directories have been added to the environment variables 
{\bf PATH} and {\bf LD\_LIBRARY\_PATH} (see SUN/118), then to link a 
non-ADAM program with the stand-alone version of the 
Error Message Service the command line would be
\end {sloppypar}

\begin {quote}
\begin{verbatim}
% f77 program.o `ems_link` -o program.out
\end{verbatim}
\end {quote}

Similarly, to link an ADAM application with the ADAM version of the 
Error Message Service the command line would be 

\begin {quote}
\begin{verbatim}
% f77 adam_application.o `ems_link_adam` -o adam_application.out
\end{verbatim}
\end {quote}

To use the C interface to EMS, the include statements are no different from
those recommended for the VAX/VMS implementation, {\em e.g.}

\begin{verbatim}
# include "sae_par.h"
# include "ems.h"
\end{verbatim}

The compilation of C code should be used with the directive {\bf -I
/star/include}, for example the command to compile a C program might be

\begin {quote}
\begin{verbatim}
% cc -c -I /star/include program.c
\end{verbatim}
\end {quote}

\begin {quote}
{\em Note that the command used to invoke the C compiler varies from 
one UNIX implementation to another (indeed, there may be more than one C
compiler available on the same machine) -- you should therefore check this
with your Site Manager before proceeding.}
\end {quote}

Because the EMS C interface calls Fortran routines it is also necessary to
explicitly link with the required Fortran libraries, {\em e.g.}

\begin {quote}
\begin{verbatim}
% cc program.o `ems_link` -lF77 -lm -o program.out
\end{verbatim}
\end {quote}

The naming and number of the Fortran libraries differs between UNIX machines 
and so it is advisable to check in the relevant Fortran documentation for 
further details.


\section {References}

\begin {trivlist} \item[]
\begin {tabular}{lll}
Lawden, M.D. & 1989. & SG/4 --- ADAM -- The Starlink Software Environment.\\
Rees, P.C.T. & 1990. & SUN/104 --- MSG and ERR -- Message and Error Reporting
Systems.\\
\end {tabular}
\end {trivlist}

\newpage
\appendix
\section {Include Files} \label{incl_sect}

There are three include files used by the Error Message Service to define
global constants during compilation. 
These files have the logical names SAE\_PAR, EMS\_PAR and EMS\_ERR.
The contents of each of these include files are given below.

\begin {description}
\item [SAE\_PAR] Defines the Starlink global constants.
\subitem {\bf SAI\_\_ERROR} -- Error encountered.
\subitem {\bf SAI\_\_OK} -- No error.
\subitem {\bf SAI\_\_WARN} -- Warning.
\indexspace
\item {\bf EMS\_PAR} Defines the Error Message Service constants.
\subitem {\bf EMS\_\_SZMSG} -- Maximum length of error message text.
\subitem {\bf EMS\_\_SZPAR} -- Maximum length of error message name.
\subitem {\bf EMS\_\_SZTOK} -- Maximum length of message token text.
\indexspace
\item {\bf EMS\_ERR} Defines the Error Message Service errors.
\subitem {\bf EMS\_\_BADOK} -- Status set to SAI\_\_OK in call to EMS\_REP
(improper use of EMS\_REP).
\subitem {\bf EMS\_\_CXOVF} -- Error context stack overflow (EMS fault).
\subitem {\bf EMS\_\_EROVF} -- Error message stack overflow (EMS fault).
\subitem {\bf EMS\_\_NOMSG} -- No error messages pending output.
\subitem {\bf EMS\_\_NSTER} -- Error in nested calls to EMS\_BEGIN and EMS\_END
(improper use of EMS).
\subitem {\bf EMS\_\_OPTER} -- Error encountered during message output.
\subitem {\bf EMS\_\_UNSET} -- Status not set in call to EMS\_REP (improper
use of EMS\_REP). 
\end {description}

\newpage
\section {Subroutine List}

\begin {description} 
\item [EMS\_ANNUL] ( STATUS ) 
\subitem Annul the contents of the current error context.
\indexspace
\item [EMS\_BEGIN] ( STATUS )
\subitem Begin a new error reporting environment.
\indexspace
\item [EMS\_ELOAD] ( PARSTR, PARLEN, OPSTR, OPLEN, STATUS ) 
\subitem Return messages from the current error context.
\indexspace
\item [EMS\_END] ( STATUS )
\subitem End the current error reporting environment.
\indexspace
\item [EMS\_FIOER] ( TOKEN, IOSTAT ) 
\subitem Assign a Fortran I/O error message to a token.
\indexspace
\item [EMS\_FMTx] ( TOKEN, FORMAT, VALUE ) 
\subitem Formatted encoding of a given value. 
\indexspace 
\item [EMS\_LEVEL] ( LEVEL )
\subitem Inquire the current error context level.
\indexspace
\item [EMS\_MARK] \hfill
\subitem Start a new error context.
\indexspace
\item [EMS\_MLOAD] ( PARAM, TEXT, OPSTR, OPLEN, STATUS ) 
\subitem Expand and return a message. 
\indexspace 
\item [EMS\_RENEW] \hfill
\subitem Renew any annulled message tokens in the current context.
\indexspace
\item [EMS\_REP] ( PARAM, TEXT, STATUS ) 
\subitem Report an error message.
\indexspace
\item [EMS\_RLSE] \hfill
\subitem Release (i.e. end) the current error context.
\indexspace
\item [EMS\_SETx] ( TOKEN, VALUE ) 
\subitem Concise encoding of a given value. 
\indexspace 
\item [EMS\_STAT] ( STATUS )
\subitem Inquire the last reported error status.
\indexspace
\item [EMS\_SYSER] ( TOKEN, SYSTAT ) 
\subitem Assign an operating system error message to a token.
\end {description}

\newpage
\section {C Interface Function Prototypes} \label{C_sect}

\begin {description} 
\item void {\bf ems\_annul\_c} ( int *status );
\subitem Annul the contents of the current error context.
\indexspace
\item void {\bf ems\_begin\_c} ( int *status );
\subitem Begin a new error reporting environment.
\indexspace
\item void {\bf ems\_eload\_c} ( char *parstr, int *parlen, char *opstr, 
int *oplen, int *status );
\subitem Return messages from the current error context.
\indexspace
\item void {\bf ems\_end\_c} ( int *status );
\subitem End the current error reporting environment.
\indexspace
\item void {\bf ems\_fmtc\_c} ( const char *token, const char *format, 
const char *cvalue, int maxchar );
\subitem Formatted encoding of a given CHARACTER value. 
\indexspace 
\item void {\bf ems\_fmtd\_c} ( const char *token, const char *format, 
double dvalue );
\subitem Formatted encoding of a given DOUBLE PRECISION value. 
\indexspace 
\item void {\bf ems\_fmti\_c} ( const char *token, const char *format, 
int ivalue );
\subitem Formatted encoding of a given INTEGER value. 
\indexspace 
\item void {\bf ems\_fmtl\_c} ( const char *token, const char *format, 
int lvalue );
\subitem Formatted encoding of a given LOGICAL value. 
\indexspace 
\item void {\bf ems\_fmtr\_c} ( const char *token, const char *format, 
float rvalue );
\subitem Formatted encoding of a given REAL value. 
\indexspace 
\item void {\bf ems\_level\_c} ( int *level );
\subitem Inquire the current error context level.
\indexspace
\item void {\bf ems\_mark\_c} ( void );
\subitem Start a new error context.
\indexspace
\item void {\bf ems\_mload\_c} ( const char *param, const char *text, 
char *opstr, int *oplen, int *status );
\subitem Expand and return a message. 
\indexspace 
\item void {\bf ems\_renew\_c} ( void );
\subitem Renew any annulled message tokens in the current context.
\indexspace
\item void {\bf ems\_rep\_c} ( const char *param, const char *text, 
int *status );
\subitem Report an error message.
\indexspace
\item void {\bf ems\_rlse\_c} ( void );
\subitem Release (i.e. end) the current error context.
\indexspace
\item void {\bf ems\_setc\_c} ( const char *token, const char *cvalue, 
int maxchar );
\subitem Concise encoding of a given CHARACTER value. 
\indexspace 
\item void {\bf ems\_setd\_c} ( const char *token, double dvalue );
\subitem Concise encoding of a given DOUBLE PRECISION value. 
\indexspace 
\item void {\bf ems\_seti\_c} ( const char *token, int ivalue );
\subitem Concise encoding of a given INTEGER value. 
\indexspace 
\item void {\bf ems\_setl\_c} ( const char *token, int lvalue );
\subitem Concise encoding of a given LOGICAL value. 
\indexspace 
\item void {\bf ems\_setr\_c} ( const char *token, float fvalue );
\subitem Concise encoding of a given REAL value. 
\indexspace 
\item void {\bf ems\_stat\_c} ( int *status );
\subitem Inquire the last reported error status.
\indexspace
\item void {\bf ems\_syser\_c} ( const char *token, int systat );
\subitem Assign an operating system error message to a token.
\end {description}

\newpage
\section {Subroutine Specifications}

\begin {small}
\sstroutine{
   EMS\_ANNUL
}{
   Annul the contents of the current error context
}{
   \sstdescription{
      Any pending error messages for the current error context are annulled,
      i.e. deleted. The values of any existing message tokens become
      undefined and the value of the status argument is reset to SAI\_\_OK.
   }
   \sstinvocation{
      CALL EMS\_ANNUL( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status: set to SAI\_\_OK on return.
      }
   }
}
\sstroutine{
   EMS\_BEGIN
}{
   Begin a new error reporting environment
}{
   \sstdescription{
      Begin a new error reporting environment by marking a new error
      reporting context and then resetting the status argument to SAI\_\_OK.
      If EMS\_BEGIN is called with the status argument set to an error
      value, a check is made to determine if there are any messages
      pending output in the current context: if there are none, then an
      error report to this effect will be made on behalf of the calling
      application.
   }
   \sstinvocation{
      CALL EMS\_BEGIN( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status: set to SAI\_\_OK on return.
      }
   }
}
\sstroutine{
   EMS\_ELOAD
}{
   Return error messages from the current error context
}{
   \sstdescription{
      Each message name and error message pending output in the current error
      context is copied into character variables from the error table.
      The subroutine is invoked repeatedly, returning the status value
      associated with the {\em following} error message, until all the error
      messages in the current context have been copied, indicated by
      STATUS being reset to SAI\_\_OK. At this point the current error
      context is annulled.
   }
   \sstinvocation{
      CALL EMS\_ELOAD( PARAM, PARLEN, OPSTR, OPLEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The error message name.
      }
      \sstsubsection{
         PARLEN = INTEGER (Returned)
      }{
         The length of the error message name.
      }
      \sstsubsection{
         OPSTR = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The error message.
      }
      \sstsubsection{
         OPLEN = INTEGER (Returned)
      }{
         The length of the error message.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status associated with the {\em next} error message: 
         set to SAI\_\_OK when the load is complete.
      }
   }
}
\newpage
\sstroutine{
   EMS\_END
}{
   End the current error reporting environment
}{
   \sstdescription{
      Check if any error messages are pending output in the previous
      error reporting context. If so, then annul and release the current
      context; if not, then just release the current context. Return
      the last reported status value.
   }
   \sstinvocation{
      CALL EMS\_END( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   EMS\_FIOER
}{
   Assign a Fortran I/O error message to a token
}{
   \sstdescription{
      The text of the error message associated with the Fortran I/O status
      value, IOSTAT, is assigned to the named message token. This token
      may then be included in an error message.
   }
   \sstinvocation{
      CALL EMS\_FIOER( TOKEN, IOSTAT )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message token name.
      }
      \sstsubsection{
         IOSTAT = INTEGER (Given)
      }{
         The Fortran I/O status value.
      }
   }
   \sstdiytopic{
      System-specific
   }{
      The messages generated using this facility will depend on the 
      computer system upon which the library is implemented.
   }
}
\newpage
\sstroutine{
   EMS\_FMTx
}{
   Assign a value to a message token (formatted)
}{
   \sstdescription{
      A given value is encoded using the supplied Fortran 77
      format field and the result assigned to the named message token.
      If the token is already defined, the result is appended to the
      existing token value. The given value may be one of the following
      standard Fortran 77 data types and there is one subroutine 
      provided for each data type:

      \begin {center}
      \begin {tabular}{||c|c||}
      \hline
      {\em x} & {\em Fortran Type}\\
      \hline
      D & DOUBLE PRECISION\\
      R & REAL\\
      I & INTEGER\\
      L & LOGICAL\\
      C & CHARACTER\\
      \hline
      \end {tabular}
      \end {center}

      If these subroutines fail, the token remains unmodified -- this 
      will be apparent in any messages which refer to this token.
   }
   \sstinvocation{
      CALL EMS\_FMTx( TOKEN, FORMAT, VALUE )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message token name.
      }
      \sstsubsection{
         FORMAT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Fortran 77 FORMAT field used to encode the supplied value.
      }
      \sstsubsection{
         VALUE = Fortran 77 Type (Given)
      }{
         The value to be assigned to the message token.
      }
   }
}
\sstroutine{
   EMS\_LEVEL
}{
   Inquire the current error context level
}{
   \sstdescription{
      Return the number of context markers set in the error message
      table. Any returned value greater than one indicates that the
      delivery of reported error messages is deferred.
   }
   \sstinvocation{
      CALL EMS\_LEVEL( LEVEL )
   }
   \sstarguments{
      \sstsubsection{
         LEVEL = INTEGER (Returned)
      }{
         The error context level.
      }
   }
}
\sstroutine{
   EMS\_MARK
}{
   Start a new error context
}{
   \sstdescription{
      Begin a new error reporting context so that delivery of
      subsequently reported error messages is deferred and the messages
      held in the error table. Calls to EMS\_ANNUL or EMS\_ELOAD
      will only annul or return the contents of the error table within 
      this new context.
   }
   \sstinvocation{
      CALL EMS\_MARK
   }
}
\newpage
\sstroutine{
   EMS\_MLOAD
}{
   Expand and return a message
}{
   \sstdescription{
      Any tokens in the supplied message are expanded and the result is
      returned in the character variable supplied. If the status argument
      is not set to SAI\_\_OK on entry, no action is taken except that the 
      values of any existing message tokens are always left undefined 
      after a call to EMS\_MLOAD. If the expanded message is longer than 
      the length of the supplied character variable, the message is 
      terminated with an ellipsis.
   }
   \sstinvocation{
      CALL EMS\_MLOAD( PARAM, MSG, OPSTR, OPLEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message name.
      }
      \sstsubsection{
         MSG = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The raw message text.
      }
      \sstsubsection{
         OPSTR = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The expanded message text.
      }
      \sstsubsection{
         OPLEN = INTEGER (Returned)
      }{
         The length of the expanded message.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
}
\sstroutine{
   EMS\_RENEW
}{
   Renew any annulled message tokens in the current context
}{
   \sstdescription{
      Any message tokens which have been annulled by a call to EMS\_REP,
      EMS\_ELOAD or EMS\_MLOAD in the current context are renewed. If any 
      new token value has been defined since the previous tokens were 
      annulled ({\em i.e.} using the EMS\_SETx or EMS\_FMTx routines), no 
      action is taken. The intended use of EMS\_RENEW is to renew all 
      existing message tokens immediately after a call to EMS\_ANNUL, 
      EMS\_ELOAD, EMS\_MLOAD or EMS\_REP for re-use in a subsequent message.
   }
   \sstinvocation{
      CALL EMS\_RENEW
   }
}
\newpage
\sstroutine{
   EMS\_REP
}{
   Report an error message
}{
   \sstdescription{
      Report an error message. According to the error context, the
      error message is either sent to the user or retained in the
      error table. The latter case allows the application to take
      further action before deciding if the user should receive the
      message. The values associated with any existing message tokens
      are left undefined. On successful completion, the global status
      is returned unchanged; if the status argument is set to SAI\_\_OK
      on entry, an error report to this effect is made on behalf of
      the application and the status argument is returned set to
      EMS\_\_BADOK; if an output error occurs, the status argument is
      returned set to EMS\_\_OPTER. The status argument may also be returned
      set to an EMS\_ fault error value, indicating that an error has 
      occurred within the error reporting software.
   }
   \sstinvocation{
      CALL EMS\_REP( PARAM, TEXT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The error message name.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The error message text.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status: this is left unchanged on successful
         completion, and is returned set to an EMS\_ error if an 
         internal error occurs.
      }
   }
}
\sstroutine{
   EMS\_RLSE
}{
   Release (end) an error context
}{
   \sstdescription{
      Release a {\tt "}mark{\tt "} in the error message table, returning
      the Error Message Service to the previous error context. Note that
      any error messages pending output will be passed to this previous
      context, {\em not} annulled.
   }
   \sstinvocation{
      CALL EMS\_RLSE
   }
}
\newpage
\sstroutine{
   EMS\_SETx
}{
   Assign a value to a message token (concise)
}{
   \sstdescription{
      A given value is encoded using a concise format and the result 
      assigned to the named message token. If the token is already
      defined, the result is appended to the existing token value. 
      The given value may be one of the following Fortran 77 data types 
      and there is one routine provided for each data type:

      \begin {center}
      \begin {tabular}{||c|c||}
      \hline
      {\em x} & {\em Fortran Type}\\
      \hline
      D & DOUBLE PRECISION\\
      R & REAL\\
      I & INTEGER\\
      L & LOGICAL\\
      C & CHARACTER\\
      \hline
      \end {tabular}
      \end {center}

      If these subroutines fail, the token remains unmodified -- this 
      will be apparent in any messages which refer to this token.
   }
   \sstinvocation{
      CALL EMS\_SETx( TOKEN, VALUE )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message token name.
      }
      \sstsubsection{
         VALUE = Fortran 77 Type (Given)
      }{
         The value to be assigned to the message token.
      }
   }
}
\sstroutine{
   EMS\_STAT
}{
   Inquire the last reported error status
}{
   \sstdescription{
      The current error context is checked for any messages pending
      output. If none exist, the status argument is returned set to
      SAI\_\_OK. If any messages have been reported, the status argument
      is returned set to the last reported value.
   }
   \sstinvocation{
      CALL EMS\_STAT( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status value: it is returned set to the last 
         reported error status within the current error context; if 
         none exist, it is returned set to SAI\_\_OK.
      }
   }
}
\newpage
\sstroutine{
   EMS\_SYSER
}{
   Assign an operating system error message to a token
}{
   \sstdescription{
      The text of the error message associated with the operating system
      status value, SYSTAT, is assigned to the named message token. This
      token may then be included in an error message.
   }
   \sstinvocation{
      CALL EMS\_SYSER( TOKEN, SYSTAT )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message token name.
      }
      \sstsubsection{
         SYSTAT = INTEGER (Given)
      }{
         The operating system status value.
      }
   }
   \sstdiytopic{
      System-specific
   }{
      The messages generated using this facility will depend on the 
      computer system upon which the library is implemented.
   }
}
\newpage
\end {small}

\section {Using EMS within ADAM system software} \label{ADAM_sect}

\subsection {Overview}

This document has so far discussed the use of EMS in a general context. 
In this section, specific differences between EMS and the ADAM versions of
the Message and Error Reporting Systems are presented.


\subsection {Message parameters}

In calls to the ADAM version of ERR\_REP, the error message name PARAM is a 
globally unique identifier for the error message text which corresponds to
the message parameter of the error message.
The ADAM interface file can be used to associate this message parameter with an 
error message, and only if this message parameter is not defined in the 
interface file is the argument TEXT used in the error report.
When using EMS\_REP or EMS\_MLOAD within the ADAM environment 
software, no access to the ADAM interface file exists and so the error message
given by the argument TEXT is always used.
The use of a globally unique error message name is still recommended for 
reported error messages to uniquely identify the error message text to the
programmer, using the convention outlined in SUN/104.


\subsection {Parameter references}

The ADAM versions of MSG and ERR allow reference to ADAM program
parameters within the message text. 
Reference can be made either to parameter-keyword associations or to the name of
an ADAM data system object, data file or device associated with a parameter.
In message text used in calls to MSG and ERR routines these parameter
associations are indicated by the percent, ``\%'', and dollar, ``\$'', escape
characters respectively.
EMS does not have access to the ADAM parameter system and so cannot refer
to ADAM parameters in the text of  messages.
The escape characters ``\%'' and ``\$'' are therefore treated literally as 
part of the message text in calls to EMS\_REP and EMS\_MLOAD, 
as they are in the stand-alone versions of MSG and ERR.


\subsection {Reserved tokens}

In the ADAM versions of MSG and ERR a reserved token, STATUS, can be used 
to associate a status value with a VAX/VMS operating system message.
In EMS, as in the stand-alone versions of MSG and ERR, there are no reserved
message tokens


\subsection {Synchronising message output}

Because there is no callable mechanism provided by EMS to deliver messages to
the user, no message synchronising mechanism is provided by EMS.


\subsection {Routines specific to the ADAM fixed part}

There are three ERR routines which start up, clear and stop the Error Reporting
System within the ADAM fixed part which ensure that the delivery of any 
reported error messages is deferred and that any messages pending output are 
delivered to the user when the application has finished.
These subroutines are ERR\_START, ERR\_CLEAR and ERR\_STOP.
ERR\_START has the effect of marking a new EMS context and thus deferring the
delivery of any reported error messages to the user.
ERR\_CLEAR has the effect of returning the current error context to the level
set by ERR\_START and flushing any reported error messages to the user.
ERR\_STOP clears error message table by calling ERR\_CLEAR and then returns the 
error reporting context to the initial context level, {\em i.e.} the level
prior to the call to ERR\_START.

\begin {quote}
{\em The use of these three routines is entirely reserved for starting up, 
clearing and 
stopping error reporting within the environment, {\em e.g.} the ADAM fixed 
part, and must not be used for any other purpose.}
\end {quote}

These routines exist only in the ADAM version of the ERR library and are linked
using the procedure given in SUN/104.

\newpage
\subsection {Subroutine specifications}

\begin {small}
\sstroutine{
   ERR\_CLEAR
}{
   Return the error table to the default context and flush its
   contents
}{
   \sstdescription{
      The Error Reporting System is returned to its default context
      level and any pending messages are flushed. This routine
      effectively resets the Error Reporting System:

      \sstitemlist{

         \sstitem
            unlike ERR\_FLUSH, no {\tt '}faulty application{\tt '} error message is
            reported if it is called when there are no error messages
            pending output, or if it is called with the status value set
            to SAI\_\_OK;

         \sstitem
            the error table is always annulled by a call to ERR\_CLEAR,
            irrespective of any message output errors which may occur.

      }
      On exit, the status is always returned as SAI\_\_OK.
   }
   \sstinvocation{
      CALL ERR\_CLEAR( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Implementation Notes
   }{
      This subroutine is for use only with the ADAM implementation of
      the Error Reporting System.
   }
}
\sstroutine{
   ERR\_START
}{
   Initialise the Error Reporting System
}{
   \sstdescription{
      Initialise the global variables used by the Error
      Reporting System.
   }
   \sstinvocation{
      CALL ERR\_START
   }
   \sstdiytopic{
      Implementation Notes
   }{
      This subroutine is for use only with the ADAM implementation of
      the Error Reporting System.
   }
}
\sstroutine{
   ERR\_STOP
}{
   Close the Error Reporting System
}{
   \sstdescription{
      Flush any messages pending output and return the Error Reporting 
      System to its initial state.
   }
   \sstinvocation{
      CALL ERR\_STOP( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Implementation Notes
   }{
      This subroutine is for use only with the ADAM implementation of
      the Error Reporting System.
   }
}

\newpage
\end {small}

\section {Portability}

\subsection {Overview}

This section discusses the portability of EMS, including the coding 
standard adopted for EMS and a list of those Starlink packages which 
need to be ported to the target machine before a port of EMS can proceed.

\subsection {Coding and porting prerequisites}

The standard of Fortran used for the coding of EMS is fundamentally Fortran 77,
using the Starlink Fortran coding conventions described in SGP/16.
Several common extensions to the Fortran 77 standard are used in the EMS source 
code, they are as follows:

\begin {itemize}
\item end-of-line comments using the ``!'' symbol;
\item symbolic subprogram names may be longer than six characters (but are 
always shorter than ten characters);
\item symbolic subprogram names include the ``\_'' symbol;
\item symbolic constant names may be longer than six characters (but are always
shorter than eleven characters);
\item symbolic constant names may include the ``\_'' symbol;
\item the full ASCII character set is assumed in character constants.
\end {itemize}

The EMS C interface is coded in ANSI C, according to the Starlink C coding
conventions described in SGP/4. 

To use EMS on any computer system the Starlink Character Handling
Routines (CHR, SUN/40) must be available.


\subsection {Operating system specific routines}

Several EMS routines make use of operating system calls specific to the 
machine upon which they are implemented.
The names of these routines and their purpose are as follows:

\begin {description}
\item [EMS\_FIOER] ( TOKEN, IOSTAT ) 
\subitem Assign a Fortran I/O error message to a token.
\indexspace
\item [EMS\_SYSER] ( TOKEN, SYSTAT ) 
\subitem Assign an operating system error message to a token.
\end {description}

These subroutines will have to be rewritten specifically for each new target
machine and operating system.

For the EMS C interface, the correspondence between Fortran and C
data types and the inter-language calling sequences are wrapped up as C
macros in the header file {\bf ems\_sys.h}.
This C header file ensures that no system-specific code exists in the C
interface functions.
The conditional compilation provided within the 
header file reflects all the available operating system implementations 
of the EMS C interface and must therefore be updated when porting EMS to 
new operating systems.

\section {Changes and New Features in Version 1.2}

\subsection {Changes in behaviour of existing routines}

\begin {description}
\item [EMS\_BEGIN] previously reported an error message if it was called
with a set status value and without an error report having been 
made within the current context. 
This message was associated  with the status value EMS\_\_NOREP, which was
subsequently returned by EMS\_END. 
It now associates the given status value  with this error message.
\item [EMS\_END] previously returned the last reported status value in the
error reporting context valid on exit.
It now returns the status value given in the nested call to EMS\_BEGIN, even
if this status value is not associated with the last reported error
message in the initial context.
If nested calls to EMS\_BEGIN and EMS\_END get out of sequence, the status
value EMS\_\_NSTER will be returned from EMS\_END.
\item [EMS\_MLOAD] previously only annulled any existing message tokens if the
given status value was SAI\_\_OK. 
It has been changed to {\em always} annul  any existing message tokens
regardless of the given status value.
\item [C Language Interface] now uses the type {\bf const char *} (as 
opposed to {\bf char *}) for all 
character strings given to the EMS C interface.
\end {description}

\subsection {New routines}

\begin {description}
\item [EMS\_RENEW] -- Renew any annulled message tokens in the current
context. It is intended that EMS\_RENEW be used to renew all existing 
message tokens set prior to a call to EMS\_ANNUL, EMS\_ELOAD, EMS\_MLOAD or 
EMS\_REP for re-use in a subsequent message.
\end {description}

\subsection {Other changes}

\begin {description}
\item [EMS\_DIR:LOGICAL.COM] -- This file has been renamed 
EMS\_DIR:EMS\_DEV.COM.
\item [EMS\_DIR:EMSLINK.COM] -- This file has been deleted.
\item [EMS\_DIR:EMSLINK.OPT] -- This file has been renamed 
EMS\_DIR:EMS\_LINK.OPT.
\item [Output format] -- The output format of error messages has changed:
the first error message in a flush of the error table begins with the character
sequence ``!!~'', {\em e.g.}

\begin{verbatim}
!! The first error message.
\end{verbatim}

Subsequent contextual error messages in a flush of the error table begin with
the character sequence ``!~~'', {\em e.g.}

\begin{verbatim}
!  A contextual error message.
\end{verbatim}

Continuation lines of a reported error message begin with the character
sequence ``!~~~~~'', {\em e.g.}

\begin{verbatim}
!! The first line of an error message ...
!     and its continuation onto another line.
!  A second contextual error message.
\end{verbatim}
\item [EMS error messages] -- The text for several EMS error messages has been
changed to be more informative.
\end {description}

\end {document}
