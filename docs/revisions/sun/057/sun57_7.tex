\documentstyle[11pt]{article} 
\pagestyle{myheadings}

%------------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocnumber}    {57.7}
\newcommand{\stardocauthors}   {D~L~Terrett \& Nicholas Eaton}
\newcommand{\stardocdate}      {18 September 1992}
\newcommand{\stardoctitle}     {GNS\\[2.5ex] Graphics Workstation Name Service}
\newcommand{\stardocversion}   {Version 1.4}
\newcommand{\stardocmanual}    {User's Guide}
%------------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

\renewcommand{\_}{{\tt\char'137}}
\newcommand{\routinehead}[1]{\vspace{\bigskipamount}{\large\bf#1}}
\newenvironment{routinelist}{\begin{list}{}{\setlength{\leftmargin}{2cm}
                             \setlength{\parsep}{\smallskipamount}}}{\end{list}}
\newcommand{\routine}[1]{\item\hspace{-1cm}#1\\}

\newenvironment{spec}[2]%
{\goodbreak\rule{\textwidth}{0.3mm}
{\Large {\bf#1} \hfill #2 \hfill {\bf#1}}
\begin{description}}{\end{description}}
\newenvironment{params}%
{\[\begin{tabular}{p{0.07\textwidth}p{0.20\textwidth}p{0.59\textwidth}}}%
{\end{tabular}\]}

\begin{document}
\thispagestyle{empty}
SCIENCE \& ENGINEERING RESEARCH COUNCIL \hfill \stardocname\\
RUTHERFORD APPLETON LABORATORY\\
{\large\bf Starlink Project\\}
{\large\bf \stardoccategory\ \stardocnumber}
\begin{flushright}
\stardocauthors\\
\stardocdate
\end{flushright}
\vspace{-4mm}
\rule{\textwidth}{0.5mm}
\vspace{5mm}
\begin{center}
{\Huge\bf  \stardoctitle \\ [2.5ex]}
{\LARGE\bf \stardocversion \\ [4.0ex]}
{\Huge\bf  \stardocmanual}
\end{center}
\vspace{5mm}

%------------------------------------------------------------------------------
%  Title page description
\vspace{25mm}

This document contains information for three categories of GNS consumer:

\begin{itemize}

\item {\bf The user of a graphics application}. This consumer is interested in
the syntax of graphics workstation names and need only read section \ref{wn}.

\item {\bf The system manager}. This consumer is interested in the contents
of the database and how to set up and modify it. System managers will need to
be familiar with the first part (section~\ref{dwn}), which deals with
workstation names. The remainder (section~\ref{wdt}) will be of interest to
anyone adding support for a new GKS or IDI device.

\item {\bf The application programmer}. This consumer is interested in the
programmer interface (appendix~\ref{prog}), the mechanism for reporting
errors (section~\ref{er}) and the means of compiling and linking the
programs (section~\ref{cl}).

\end{itemize}
%------------------------------------------------------------------------------

\newpage

%------------------------------------------------------------------------------
%  Add this part if you want a table of contents
\setlength{\parskip}{0mm}
\tableofcontents
\setlength{\parskip}{\medskipamount}
\markright{\stardocname}
%------------------------------------------------------------------------------

\newpage

\section{Introduction}\label{in}

Almost any program that does any graphics requires the user to identify which
graphics device is to be used. When the graphics package used by the program is
GKS, and for the majority of Starlink software it is, graphics devices are
identified by two integers, a `workstation type' and a `connection
identifier'. (`Workstation' is GKS terminology for a graphics device of any
description and this is the sense in which it is used throughout this
document.) No one can be expected to remember the workstation types of all the
devices supported by Starlink (more than 60 at present) so a package has been
provided that translates `friendly' and easy to remember names into their GKS
equivalents.

Most high level graphics packages, such as SGS and PGPLOT, call GNS to
perform the necessary name translation when a workstation is opened, so
unless you are writing programs that open GKS workstations directly
(by calling {\tt GOPWK}), or need to make specialised device inquiries,
you will not need to call any GNS routines yourself.

The graphics workstation name service package provides three sorts of service
to the users and writers of graphics subroutine libraries and applications 
programs:

\begin{itemize}

\item The translation of workstation names to their GKS equivalents.

\item Generating a list of the names and types of the graphics devices
available on a system.

\item Answering a variety of enquiries about the properties of a particular
graphics device; for example, its category (pen plotter, image display
etc.) or its device name.

\end{itemize}

GNS also provides support for the Image Display Interface (IDI) and the
Applications Graphics Interface (AGI), but in both cases the use of GNS
is internal to the package libraries and so its presence is not normally
apparent to the user.

\section{Workstation Names}\label{wn}
\subsection{GKS Names}

A GKS workstation name is a character string that represents a graphics device
that may be opened and manipulated using GKS. 
The simplest way to get a list of valid workstation names is to run the
demonstration program (section \ref{demo-prog}).
When you supply a workstation name to a program that uses GNS (either directly
or indirectly via a high level graphics package) you can abbreviate the name
provided that the abbreviation is not ambiguous. You can also supply a
logical name that translates to a workstation name; this can be used to create
``nicknames'' for devices that you use frequently.

Each workstation name identifies a device type and may also identify a
particular device (or file). For example, the workstation name {\tt CIFER\_T5}
might translate to {\tt 801} (the GKS workstation type for a Cifer T5
terminal), while {\tt IKON} might translate to {\tt 3200} and {\tt XAA0}
(the GKS workstation type and the usual device name of a Digisolve Ikon). 

If a name translates to just a workstation type then a  ``default'' device
is used. All device types have a default device name associated with them,
and this is most important for terminals where the default is the terminal
from which the program is being run. In this case the default device name
depends on which terminal is being used.

The device name implied by a workstation name can be overridden by
appending a semicolon followed by a new device or file name to the
workstation name. For example, the name {\tt IKON;XAB0} would use {\tt
XAB0} instead of {\tt XAA0}. This facility can also be used with
workstations that write files rather than driving the graphics device
directly in order to place the files in a directory other than the current
default. For example, {\tt CANON;disk\$scratch:[scratch]myplot.dat} could
be used to place the plot file on a scratch disk.

If an explicit device name is supplied there are no checks made to ensure
that the device is the right type; attempting to use the wrong type will
either cause the attempt to open the GKS workstation to fail or garbage to
be sent to the device.

An application program can also override the device name {\em implied\/} by a
workstation name; if it does, the program's documentation should make this
clear. An application cannot override a device name which is supplied
{\em explicitly\/} as part of a workstation name.

It is also possible to specify an explicit GKS device type and connection
identifier as a pair of integers separated by a comma, space or underscore. If
the connection identifier is omitted, it defaults to zero.

Finally, a workstation name can be a VMS logical name (or UNIX environment
variable) that translates to a valid workstation name (which can be another
logical name). Any explicit device
name is removed before the translation is attempted and the first device name
encountered is the one that is used; any subsequent device names are ignored.
Logical name translation continues recursively until either no translation is
found or the resulting name begins with ``{\tt GKS\_}''.

\subsection{IDI Names}

An IDI workstation (or device) name is simply a character string (for example,
{\tt IKON}) which identifies an image display and its type. The default 
device name can be overridden by appending a semicolon followed by the new
device name after the workstation name. For example the name {\tt IKON;XAB0}
would use {\tt XAB0} instead of {\tt XAA0}. Logical names can be set up and
translation proceeds recursively until a name is found that does not
translate to another name.

\subsection{GWM windows}

There are some special features of GNS that apply to GWM window devices;
these are X window display devices under the control of the Graphics
Window Manager. All GWM windows have a name (usually displayed in the title
bar) which need not be the same as the workstation name supplied at a prompt
or as an argument to a routine such as GNS\_TNG. This window name is the one
that is supplied as an argument to the xmake or xdestroy facilities. When a
GWM window is accessed through GNS (for both GKS and IDI) the supplied
workstation name is translated into a GWM window with a default name. For
instance the workstation name "xwindows" usually translates into a window
named "xwindows". Note that the GKS workstation name "xoverlay" also
translates into a window named "xwindows" because the overlay device is part
of the same GWM window.

Both GKS and IDI will create a new GWM window with the default name
if one does not already exist. The default window name can be overridden
by using the device name field of the workstation name. The device name
field is separated from the workstation name by a semi-colon; thus the
string `xw;bert' is parsed into the workstation name `xw' and the device
name `bert'. The device name supersedes the default and so a window
named `bert' is used rather than one named `xwindows'

By default a GWM window created by a GKS or IDI graphics application
will not have an overlay plane unless the overlay option is specified
in the X defaults file. The user can request that a window is created
with an overlay plane by appending a `+' to the name when prompted for
it. Thus the workstation name `xwindows+' or `xw+' will result in a
GWM window with an overlay. Note that when using GKS specifying `xw+'
will create a window with an overlay, but the drawing will be done in
the base plane (specifying `xoverlay' automatically results in a window
with an overlay).

\subsection{Demonstration Program}\label{demo-prog}

A complete list of all the workstation names defined on your current node can
be obtained by running the program {\tt GNS\_DIR:GNSRUN} (on UNIX
{\tt /star/bin/examples/gnsrun}). Depending on the set up of the database
you may obtain different lists on different nodes of the cluster.
After listing all the GKS names along with a short description of each
workstation, the program prompts for a workstation name. If one of the names
in the list (or any other valid workstation name) is entered, a simple
demonstration picture is plotted on the device selected. The IDI devices are
then listed and again a demonstration plot can be generated by providing an
appropriate device name.

If running the program produces any unexpected error messages
you should report them to your system manager; however, you should not
necessarily expect all workstations on the lists to be useable. A device could,
for example, be in use by someone else.

\section{Database Management}\label{dm}
\subsection{Workstation Names}\label{dwn}

It is the responsibility of the system manager to set up and maintain the
database of workstation name translations.
This section describes the structure of the database and the modifications
that the system manager typically has to make when installing the system.
Template files showing the required format for the database names file
exist for each graphics package supported; these can be found in
{\tt GNS\_DIR:GKSNAMES.TEMPLATE} and {\tt GNS\_DIR:IDINAMES.TEMPLATE}.
These files show some optional fields such as node name and sequence number
in angled brackets; when creating a version of the {\tt GKSNAMES.DAT} or
{\tt IDINAMES.DAT} file from the templates these optional fields should be
filled in or deleted.

\subsubsection{GKS Names}\label{GKS-names}

The GKS workstation names are stored in a text file which is opened using the
logical name {\tt GNS\_GKSNAMES} (which usually translates to {\tt
GNS\_DIR:GKSNAMES.DAT}). (On UNIX the file is located by the explicit
path name {\tt /star/etc/gns\_gksnames}).
Each line in the file describes one workstation name
and contains the name, the GKS workstation type that it translates to, the
device name of the workstation, a short description of the workstation and,
optionally, the VAXcluster node from which the device is accessible and a
sequence number (see subsequent section). The
fields are separated by the slash ({\tt/}) character and a complete record
might look like:
\begin{verbatim}
      IKON_A/3200/XAA0:/Ikon Image display A/NODEA/ 1/
\end{verbatim}
However, the device name field is usually blank which means that the
default device associated with the workstation type is used, the node field
will usually be blank as most devices are common to all nodes in a cluster
and the sequence number will normally be absent;
so most records in the file will be more like:
\begin{verbatim}
      TEK4010/201/ /Tektronix 4010 terminal/
\end{verbatim}
Note that on VMS the trailing colon must be included in a physical device name.
An explicit device name is only required when you need different names for two
or more devices of the same type. On a system which is not part of a VAXcluster
(or more precisely on system that does not have the sysgen parameter SCSNODE
set) the node name field {\em must} be omitted.

For X window devices the device name is used as the GWM window name, and the
sequence number should be left blank. The device name field is case sensitive
and lower case window names are used for compatibility with UNIX boxes.
\begin{verbatim}
      XWINDOWS/3800/xwindows/X Windows/
\end{verbatim}

If a device such as an image display is available on more than one node of a
cluster, the same name can be used for device on all nodes by duplicating the 
workstation name definition with different node name specifications. For
example if cluster nodes {\tt NODEA} and {\tt NODEB} both have Ikons (but {\tt
NODEC} doesn't) the file could contain:
\begin{verbatim}
      IKON/3200/XAA0:/Ikon Image display A/NODEA/
      IKON/3200/XAA0:/Ikon Image display A/NODEB/
\end{verbatim}
The system is distributed with a file containing a name for every workstation
type supported by RAL-GKS and so will work without any modification. However,
programs that list the available workstations will
present users with a long list of workstation names, most of which
cannot be used, so the first task is to delete from the file the definitions
for devices that are not available on your system. 

As well as eliminating extraneous names from listings of available workstations
this will also make abbreviations more useful. For example, some of the 
names are somewhat unwieldy because they have to be able to distinguish between
different devices made by the same manufacturer such as {\tt CIFER\_T5} for the
Cifer T5 terminal and {\tt CIFER\_2634} for the Cifer 2634. If, on a system with
only one sort of Cifer terminal the unwanted name is deleted, then {\tt
CIFER} becomes an acceptable abbreviation.

Any new names you wish to define can be added to the file. For example,
additional names will have to be defined on systems with more than one image
display of the same type (for example, {\tt IKON\_1} and {\tt IKON\_2}
referring to {\tt XAA0} and {\tt XAB0} respectively).

Having edited {\tt GKSNAMES.DAT} you should test the system by running the
demonstration program described in section \ref{demo-prog}. On a cluster
it is worth running the program on each of the nodes.

A copy of the complete list of names can be found in {\tt GKSNAMES.TEMPLATE} so
that names you have deleted can easily be restored if you acquire new graphics
devices in the future.

\subsubsection{IDI Names}

The IDI workstation names are stored in a text file which is opened using the
logical name {\tt GNS\_IDINAMES} (which usually translates to {\tt
GNS\_DIR:IDINAMES.DAT}). (On UNIX the file is located by the explicit
path name {\tt /star/etc/gns\_idinames}).
Each line in the file describes one workstation name
and contains the name, the IDI workstation type that it translates to (a two
or three character code), the
device name of the workstation, a short description of the workstation and,
optionally, the VAXcluster node from which the device is accessible and a
sequence number (see next section). For example:
\begin{verbatim}
      IKON/IK/XAA0:/Ikon Image display A/NODEA/ 1/
      XWINDOWS/XW/xwindows/X Windows/NODEC/ /
      X2WINDOWS/XW2/xwindows2/X Windows/NODEC/ /
\end{verbatim}
The use of the node name field is the same as for GKS names
(see section~\ref{GKS-names}). For X window devices the first two characters
of the workstation type must be 'XW', the device name is a string (up to
10 characters) which is used as the GWM window name, and the sequence
number should be left blank. The device name field is case sensitive and
lower case window names are used for compatibility with UNIX boxes.

\subsubsection{Sequence numbers}

The sequence number can be thought of as a kind of serial number which
uniquely identifies a device. The main purpose of the sequence number
is to uniquely identify two or more display devices of the same type
(e.g.~Ikons) on the same node. Each device has to have its own sequence
number as in the following GKS example:
\begin{verbatim}
      IKON_1/   3200/XAA0:/Ikon Image display 1/NODEA/ 1/
      IKONOV_1/ 3201/XAA0:/Ikon Image overlay 1/NODEA/ 1/ 
      IKON_2/   3200/XAB0:/Ikon Image display 2/NODEA/ 2/
      IKONOV_2/ 3201/XAB0:/Ikon Image overlay 2/NODEA/ 2/
\end{verbatim}
The sequence number refers to the physical device, so that devices that
have multiple names should have the same sequence number. This also
applies to devices that have multiple GKS workstation types, such as an
overlay plane, or display with VT terminal interface, as in the above
example.

If a sequence number has been set in the {\tt GKSNAMES} file and the same
device has an entry in the {\tt IDINAMES} file then it should be given
the same sequence number (and vice versa). That is if a device supports
both GKS and IDI then the sequence number should be the same in both files.
Continuing the previous example the {\tt IDINAMES} file would have
the following entries:
\begin{verbatim}
      IKON_1/IK/XAA0:/Ikon Image display 1/NODEA/ 1/
      IKON_2/IK/XAB0:/Ikon Image display 2/NODEA/ 2/
\end{verbatim}

A sequence number is an integer in the range 1 to 99. If the sequence number
is not present in the database then a default value of 0 is used.

\subsection{Workstation Description Table}\label{wdt}

\subsubsection{GKS Descriptions}

The workstation description file only needs to be modified if a new device type
is supported by GKS so this section will only be of interest to someone adding
a new workstation handler.

The workstation description table is stored in a binary file which is opened
using the logical name {\tt GNS\_GKSDEVICES} (which usually translates to {\tt
GNS\_DIR:GKSDEVICES.DAT}). (On UNIX the file is located by the explicit
path name {\tt /star/etc/gns\_gksdevices}).
This binary file is built from a text version of the
description table by running {\tt GNS\_DIR:GKSBUILD.EXE}.

The description table distributed with the system contains an entry for every
workstation type supported by GKS-UK and is built from the text file {\tt
GNS\_DIR:GKSDEVICES.TXT} which can be used as a template for any changes or
additions.

The text file looks something like:

\begin{verbatim}
      WORKSTATION = 10
         CLASS = METAFILE_INPUT
         OUTPUT =  FILE
      WORKSTATION = 50
         CLASS = METAFILE_OUTPUT
         OUTPUT = FILE
      WORKSTATION = 101
         CLASS = TERMINAL
         SCALE = 3.3833E-4
         OUTPUT = DIRECT
         CLEAR = SELECTIVE
\end{verbatim}

Each workstation description starts with {\tt WORKSTATION =} {\em type} and
contains a list of statements of the form {\em keyword} {\tt =} {\em value}.

The value field takes one of the following forms:
\begin{description}
\item[Integer] A decimal integer.
\item[Real] A real number constructed according to the usual FORTRAN rules but
without any imbedded spaces.
\item[Keyword] A character keyword.
\item[Character string] A character string delimited by the first non-space 
character following the equals sign and the next occurrence of that same 
character.
When character strings are being interpreted the {\tt\char94} character is used
as an ``escape'' character for inserting control characters (e.g. control Z
(ASCII 26) is represented by {\tt\char94 Z}). A literal {\tt\char94} character
is represented by {\tt\char94\char94}.
\end{description}

The only mandatory keyword is {\tt CLASS} which indicates to which category of
device the workstation belongs and must have one of the following
keywords as its value:

\[\begin{tabular}{l}
\tt GRAPHICS\_OVERLAY\\
\tt IMAGE\_DISPLAY\\
\tt IMAGE\_OVERLAY\footnotemark\\
\tt MATRIX\_PRINTER\\
\tt METAFILE\_INPUT\\
\tt METAFILE\_OUTPUT\\
\tt PEN\_PLOTTER\\
\tt TERMINAL\\
\tt WINDOW\\
\tt WINDOW\_OVERLAY
\end{tabular}\]
\footnotetext{an image overlay is a graphics overlay 
that is also capable of plotting cell arrays}

For all workstation types other than those of class {\tt TERMINAL}, {\tt
METAFILE\_INPUT} and {\tt METAFILE\_OUTPUT} the keyword {\tt
DEFAULT\_NAME} is also mandatory. The value must be the name of the
device used when the workstation is opened with a connection identifier of
0. For devices of class {\tt TERMINAL} the logged-on terminal is used in
these circumstances. 

Other keywords describe such things as the
approximate size of ``device units'' and a character string that can be
used to clear the text screen of a terminal.

A complete list of all the keywords that can appear in the description file
can be found in appendix~\ref{key}.

\subsubsection{IDI Descriptions}

There is an equivalent description file for IDI stored in a binary file
pointed to by the logical name {\tt GNS\_IDIDEVICES}. 
(On UNIX the file is located by the explicit path name
{\tt /star/etc/gns\_gksnames}).
This binary file is built from a text version of the description table by
running {\tt GNS\_DIR:\-IDIBUILD.EXE}. At present the description table only
contains one entry which is the {\tt AGITYPE}; this is mandatory for an IDI
workstation. The text file looks something like:

\begin{verbatim}
      WORKSTATION = /IK/
         AGITYPE = 3200
      WORKSTATION = /XW/
         AGITYPE = 3800
      WORKSTATION = /XW2/
         AGITYPE = 3801
\end{verbatim}

\section{Error Messages}\label{er}

All GNS routines use the so called {\em inherited status strategy}, which means
that if the {\tt STATUS} argument is not set to the value {\tt SAI\_\_OK}
(equals zero) on entry the routine will exit without performing any action. If
an error occurs during the execution of a routine, {\tt STATUS} will be set to
one of the values defined in the FORTRAN include file {\tt GNS\_ERR}.

GNS now uses the error message service (EMS) to report errors. This means
that it is no longer necessary to call the routine {\tt GNS\_MSG} to obtain
a meaningful error message. The description of the routine {\tt GNS\_MSG}
has therefore been removed from this user note, but the routine still exists
in the object library so that existing applications which use it do not have
to be altered.

\section{Compiling and Linking Programs with GNS}\label{cl}

\subsection{VAX/VMS Systems}

The link procedures for most high level graphics packages (e.g. IDI, SGS etc.)
and for ADAM programs already contain a reference to GNS. Programs that do not
link with such packages can be linked to GNS by first executing the command
\begin{verbatim}
      $ GNS_DEV
\end{verbatim}
and then by including the options file {\tt GNS\_LINK/OPT} in the
link command.
\begin{verbatim}
      $ LINK objmodule,GNS_LINK/OPT
\end{verbatim}

There are two FORTRAN include files which define the global constants used
by GNS. {\tt GNS\_PAR} defines the constants used by GNS, and {\tt GNS\_ERR}
contains the error status values.

\subsection{UNIX Systems}

Any programs requiring the GNS include files have to specify the path
explicitly. The name should be given in lower case. For example
\begin{verbatim}
      INCLUDE '/star/include/gns_err'
\end{verbatim}

The link procedures for most high level graphics packages (e.g. IDI, SGS etc.)
already contain a reference to GNS. Programs that do not link with such
packages can be linked to GNS by using the substitute command `gns\_link`
or `gns\_link\_adam`. For example to compile and link an ADAM task called
`task.f' the following is used
\begin{verbatim}
      % alink task.f `gns_link_adam`
\end{verbatim}
(note the use of the backward quotes)

To compile and link a standalone application called `prog.f' the following
is used
\begin{verbatim}
      % f77 prog.f -o prog `gns_link`
\end{verbatim}

\section{References}\label{ref}

SUN/48 AGI --- Applications Graphics Interface Programmer's Guide.\\
SUN/83 GKS --- Graphical Kernel System.\\
SUN/85 SGS --- Simple Graphics System.\\
SUN/104 MSG and ERR --- Message and Error Reporting Systems.\\
SUN/130 GWM --- X Graphics Window Manager.\\
SSN/4 EMS --- Error Message Service.

\newpage\appendix
\section{Workstation Description File Keywords}\label{key}

\newcommand{\desc}[1]{\parbox[t]{30em}{#1}}
\begin{tabbing}
\tt XXXXXXXXXXXXXXX\=\tt characterXX\=\kill
\tt CLASS \>keyword \>\desc{The workstation class; the following classes
are defined:
\[\tt\begin{tabular}{l}
GRAPHICS\_OVERLAY\\
IMAGE\_DISPLAY\\
IMAGE\_OVERLAY\\
MATRIX\_PRINTER\\
METAFILE\_INPUT\\
METAFILE\_OUTPUT\\
PEN\_PLOTTER\\
TERMINAL\\
WINDOW\\
WINDOW\_OVERLAY
\end{tabular}\]}\\
\\
\tt ERASE\_TEXT\footnotemark
\>\tt character \>\desc{A character string that can be sent to
the terminal to clear the text screen. Control characters are represented
by {\tt\char94}.}\\
\\
\tt DEFAULT\_NAME\footnotemark
\>\tt character \>\desc{The name used by the workstation handler
to open the device when a connection identifier of 0 is used.}\\
\\
\tt SCALE
\>\tt real \>\desc{The approximate size in metres of the workstation's 
device units. This item is ignored if the GKS `device units' for the
workstation are metres.}\\
\\
\tt OUTPUT
\>\tt keyword \>\desc{Either {\tt DIRECT} if the workstation handler sends
instructions directly to the device or {\tt FILE} if they are written to
a file.}\\
\\
\tt CLEAR
\>\tt keyword \>\desc{{\tt SELECTIVE} if areas of the display surface
can be erased by writing with colour index zero.}\\
\\
\tt OPEN
\>\tt keyword \>\desc{{\tt NORESET} if the device can be opened without
resetting the device.}\\
\\
\tt AGITYPE
\>\tt integer \>\desc{This is used internally to construct the AGI name.
It is mandatory for every IDI workstation.
It is also required in GKS for those devices where the AGI type does not
correspond directly to the GKS type (e.g. for devices which are image
overlays).}

\end{tabbing}
\addtocounter{footnote}{-1}
\footnotetext{For devices of class {\tt TERMINAL} only.}
\addtocounter{footnote}{1}
\footnotetext{Not for devices of class {\tt TERMINAL}.}

\newpage
\section{Programmer Interface}\label{prog}

When the first GNS routine is called, the GNS database files are opened. It is
therefore not necessary to call {\tt GNS\_START} unless you want to verify that
the database can be opened before it is accessed. {\tt GNS\_STOP} will close
the database but can be omitted in stand alone programs where image exit will
close the database.

Most character output arguments are accompanied by an integer length argument;
when the requested information is not available, the length argument is
returned as zero. This length must therefore always be checked before being
used to access a sub-string of the character argument. The symbolic constants
representing the maximum lengths of the various character arguments are defined 
in a FORTRAN include file that can be referenced by the logical name {\tt
GNS\_PAR}.

All routines that are specific to GKS have names ending in the letter ``G'' and
routines specific to IDI have names ending in the letter ``I''.

\subsection{Summary of GNS calls}

\begin{routinelist}
\routine{GNS\_GTN( NAME, LNAME, STATUS)}
   Get terminal name.
\routine{GNS\_GWNG( FILTER, ICNTX, NAME, DESCR, LD, STATUS)}
   Get next GKS workstation name.
\routine{GNS\_GWNI( FILTER, ICNTX, NAME, DESCR, LD, STATUS)}
   Get next IDI workstation name.
\routine{GNS\_IANG( NAME, AGINAM, STATUS)}
   Inquire AGI name of GKS workstation.
\routine{GNS\_IANI( NAME, AGINAM, STATUS)}
   Inquire AGI name of IDI workstation.
\routine{GNS\_IDNG( IWKID, NAME, LNAME, STATUS)}
   Inquire device name of GKS workstation.
\routine{GNS\_IETG( IWKID, ERTXT, LTXT, STATUS)}
   Inquire string to erase text screen.
\routine{GNS\_IGAG( AGINAM, NAME, STATUS)}
   Inquire GKS workstation name from AGI name.
\routine{GNS\_IIAI( AGINAM, NAME, STATUS)}
   Inquire IDI workstation name from AGI name.
\routine{GNS\_IONG( IWKID, NAME, LNAME, STATUS)}
   Inquire overlay device name of GKS workstation
\routine{GNS\_ITWCG( IWKTYP, CHAR, VALUE, STATUS)}
   Inquire a workstation characteristic from its type.
\routine{GNS\_IWCG( IWKID, CHAR, VALUE, STATUS)}
   Inquire a workstation characteristic.
\routine{GNS\_IWSG( IWKID, SCALE, STATUS)}
   Inquire workstation scale.
\routine{GNS\_START( PKG, STATUS)}
   Start the GNS system for the specified package.
\routine{GNS\_STOP( PKG, STATUS)}
   Stop the GNS system for the specified package.
\routine{GNS\_TNDG( NAME, DEVICE, IWKTYP, ICONID, STATUS)}
   Translate a name and device to a GKS device specification.
\routine{GNS\_TNG( NAME, IWKTYP, ICONID, STATUS)}
   Translate a name to a GKS device specification.
\routine{GNS\_TNI( NAME, TYPE, DEVICE, STATUS)}
   Translate a name to a IDI device specification.
\end{routinelist}

\subsection{Subroutine Specifications}

%+
%  Name:
%     LAYOUT.TEX

%  Purpose:
%     Define Latex commands for laying out documentation produced by PROLAT.

%  Language:
%     Latex

%  Type of Module:
%     Data file for use by the PROLAT application.

%  Description:
%     This file defines Latex commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by Latex. The
%     contents of this file should be included in the source presented to
%     Latex in front of any output from PROLAT. By default, this is done
%     automatically by PROLAT.

%  Notes:
%     The definitions in this file should be included explicitly in any file
%     which requires them. The \include directive should not be used, as it
%     may not then be possible to process the resulting document with Latex
%     at a later date if changes to this definitions file become necessary.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     10-DEC-1991 (RFWS):
%        Refer to font files in lower case for UNIX compatibility.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}

%  Define a \tt font of the required size.
\font\ssttt=cmtt10 scaled 1095

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.45pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{\item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[1]{\item[{\ssttt #1}] \mbox{} \\}

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  End of LAYOUT.TEX layout definitions.
%.
\begin{small}
\sstroutine{
   GNS\_GTN
}{
   Get terminal name
}{
   \sstdescription{
      The physical device name of the terminal attached to the current
      process (or its parents) is returned. If there is no terminal
      available (for example in batch, network or detached processes)
      the name is set to blanks and the length set to zero.

      If the name is longer than the supplied character variable the
      name is truncated but the length returned is the length of the
      actual name.
   }
   \sstinvocation{
      CALL GNS\_GTN( NAME, LNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER$*$(GNS\_\_SZTER) (Returned)
      }{
         The device name of the terminal attached to the process
      }
      \sstsubsection{
         LNAME = INTEGER (Returned)
      }{
         The number of characters in the terminal name
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}
\sstroutine{
   GNS\_GWNG
}{
   Get next GKS workstation name
}{
   \sstdescription{
      The name and description of the {\tt "}next{\tt "} GKS workstation from the
      list of defined workstation names is returned. If the context
      argument is set to zero the first name in the list will be returned.
      The context argument is incremented each time a new name is returned
      until there are no more names in the list when it will be set to
      zero.

      FILTER is the name of a logical function that is called for each
      workstation name in the list and can be used to select or reject
      workstations on criteria such as workstation class. It should
      return the value .TRUE. if the name is to be included in the list
      and .FALSE. if it should not. FILTER has one integer argument; the
      GKS workstation type.

      The GNS library contains a suitable function called GNS\_FILTG which
      rejects any workstations that are not supported by the copy of GKS
      being run (if GKS is open; if it is not all workstation types are
      selected).
   }
   \sstinvocation{
      CALL GNS\_GWNG( FILTER, ICNTX, NAME, DESCR, LD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILTER = LOGICAL FUNCTION (Given)
      }{
         The name of the filter routine (which must be declared as
         external in the calling routine)
      }
      \sstsubsection{
         ICNTX = INTEGER (Given and Returned)
      }{
         Search context. An input value of zero starts at the beginning
         of the list; returned as zero when there are no more names in
         the list.
      }
      \sstsubsection{
         NAME = CHARACTER$*$(GNS\_\_SZNAM) (Returned)
      }{
         Workstation name
      }
      \sstsubsection{
         DESCR = CHARACTER$*$(GNS\_\_SZDES) (Returned)
      }{
         Text description of the workstation
      }
      \sstsubsection{
         LD = INTEGER (Returned)
      }{
         Length of description
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}
\sstroutine{
   GNS\_GWNI
}{
   Get next IDI workstation name
}{
   \sstdescription{
      The name and description of the {\tt "}next{\tt "} IDI workstation from the
      list of defined workstation names is returned. If the context
      argument is set to zero the first name in the list will be returned.
      The context argument is incremented each time a new name is returned
      until there are no more names in the list when it will be set to
      zero.

      FILTER is the name of a logical function that is called for each
      workstation name in the list and can be used to select or reject
      workstations on criteria such as the workstation class. It should
      return the value .TRUE. if the name is to be included in the list
      and .FALSE. if it should not. FILTER has one character argument;
      the IDI workstation type.

      The GNS library contains a suitable function called GNS\_FILTI which
      selects all workstations.
   }
   \sstinvocation{
      CALL GNS\_GWNI( FILTER, ICNTX, NAME, DESCR, LD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILTER = LOGICAL FUNCTION (Given)
      }{
         The name of the filter routine (which must be declared as
         external in the calling routine).
      }
      \sstsubsection{
         ICNTX = INTEGER (Given and Returned)
      }{
         Search context. An input value of zero starts at the beginning
         of the list; returned as zero when there are no more names in
         the list.
      }
      \sstsubsection{
         NAME = CHARACTER$*$(SZNAM) (Returned)
      }{
         Workstation name
      }
      \sstsubsection{
         DESCR = CHARACTER$*$(SZDES) (Returned)
      }{
         Text description of the workstation
      }
      \sstsubsection{
         LD = INTEGER (Returned)
      }{
         Length of description
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}
\sstroutine{
   GNS\_IANG
}{
   Inquire AGI name of GKS workstation
}{
   \sstdescription{
      The AGI name corresponding to the specified GKS workstation is
      returned. If the name is longer then the supplied character
      variable the name is truncated.
   }
   \sstinvocation{
      CALL GNS\_IANG( NAME, AGINAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER$*$($*$) (Given)
      }{
         GKS workstation name
      }
      \sstsubsection{
         AGINAM = CHARACTER$*$(GNS\_\_SZAGI) (Returned)
      }{
         AGI name
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstnotes{
      The AGI name is constructed from {\tt '}AGI\_$<$wktype$>$\_$<$seqno$>${\tt '} using the
      GKS workstation type and a sequence number. The GKS workstation
      type from the GKSNAMES file is used unless there is an AGITYPE
      keyword for that device. A sequence number of zero is used unless
      there is an explicit sequence number in the GKSNAMES file.

      This routine is used by AGI and will not normally be called by an
      applications program.
   }
}
\sstroutine{
   GNS\_IANI
}{
   Inquire AGI name of IDI workstation
}{
   \sstdescription{
      The AGI name corresponding to the specified IDI workstation is
      returned.

      If the name is longer than the supplied character variable the
      name is truncated.
   }
   \sstinvocation{
      CALL GNS\_IANI( NAME, AGINAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER$*$($*$) (Given)
      }{
         IDI workstation name
      }
      \sstsubsection{
         AGINAM = CHARACTER$*$(GNS\_\_SZAGI) (Returned)
      }{
         AGI name
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstnotes{
      The AGI name is constructed from {\tt '}AGI\_$<$wktype$>$\_$<$seqno$>${\tt '} using the
      GKS workstation type and a sequence number. The GKS workstation
      type is obtained from the AGITYPE attribute. A sequence number of
      zero is used unless there is an explicit sequence number in the
      IDINAMES file.

      This routine is used by AGI and will not normally be called by an
      applications program.
   }
}
\sstroutine{
   GNS\_IDNG
}{
   Inquire device name of GKS workstation
}{
   \sstdescription{
      The physical device name or file name of the specified GKS
      workstation is returned. The name may be a logical name that
      translates to the device or file name rather than the name itself.

      If the name is longer than the supplied character variable the
      name is truncated but the length returned is the actual length of
      the name.
   }
   \sstinvocation{
      CALL GNS\_IDNG( IWKID, NAME, LNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWKID = INTEGER (Given)
      }{
         GKS workstation identifier
      }
      \sstsubsection{
         NAME = CHARACTER$*$(GNS\_\_SZDEV) (Returned)
      }{
         Device or file name
      }
      \sstsubsection{
         LNAME = INTEGER (Returned)
      }{
         Length of name
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}
\sstroutine{
   GNS\_IETG
}{
   Inquire string to erase text screen
}{
   \sstdescription{
      A character string is returned that will clear the text screen if
      written to the specified device (normally a terminal). The string
      may contain control characters.

      If no string is available a length of zero is returned.
   }
   \sstinvocation{
      CALL GNS\_IETG( IWKID, TXT, LTXT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWKID = INTEGER (Given)
      }{
         GKS workstation identifier
      }
      \sstsubsection{
         TXT = CHARACTER$*$(GNS\_\_SZTXT) (Returned)
      }{
         Text string
      }
      \sstsubsection{
         LTXT = INTEGER (Returned)
      }{
         Length of text string
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}
\sstroutine{
   GNS\_IGAG
}{
   Inquire GKS workstation name from AGI name
}{
   \sstdescription{
      A GKS workstation name that corresponds to the specified AGI name
      is returned. If the name is longer than the supplied character
      variable the name is truncated.
   }
   \sstinvocation{
      CALL GNS\_IGAG( AGINAM, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         AGINAM = CHARACTER$*$($*$) (Given)
      }{
         AGI name
      }
      \sstsubsection{
         NAME = CHARACTER$*$(GNS\_\_SZDEV) (Returned)
      }{
         Device name
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstnotes{
      This routine is used by AGI and will not normally be called by an
      applications program.
   }
}
\sstroutine{
   GNS\_IIAI
}{
   Inquire IDI workstation name from AGI name
}{
   \sstdescription{
      An IDI workstation name that corresponds to the supplied AGI name
      is returned. If the name is longer than the supplied character
      variable the name is truncated.
   }
   \sstinvocation{
      CALL GNS\_IIAI( AGINAM, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         AGINAM = CHARACTER$*$($*$) (Given)
      }{
         AGI name
      }
      \sstsubsection{
         NAME = CHARACTER$*$(GNS\_\_SZDEV) (Returned)
      }{
         Device name
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstnotes{
      This routine is used by AGI and will not normally be called by an
      applications program.
   }
}
\sstroutine{
   GNS\_IONG
}{
   Inquire overlay device name of GKS workstation
}{
   \sstdescription{
      The name of the overlay device for the GKS workstation specified
      by the workstation identifier is returned. This can then be used
      to open the device with GKS. If the device does not have an
      overlay then an error is returned.

      If the name is longer than the supplied character variable the
      name is truncated but the length returned is the actual length of
      the name.
   }
   \sstinvocation{
      CALL GNS\_IONG( IWKID, NAME, LNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWKID = INTEGER (Given)
      }{
         GKS workstation identifier
      }
      \sstsubsection{
         NAME = CHARACTER$*$($*$) (Returned)
      }{
         Overlay device name
      }
      \sstsubsection{
         LNAME = INTEGER (Returned)
      }{
         Length of name
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}
\sstroutine{
   GNS\_ITWCG
}{
   Inquire workstation characteristic from its type
}{
   \sstdescription{
      The specified characteristic is returned as a character string,
      blank filled or truncated as necessary. If the characteristic does
      not exist then a blank string is returned.

      Any characteristic with a keyword value (see appendix A) can be
      inquired with this routine.
   }
   \sstinvocation{
      CALL GNS\_ITWCG( IWKTYP, CHAR, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWKTYP = INTEGER (Given)
      }{
         GKS workstation type
      }
      \sstsubsection{
         CHAR = CHARACTER$*$($*$) (Given)
      }{
         Characteristic name
      }
      \sstsubsection{
         VALUE = CHARACTER$*$(GNS\_\_SZKEY) (Returned)
      }{
         The value of the requested characteristic
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstnotes{
      This performs the same function as GNS\_IWCG except that the device
      is specified by its GKS type and therefore the characteristics can
      be queried before the device is opened by GKS.
   }
}
\sstroutine{
   GNS\_IWCG
}{
   Inquire workstation characteristic
}{
   \sstdescription{
      The specified characteristic is returned as a character string,
      blank filled or truncated as necessary. If the characteristic does
      not exist then a blank string is returned.

      Any characteristic with a keyword value (see appendix A) can be
      inquired with this routine.
   }
   \sstinvocation{
      CALL GNS\_IWCG( IWKID, CHAR, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWKID = INTEGER (Given)
      }{
         GKS workstation identifier
      }
      \sstsubsection{
         CHAR = CHARACTER$*$($*$) (Given)
      }{
         Characteristic name
      }
      \sstsubsection{
         VALUE = CHARACTER$*$(GNS\_\_SZKEY) (Returned)
      }{
         The value of the specified characteristic
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}
\sstroutine{
   GNS\_IWSG
}{
   Inquire workstation scale
}{
   \sstdescription{
      The size in metres of {\tt '}device units{\tt '} for the specified GKS
      workstation is returned.

      Note that device units as defined by GKS are not necessarily the
      same as the device resolution. On devices with a well defined actual
      size such as plotters and printers device units are metres and a
      value of 1.0 will be returned.
   }
   \sstinvocation{
      CALL GNS\_IWSG( IWKID, WSSCA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWKID = INTEGER (Given)
      }{
         GKS workstation identifier
      }
      \sstsubsection{
         WSSCA = REAL (Returned)
      }{
         Size in metres of device units
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}
\sstroutine{
   GNS\_START
}{
   Start the GNS system
}{
   \sstdescription{
      The GNS databases for the specified package are opened. This routine
      is called automatically by any other routine that accesses the
      databases.
   }
   \sstinvocation{
      CALL GNS\_START( PKG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PKG = CHARACTER$*$($*$) (Given)
      }{
         The package name. The only packages currently supported are
         GKS and IDI.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}
\sstroutine{
   GNS\_STOP
}{
   Stop the GNS system
}{
   \sstdescription{
      The GNS databases for the specified package are closed.
   }
   \sstinvocation{
      CALL GNS\_STOP( PKG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PKG = CHARACTER$*$($*$) (Given)
      }{
         The package name. The only packages currently supported are
         GKS and IDI.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}
\sstroutine{
   GNS\_TNDG
}{
   Translate name and device to GKS specification
}{
   \sstdescription{
      The workstation name and physical device specification are
      translated to a GKS workstation type and connection identifier
      and, if necessary, a logical name created to map the connection
      identifier onto the specified physical device or file.
   }
   \sstinvocation{
      CALL GNS\_TNDG( NAME, DEVICE, IWKTYP, ICONID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER$*$($*$) (Given)
      }{
         Workstation name
      }
      \sstsubsection{
         DEVICE = CHARACTER$*$($*$) (Given)
      }{
         Physical device name
      }
      \sstsubsection{
         IWKTYP = INTEGER (Returned)
      }{
         GKS workstation type
      }
      \sstsubsection{
         ICONID = INTEGER (Returned)
      }{
         Connection identifier
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstdiytopic{
      Side Effects
   }{
      A logical name of the form GKS\_n\_m or FORnnn may be created.

      A GWM window with an overlay may be created.
   }
}
\sstroutine{
   GNS\_TNG
}{
   Translate name to a GKS device specification
}{
   \sstdescription{
      The workstation name is translated to a GKS workstation type and
      connection identifier and, if necessary, a logical name created to
      map the connection identifier onto the device implied by the
      workstation name.

      This routine is the same as GNS\_TNDG but without an explicit
      physical device name argument.
   }
   \sstinvocation{
      CALL GNS\_TNG( NAME, IWKTYP, ICONID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER$*$($*$) (Given)
      }{
         Workstation name
      }
      \sstsubsection{
         IWKTYP = INTEGER (Returned)
      }{
         GKS workstation type
      }
      \sstsubsection{
         ICONID = INTEGER (Returned)
      }{
         Connection identifier
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}
\sstroutine{
   GNS\_TNI
}{
   Translate name to an IDI device specification
}{
   \sstdescription{
      The workstation name is translated to an IDI workstation type, and
      a physical device name.
   }
   \sstinvocation{
      CALL GNS\_TNI( NAME, TYPE, DEVICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER$*$($*$) (Given)
      }{
         Workstation name
      }
      \sstsubsection{
         TYPE = CHARACTER$*$($*$) (Returned)
      }{
         IDI workstation type
      }
      \sstsubsection{
         DEVICE = CHARACTER$*$($*$) (Returned)
      }{
         Device name
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstnotes{
      IIDOPN requires a GNS workstation name as its name argument which
      is translated by IIDOPN calling GNS\_TNI; GNS\_TNI is therefore not
      normally called by applications programs.
   }
   \sstdiytopic{
      Side Effects
   }{
      A GWM window with an overlay may be created.
   }
}
\end{small}
\end{document}
