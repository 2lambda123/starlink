\documentstyle[11pt]{article} 
\pagestyle{headings}

%------------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocnumber}    {92.9}
\newcommand{\stardocauthors}   {R.F.~Warren-Smith \& M.D.~Lawden}
\newcommand{\stardocdate}      {20th December 1993}
\newcommand{\stardoctitle}     {HDS\\ [1ex]
                                Hierarchical Data System}
\newcommand{\stardocversion}   {Version 4.1}
\newcommand{\stardocmanual}    {Programmer's Manual}
%------------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

\renewcommand{\_}{{\tt\char'137}}
\renewcommand{\thepage}{\roman{page}}

\begin{document}

\thispagestyle{empty}
SCIENCE \& ENGINEERING RESEARCH COUNCIL \hfill \stardocname\\
RUTHERFORD APPLETON LABORATORY\\
{\large\bf Starlink Project\\}
{\large\bf \stardoccategory\ \stardocnumber}
\begin{flushright}
\stardocauthors\\
\stardocdate
\end{flushright}
\vspace{-4mm}
\rule{\textwidth}{0.5mm}
\vspace{5mm}
\begin{center}
{\Huge\bf  \stardoctitle \\ [2.5ex]}
{\LARGE\bf \stardocversion \\ [4ex]}
{\Huge\bf  \stardocmanual}
\end{center}
\vspace{15mm}

%------------------------------------------------------------------------------
%  Package Description
\begin{center}
{\Large\bf Description}
\end{center}

HDS is a file-based hierarchical data system designed for the storage of a wide
variety of information. It is particularly suited to the storage of large
multi-dimensional arrays (with their ancillary data) where efficiency of access
is a requirement.

HDS permits data to be organised into hierarchies, broadly similar to the
directory structure of a hierarchical filing system, but contained within a
single HDS {\em container file.} The structures stored in these files are
self-describing and flexible; HDS supports modification and extension of
structures previously created, as well as deletion, copying, renaming, {\em
etc.}

All information stored in HDS files is portable between the machines on which
HDS is implemented. Thus, the user of HDS will encounter no format conversion
problems when moving between machines.

The routines described in this document may be used to perform operations on
any HDS data. In addition, HDS forms a toolkit for the construction of higher
level (more specialised) data structures and the software which accesses them.
HDS routines are therefore invoked implicitly by many other items of Starlink
software.

%------------------------------------------------------------------------------
%  Add this part if you want a table of contents
\newpage
\markright{\stardocname}
\null\vspace {5mm}
\begin {center}
\rule{80mm}{0.5mm} \\ [1ex]
{\Large\bf \stardoctitle \\ [2.5ex]
           \stardocversion} \\ [2ex]
\rule{80mm}{0.5mm}
\end{center}

\setlength{\parskip}{0mm}
\tableofcontents
\setlength{\parskip}{\medskipamount}

%------------------------------------------------------------------------------
%  Introduction page
\newpage
\markright{\stardocname}
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\null\vspace {5mm}
\begin {center}
\rule{80mm}{0.5mm} \\ [1ex]
{\Large\bf \stardoctitle \\ [2.5ex]
           \stardocversion} \\ [2ex]
\rule{80mm}{0.5mm}
\end{center}
\vspace{30mm}

\section {INTRODUCTION}

This document\footnote{This document started life as a guide to HDS written by
Jim Peden at the University of Birmingham. It has subsequently been revised and
expanded by Mike Lawden, Alan Chipperfield and Rodney Warren-Smith.} is meant
for those people who intend to write programs using HDS. It is tutorial in
style and assumes no prior knowledge of HDS, although some knowledge of a
modern hierarchical filing system will be helpful. Anyone who has used UNIX or
VMS should understand the analogies that are drawn between directories and HDS
structures in the text. 

This note mainly deals with HDS as a ``stand-alone'' software package. Routines
which interface HDS with a particular software environment ({\em i.e.}\ the
HDS/ADAM parameter system routines) are not considered here, although they may
be included in future versions (see APN/7 for a description of these routines).

Reference information is presented in the appendices.
Appendix~\ref{appendix:alphalist} gives a list of the calling sequences for the
HDS routines; this will be useful to experienced programmers who just want to
be reminded of the parameters required, while Appendix~\ref{appendix:routines}
gives full routine specifications for all of HDS.
Appendix~\ref{appendix:errors} describes the HDS error codes. Programming
support for HDS, in the form of subroutine templates and on-line help, is also
provided by the Starlink language sensitive editor STARLSE (SUN/105).

HDS stands for `Hierarchical Data System'. It is a flexible system for storing
and retrieving data and takes over from a computer's filing system at the level
of an individual file (Fig~\ref{fig:hierarchy}). A conventional file
effectively contains an 1-dimensional collection of records, whereas an HDS
file can contain a more complex structure. There are many parallels between the
hierarchical way HDS stores data within files and and the way that a filing
system organises the files themselves. These analogies will be helpful in what
follows. 

\begin{figure}
\begin{center}
\begin{picture}(150,90)
\setlength{\unitlength}{1mm}
\thicklines
\put (20,70){\framebox(30,5){Root directory}}
\put (0,55){\framebox(30,5){User directory}}
\put (40,55){\framebox(30,5){User directory}}
\put (40,45){\framebox(30,5){Subdirectory}}
\put (20,30){\framebox(30,5){File}}
\put (60,30){\framebox(30,5){File}}
\put (100,30){\framebox(30,5){Container File}}
\put (100,20){\framebox(30,5){HDS Object}}
\put (80,5){\framebox(30,5){Object}}
\put (120,5){\framebox(30,5){Object}}
\put (15,65){\vector(0,-1){5}}
\put (55,65){\vector(0,-1){5}}
\put (55,55){\vector(0,-1){5}}
\put (35,40){\vector(0,-1){5}}
\put (75,40){\vector(0,-1){5}}
\put (115,30){\vector(0,-1){5}}
\put (95,15){\vector(0,-1){5}}
\put (135,15){\vector(0,-1){5}}
\put (90,32.5){\vector(1,0){10}}
\put (100,32.5){\vector(-1,0){10}}
\put (35,70){\line(0,-1){5}}
\put (55,45){\line(0,-1){5}}
\put (115,20){\line(0,-1){5}}
\put (15,65){\line(1,0){40}}
\put (35,40){\line(1,0){40}}
\put (95,15){\line(1,0){40}}
\put (15,55){\line(0,-1){1}}
\put (15,53){\line(0,-1){1}}
\put (15,51){\line(0,-1){1}}
\put (23,80){\bf Filing System}
\put (110,80){\bf HDS}
\end{picture}
\end{center}
\caption{The relationship between a computer's filing system and HDS.}
\label{fig:hierarchy}
\end{figure}

The advantage of HDS is that it allows many different kinds of data to be
stored in a consistent and logical fashion. It is also very flexible, in that
objects can be added or deleted whilst retaining the logical structure. HDS
also provides portability of data, so that the same data objects may be
accessed from different types of computer despite the fact that each may
actually format its files and data in different ways. 

\section{OBJECTS}

HDS files are known as {\em container files} and by default have the extension
`.sdf'.\footnote{On VMS systems, this extension (and file names in general) use
upper case, whereas the default extension on UNIX systems will be in lower case.
In this document, lower case is used for file names.} HDS files contain {\em
data objects} which will often be referred to simply as {\em objects}. An object
is an entity which contains data or other objects. This is the basis of the
hierarchical nature of HDS and is analogous to the concepts of {\em file} and
{\em directory} --- a directory can contain files and directories which can
themselves contain files and directories and so on (Fig~\ref{fig:hierarchy}). An
HDS object possesses the following attributes, each of which is described in
more detail below:

\begin{itemize}
\item Name
\item Type
\item Shape
\item State
\item Group
\item Value
\end{itemize}

\subsection{Name}

The primary way of identifying an object is by its {\em name}, which must be
unique within its own container object.\footnote{This is in contrast to some
operating systems ({\em e.g.}\ VMS) where different files in the same directory
may be distinguished by their version numbers.} The name of an object is a
character string which may contain any printing characters; white space is
ignored and alphabetic characters are capitalised. Currently, the maximum length
of an HDS name is 15 characters.

There are no special rules governing the first character ({\em i.e.}\ it can be
numeric), so HDS itself allows great freedom in specifying names (and also
types --- see below). In practice, however, some restrictions will be imposed
by considerations of portability of data and applications, and of possible
syntax conflicts with the environment within which HDS is used.

\subsection{Type}

The {\em type} of an object falls into two {\em classes}:

\begin{itemize}
\item Structure
\item Primitive
\end{itemize}

Structure objects contain other objects called {\em components}. Primitive
objects contain only numeric, character, or logical values. Objects in the
different classes are referred to as {\em structures} and {\em primitives}
while the more general term {\em object} refers to either a {\em structure} or
a {\em primitive}. Structures are analogous to the directories in a filing
system --- they can contain a part of the hierarchy below them. Primitives are
analogous to files --- they are at the bottom of any branch of the structure.

In HDS, structure types are represented by character strings with the same
rules of formation as {\em name,} except that a structure type may not start
with an underscore character `\_' (a structure type may also be completely
blank). Examples of structure types are `IMAGE', `SPECTRUM', `INSTR\_RESP',
{\em etc.} These do not begin with an underscore, so they are easily
distinguished from the primitive types, which do.

Special rules apply to the primitive types, which all begin with an underscore
and are ``pre-defined'' by HDS, as follows:

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\em HDS Type} & {\em Fortran Type\footnotemark} & {\em Description}\\
\hline \hline
\_INTEGER & INTEGER & Integer (signed)\\
\_REAL & REAL & Single precision\\
\_DOUBLE & DOUBLE PRECISION & Double precision\\
\_LOGICAL & LOGICAL & Logical\\
\_CHAR[$*$n] & CHARACTER[$*$n] & Character string\\
\hline
\_WORD & INTEGER$*$2 & Word (signed)\\
\_UWORD & INTEGER$*$2 & Unsigned word\\
\_BYTE & BYTE & Byte (signed)\\
\_UBYTE & BYTE & Unsigned byte\\
\hline
\end{tabular}
\end{center}
\footnotetext{The non-standard types in this table are VAX Fortran data types.
Equivalent types exist in most other implementations of Fortran.}

The first five of these primitive types are referred to as {\em standard data
types}, since they correspond with standard Fortran~77 data types. The last four
are {\em non-standard data types} and are typically required to accommodate raw
data from instrumental hardware, which often generates numbers in these formats.
The range of values which may be stored in each primitive numeric type is
determined by the numerical capabilities of your machine and the particular
implementation of Fortran you are using. Details of HDS, which include
information about the properties of the primitive data types on the system you
are using, may be found in the file:

\small
\begin{verbatim}
   hds_datestamp
\end{verbatim}
\normalsize

in the directory in which the HDS source files reside.\footnote{On Starlink
systems this directory will normally be called {\tt /star/starlink/lib/hds} on
UNIX and HDS\_DIR on VMS.}

The rules by which character values are handled by HDS is the same as for
Fortran~77, {\em i.e.}\ character values are padded with blanks or truncated
from the right depending on the relative length of the program value and the
object. 

\subsection{Shape}

Every object has a {\em shape} or dimensionality. This is described by an
integer (the number of dimensions) and an integer array (the size of each
dimension). A {\em scalar} (for example a single number) has, by convention, a
dimensionality of zero; {\em i.e.}\ its number of dimensions is 0. A {\em
vector} has a dimensionality of 1; {\em i.e.}\ its number of dimensions is 1,
and the first element of the dimension array contains the size of the vector.
An {\em array} refers to an object with 2 or more dimensions; currently a
maximum of 7 dimensions are allowed. Objects may be referred to as {\em scalar
primitives} or {\em vector structures} and so on. 

\subsection{State}

The {\em state} of an object specifies whether or not its value is defined. It
is represented as a logical value where .TRUE.\ means defined and .FALSE.\
means undefined. 

\subsection{Group}

In order to access an object it is first necessary to ``associate'' a {\em
locator} with it (like opening a file). This locator can then be used to
address the object. When the program no longer needs to access the object the
locator should be ``annulled'' (like closing the file again). A locator is
analogous to a Fortran logical unit number (but is actually a character
variable, not an integer). The {\em group} attribute is used to form an
association between objects so that all their locators can be annulled
together. A group is written as a character string whose rules of formation are
the same as {\em name}. 

\subsection {Value}

When a primitive object is first created it contains no value (rather like
opening a file) and it must be given a value in a separate operation. A value
can be a scalar, a vector or an array. The elements of a vector or array must
all be of the same type.

\subsection{Illustration}

To fix these ideas, look at the example in Fig~\ref{fig:ndf}. Here we have
described a structure of type NDF using the following notation to describe each
object: 

\small
\begin{verbatim} 
                      NAME[(dimensions)] <TYPE> [value]
\end{verbatim}
\normalsize

Note that scalar objects have no dimensions and that each level down the
hierarchy is indented. 

\begin{figure}[h]
\small
\begin{verbatim}
   DATASET <NDF>
      DATA_ARRAY(512,1024)    <_UBYTE>   0,0,0,1,2,3,255,3,...
      LABEL                   <_CHAR*80> 'This is the data label'
      AXIS(2) <AXIS>
         AXIS <AXIS>
            DATA_ARRAY(512)   <_REAL>    0.5,1.5,2.5,...
            LABEL             <_CHAR*30> 'Axis 1'
         AXIS <AXIS>
            DATA_ARRAY(1024)  <_REAL>    5,10,15.1,20.3,...
            LABEL             <_CHAR*10> 'Axis 2'
\end{verbatim}
\normalsize
\caption{A simple NDF structure.}
\label{fig:ndf}
\end{figure}

This example exhibits several of the properties we have mentioned above:

\begin{itemize}
\item Both structures and primitives are present in the structure.
\item Scalar and non-scalar objects are present.
\item The AXIS component is a vector structure (with two elements).
\end{itemize}


\section{ROUTINES AND CONSTANTS}

\subsection{Routine Names}

Objects are created, accessed, modified and deleted in programs by means of
calls to HDS routines. The routine names have the following structure: 

\small
\begin{verbatim}
    <pck>_<func><qual>
\end{verbatim}
\normalsize

where \verb+<pck>+ is the package name, \verb+<func>+ represents the
function performed by the routine and \verb+<qual>+ is a qualifier which is
used to identify different versions of the GET, MAP, MOD,
NEW and PUT routines. 

\subsection{Symbolic Names and Include Files}

Stand-alone HDS programs will typically have the following structure: 

\small
\begin{verbatim}
            <declarations>

          INCLUDE `SAE_PAR'
          INCLUDE 'DAT_PAR'
          INCLUDE `DAT_ERR'
          INCLUDE `CMP_ERR'

          STATUS = SAI__OK

            <executable statements>

          END
\end{verbatim}
\normalsize

Various symbolic names should be used for important constant values in HDS
programs to make the programs clearer and to insulate them from possible future
changes. These symbolic names are defined by several Fortran ``include'' files.
This explains the existence of the {\tt INCLUDE} statements in the example
above. The following include files are available: 

\begin{description}

\item [SAE\_PAR:]
This file is not actually part of HDS, but it defines the global symbolic
constant SAI\_\_OK (the value of the status return indicating success) and will
be required by nearly all routines which call HDS. It should normally be
included as a matter of course.\footnote{Due to a historical anomaly on VAX/VMS
systems, the file SAE\_PAR also contains definitions for the DAT\_\_ symbolic
constants which should properly reside in DAT\_PAR. To prevent multiple
definitions occurring, DAT\_PAR is therefore an empty file on VAX/VMS systems.
Thus, if SAE\_PAR has been included, the further inclusion of DAT\_PAR is
optional (but only on VAX/VMS). Its inclusion is recommended, however, because
this allows the same software to be used on other systems without change.}

\item [DAT\_PAR:]
Defines various symbolic constants for HDS. These should be used whenever the
associated value is required (typically this is when program variables are
defined): 

\small
\begin{verbatim}
      DAT__MXDIM        Maximum number of object dimensions
      DAT__NOLOC        Null (invalid) locator value
      DAT__NOWLD        Null wild-card search context
      DAT__SZGRP        Size of group name
      DAT__SZLOC        Size of locator
      DAT__SZMOD        Size of access mode string
      DAT__SZNAM        Size of object name
      DAT__SZTYP        Size of type string
\end{verbatim}
\normalsize

\item [DAT\_ERR:]
This defines symbolic names for the error status values returned by the DAT\_ 
and HDS\_ routines.

\item [CMP\_ERR:]
This defines symbolic names for the additional error status values returned  by
the CMP\_ routines.
\end{description}

If it is required to test for specific error conditions, the appropriate
include file should be used and the symbolic names (listed in
Appendix~\ref{appendix:errors}) used in the test. Here is an example of how to
use these symbols: 

\small
\begin{verbatim}
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'DAT_ERR'
      ...

      CHARACTER * ( DAT__SZLOC ) LOC1, LOC2
      CHARACTER * ( DAT__SZNAM ) NAME
      INTEGER STATUS
      ...

* Find a structure component.
      CALL DAT_FIND( LOC1, NAME, LOC2, STATUS )

* Check the status value returned.
      IF ( STATUS .EQ. SAI__OK ) THEN
        <normal action>
      ELSE IF ( STATUS .EQ. DAT__OBJNF ) THEN
        <take appropriate action for object not found>
      ELSE
        <action on other errors>
      END IF
\end{verbatim}
\normalsize

\section{CREATING OBJECTS}
\label{sect:creating}

Here is an example showing how to create the NDF structure in
Fig~\ref{fig:ndf}. 

\small
\begin{verbatim}
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      CHARACTER * ( DAT__SZLOC ) NLOC, ALOC, CELL
      INTEGER DIMS( 2 ), STATUS
      DATA DIMS / 512, 1024 /

*  Create a container file with a top level scalar object of type NDF.
      CALL HDS_NEW( 'dataset', 'DATASET', 'NDF', 0, 0, NLOC, STATUS )

*  Create components in the top level object.
      CALL DAT_NEW( NLOC, 'DATA_ARRAY', '_UBYTE', 2, DIMS, STATUS )
      CALL DAT_NEWC( NLOC, 'LABEL', 80, 0, 0, STATUS )
      CALL DAT_NEW( NLOC, 'AXIS', 'AXIS', 1, 2, STATUS )

*  Create components in the AXIS structure...

*  Get a locator to the AXIS component.
      CALL DAT_FIND( NLOC, 'AXIS', ALOC, STATUS )

*  Get a locator to the array cell AXIS(1).
      CALL DAT_CELL( ALOC, 1, 1, CELL, STATUS )

*  Create internal components within AXIS(1) using the CELL locator.
      CALL DAT_NEW( CELL, 'DATA_ARRAY', '_REAL', 1, DIM( 1 ), STATUS )
      CALL DAT_NEWC( CELL, 'LABEL', 30, 0, 0, STATUS )

*  Annul the cell locator
      CALL DAT_ANNUL( CELL, STATUS )

*  Do the same for AXIS(2).
      CALL DAT_CELL( ALOC, 1, 2, CELL, STATUS )
      CALL DAT_NEW( CELL, 'DATA_ARRAY', '_REAL', 1, DIM( 2 ), STATUS )
      CALL DAT_NEWC( CELL, 'LABEL', 10, 0, 0, STATUS )
      CALL DAT_ANNUL( CELL, STATUS )

*  Access objects which have been created.
      ...

*  Tidy up
      CALL DAT_ANNUL( ALOC, STATUS )
      CALL DAT_ANNUL( NLOC, STATUS )

      END
\end{verbatim}
\normalsize

The following points should be borne in mind:
\begin{itemize}

\item The structure we have created is in no way static --- we can add new
objects or delete existing ones at any level without disturbing what already
exists. 

\item No primitive values have been stored yet --- we will do that next. 

\end{itemize}

Here are some notes on particular aspects of this example: 

\begin{description}

\item [DAT\_\_SZLOC:]
This is an INTEGER constant which is defined in the include file DAT\_PAR
and specifies the length in characters of all HDS locators. Similar
constants, DAT\_\_SZNAM and DAT\_\_SZTYP, specify the maximum lengths of
object names and types. 

\item [STATUS:]
HDS routines conform to Starlink error handling conventions (described fully
in SUN/104) and use {\em inherited status checking}. This normally means
(unless otherwise noted in the routine description) that if the STATUS
variable is not set to a value indicating success on entry
(STATUS=SAI\_\_OK), then the subroutine will exit without action. This
behaviour can be very useful in reducing the effort required to check
properly for all possible error conditions. 

\item [HDS\_NEW:]
A container file called ``dataset'' is created (HDS provides the default file
extension of `.sdf'). A scalar structure called DATASET with a type of NDF is
created within this file, and a locator (NLOC) is associated with this
structure. It is usually convenient, although not essential, to make the
top-level object name match the container file name, as here.

\item [DAT\_NEW/DAT\_NEWC:]
These routines create new objects within HDS itself --- they are not equivalent
to HDS\_NEW because they don't have any reference to the container file,
only to a higher level structure.

We use two variants of this routine simply because the character string length
has to be specified when creating a character object and it is normally most
convenient to provide this via an additional integer argument.  However, 
DAT\_NEW may be used to create new objects of any type, including character
objects. In this case the character string length would be provided via the
type specification, {\em e.g.}\ `\_CHAR$*$15' (a character string length of one
is assumed if `\_CHAR' is specified alone). 

\item [DAT\_FIND:]
After an object has been created it is necessary to associate a locator with
it before values can be inserted into it; DAT\_FIND performs this
function. 

\item [DAT\_CELL:]
There are several routines for accessing subsets of objects. DAT\_CELL
obtains a locator to a scalar object (structure or primitive) within a
non-scalar object like a vector. 

\item [DAT\_ANNUL:]
This is used to release a locator (just as CLOSE releases a logical unit number
in Fortran). It also closes the container file when it is no longer being used.

\end{description}

\section{WRITING AND READING OBJECTS}

Having created our structure we now want to put some values into it. This
can be done by using the DAT\_PUT and DAT\_PUTC routines. For
example, to fill the main data array in the above example with values we
might do the following: 

\small
\begin{verbatim}
      ...
      BYTE IMVALS( 512, 1024 )
      CHARACTER * ( DAT__SZLOC ) LOC

*  Put data from array IMVALS to the object DATA_ARRAY.
      CALL DAT_FIND( NLOC, 'DATA_ARRAY', LOC, STATUS )
      CALL DAT_PUT( LOC, '_UBYTE', 2, DIMS, IMVALS, STATUS )
      CALL DAT_ANNUL( LOC, STATUS )

*  Put data from character constant to the object LABEL.
      CALL DAT_FIND( NLOC, 'LABEL', LOC, STATUS )
      CALL DAT_PUTC( LOC, 0, 0, 'This is the data label', STATUS )
      CALL DAT_ANNUL( LOC, STATUS )
      ...
\end{verbatim}
\normalsize

Because this sort of activity occurs quite often, ``packaged'' access routines
have been developed and are available to the programmer (see
Appendix~\ref{appendix:alphalist}).  A complementary set of routines also
exists for getting data from objects back into program arrays or variables;
these are the DAT\_GET routines. Again, packaged versions exist and are
often handy in reducing the number of  subroutine calls required.

\section{ACCESSING OBJECTS BY MAPPING}

Another technique for accessing values stored in primitive HDS objects is
termed `mapping'.\footnote{This terminology derives from the facility
originally provided by VAX/VMS for {\em mapping} the contents of files into the
computer's memory, so that they appear as if they are arrays of numbers
directly accessible to a program. Although HDS still exploits this technique
when appropriate, other techniques are also used internally so that HDS no
longer depends on the use of file mapping (which some operating systems do not
provide). The terminology remains in use, however.} An important advantage of
this technique is that it removes a size restriction imposed by having to
declare fixed size program arrays to hold data. This simplifies software, so
that a single routine can handle objects of arbitrary size without recourse to
accessing subsets. 

HDS provides mapped access to primitive objects via the DAT\_MAP
routines. Essentially DAT\_MAP will return a pointer to a region of the
computer's memory in which the object's values are stored. This pointer can
then be passed to another routine using the VAX Fortran `\%VAL'
facility.\footnote{This VAX extension to Fortran~77 is also supported by the
other implementations of Fortran for which HDS is available. The technique
works because Fortran normally passes the address of an array to a subroutine,
so the routine is fooled into thinking it's getting an array.} An example will
illustrate this: 

\small
\begin{verbatim}
      ...
      INTEGER PNTR, EL

*  Map the DATA_ARRAY component of the NDF structure as a vector of type
*  _REAL (even though the object is actually a 512 x 1024 array whose
*  elements are of type _UBYTE).
      CALL DAT_FIND( NLOC, 'DATA_ARRAY', LOC, STATUS )
      CALL DAT_MAPV( LOC, '_REAL', 'UPDATE', PNTR, EL, STATUS )

*  Pass the "array" to a subroutine.
      CALL SUB( EL, %VAL( PNTR ), STATUS )

*  Unmap the object and annul the locator.
      CALL DAT_UNMAP( LOC, STATUS )
      CALL DAT_ANNUL( LOC, STATUS )

      END

*  Routine which takes the LOG of all values in a REAL array.
      SUBROUTINE SUB( N, A, STATUS )
      INCLUDE 'SAE_PAR'
      INTEGER N, STATUS
      REAL A( N )
      IF ( STATUS .NE. SAI__OK ) RETURN

      DO 1 I = 1, N
         A( I ) = LOG( A( I ) )
 1    CONTINUE

      END
\end{verbatim}
\normalsize

This example illustrates two features of HDS which we haven't already
mentioned:

\begin{description}
\label{sect:mapping}

\item [Vectorisation:]
It is possible to force HDS to regard objects as vectors, irrespective of
their true dimensionality. This facility was useful in the above example as
it made the subroutine SUB much more general in that it could be applied to
any numeric primitive object. 

\item [Automatic type conversion:]
The program can specify the data type it wishes to work with and the program
will work even if the data is stored as a different type. HDS will (if
necessary) automatically convert the data to the type required by the
program.\footnote{This will work even if the object was originally created on a
different computer which formats its numbers differently.} This useful feature
can greatly simplify programming --- simple programs can handle all data types.
Automatic conversion works on reading, writing and mapping. 

\end{description}

Note that once a primitive has been mapped, the associated locator cannot be
used to access further data until the original object is unmapped.

\section{MAPPING CHARACTER DATA}
\label{sect:charmapping}

Although the above example used a numeric type of `\_REAL' to access the data,
HDS actually allows any primitive type to be specified as an access type,
including `\_CHAR'. In the particular case of mapping data as character
strings, however, there are some additional subtleties imposed by the way that
different computer systems handle this data type. These are described below.

HDS gives you a choice about how to determine the length of the character
strings it will map. You may either specify the length you want explicitly,
{\em e.g:}

\small
\begin{verbatim}
      CALL DAT_MAPV( LOC '_CHAR*30', 'READ', PNTR, EL, STATUS )
\end{verbatim}
\normalsize

(in which case HDS would map an array of character strings with each element 
containing 30 characters) or you may leave HDS to decide on the length
required by omitting the length specification, thus:

\small
\begin{verbatim}
      CALL DAT_MAPV( LOC '_CHAR', 'READ', PNTR, EL, STATUS )
\end{verbatim}
\normalsize

In this latter case, HDS will determine the number of characters actually
required to format the object's values without loss of information. It uses
decimal strings for numerical values and the values `TRUE' and `FALSE' to
represent logical values as character strings. If the object is already of
character type, then its actual length will be used directly. The routine
DAT\_MAPC also operates in this manner.

On VMS systems, the returned pointer may be passed to another routine to access
the mapped character data in the normal way. For example:

\small
\begin{verbatim}
      CALL DAT_MAPV( LOC, '_CHAR*80', 'READ', PNTR, EL, STATUS )
      CALL SHOW( EL, %VAL( PNTR ) )
      ...

      SUBROUTINE SHOW( EL, HEADER )
      INTEGER EL
      CHARACTER * ( * ) HEADER( EL )
      DO 1 I = 1, EL
         PRINT *, HEADER( I )
 1    CONTINUE
      END
\end{verbatim}
\normalsize

By declaring the character argument of subroutine SHOW to be an array of {\em
assumed length} character strings, the actual length of the strings mapped by
HDS becomes available to the subroutine via the Fortran intrinsic function LEN
(although this is not used in this particular example).

On UNIX systems, the length of a character string is not passed to a subroutine
in the same manner, but is handled instead by the compiler adding additional
``invisible'' arguments to the end of a subroutine call to specify the lengths
of any character values which are passed. Unfortunately, a compiler cannot
recognise the data type of a mapped array, so it will not be able to
automatically add length information about mapped character strings. This
information must therefore be passed explicitly.

As an example, suppose we mapped an array of character strings specifying that
each string should be of length 80 characters, thus:

\small
\begin{verbatim}
      CALL DAT_MAPV( LOC, '_CHAR*80', 'READ', PNTR, EL, STATUS )
\end{verbatim}
\normalsize

This mapped array could be passed to the (same) SHOW subroutine on a UNIX
system as follows:

\small
\begin{verbatim}
      CALL SHOW( EL, %VAL( PNTR ), %VAL( 80 ) )
\end{verbatim}
\normalsize

Note how the character string length (80) is passed as an additional argument
(which does not appear in the formal argument list of the SHOW subroutine)
using the `\%VAL' facility. If an access mode of `\_CHAR' were specified
(leaving HDS to determine the length of the mapped strings) then an additional
call to DAT\_CLEN would be required to determine this length, as follows:

\small
\begin{verbatim}
      ...
      INTEGER LENGTH

      CALL DAT_MAPV( LOC, '_CHAR', 'READ', PNTR, EL, STATUS )
      CALL DAT_CLEN( LOC, LENGTH, STATUS )
      CALL SHOW( EL, %VAL( PNTR ), %VAL( LENGTH ) )
\end{verbatim}
\normalsize

If more than one mapped character array is being passed, then the length of
each must be passed separately by adding it to the end of the argument list.
This must be done in the same order as the arrays themselves are passed. 

Unfortunately, this technique will only work if there are no other character
values being passed at earlier points in the argument list. Otherwise, there is
no way of adding additional length information so that it appears in the
correct position relative to the ``invisible'' information that the compiler
will already have generated for the other argument(s). The only solution in
such cases is to provide a dummy routine whose purpose is simply to permute the
argument order so that mapped character arrays may be passed at the start of the
formal argument list.

For software that is intended to be portable between UNIX and VMS systems, it is
recommended that the UNIX passing mechanism be adopted for mapped character
values. VMS will simply ignore the additional length information.

\section{COPYING AND DELETING OBJECTS}

HDS can also copy and delete objects. 
Routines DAT\_COPY and DAT\_ERASE will recursively copy and
erase all levels of the hierarchy below that specified in the subroutine
call: 

\small
\begin{verbatim}
      ...
      CHARACTER * ( DAT__SZLOC ) OLOC

*  Copy the AXIS structure to component AXISCOPY of the structure located
*  by OLOC (which must have been previously defined).
      CALL DAT_FIND( NLOC, 'AXIS', ALOC, STATUS )
      CALL DAT_COPY( ALOC, OLOC, 'AXISCOPY', STATUS )
      CALL DAT_ANNUL( ALOC, STATUS )

* Erase the original AXIS structure.
      CALL DAT_ERASE( NLOC, 'AXIS', STATUS )
\end{verbatim}
\normalsize

Note that we annulled the locator to the AXIS object before attempting to
delete it. This whole operation can also be done using DAT\_MOVE:

\small
\begin{verbatim}
      CALL DAT_MOVE( ALOC, OLOC, 'AXISCOPY', STATUS )
\end{verbatim}
\normalsize

\section{SUBSETS OF OBJECTS}
The routine DAT\_CELL accesses a single element of an array. An
example was shown in \S\ref{sect:creating}. The routine DAT\_SLICE
accesses a subset of an arbitrarily dimensioned object. This subset can then be
treated as if it were an object in its own right. For example: 

\small
\begin{verbatim}
      ...
      CHARACTER * ( DAT__SZLOC ) SLICE
      INTEGER LOWER( 2 ), UPPER( 2 )
      DATA LOWER / 100, 100 /
      DATA UPPER / 200, 200 /

*  Get a locator to the subset DATA_ARRAY(100:200,100:200).
      CALL DAT_FIND( NLOC, 'DATA_ARRAY', LOC, STATUS )
      CALL DAT_SLICE( LOC, 2, LOWER, UPPER, SLICE, STATUS )

*  Map the subset as a vector.
      CALL DAT_MAPV( SLICE, '_REAL', 'UPDATE', PNTR, EL, STATUS )
      ...
\end{verbatim}
\normalsize

In contrast to DAT\_SLICE, DAT\_ALTER makes a permanent change to a
non-scalar object. The object can be made larger or smaller, but only the last
dimension can be ALTERed. This function is entirely dynamic, {\em i.e.}\ can be
done at any time provided that the object is not mapped for access. Note that
DAT\_ALTER works on both primitives and structures. It is important to
realise that the number of dimensions cannot be changed by DAT\_ALTER. 

\section{TEMPORARY OBJECTS}
Temporary objects of any type and shape may be created by using the 
DAT\_TEMP routine. This returns a locator to the newly created object and this
may then be manipulated just as if it were an ordinary object (in fact a
temporary container file is created with a unique name to hold all such objects,
and this is deleted when the program terminates, or when HDS\_STOP is
called, if this happens earlier). This is often useful for providing workspace
for algorithms which may have to deal with large arrays. 

\section{USING LOCATORS}
\label{sect:locators}

\subsection{Locator Validity}
As has been illustrated earlier, HDS refers to data objacts by means of values
held in character variables called {\em locators}.  Of course, these character
values are not HDS data objects themselves; they simply identify the data
objects, whose internal details are hidden within the HDS system.

Each locator has a unique value which will not be re-used, and this property
makes it possible to tell at any time whether a character value is a valid HDS
locator or not.  A locator's validity depends on a number of things, such as its
actual value (the value DAT\_\_NOLOC\footnote{As defined in the include file
DAT\_PAR.} is never valid for instance) and the previous history and current
state of the HDS system (a locator which refers to a data object which has
been deleted will no longer be valid).  Note that locator values should not be
explicitly altered by applications, as this may also cause them to become
invalid. 

Locator validity can be determined by using the routine DAT\_VALID, which
returns a logical value of .TRUE.\ via its VALID argument if the locator
supplied is valid: 

\small
\begin{verbatim}
      CALL DAT_VALID( LOC, VALID, STATUS )
\end{verbatim}
\normalsize

This is the only HDS routine to which an invalid locator may be passed without
provoking an error.

\subsection{Annulling Locators}
\label{sect:annul}

The number of locators available at any time is quite large, but each locator
consumes various computer resources which may be limited, so it is important to
ensure that locators are {\em annulled\/} once they have been finished with,
{\em i.e.}\ when access to the associated data object is no longer required. 

Annulling an HDS locator renders it invalid and resets its value to
DAT\_\_NOLOC.  It differs from simply setting the locator's variable to this
value, however, because it ensures that all resources associated with it are
released and made available for re-use. A locator is annulled using the routine
DAT\_ANNUL, as follows:

\small
\begin{verbatim}
      CALL DAT_ANNUL( LOC, STATUS )
\end{verbatim}
\normalsize

Note that annulling an invalid locator will produce an error, but this will be
ignored if the STATUS argument is not set to SAI\_\_OK when DAT\_ANNUL is called
({\em i.e.}\ indicating that a previous error has occurred). This means that it
is not usually necessary to check whether a locator is valid before annulling
it, so long as the only possible reason for it being invalid is a previous error
which has set a STATUS value. 

\subsection{Cloning Locators}

Since an HDS locator only refers to a data object and does not itself contain
any data values, it is possible to have several locators referring to the same
object.  A duplicate locator for an HDS object may be derived from an existing
one by a process called {\em cloning}, which is performed by the routine
DAT\_CLONE, as follows:

\small
\begin{verbatim}
      CALL DAT_CLONE( LOC1, LOC2, STATUS )
\end{verbatim}
\normalsize

This returns a second locator LOC2 which refers to the same data object as LOC1.

Cloning is not required frequently, but it can occasionally be useful in
allowing an application to ``hold on'' to a data oabject when a locator is
passed to a routine which may annul it; {\em i.e.}\ you simply pass the original
locator and keep the cloned copy.

\subsection{Primary and Secondary Locators}
\label{sect:primary}

Since data objects are stored in container files, HDS has to decide when to open
and close these files (it would be very inefficient if a file had to be opened
every time an object within it was referenced). To allow control over this, HDS
locators are divided into two classes termed {\em primary} and {\em secondary},
and it is the primary locators that are responsible for holding container files
open.

To be more specific, an HDS container file will remain open, so that data
objects within it are accessible, for as long as there is at least one valid
primary locator associated with it (that is, with one of the data objects within
the file). Not surprisingly, those routines intended for opening container files
(HDS\_OPEN, HDS\_NEW and HDS\_WILD) will return primary locators -- so that the
file subsequently remains open. However, all other routines return secondary
locators (with the exception of DAT\_PRMRY, which may be used to manipulate this
attribute -- see \S\ref{sect:promote}).

\subsection{Container File Reference Counts}
The number of primary locators associated with an HDS container file is called
its {\em reference count} and may be determined using the DAT\_REFCT routine as
follows:

\small
\begin{verbatim}
      CALL DAT_REFCT( LOC, REFCT, STATUS )
\end{verbatim}
\normalsize

Here, LOC is a locator associated with any object in the file and the reference
count is returned via the integer REFCT argument. The file will remain open for
as long as this value is greater than zero.

Normally, a file's reference count will fall to zero due to annulling the last
primary locator associated with it (usually the locator obtained when the file
was originally opened), and at this point the file will be closed. Before this
happens, however, any mapped primitive objects within it will be un-mapped. In
addition, any secondary locators that remain associated with data objects in the
same file will be annulled ({\em i.e.}\ they will become invalid).\footnote{You
are advised not to depend on this mechanism for annulling secondary locators
because you will not normally have complete control over a file's reference
count (for instance, it may be opened independently for some other purpose in
the same piece of software).} No further reference to objects within the file
may be made until it has been explicitly re-opened.

\subsection{Promoting and Demoting Locators}
\label{sect:promote}

A locator may, at any time, be ``promoted'' to become a primary locator (thus
incrementing the container file's reference count) or ``demoted'' to become a
secondary locator (and decrementing the reference count). This is done by using
the DAT\_PRMRY routine with its (first) SET argument set to .TRUE., thus:

\small
\begin{verbatim}
      PRMRY = .TRUE.             ! Promote the locator
      CALL DAT_PRMRY( .TRUE., LOC, PRMRY, STATUS )
\end{verbatim}
\normalsize

With its first argument set to .FALSE., the same routine may also be used to
enquire whether a locator is primary or not.

The main reason for promoting locators is to allow HDS objects to be passed
between routines while ensuring that the associated container file remains open,
so that the object remains accessible. For example, consider the following
simple routine which returns a locator for a named object inside a container
file:

\small
\begin{verbatim}
      SUBROUTINE FINDIT( FILE, LOC, STATUS )

      <declarations, etc.>

*  Open the container file and find the required object.
      CALL HDS_OPEN( FILE, 'READ', TMPLOC, STATUS )
      CALL DAT_FIND( TMPLOC, 'MY_OBJECT', LOC, STATUS )

*  Promote the new locator and annul the orginal.
      CALL DAT_PRMRY( .TRUE., LOC, .TRUE., STATUS )
      CALL DAT_ANNUL( LOCTMP, STATUS )
      END
\end{verbatim}
\normalsize

Note how the temporary locator returned by HDS\_OPEN is annulled after first
promoting the secondary locator derived from it, so that the container file
remains open. If this is the first time the file has been opened, its reference
count will be 1 when this routine exits, so it will be closed when the caller
later annuls the returned locator LOC.

\section{ENQUIRIES}
One of the most important properties of HDS is that its data files are self
describing. This means that each object carries with it information describing
all its attributes (not just its value), and these attributes can be obtained
by means of enquiry routines. An example will illustrate:

\small
\begin{verbatim}
      ...
      PARAMETER ( MAXCMP = 10 )
      CHARACTER * ( DAT__SZNAM ) NAME( MAXCMP )
      CHARACTER * ( DAT__SZTYP ) TYPE( MAXCMP )
      INTEGER NCOMP, I
      LOGICAL PRIM( MAXCMP )

*  Enquire the names and types of up to MAXCMP components...

*  First store the total number of components.
      CALL DAT_NCOMP( NLOC, NCOMP, STATUS)

*  Now index through the structure's components, obtaining locators and the
*  required information.
      DO 1 I = 1, MIN( NCOMP, MAXCMP )

*  Get a locator to the I'th component.
         CALL DAT_INDEX( NLOC, I, LOC, STATUS )

* Obtain its name and type.
         CALL DAT_NAME( LOC, NAME( I ), STATUS )
         CALL DAT_TYPE( LOC, TYPE( I ), STATUS )

* Is it primitive?
         CALL DAT_PRIM( LOC, PRIM( I ), STATUS )
         CALL DAT_ANNUL( LOC, STATUS )
 1    CONTINUE
      ...
\end{verbatim}
\normalsize

Here DAT\_INDEX is used to get locators to objects about which (in
principle) we know nothing. This is just like listing the files in a
directory, except that the order in which the components are stored in an
HDS structure is arbitrary (so they won't necessarily be accessed in
alphabetical order). 

\section{PACKAGED ROUTINES}
HDS provides families of routines which provide a more convenient method of
access to objects than the basic routines. For instance DAT\_PUT$*$ and
DAT\_GET$*$ package DAT\_PUT and DAT\_GET by type and
dimensionality. Thus DAT\_PUT0I will write a single INTEGER value to a
scalar primitive. DAT\_GET1R will read the value of a vector primitive
and store it in a REAL program array. There are no DAT\_GET2x
routines; all dimensionalities higher than one are handled by 
DAT\_GETNx and DAT\_PUTNx. 

Another family of routines are the CMP routines. These access components of
the `current level'. This usually involves: 

\begin{itemize}

\item FINDing the required object and getting a locator to it.

\item Performing the required operation, {\em e.g.}\ PUTting some value into
it.

\item ANNULling the locator.

\end{itemize}

The CMP routines package this sort of operation, replacing three or so
subroutine calls with one. The naming scheme is based on the associated DAT
routines. An example is shown below. 

\small
\begin{verbatim}
      ...
      CHARACTER * 80 DLAB
      INTEGER DIMS( 2 )
      REAL IMVALS( 512, 1024 )
      DATA DIMS / 512, 1024 /

*  Get REAL values from the DATA_ARRAY component.
      CALL CMP_GETNR( NLOC, 'DATA_ARRAY', 2, DIMS, IMVALS, DIMS, STATUS )

*  Get a character string from the LABEL component and store it in DLAB.
      CALL CMP_GET0C( NLOC, 'LABEL', DLAB, STATUS )
      ...
\end{verbatim}
\normalsize

\section{TUNING}
\label{sect:tuning}

\subsection{Setting HDS Tuning Parameters}
HDS has a number of internal integer {\em tuning parameters} whose values
control various aspects of its behaviour and some of which may have an important
effect on its performance. Each of these parameters has a default value, but may
be over-ridden by either of two mechanisms.

\paragraph{Method 1.} By defining appropriate environment
variables\footnote{Logical names on VMS systems.} it is possible to set new
default values for HDS tuning parameters. The translation of these environment
variables is picked up when HDS starts up (typically when the first HDS routine
is called) and an attempt is then made to interpret the resulting value as an
integer. If successful, the default value of the tuning parameter is set to the
new value. If not, it remains unchanged. HDS applies sensible constraints to any
new values supplied.

For example, on VMS systems, the logical name definition:

\small
\begin{verbatim}
   $ DEFINE/JOB HDS_INALQ 10
\end{verbatim}
\normalsize

could be used to increase the default size of all newly created HDS files to 10
blocks. The equivalent C~shell definition on UNIX systems would be:

\small
\begin{verbatim}
   % setenv HDS_INALQ 10
\end{verbatim}
\normalsize

The name of the environment variable is constructed by prefixing the string
`HDS\_' to the tuning parameter name. All such environment variables must be
specified using upper case.

It should be recognised that this ability to set tuning parameter values via
environment variables can be dangerous. It is provided mainly to encourage
experimentation and to overcome ``one-off'' tuning problems, but it carries a
risk of disrupting normal program behaviour. In particular, you should not
expect that all HDS programs will necessarily continue to work with all possible
settings of their tuning parameters, and software developers are urged not to
write programs which depend on non-default settings of HDS tuning parameters, as
this may give rise to conflicts with other software. If a tuning parameter
setting really is critical, then it should be set by the software itself (see
below), so as to prohibit outside interference.

\paragraph{Method 2.} Tuning parameter values may also be set directly from
within an item of software by means of calls to the routine HDS\_TUNE. This
allows programs to over-ride the default settings (or those established {\em
via} environment variables). To modify the `MAP' tuning parameter, for example,
the following call might be used:

\small
\begin{verbatim}
      CALL HDS_TUNE( 'MAP', 0, STATUS )
\end{verbatim}
\normalsize

This would have the effect of disabling file mapping in favour of reading and
writing as the preferred method of accessing data in container files. The
related routine HDS\_GTUNE may be used to determine the current setting of a
tuning parameter (see \S\ref{sect:gtune} for an example of its use).


\subsection{Tuning Parameters Available}
\label{sect:tuning_parameters}

HDS currently uses the following tuning parameters to control its behaviour.

\begin{description}

\item [INALQ - Initial File Allocation Quantity:]\mbox{}\\
This value determines how many blocks\footnote{An HDS block is 512 bytes.} are
to be allocated when a new container file is created. The default value of 2 is
the minimum value allowed; the first block contains header information and the
second contains the top-level object. Note that the host operating system may
impose further restrictions on allowable file sizes, so the actual size of a
file may not match the value specified exactly.

The value of this parameter reverts to its default value (or the value specified
by the HDS\_INALQ environment variable) after each file is created, so if it is
being set from within a program, it must be set every time that it is required.

If a file is to be extended frequently (through the creation of new objects
within it), then this parameter may provide a worthwhile efficiency gain by
allowing a file of a suitable size to be created initially. This can be useful
on VMS systems, where file extension can be a relatively slow operation. On UNIX
systems, however, the benefits may be minimal.

\item [MAP - Use file mapping if available?]\mbox{}\\
This value controls the method by which HDS performs I/O operations on the
values of primitive objects and may take the following values:

\begin{description}
\item[MAP$=$1:]\mbox{}\\
Use ``file mapping'' (if supported) as the preferred method of accessing
primitive data.

\item[MAP$=$0:]\mbox{}\\
Use read/write operations (if supported) as the preferred data access method.

\item[MAP$=-$1:]\mbox{}\\
Use whichever method is normally faster for sequential access to all elements of
a large array of data.

\item[MAP$=-$2:]\mbox{}\\
Use whichever method is normally faster for sparse random access to a large
array of data.

\item[MAP$=-$3:]\mbox{}\\
Use whichever method normally makes the smaller demand on system memory
resources (normally this means a request to minimise use of address space or
swap/page file space, but the precise interpretetion is operating system
dependent). This is normally the appropriate option if you intend to use HDS
arrays as temporary workspace.
\end{description}

HDS converts all other values to one. The value may be changed at any time.

A subsequent call to HDS\_GTUNE, specifying the `MAP' tuning parameter, will
return 0 or 1 to indicate which option was actually chosen. This may depend on
the capabilities of the host operating system and the particular implementation
of HDS in use. The default value for this tuning parameter is also system
dependent (see \S\ref{sect:system_map}).

Typically, file mapping has the following plus and minus points:

\begin{itemize}

\item[$+$] It allows large arrays accessed via the HDS mapping routines to be
sparsely accessed in an efficient way. In this case, only those regions of the
array actually accessed will need to be read/written, as opposed to reading the
entire array just to access a small fraction of it. This might be useful, for
instance, if a 1-dimensional profile through a large image were being
generated.

\item[$+$] It allows HDS container files to act as ``backing store'' for the
virtual memory associated with objects accessed via the mapping routines. The
operating system can then use HDS files, rather than its own backing (swap/page)
file, to implement virtual memory management. This means that you do not need to
have a large system backing file available in order to access large datasets.

\item[$+$] For the same reason, temporary objects created with DAT\_TEMP
and mapped to provide temporary workspace make no additional demand on the
system backing file.

\item[$?$] On some operating systems file mapping may be less efficient in terms
of elapsed time than direct read/write operations. This is particularly so on
VMS systems when they are heavily loaded. Conversely, on some operating systems
it may be more efficient.

\item[$-$] Not all operating systems support file mapping and it generally
requires system-specific programming techniques, making it more trouble to
implement on a new operating system.

\end{itemize}

Using read/write access has the following advantages and disadvantages:

\begin{itemize}

\item[$+$] On some operating systems (notably VMS) it may be more efficient than
file mapping in terms of elapsed time in cases where an array of data will be
accessed in its entirety (the normal situation).

\item[$-$] It is an inefficient method of accessing a small subset of a large
array because it requires the entire array to be read/written. The solution to
this problem is to explicitly access the required subset using ({\em e.g.\/})
DAT\_SLICE, although this complicates the software somewhat.

\item[$-$] It makes demands on the operating system's backing file which the
file mapping technique avoids (see above). As a result, there is little point
in creating scratch arrays with DAT\_TEMP for use as workspace unless
file mapping is available (because the system backing file will be used anyway).

\item[$?$] If an object is accessed several times simultaneously using HDS
mapping routines, then modifications made via one mapping may not be
consistently reflected in the other mapping (modifications will only be updated
in the container file when the object is unmapped, so the two mappings may get
out of step in the mean time). Conversely, if file mapping is in use and a
primitive object is mapped in its entirety without type conversion, then this
behaviour does not occur (all mappings remain consistent). It may occur,
however, if a slice is being accessed or if type conversion is needed.

It is debatable which behaviour is preferable. The best policy is to avoid the
problem entirely by not utilising multiple access to the same object while
modifications are being made.

\end{itemize}

\item [MAXWPL - Maximum Size of the ``Working Page List'':]\mbox{}\\
This value specifies how many blocks\footnotemark[\thefootnote] are
to be allocated to the memory cache which HDS uses to hold information about
the structure of HDS files and objects and to buffer its I/O operations when
obtaining this information. The default value is 32 blocks; this value cannot
be decreased. Modifications to this value will only have an effect if made
before HDS becomes active ({\em i.e.}\ before any call is made to another HDS
routine).

There will not normally be any need to increase this value unless excessively
complex data structures are being accessed with very large numbers of locators
simultaneously active.

\item [NBLOCKS - Size of the internal ``Transfer Buffer'':]\mbox{}\\
When HDS has to move large quantities of data from one location to another, it
often has to store an intermediate result. In such cases, rather than allocate a
large buffer to hold all the intermediate data, it uses a smaller buffer and
performs the transfer in pieces. This parameter specifies the maximum size in
blocks\footnotemark[\thefootnote] which this transfer buffer may have and is
constrained to be no less than the default, which is 32 blocks.

The value should not be too small, or excessive time will be spent in loops
which repeatedly refill the buffer. Conversely, too large a value will make
excessive demands on memory. In practice there is a wide range of acceptable
values, so this tuning parameter will almost never need to be altered.

\item [NCOMP - Optimum number of structure components:]\mbox{}\\
This value may be used to specify the expected number of components which will
be stored in an HDS structure. HDS does not limit the number of structure
components, but when a structure is first created, space is set aside for
creation of components in future. If more than the expected number of
components are subsequently created, then HDS must eventually re-organise part
of the container file to obtain the space needed. Conversely, if fewer
components are created, then some space in the file will remain unused. The
value is constrained to be at least one, the default being 6 components.

The value of this parameter is used during the creation of the first component
in every new structure.  It reverts to its default value (or the value specified
by the HDS\_NCOMP environment variable) afterwards, so if it is being set from
within a program, it must be set every time it is needed.

\item [SHELL - Preferred shell:]\mbox{}\\
This parameter only has an effect on UNIX systems (it is accepted but has no
effect on other systems) and determines which shell should be used to interpret
container file names which contain ``special'' characters representing
pattern-matching, environment variable substitution, {\em etc.} Each shell
typically has its own particular subtleties about how these characters are
interpreted, so users of HDS may wish to select the same shell as they normally
use for entering commands. The following values are allowed:

\begin{description}
\item[SHELL$=$2:]\mbox{}\\
Use the ``tcsh'' shell (if available). If this is not available, then use the
same shell as when SHELL$=$1.

\item[SHELL$=$1:]\mbox{}\\
Use the ``csh'' shell (C~shell on traditional UNIX systems). If this is not
available, then use the same shell as when SHELL$=$0.

\item[SHELL$=$0 (the default):]\mbox{}\\
Use the ``sh'' shell. This normally means the Bourne Shell on traditional UNIX
systems, but on systems which support it, the draft POSIX.2 (Shell and
Utilities) ``sh'' shell may be used instead.

\item[SHELL$=-$1:]\mbox{}\\
Don't use any shell for interpreting single file names (all special characters
are to be interpreted literally). When performing ``wild-card'' searches for
multiple files (with HDS\_WILD), use the same shell as when SHELL$=$0.
\end{description}

HDS converts all other values to zero.

\item [SYSLCK - System wide lock flag:]\mbox{}\\
This parameter only has an effect on VMS systems (it is accepted but has no
effect on other systems). It acts as a logical switch; a value of zero (the
default) causes VMS file locking to operate only on a UIC group-wide basis,
while a  value of 1 causes file locking to operate on a system-wide basis. HDS
converts all non-zero values to one. Note that only processes with the
``SYSLCK'' privilege can make use of system-wide locking on VMS (see the VMS
Lock Management Services documentation for further details).

\item [WAIT - Wait for locked files?]\mbox{}\\
This value acts as a logical switch which specifies the action to be taken if
HDS detects that a container file which it needs to access is locked by another
process. A value of zero (the default) causes HDS to return with an error if
this condition occurs, while a value of 1 causes it to wait until the other
process unlocks the file. HDS converts all non-zero values to one.

\end{description}

\subsection{Tuning in Practice}
\label{sect:gtune}

Normally, a single application which wished to tune HDS itself (rather than
accepting the default settings, or those specified by environment variables)
would do so via calls to HDS\_TUNE at the start, and would thus establish
a default ``tuning profile'' to apply throughout the rest of the program.
Similarly, a software environment can initially tune HDS to obtain the required
default behaviour for the applications it will later invoke.

Sometimes, however, it may be necessary to modify a tuning parameter to improve
performance locally while not affecting behaviour of other parts of a program
(or other applications in a software environment). The routine HDS\_GTUNE
may therefore be used to determine the current setting of an HDS tuning
parameter, so that it may later be returned to its original value. For
instance, if the `MAP' parameter were to be set locally to allow sparse access
to a large array of data, the following technique might be used:

\small
\begin{verbatim}
      ...
      INTEGER OLDMAP

*  Obtain the original setting of the MAP parameter.
      CALL HDS_GTUNE( 'MAP', OLDMAP, STATUS )
      IF ( STATUS .EQ. SAI__OK ) THEN

*  Set a new value.
         CALL HDS_TUNE( 'MAP', -2, STATUS )

         <map the array>

*  Return to the old tuning setting.
         CALL ERR_BEGIN( STATUS )
         CALL HDS_TUNE( 'MAP', OLDMAP, STATUS )
         CALL ERR_END( STATUS )
      END IF
\end{verbatim}
\normalsize

Notice how great care has been taken over handling error conditions. In a large
software system it could prove disastrous if a tuning parameter remained set to
an incorrect value (perhaps causing gross inefficiencies elsewhere) simply
because HDS\_TUNE did not execute after an unexpected error had caused STATUS to
be set to an error value.

\section{COMPILING AND LINKING}

\subsection{UNIX Systems}

Before compiling applications which use HDS routines on UNIX systems, you should
normally ``log in'' for HDS software development with the following shell
command:

\small
\begin{verbatim}
   % hds_dev
\end{verbatim}
\normalsize

This will create links in your current working directory which refer to the HDS
include files. You may then refer to these files using their standard (upper
case) names without having to know where they actually reside. These links will
persist, but may be removed at any time, either explicitly or with the command:

\small
\begin{verbatim}
   % hds_dev remove
\end{verbatim}
\normalsize

If you do not ``log in'' in this way, then references to HDS include files
should be in lower case and must contain an absolute pathname identifying the
Starlink include file directory, thus:

\small
\begin{verbatim}
      INCLUDE '/star/include/dat_par'
\end{verbatim}
\normalsize

The former method is recommended.

Users of the ADAM programming environment (SG/4) on UNIX systems need take no
special steps in order to link with HDS because the normal ADAM commands for
building tasks will do this automatically. Thus, for instance, an ADAM A-task
which calls HDS routines might be built simply as follows:

\small
\begin{verbatim}
   % alink adamprog.f
\end{verbatim}
\normalsize

``Stand-alone'' ({\em i.e.}\ non-ADAM) applications which use HDS may be linked
by specifying `hds\_link` on the compiler command line. Thus, to compile and
link a stand-alone application called `prog', the following might be used:

\small
\begin{verbatim}
   % f77 prog.f -L/star/lib `hds_link` -o prog
\end{verbatim}
\normalsize

(note the use of backward quote characters, which are required).

\subsection{VMS Systems}

Users of the ADAM programming environment (SG/4) on VMS systems need take no
special steps in order to access HDS routines. The normal ADAM startup commands:

\small
\begin{verbatim}
   $ ADAMSTART
   $ ADAMDEV
\end{verbatim}
\normalsize

will ensure that all necessary definitions are made, and the standard ADAM link
commands will automatically access the appropriate version of the HDS library.
Thus, for instance, an ADAM A-task which calls HDS routines might be linked
simply as follows:

\small
\begin{verbatim}
   $ FORTRAN ADAMPROG
   $ ALINK ADAMPROG
\end{verbatim}
\normalsize

For non-ADAM users, the initialisation command:

\small
\begin{verbatim}
   $ HDS_DEV
\end{verbatim}
\normalsize

must first be executed before compiling or linking an application which calls
HDS routines. This will define all the logical names required for accessing
include files and linker options files.

The preferred method of linking ``stand-alone'' ({\em i.e.}\ non-ADAM)
applications which use HDS is {\em via} the standard STAR\_LINK options file.
Thus, to compile and link a stand-alone application, the following might be
used:

\small
\begin{verbatim}
   $ FORTRAN PROG
   $ LINK PROG,STAR_LINK/OPT
\end{verbatim}
\normalsize

If, for any reason, you wish to link explicitly with the HDS library, rather
than {\em via} the STAR\_LINK library, then the options file HDS\_LINK may be
used instead, thus:

\small
\begin{verbatim}
   $ LINK PROG,HDS_LINK/OPT
\end{verbatim}
\normalsize

\section{ACKNOWLEDGEMENTS}
The routines currently distributed as HDS derive from two original sources. The
first is the initial implementation written by Dave Pearce and Anton Walter at
RAL (initially using the BLISS language), which was subsequently converted into
C by Mike Lawden (RAL) and William Lupton (RGO and AAO). The second source is a
collection of higher-level routines mostly written at University College London
in Fortran~77 by Sid Wright and Jack Giddings. William Lupton subsequently
performed some of the initial work aimed at making HDS more portable.

Since then, HDS has undergone considerable internal change, including
substantial re-coding to produce a fully portable system. It is currently
supported by Rodney Warren-Smith at RAL.

\appendix

\newpage
\section{ALPHABETICAL LIST OF ROUTINES}
\label{appendix:alphalist}

Note that the argument lists of all the following routines, together with
on-line help information, are available within the Starlink language sensitive
editor STARLSE (SUN/105).

\small
\noindent
{\bf CMP\_GET0x}{\em (loc,name;value,status)} --- Read scalar component\\
{\bf CMP\_GET1x}{\em (loc,name,elx;value,el,status)} --- Read vector component\\
{\bf CMP\_GETNx}{\em (loc,name,ndim,dimx;value,dim,status)} --- Read array component\\
{\bf CMP\_GETVx}{\em (loc,name,elx;value,el,status)} --- Read vectorised component\\
{\bf CMP\_LEN}{\em (loc,name;len,status)} --- Enquire component precision\\
{\bf CMP\_MAPN}{\em (loc,name,type,mode,ndim;pntr,dim,status)} --- Map array component\\
{\bf CMP\_MAPV}{\em (loc,name,type,mode;pntr,el,status)} --- Map vectorised component\\
{\bf CMP\_MOD}{\em (loc,name,type,ndim,dim;status)} --- Obtain component\\
{\bf CMP\_MODC}{\em (loc,name,len,ndim,dim;status)} --- Obtain string component\\
{\bf CMP\_PRIM}{\em (loc,name;reply,status)} --- Enquire component primitive\\
{\bf CMP\_PUT0x}{\em (loc,name,value;status)} --- Write scalar component\\
{\bf CMP\_PUT1x}{\em (loc,name,el,value;status)} --- Write vector component\\
{\bf CMP\_PUTNx}{\em (loc,name,ndim,dimx,value,dim;status)} --- Write array component\\
{\bf CMP\_PUTVx}{\em (loc,name,el,value;status)} --- Write vectorised component\\
{\bf CMP\_SHAPE}{\em (loc,name,ndimx;dim,ndim,status)} --- Enquire component shape\\
{\bf CMP\_SIZE}{\em (loc,name;size,status)} --- Enquire component size\\
{\bf CMP\_STRUC}{\em (loc,name;reply,status)} --- Enquire component structure\\
{\bf CMP\_TYPE}{\em (loc,name;type,status)} --- Enquire component type\\
{\bf CMP\_UNMAP}{\em (loc,name;status)} --- Unmap component\\

{\bf DAT\_ALTER}{\em (loc,ndim,dim;status)} --- Alter object size \\
{\bf DAT\_ANNUL}{\em (loc;status)} --- Annul locator \\
{\bf DAT\_BASIC}{\em (loc,mode;pntr,len,status)} --- Map primitive as basic units \\
{\bf DAT\_CCOPY}{\em (loc1,loc2,name;loc3,status)} --- Copy one structure level\\
{\bf DAT\_CCTYP}{\em (size;type)} --- Create type string\\
{\bf DAT\_CELL}{\em (loc1,ndim,sub;loc2,status)} --- Locate cell \\
{\bf DAT\_CLEN}{\em (loc;clen,status)} --- Enquire character string length \\
{\bf DAT\_CLONE}{\em (loc1;loc2,status)} --- Clone locator \\
{\bf DAT\_COERC}{\em (loc1,ndim;loc2,status)} --- Coerce object shape \\
{\bf DAT\_COPY}{\em (loc1,loc2,name;status)} --- Copy object \\
{\bf DAT\_DREP}{\em (loc;format,order,status)} --- Obtain primitive data representation information\\
{\bf DAT\_ERASE}{\em (loc,name;status)} --- Erase component \\
{\bf DAT\_ERMSG}{\em (status;length,msg)} --- Translate error status\\
{\bf DAT\_FIND}{\em (loc1,name;loc2,status)} --- Find named component \\
{\bf DAT\_GET}{\em (loc,type,ndim,dim;value,status)} --- Read primitive \\
{\bf DAT\_GETx}{\em (loc,ndim,dim;value,status)} --- Read primitive \\
{\bf DAT\_GET0x}{\em (loc;value,status)} --- Read scalar primitive\\
{\bf DAT\_GET1x}{\em (loc,elx;value,el,status)} --- Read vector primitive\\
{\bf DAT\_GETNx}{\em (loc,ndim,dimx;value,dim,status)} --- Read array primitive\\
{\bf DAT\_GETVx}{\em (loc,elx;value,el,status)} --- Read vectorised primitive\\
{\bf DAT\_INDEX}{\em (loc1,index;loc2,status)} --- Index into component list \\
{\bf DAT\_LEN}{\em (loc;len,status)} --- Enquire primitive precision \\
{\bf DAT\_MAP}{\em (loc,type,mode,ndim,dim;pntr,status)} --- Map primitive \\
{\bf DAT\_MAPx}{\em (loc,mode,ndim,dim;pntr,status)} --- Map primitive \\
{\bf DAT\_MAPN}{\em (loc,type,mode,ndim;pntr,dim,status)} --- Map array primitive\\
{\bf DAT\_MAPV}{\em (loc,type,mode;pntr,el,status)} --- Map vectorised primitive\\
{\bf DAT\_MOULD}{\em (loc,ndim,dim;status)} --- Alter object shape \\
{\bf DAT\_MOVE}{\em (loc1,loc2,name;status)} --- Move object \\
{\bf DAT\_MSG}{\em (token,loc)} --- Assign object name to message token \\
{\bf DAT\_NAME}{\em (loc;name,status)} --- Enquire object name \\
{\bf DAT\_NCOMP}{\em (loc;ncomp,status)} --- Enquire number of components \\
{\bf DAT\_NEW}{\em (loc,name,type,ndim,dim;status)} --- Create component \\
{\bf DAT\_NEW0x}{\em (loc,name;status)} --- Create scalar component\\
{\bf DAT\_NEW0C}{\em (loc,name,len;status)} --- Create scalar string component\\
{\bf DAT\_NEW1x}{\em (loc,name,el;status)} --- Create vector component\\
{\bf DAT\_NEW1C}{\em (loc,name,len,el;status)} --- Create vector string component\\
{\bf DAT\_NEWC}{\em (loc,name,len,ndim,dim;status)} --- Create string component\\
{\bf DAT\_PAREN}{\em (loc1;loc2,status)} --- Find parent \\
{\bf DAT\_PREC}{\em (loc;nbyte,status)} --- Enquire storage precision\\
{\bf DAT\_PRIM}{\em (loc;reply,status)} --- Enquire object primitive \\
{\bf DAT\_PRMRY}{\em (set;loc,prmry,status)} --- Set or enquire
primary/secondary locator \\
{\bf DAT\_PUT}{\em (loc,type,ndim,dim,value;status)} --- Write primitive \\
{\bf DAT\_PUTx}{\em (loc,ndim,dim,value;status)} --- Write primitive \\
{\bf DAT\_PUT0x}{\em (loc,value;status)} --- Write scalar primitive\\
{\bf DAT\_PUT1x}{\em (loc,el,value;status)} --- Write vector primitive\\
{\bf DAT\_PUTNx}{\em (loc,ndim,dimx,value,dim;status)} --- Write array primitive\\
{\bf DAT\_PUTVx}{\em (loc,el,value;status)} --- Write vectorised primitive\\
{\bf DAT\_REF}{\em (loc;ref,lref,status)} --- Obtain reference name for object \\
{\bf DAT\_REFCT}{\em (loc;refct,status)} --- Enquire the reference count for
a container file \\
{\bf DAT\_RENAM}{\em (loc,name;status)} --- Rename object \\
{\bf DAT\_RESET}{\em (loc;status)} --- Reset object state \\
{\bf DAT\_RETYP}{\em (loc,type;status)} --- Change object type \\
{\bf DAT\_SHAPE}{\em (loc,ndimx;dim,ndim,status)} --- Enquire object shape \\
{\bf DAT\_SIZE}{\em (loc;size,status)} --- Enquire object size \\
{\bf DAT\_SLICE}{\em (loc1,ndim,diml,dimu;loc2,status)} --- Locate slice \\
{\bf DAT\_STATE}{\em (loc;reply,status)} --- Enquire object state \\
{\bf DAT\_STRUC}{\em (loc;reply,status)} --- Enquire object structure \\
{\bf DAT\_TEMP}{\em (type,ndim,dim;loc,status)} --- Create temporary object \\
{\bf DAT\_THERE}{\em (loc,name;reply,status)} --- Enquire component existence \\
{\bf DAT\_TYPE}{\em (loc;type,status)} --- Enquire object type \\
{\bf DAT\_UNMAP}{\em (loc;status)} --- Unmap object \\
{\bf DAT\_VALID}{\em (loc;reply,status)} --- Enquire locator valid \\
{\bf DAT\_VEC}{\em (loc1;loc2,status)} --- Vectorise object \\
{\bf DAT\_WHERE}{\em (loc;block,offset,status)} --- Where is primitive data in file? \\

{\bf HDS\_COPY}{\em (loc,file,name;status)} --- Copy object to container file \\
{\bf HDS\_ERASE}{\em (loc;status)} --- Erase container file \\
{\bf HDS\_EWILD}{\em (iwld,status)} --- End a wild-card search for HDS container
files \\
{\bf HDS\_FLUSH}{\em (group;status)} --- Flush locator group \\
{\bf HDS\_FREE}{\em (loc;status)} --- Free container file \\
{\bf HDS\_GROUP}{\em (loc;group,status)} --- Enquire locator group \\
{\bf HDS\_GTUNE}{\em (param;value,status)} --- Enquire value of tuning parameter \\
{\bf HDS\_LINK}{\em (loc,group;status)} --- Link locator group \\
{\bf HDS\_LOCK}{\em (loc;status)} --- Lock container file \\
{\bf HDS\_NEW}{\em (file,name,type,ndim,dim;loc,status)} --- Create container file \\
{\bf HDS\_OPEN}{\em (file,mode;loc,status)} --- Open container file \\
{\bf HDS\_SHOW}{\em (topic;status)} --- Show HDS statistics \\
{\bf HDS\_STATE}{\em (state,status)} --- Enquire HDS state \\
{\bf HDS\_STOP}{\em (status)} --- Close down HDS \\
{\bf HDS\_TRACE}{\em (loc;nlev,path,file,status)} --- Trace object path \\
{\bf HDS\_TUNE}{\em (param,value;status)} --- Set HDS parameter \\
{\bf HDS\_WILD}{\em (fspec,mode;iwld,loc,status)} --- Perform a wild-card search
for HDS container files
\normalsize

\newpage
\section{ROUTINE DESCRIPTIONS}
\label{appendix:routines}

This appendix gives specifications for all the stand-alone HDS routines. The
parameter descriptions have the following format:

\begin{tabbing}
XXXXXXXX\=descrxxx\=descrxxx\=\kill
\>{\em par}\>type\>description
\end{tabbing}

The `type' specifications use the following codes with the meanings shown:

\begin{tabbing}
XXXXXX\=XXXXXXX\=\kill
\>\+C\>CHARACTER$*$($*$)\\
Cloc\>CHARACTER$*$(DAT\_\_SZLOC)\\
Cnam\>CHARACTER$*$(DAT\_\_SZNAM)\\
Ctyp\>CHARACTER$*$(DAT\_\_SZTYP)\\
E\>EXTERNAL\\
I\>INTEGER\\
L\>LOGICAL\\
?\>CHARACTER$*$($*$), DOUBLE PRECISION, INTEGER, LOGICAL or REAL\\
()\>Array of one of the above types
\end{tabbing}

Some general information on the most common parameters is given below:

\begin{itemize}

\item {\em dim, dimx, ndim, ndimx:}
Parameters {\em dim} and {\em ndim} specify the shape of an object; {\em dimx}
and {\em ndimx} specify the largest permitted values of {\em dim} and {\em
ndim}. The vector {\em dim} holds the sizes of the object dimensions. Thus {\em
dim(1)} holds the size of the first dimension, {\em dim(2)} holds the size of
the second dimension, and so on. The integer {\em ndim} holds the number of
dimensions in an object. HDS supports a maximum of seven object dimensions,
thus {\em dim} should have a maximum of seven elements and {\em ndim} should
not be more than 7. The values of {\em dim} and {\em ndim} must match the
actual shape of the object being processed. A value of zero for {\em ndim}
denotes a `scalar' object; any value specified for {\em dim} will be ignored in
this case. A vector containing a single value is different from a scalar.

\item {\em el, elx:}
When an object is a vector (or is treated as one), {\em el} holds the number of
elements in the vector. When a vector is being read (as in the GET
routines), the actual number of elements may be unknown. In this case {\em elx}
holds the maximum permissible number of elements. This should be equal to the
size of the {\em value} array which is to receive the vector.

\item {\em loc, loc1, loc2, loc3:}
A locator is a CHARACTER$*$(DAT\_\_SZLOC) variable, substring or array element
used to `locate' objects within the data system. The contents are used by HDS
to access internal information and must not be altered explicitly by a program.
When more than one routine parameter is a locator, {\em loc1}, {\em loc2} and
{\em loc3} are used to identify them. The locator for a structure array refers
to the array as a whole. Each element of a structure array is itself a
structure If you wish to address an element of a structure array you must
obtain a new locator for it (using DAT\_CELL). It is important to
distinguish between routines which operate on structures and those which
operate on arrays.

\item {\em name:}
This is a character value specifying the name of an object. A name is written
as a character string containing any printing characters. White space is
ignored and alphabetic characters are capitalised. There are no special rules
governing the first character ({\em i.e.}\ it can be numeric).

\item {\em pntr:}
Routines which map an object value return a pointer to the first element of
that object in the parameter {\em pntr}. This can be converted to a normal
array reference by use of the VAX Fortran `\%VAL' facility as shown in
\S\ref{sect:mapping} and \S\ref{sect:charmapping}.

\item {\em status:}
This receives the HDS status value. If, on entry, a routine finds that {\em
status} is not equal to SAI\_\_OK it assumes an error has occurred previously
and returns immediately without action. This allows tests of {\em status} to be
deferred until after several routine calls have been made. If a routine detects
an error itself, it will set {\em status} to one of the error codes specified
in Appendix~\ref{appendix:errors} and will make an error report in the usual
manner (see SUN/104). Where exceptions to this behaviour exist, they are
documented in the individual routine descriptions.

\item {\em type:}
This specifies the data type the program wishes to use when manipulating a
value. This may be different from the data type used to store the value. We
will call the type used by the program the {\em access type} and the type used
to store the value the {\em storage type}. If these two types differ, automatic
conversion is performed. This is particularly relevant to the GET, 
PUT and MAP routines. The types specified in the names or the {\em type}
parameter of these routines refer to the access type, thus CMP\_GET0I
will read a scalar component and present it to the program as an integer, no
matter how that value is stored in the container file. Thus, {\em type} means
{\em access type}; it also specifies the {\em storage type} in routines which
write a value.

\item {\em value:}
This holds the value of a primitive and could be a scalar, vector or an array.
If a value is being read, the size and shape of the vector or array {\em value}
should match the shape of the object. In some routines {\em value} holds a
`vectorised' object value. This means that the value will be addressed as a
linear sequence of elements instead of as its normal structure. The effect of
this depends on how a structure is mapped. The purpose of vectorising an array
is to enable a simple operation ({\em e.g.}\ adding a constant) to be carried
out on every element without bothering about how each element should be
addressed

\end{itemize}

%+
%  Name:
%     LAYOUT.TEX

%  Purpose:
%     Define Latex commands for laying out documentation produced by PROLAT.

%  Language:
%     Latex

%  Type of Module:
%     Data file for use by the PROLAT application.

%  Description:
%     This file defines Latex commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by Latex. The
%     contents of this file should be included in the source presented to
%     Latex in front of any output from PROLAT. By default, this is done
%     automatically by PROLAT.

%  Notes:
%     The definitions in this file should be included explicitly in any file
%     which requires them. The \include directive should not be used, as it
%     may not then be possible to process the resulting document with Latex
%     at a later date if changes to this definitions file become necessary.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}

%  Define a \tt font of the required size.
\font\ssttt=cmtt10 scaled 1095

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em} 
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.45pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{\item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[1]{\item[{\ssttt #1}] \mbox{} \\}

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  End of LAYOUT.TEX layout definitions.
%.

\newpage
\small
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_GET0x} \hfill Read scalar component \hfill {\bf CMP\_GET0x}}
\begin{description}
\item [ACTION]:
Read a scalar primitive component of a structure.
\item [CALL]:
{\tt CALL CMP\_GET0x(loc,name,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em value}\>?\>Component value.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_GET1x} \hfill Read vector component \hfill {\bf CMP\_GET1x}}
\begin{description}
\item [ACTION]:
Read a vector primitive component of a structure.
\item [CALL]:
{\tt CALL CMP\_GET1x(loc,name,elx,value,el,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em elx}\>I\>Maximum size of {\em value}.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em value}\>?()\>Component value.\\
{\em el}\>I\>Number of elements.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_GETNx} \hfill Read array component \hfill {\bf CMP\_GETNx}}
\begin{description}
\item [ACTION]:
Read an array primitive component of a structure.
\item [CALL]:
{\tt CALL CMP\_GETNx(loc,name,ndim,dimx,value,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dimx}\>I()\>Dimensions of {\em value}.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em value}\>?()\>Component value.\\
{\em dim}\>I()\>Component dimensions.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_GETVx} \hfill Read vectorised component \hfill {\bf CMP\_GETVx}}
\begin{description}
\item [ACTION]:
Read a primitive component of a structure as if it were vectorised.
\item [CALL]:
{\tt CALL CMP\_GETVx(loc,name,elx,value,el,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em elx}\>I\>Maximum size of {\em value}.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em value}\>?()\>Component value.\\
{\em el}\>I\>Number of elements.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each structure data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_LEN} \hfill Enquire component precision \hfill {\bf CMP\_LEN}}
\begin{description}
\item [ACTION]:
Enquire the number of bytes per element of a primitive component.
\item [CALL]:
{\tt CALL CMP\_LEN(loc,name,len,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em len}\>I\>Number of bytes per element.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_MAPN} \hfill Map array component \hfill {\bf CMP\_MAPN}}
\begin{description}
\item [ACTION]:
Map a primitive component of a structure as an array.
\item [CALL]:
{\tt CALL CMP\_MAPN(loc,name,type,mode,ndim,pntr,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em type}\>Ctyp\>Data type.\\
{\em mode}\>C\>Access mode (`READ', `WRITE', `UPDATE').\\
{\em ndim}\>I\>Number of dimensions.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em pntr}\>I\>Pointer to the mapped value.\\
{\em dim}\>I()\>Component dimensions.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_MAPV} \hfill Map vectorised component \hfill {\bf CMP\_MAPV}}
\begin{description}
\item [ACTION]:
Map a primitive component of a structure as if it were vectorised.
\item [CALL]:
{\tt CALL CMP\_MAPV(loc,name,type,mode,pntr,el,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em type}\>Ctyp\>Data type.\\
{\em mode}\>C\>Access mode (`READ', `WRITE', `UPDATE').
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em pntr}\>I\>Pointer to the mapped value.\\
{\em el}\>I\>Number of elements.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_MOD} \hfill Obtain component \hfill {\bf CMP\_MOD}}
\begin{description}
\item [ACTION]:
A locator for a component with the specified name, type and shape is obtained.
If a component with that name does not exist, one is created.
If a component with that name does exist but has a different type or shape, it
is deleted and a new one created with the specified type and shape.
\item [CALL]:
{\tt CALL CMP\_MOD(loc,name,type,ndim,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em type}\>Ctyp\>Data type.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_MODC} \hfill Obtain string component \hfill {\bf CMP\_MODC}}
\begin{description}
\item [ACTION]:
A locator for a component with the specified name, type string precision and
shape is obtained.
If a component with that name does not exist, one is created.
If a component with that name does exist but has a different type, precision or
shape, it is deleted and a new one created with the specified type, precision
and shape.
\item [CALL]:
{\tt CALL CMP\_MODC(loc,name,len,ndim,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em len}\>I\>Number of characters per value.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_PRIM} \hfill Enquire component primitive \hfill {\bf CMP\_PRIM}}
\begin{description}
\item [ACTION]:
Enquire if a structure component is a primitive object.
\item [CALL]:
{\tt CALL CMP\_PRIM(loc,name,reply,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em reply}\>L\>`.TRUE.' if primitive, otherwise `.FALSE.'.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_PUT0x} \hfill Write scalar component \hfill {\bf CMP\_PUT0x}}
\begin{description}
\item [ACTION]:
Write a scalar primitive component.
\item [CALL]:
{\tt CALL CMP\_PUT0x(loc,name,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em value}\>?\>Component value.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_PUT1x} \hfill Write vector component \hfill {\bf CMP\_PUT1x}}
\begin{description}
\item [ACTION]:
Write a vector primitive component.
\item [CALL]:
{\tt CALL CMP\_PUT1x(loc,name,el,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em el}\>I\>Number of elements.\\
{\em value}\>?()\>Component value.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_PUTNx} \hfill Write array component \hfill {\bf CMP\_PUTNx}}
\begin{description}
\item [ACTION]:
Write an array primitive component.
\item [CALL]:
{\tt CALL CMP\_PUTNx(loc,name,ndim,dimx,value,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dimx}\>I()\>Dimensions of {\em value}.\\
{\em value}\>?()\>Component value.\\
{\em dim}\>I()\>Component dimensions.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_PUTVx} \hfill Write vectorised component \hfill {\bf CMP\_PUTVx}}
\begin{description}
\item [ACTION]:
Write a primitive component as if it were vectorised.
\item [CALL]:
{\tt CALL CMP\_PUTVx(loc,name,el,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em el}\>I\>Number of elements.\\
{\em value}\>?()\>Component value.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_SHAPE} \hfill Enquire component shape \hfill {\bf CMP\_SHAPE}}
\begin{description}
\item [ACTION]:
Enquire the shape of a component.
\item [CALL]:
{\tt CALL CMP\_SHAPE(loc,name,ndimx,dim,ndim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em ndimx}\>I\>Size of {\em dim}.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em dim}\>I()\>Component dimensions.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_SIZE} \hfill Enquire component size \hfill {\bf CMP\_SIZE}}
\begin{description}
\item [ACTION]:
Enquire the size of a component.
For an array this will be the product of the dimensions; for a scalar, a
value of 1 is returned.
\item [CALL]:
{\tt CALL CMP\_SIZE(loc,name,size,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em size}\>I\>Component size.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_STRUC} \hfill Enquire component structure \hfill {\bf CMP\_STRUC}}
\begin{description}
\item [ACTION]:
Enquire if a structure component is a structure.
\item [CALL]:
{\tt CALL CMP\_STRUC(loc,name,reply,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em reply}\>L\>`.TRUE.' if a structure, otherwise `.FALSE.'.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_TYPE} \hfill Enquire component type \hfill {\bf CMP\_TYPE}}
\begin{description}
\item [ACTION]:
Enquire the type of a structure component.
\item [CALL]:
{\tt CALL CMP\_TYPE(loc,name,type,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em type}\>Ctyp\>Data type.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf CMP\_UNMAP} \hfill Unmap component \hfill {\bf CMP\_UNMAP}}
\begin{description}
\item [ACTION]:
Unmap a structure component mapped by {\bf CMP\_MAPV} or {\bf CMP\_MAPN}.
\item [CALL]:
{\tt CALL CMP\_UNMAP(loc,name,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_ALTER} \hfill Alter object size \hfill {\bf DAT\_ALTER}}
\begin{description}
\item [ACTION]:
Alter the size of an array by increasing or reducing the last (or only)
dimension.
If a structure array is to be reduced in size, the operation will fail if any
truncated elements contain components.
\item [CALL]:
{\tt CALL DAT\_ALTER(loc,ndim,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_ANNUL} \hfill Annul locator \hfill {\bf DAT\_ANNUL}}
\begin{description}
\item [ACTION]:
Cancel the association between a locator and an object. Any primitive value
currently mapped to the locator is automatically unmapped. If the last primary
locator associated with a container file is annulled, then the container file
will be closed.
\item [CALL]:
{\tt CALL DAT\_ANNUL(loc,status)}
\item [INPUT/OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator. A value of DAT\_\_NOLOC is returned.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
This routine attempts to execute even if {\em status} is set on entry, although
no further error report will be made if it subsequently fails under these
circumstances. In particular, it will fail if the locator supplied is not
valid, but this will only be reported if {\em status} is set to SAI\_\_OK on
entry.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_BASIC} \hfill Map primitive as basic units \hfill {\bf DAT\_BASIC}}
\begin{description}
\item [ACTION]:
Map a primitive as a sequence of basic machine units (bytes) for
reading, writing or updating.
\item [CALL]:
{\tt CALL DAT\_BASIC(loc,mode,pntr,len,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em mode}\>C\>Access mode (`READ', `WRITE', `UPDATE').
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em pntr}\>I\>Pointer to the mapped value.\\
{\em len}\>I\>Total number of bytes mapped.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
If the primitive data have been written on a different machine which uses a
different data representation, then they will be mapped as written (i.e. they
will not be converted to or from the data representation used by the host
machine).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_CCOPY} \hfill Copy one structure level \hfill {\bf DAT\_CCOPY}}
\begin{description}
\item [ACTION]:
Copy an object into a structure and give the new component the specified name.
If the source object is a structure, a new structure of the same type and shape
is created but the content of the original structure is not copied.
\item [CALL]:
{\tt CALL DAT\_CCOPY(loc1,loc2,name,loc3,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc1}\>Cloc\>Object locator.\\
{\em loc2}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc3}\>Cloc\>Component locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_CCTYP} \hfill Create type string \hfill {\bf DAT\_CCTYP}}
\begin{description}
\item [ACTION]:
Create a type string for a specified size of character string.
\item [CALL]:
{\tt CALL DAT\_CCTYP(size,type)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em size}\>I\>Character string size.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em type}\>Ctyp\>Type string.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_CELL} \hfill Locate cell \hfill {\bf DAT\_CELL}}
\begin{description}
\item [ACTION]:
Return a locator to a `cell' (element) of an array object.
\item [CALL]:
{\tt CALL DAT\_CELL(loc1,ndim,sub,loc2,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc1}\>Cloc\>Object locator.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em sub}\>I()\>Subscript values.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc2}\>Cloc\>Cell locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
Typically, this is used to locate an element of a structure array for
subsequent access to its components, although this does not preclude its use
in accessing a single pixel in a 2-D image for example.
\end{description}
\goodbreak

\sstroutine{
   DAT\_CLEN
}{
   Obtain character string length
}{
   \sstdescription{
      The routine returns the number of characters required to
      represent the values of a primitive object. If the object is
      character-type, then its length is returned directly. Otherwise,
      the value returned is the number of characters required to format
      the object{\tt '}s values (as a decimal string if appropriate) without
      loss of information.
   }
   \sstinvocation{
      CALL DAT\_CLEN( LOC, CLEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Primitive object locator.
      }
      \sstsubsection{
         CLEN = INTEGER (Returned)
      }{
         Character string length.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The value returned by this routine is equal to the default
         number of characters allocated to each element whenever a
         primitive object is mapped using an access type of {\tt '}\_CHAR{\tt '} (i.e.
         without specifying the length to be used explicitly).

         \sstitem
         If this routine is called with STATUS set, then a value of 1
         will be returned for the CLEN argument, although no further
         processing will occur. The same value will also be returned if
         the routine should fail for any reason.
      }
   }
}

\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_CLONE} \hfill Clone locator \hfill {\bf DAT\_CLONE}}
\begin{description}
\item [ACTION]:
Clone (duplicate) a locator.
\item [CALL]:
{\tt CALL DAT\_CLONE(loc1,loc2,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc1}\>Cloc\>Object locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc2}\>Cloc\>Object locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
All information is inherited except that concerned with any mapped primitive
data and the primary/secondary locator characteristic (a secondary locator is
always produced -- see DAT\_PRMRY). A call to this routine is {\em not}
equivalent to the Fortran statement `\verb+LOC2 = LOC1+'.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_COERC} \hfill Coerce object shape \hfill {\bf DAT\_COERC}}
\begin{description}
\item [ACTION]:
Temporarily coerce an object into changing its shape.
\item [CALL]:
{\tt CALL DAT\_COERC(loc1,ndim,loc2,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc1}\>Cloc\>Object locator.\\
{\em ndim}\>I\>Number of dimensions.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc2}\>Cloc\>Coerced object locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
If the number of dimensions in the object is to be increased, each additional
dimension size is set to 1, e.g.\ if {\em loc1} is associated with a 2-D object
of shape (512,256) say, setting {\em ndim} to 3 transforms the dimensions to
(512,256,1).
Likewise, if the number of dimensions is to be reduced, the appropriate trailing
dimension sizes are discarded; the routine will fail if any of these do not have
the value 1.
As with {\bf DAT\_VEC}, only the appearance of the object is changed --- the
original shape remains intact.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_COPY} \hfill Copy object \hfill {\bf DAT\_COPY}}
\begin{description}
\item [ACTION]:
Recursively copy an object into a component. This means that the complete
object (including its components and its components' components, etc.)
is
copied, not just the top level.
\item [CALL]:
{\tt CALL DAT\_COPY(loc1,loc2,name,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc1}\>Cloc\>Object locator.\\
{\em loc2}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak

\sstroutine{
   DAT\_DREP
}{
   Obtain primitive data representation information
}{
   \sstdescription{
      The routine returns information describing how the data stored in
      a primitive object are actually represented. An object{\tt '}s data
      representation will match that used by the computer system on
      which it was created, and this forms a permanent attribute of the
      object. If necessary, HDS will automatically perform conversion
      to the representation used by the host computer when the data are
      accessed (except when using DAT\_BASIC, which provides direct
      access to the data without conversion).
   }
   \sstinvocation{
      CALL DAT\_DREP( LOC, FORMAT, ORDER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Primitive object locator.
      }
      \sstsubsection{
         FORMAT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Description of the format used to encode each data element
         (see the {\tt "}Data Format{\tt "} section).
      }
      \sstsubsection{
         ORDER = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Description of the (byte) storage order used for each data
         element (see the {\tt "}Storage Order{\tt "} section).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      Not all combinations of data format and storage order are
      supported.
   }
   \sstdiytopic{
      Data Format
   }{
      HDS currently supports the following encodings of primitive data
      elements. Each description is preceded by the character string
      returned by DAT\_DREP to describe it:

      \sstitemlist{

         \sstitem
         {\tt '}BIT0{\tt '}: Used to encode logical values, in which the least
         significant bit (bit zero) holds the logical value such that 1
         implies .TRUE. and 0 implies .FALSE.. All other bits are
         disregarded (except in {\tt "}bad{\tt "} data values when they are all
         significant).

         \sstitem
         {\tt '}NZ{\tt '}: Used to encode logical values, in which all bits set to
         zero implies .FALSE. and any bit set to 1 (i.e. a non-zero data
         value) implies .TRUE..

         \sstitem
         {\tt '}BINARY{\tt '}: Used for unsigned integers; this is a straight
         binary encoding.

         \sstitem
         {\tt '}2COMP{\tt '}: Used for signed integers in which a {\tt "}2{\tt '}s complement{\tt "}
         binary encoding of the sign information is employed.

         \sstitem
         {\tt '}VAXF{\tt '}: Used for single precision floating point values; this
         is the VAX/VMS {\tt "}F-floating{\tt "} number representation.

         \sstitem
         {\tt '}IEEE\_S{\tt '}: Used for single precision floating point values;
         this is the standard IEEE single precision floating point format.

         \sstitem
         {\tt '}VAXD{\tt '}: Used for double precision floating point values; this
         is the VAX/VMS {\tt "}D-floating{\tt "} number representation.

         \sstitem
         {\tt '}IEEE\_D{\tt '}: Used for double precision floating point values;
         this is the standard IEEE double precision floating point format.

         \sstitem
         {\tt '}ASCII{\tt '}: Used for character strings; each character employs
         the standard ASCII encoding.
      }
   }
   \sstdiytopic{
      Storage Order
   }{
      HDS currently supports the following storage orders for the bytes
      of primitive data elements. Each description is preceded by the
      character string returned by DAT\_DREP to describe it:

      \sstitemlist{

         \sstitem
         {\tt '}MSB{\tt '}: Most significant byte stored first.

         \sstitem
         {\tt '}LSB{\tt '}: Least significant byte stored first.

      }
      In the case of floating point formats, the byte in question is the
      most/least significant byte of the fraction.
   }
}

\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_ERASE} \hfill Erase component \hfill {\bf DAT\_ERASE}}
\begin{description}
\item [ACTION]:
Recursively delete a component.
This means that all its lower level components are deleted as well.
\item [CALL]:
{\tt CALL DAT\_ERASE(loc,name,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak

\sstroutine{
   DAT\_ERMSG
}{
   Translate a status value into an error message
}{
   \sstdescription{
      This routine translates an error status value into an associated
      error message. It first attempts to translate the value supplied
      as a DAT\_\_ error code. If this fails, it then attempts to
      translate it as a system status code for the host operating
      system. If this also fails, then the returned string is a message
      indicating that the status value could not be translated.
   }
   \sstinvocation{
      CALL DAT\_ERMSG( STATUS, LENGTH, MSG )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The error status value to be translated.
      }
      \sstsubsection{
         LENGTH = INTEGER (Returned)
      }{
         Number of significant characters in the returned error message
         (i.e.  excluding trailing blanks). This value will not exceed
         the length of the character variable supplied for the MSG
         argument.
      }
      \sstsubsection{
         MSG = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The error message.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the variable supplied for the MSG argument is not long
         enough to accommodate the error message, then the message will be
         truncated and the returned value of LENGTH will reflect the
         truncated length.

         \sstitem
         No returned error message will contain more significant
         characters than the value of the EMS\_\_SZMSG symbolic constant.
         This constant is defined in the include file EMS\_PAR.
      }
   }
}

\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_FIND} \hfill Find named component \hfill {\bf DAT\_FIND}}
\begin{description}
\item [ACTION]:
Obtain a locator for a named component.
\item [CALL]:
{\tt CALL DAT\_FIND(loc1,name,loc2,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc1}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc2}\>Cloc\>Component locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
If the structure is an array, {\em loc1} must be explicitly associated with an
individual cell.
If the component is a structure array, {\em loc2} will be associated with
the complete array, {\em not} the first cell.
Access to its components can only be made through another locator explicitly
associated with an individual cell (see {\bf DAT\_CELL}).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_GET} \hfill Read primitive \hfill {\bf DAT\_GET}}
\begin{description}
\item [ACTION]:
Read a primitive (access type specified by a parameter).
\item [CALL]:
{\tt CALL DAT\_GET(loc,type,ndim,dim,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em type}\>Ctyp\>Data type.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em value}\>?()\>Object value.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
When reading character strings the normal Fortran~77 rules for
character assignment are followed, ie.\ if the string length of the primitive
object is less than that of the {\em value} array, each string is padded to the
right with blanks; if greater, the strings are truncated from the right.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_GETx} \hfill Read primitive \hfill {\bf DAT\_GETx}}
\begin{description}
\item [ACTION]:
Read a primitive (access type specified by routine name).
\item [CALL]:
{\tt CALL DAT\_GETx(loc,ndim,dim,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em value}\>?()\>Object value.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
See {\bf DAT\_GET} notes on character conversion.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_GET0x} \hfill Read scalar primitive \hfill {\bf DAT\_GET0x}}
\begin{description}
\item [ACTION]:
Read a scalar primitive.
\item [CALL]:
{\tt CALL DAT\_GET0x(loc,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em value}\>?\>Object value.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
See {\bf DAT\_GET} notes on character conversion.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_GET1x} \hfill Read vector primitive \hfill {\bf DAT\_GET1x}}
\begin{description}
\item [ACTION]:
Read a vector primitive.
\item [CALL]:
{\tt CALL DAT\_GET1x(loc,elx,value,el,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em elx}\>I\>Maximum size of {\em value}.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em value}\>?()\>Object value.\\
{\em el}\>I\>Number of elements.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
See {\bf DAT\_GET} notes on character conversion.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_GETNx} \hfill Read array primitive \hfill {\bf DAT\_GETNx}}
\begin{description}
\item [ACTION]:
Read an array primitive.
\item [CALL]:
{\tt CALL DAT\_GETNx(loc,ndim,dimx,value,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dimx}\>I()\>Dimensions of {\em value}.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em value}\>?()\>Object value.\\
{\em dim}\>I()\>Object dimensions.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
See {\bf DAT\_GET} notes on character conversion.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_GETVx} \hfill Read vectorised primitive \hfill {\bf DAT\_GETVx}}
\begin{description}
\item [ACTION]:
Read a primitive as if it were vectorised (ie.\ regardless of its actual shape).
\item [CALL]:
{\tt CALL DAT\_GETVx(loc,elx,value,el,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em elx}\>I\>Maximum size of {\em value}.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em value}\>?()\>Object value.\\
{\em el}\>I\>Number of elements.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
See {\bf DAT\_GET} notes on character conversion.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_INDEX} \hfill Index into component list \hfill {\bf DAT\_INDEX}}
\begin{description}
\item [ACTION]:
Index into a structure's component list and return a locator to the object
at the given position.
\item [CALL]:
{\tt CALL DAT\_INDEX(loc1,index,loc2,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc1}\>Cloc\>Structure locator.\\
{\em index}\>I\>List position.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc2}\>Cloc\>Component locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_LEN} \hfill Enquire primitive length \hfill {\bf DAT\_LEN}}
\begin{description}
\item [ACTION]:
Enquire the length of a primitive. In the case of a character object, this is
the number of characters per element. For other primitive types it is the
number of bytes per element.
\item [CALL]:
{\tt CALL DAT\_LEN(loc,len,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em len}\>I\>Number of bytes per value.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_MAP} \hfill Map primitive \hfill {\bf DAT\_MAP}}
\begin{description}
\item [ACTION]:
Map a primitive (access type specified by a parameter).
\item [CALL]:
{\tt CALL DAT\_MAP(loc,type,mode,ndim,dim,pntr,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em type}\>Ctyp\>Data type.\\
{\em mode}\>C\>Access mode (`READ', `WRITE', `UPDATE').\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em pntr}\>I\>Pointer to the mapped value.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_MAPx} \hfill Map primitive \hfill {\bf DAT\_MAPx}}
\begin{description}
\item [ACTION]:
Map a primitive (access type specified by routine name).
\item [CALL]:
{\tt CALL DAT\_MAPx(loc,mode,ndim,dim,pntr,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em mode}\>C\>Access mode (`READ', `WRITE', `UPDATE').\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em pntr}\>I\>Pointer to the mapped value.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_MAPN} \hfill Map array primitive \hfill {\bf DAT\_MAPN}}
\begin{description}
\item [ACTION]:
Map a primitive as an array.
\item [CALL]:
{\tt CALL DAT\_MAPN(loc,type,mode,ndim,pntr,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em type}\>Ctyp\>Data type.\\
{\em mode}\>C\>Access mode (`READ', `WRITE', `UPDATE').\\
{\em ndim}\>I\>Number of dimensions.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em pntr}\>I\>Pointer to the mapped value.\\
{\em dim}\>I()\>Object dimensions.\\
{\em status}\>I\>Status value.  
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_MAPV} \hfill Map vectorised primitive \hfill {\bf DAT\_MAPV}}
\begin{description}
\item [ACTION]:
Map a primitive as if it were vectorised.
\item [CALL]:
{\tt CALL DAT\_MAPV(loc,type,mode,pntr,el,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em type}\>Ctyp\>Data type.\\
{\em mode}\>C\>Access mode (`READ', `WRITE', `UPDATE').
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em pntr}\>I\>Pointer to the mapped value.\\
{\em el}\>I\>Number of elements.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_MOULD} \hfill Alter object shape \hfill {\bf DAT\_MOULD}}
\begin{description}
\item [ACTION]:
Alter an object's shape permanently.
\item [CALL]:
{\tt CALL DAT\_MOULD(loc,ndim,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
The shape is altered permanently (unlike {\bf DAT\_COERC}).
The number of dimensions {\em cannot} be increased.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_MOVE} \hfill Move object \hfill {\bf DAT\_MOVE}}
\begin{description}
\item [ACTION]:
Move an object to a new location (ie.\ copy and erase the original).
\item [CALL]:
{\tt CALL DAT\_MOVE(loc1,loc2,name,status)}
\item [INPUT/OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc1}\>Cloc\>Object locator. A value of DAT\_\_NOLOC is returned.
\end{tabbing}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc2}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
If the object is an array, {\em loc1} must point to the complete array, not a
slice or cell. {\em loc1} is annulled if the operation is successful (if it is
the last primary locator associated with a container file, then the container
file will be closed -- see DAT\_PRMRY). The operation will fail if a component
of the same name already exists in the structure. The object to be moved need
not be in the same container file as the structure.
\end{description}
\goodbreak

\sstroutine{
   DAT\_MSG
}{
   Assign the name of an HDS object to a message token
}{
   \sstdescription{
      The routine assigns the full name (including the file name) of an
      HDS object to a message token for use with the ERR\_ and MSG\_
      routines (SUN/104) or with the EMS\_ routines (SSN/4). Appropriate
      syntax is used to represent file names which do not have the
      standard (.sdf) file extension.
   }
   \sstinvocation{
      CALL DAT\_MSG( TOKEN, LOC )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the message token.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Locator to the HDS object.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine has no STATUS argument and does not perform
         normal error checking. If it should fail, then no value will be
         assigned to the message token and this will be apparent in the
         final message.
      }
   }
   \sstdiytopic{
      Machine-specific features used
   }{
      \sstitemlist{

         \sstitem
         This routine makes assumptions about the form of VMS and UNIX
         file names.
      }
   }
}

\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_NAME} \hfill Enquire object name \hfill {\bf DAT\_NAME}}
\begin{description}
\item [ACTION]:
Enquire the name of an object.
\item [CALL]:
{\tt CALL DAT\_NAME(loc,name,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em name}\>Cnam\>Object name.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_NCOMP} \hfill Enquire number of components \hfill {\bf DAT\_NCOMP}}
\begin{description}
\item [ACTION]:
Return the number of components in a structure.
\item [CALL]:
{\tt CALL DAT\_NCOMP(loc,ncomp,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em ncomp}\>I\>Number of components.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
If the structure is an array, {\em loc} must be explicitly associated with an
individual cell.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_NEW} \hfill Create component \hfill {\bf DAT\_NEW}}
\begin{description}
\item [ACTION]:
Create a new component in a structure.
\item [CALL]:
{\tt CALL DAT\_NEW(loc,name,type,ndim,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em type}\>Ctyp\>Data type.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Component dimensions.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
If {\em type} matches one of the primitive type names a primitive of
the appropriate type is created, otherwise the object is assumed to be a
structure.
The new object can subsequently be located by {\bf DAT\_FIND}.
The operation will fail if a component of the same name already exists.
Because {\bf DAT\_COPY} is so fast, you should consider creating template
container files containing ready-defined structures and then use {\bf DAT\_COPY}
to create new such structures rather than using sequences of {\bf DAT\_NEW} and
{\bf DAT\_FIND} commands.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_NEW0x} \hfill Create scalar component \hfill {\bf DAT\_NEW0x}}
\begin{description}
\item [ACTION]:
Create a new scalar primitive component in a structure.
\item [CALL]:
{\tt CALL DAT\_NEW0x(loc,name,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical), {\bf R} (Real).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_NEW0C} \hfill Create scalar string component \hfill {\bf DAT\_NEW0C}}
\begin{description}
\item [ACTION]:
Create a new scalar string component in a structure.
\item [CALL]:
{\tt CALL DAT\_NEW0C(loc,name,len,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em len}\>I\>Number of characters per value.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_NEW1x} \hfill Create vector component \hfill {\bf DAT\_NEW1x}}
\begin{description}
\item [ACTION]:
Create a new vector primitive component in a structure.
\item [CALL]:
{\tt CALL DAT\_NEW1x(loc,name,el,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em el}\>I\>Number of elements.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical), {\bf R} (Real).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_NEW1C} \hfill Create vector string component \hfill {\bf DAT\_NEW1C}}
\begin{description}
\item [ACTION]:
Create a new vector string component in a structure.
\item [CALL]:
{\tt CALL DAT\_NEW1x(loc,name,len,el,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em len}\>I\>Number of characters per value.\\
{\em el}\>I\>Number of elements.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_NEWC} \hfill Create string component \hfill {\bf DAT\_NEWC}}
\begin{description}
\item [ACTION]:
Create a new component whose elements are of type `\_CHAR$*$n'.
\item [CALL]:
{\tt CALL DAT\_NEWC(loc,name,len,ndim,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em len}\>I\>Number of characters per value.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak

\sstroutine{
   DAT\_PAREN
}{
   Locate parent structure
}{
   \sstdescription{
      The routine returns a locator for the parent structure of an HDS
      object; i.e. the structure which contains the object.
   }
   \sstinvocation{
      CALL DAT\_PAREN( LOC1, LOC2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Object locator.
      }
      \sstsubsection{
         LOC2 = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Parent structure locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         On successful exit, the parent structure locator will identify
         a scalar structure (number of dimensions zero). If appropriate,
         this may be a cell of a structure array.

         \sstitem
         An error will result, and the STATUS value DAT\_\_OBJIN will be
         returned if the object supplied does not have a parent; i.e. if
         it is the top-level object in a container file. The DAT\_\_OBJIN
         error code is defined in the include file DAT\_ERR.

         \sstitem
         If this routine is called with STATUS set, then a value of
         DAT\_\_NOLOC will be returned for the LOC2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The
         DAT\_\_NOLOC constant is defined in the include file DAT\_PAR.
      }
   }
   \sstdiytopic{
      Example
   }{
      The parent of the object A.B.C.D is A.B.C, the parent of
      X.DATA.ARRAY(1:256) is X.DATA, and the parent of Z.STRUC(17).FLAG
      is Z.STRUC(17).
   }
}

\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_PREC} \hfill Enquire storage precision \hfill {\bf DAT\_PREC}}
\begin{description}
\item [ACTION]:
Enquire the number of basic machine units (bytes) used to store a single element
of a primitive.
\item [CALL]:
{\tt CALL DAT\_PREC(loc,nbyte,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em nbyte}\>I\>Number of machine units.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_PRIM} \hfill Enquire object primitive \hfill {\bf DAT\_PRIM}}
\begin{description}
\item [ACTION]:
Enquire if an object is a primitive.
\item [CALL]:
{\tt CALL DAT\_PRIM(loc,reply,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em reply}\>L\>`.TRUE.' if primitive, otherwise `.FALSE.'.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\newpage
\sstroutine{
   DAT\_PRMRY
}{
   Set or enquire primary/secondary locator status
}{
   \sstdescription{
      The routine may be used to promote a locator to become a
      {\tt "}primary{\tt "} locator, to demote it to become a {\tt "}secondary{\tt "} locator,
      or to enquire about the primary/secondary status of a locator.
      It allows control over the duration for which an HDS container
      file remains open; each file remains open only so long as there
      is at least one primary locator associated with it.
   }
   \sstinvocation{
      CALL DAT\_PRMRY( SET, LOC, PRMRY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SET = LOGICAL (Given)
      }{
         If a .TRUE. value is given for this argument, then the routine
         will perform a {\tt "}set{\tt "} operation to set the primary/secondary
         status of a locator.  Otherwise it will perform an {\tt "}enquire{\tt "}
         operation to return the value of this status without changing
         it.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The locator whose primary/secondary status is to be set or
         enquired.
      }
      \sstsubsection{
         PRMRY = LOGICAL (Given and Returned)
      }{
         If SET is .TRUE., then this is an input argument and specifies
         the new value to be set (.TRUE. for a primary locator, .FALSE.
         for a secondary locator). If SET is .FALSE., then this is an
         output argument and will return a value indicating whether or
         not a primary locator was supplied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The value of the LOC argument will not normally be changed.
         However, if it is the last primary locator associated with a
         container file, and is being demoted from a primary to a
         secondary locator, then the container file will be left without
         an associated primary locator. In this case, the locator supplied
         will be annulled (along with any other secondary locators
         associated with the same file), a value of DAT\_\_NOLOC will be
         returned, and the file will be closed.

         \sstitem
         The DAT\_\_NOLOC constant is defined in the include file
         DAT\_PAR.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1992 Science \& Engineering Research Council
   }
}

\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_PUT} \hfill Write primitive \hfill {\bf DAT\_PUT}}
\begin{description}
\item [ACTION]:
Write a primitive (type specified by a parameter).
\item [CALL]:
{\tt CALL DAT\_PUT(loc,type,ndim,dim,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em type}\>Ctyp\>Data type.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.\\
{\em value}\>?()\>Object value.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
When writing character strings the normal Fortran~77 rules for
character assignment are followed, ie.\ if the string length of the {\em value}
array is less than that of the primitive, each string is padded to the
right with blanks; if greater, they are truncated from the right.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_PUTx} \hfill Write primitive \hfill {\bf DAT\_PUTx}}
\begin{description}
\item [ACTION]:
Write a primitive (type specified by routine name).
\item [CALL]:
{\tt CALL DAT\_PUTx(loc,ndim,dim,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.\\
{\em value}\>?()\>Object value.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
See {\bf DAT\_PUT} notes on character conversion.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_PUT0x} \hfill Write scalar primitive \hfill {\bf DAT\_PUT0x}}
\begin{description}
\item [ACTION]:
Write a scalar primitive.
\item [CALL]:
{\tt CALL DAT\_PUT0x(loc,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em value}\>?\>Object value.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
See {\bf DAT\_PUT} notes on character conversion.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_PUT1x} \hfill Write vector primitive \hfill {\bf DAT\_PUT1x}}
\begin{description}
\item [ACTION]:
Write a vector primitive.
\item [CALL]:
{\tt CALL DAT\_PUT1x(loc,el,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em el}\>I\>Number of elements.\\
{\em value}\>?()\>Object value.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
See {\bf DAT\_PUT} notes on character conversion.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_PUTNx} \hfill Write array primitive \hfill {\bf DAT\_PUTNx}}
\begin{description}
\item [ACTION]:
Write an array primitive.
\item [CALL]:
{\tt CALL DAT\_PUTNx(loc,ndim,dimx,value,dim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dimx}\>I()\>Dimensions of {\em value}.\\
{\em value}\>?()\>Object value.\\
{\em dim}\>I()\>Object dimensions.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
See {\bf DAT\_PUT} notes on character conversion.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_PUTVx} \hfill Write vectorised primitive \hfill {\bf DAT\_PUTVx}}
\begin{description}
\item [ACTION]:
Write a primitive as if it were vectorised (ie.\ regardless of its actual
shape).
\item [CALL]:
{\tt CALL DAT\_PUTVx(loc,el,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em el}\>I\>Number of elements.\\
{\em value}\>?()\>Object value.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
There is a routine for each standard data type; to call them, replace {\bf x}
by {\bf C} (Character), {\bf D} (Double), {\bf I} (Integer), {\bf L} (Logical),
{\bf R} (Real).
See {\bf DAT\_PUT} notes on character conversion.
\end{description}
\goodbreak

\sstroutine{
   DAT\_REF
}{
   Obtain a reference for an HDS object
}{
   \sstdescription{
      The routine returns a {\tt "}reference name{\tt "} for an HDS object whose
      locator is supplied. This name identifies the object uniquely by
      including both the name of the container file and the {\tt "}path name{\tt "}
      which locates the object within this file. If a locator to a cell
      or a slice is supplied, then subscript information will also be
      included.  Appropriate syntax is used to represent file names
      which do not have the standard (.sdf) file extension.
   }
   \sstinvocation{
      CALL DAT\_REF( LOC, REF, LREF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Locator to the HDS object.
      }
      \sstsubsection{
         REF = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The object{\tt '}s reference name.
      }
      \sstsubsection{
         LREF = INTEGER (Returned)
      }{
         Number of significant characters in the reference name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Machine-specific features used
   }{
      \sstitemlist{

         \sstitem
         This routine makes assumptions about the form of VMS and UNIX
         file names.
      }
   }
}

\goodbreak

\sstroutine{
   DAT\_REFCT
}{
   Enquire the reference count for a container file
}{
   \sstdescription{
      The routine returns a count of the number of {\tt "}primary{\tt "} locators
      associated with an HDS container file (its reference count). The
      file will remain open for as long as this number is greater than
      zero.
   }
   \sstinvocation{
      CALL DAT\_REFCT( LOC, REFCT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Locator associated with any object in the container file.
      }
      \sstsubsection{
         REFCT = INTEGER (Returned)
      }{
         Number of primary locators currently associated with the file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine may be used to determine whether annulling a primary
      locator will cause a container file to be closed (also see the
      routine DAT\_PRMRY).
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1992 Science \& Engineering Research Council
   }
}

\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_RENAM} \hfill Rename object \hfill {\bf DAT\_RENAM}}
\begin{description}
\item [ACTION]:
Rename an object.
\item [CALL]:
{\tt CALL DAT\_RENAM(loc,name,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.\\
{\em name}\>Cnam\>New object name.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_RESET} \hfill Reset object state \hfill {\bf DAT\_RESET}}
\begin{description}
\item [ACTION]:
Reset the state of a primitive, ie.\ `un-define' its value.
All subsequent read operations will fail until the object is written to
(re-defined).
\item [CALL]:
{\tt CALL DAT\_RESET(loc,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_RETYP} \hfill Change object type \hfill {\bf DAT\_RETYP}}
\begin{description}
\item [ACTION]:
Change the type of an object.
A blank type may be specified.
\item [CALL]:
{\tt CALL DAT\_RETYP(loc,type,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object name.\\
{\em type}\>Ctyp\>Data type.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_SHAPE} \hfill Enquire object shape \hfill {\bf DAT\_SHAPE}}
\begin{description}
\item [ACTION]:
Enquire the shape of an object.
\item [CALL]:
{\tt CALL DAT\_SHAPE(loc,ndimx,dim,ndim,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.\\
{\em ndimx}\>I\>Size of {\em dim}.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em dim}\>I()\>Object dimensions.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_SIZE} \hfill Enquire object size \hfill {\bf DAT\_SIZE}}
\begin{description}
\item [ACTION]:
Enquire the size of an object.
For an array this will be the product of the dimensions; for a scalar, a
value of 1 is returned.
\item [CALL]:
{\tt CALL DAT\_SIZE(loc,size,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em size}\>I\>Object size.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_SLICE} \hfill Locate slice \hfill {\bf DAT\_SLICE}}
\begin{description}
\item [ACTION]:
Return a locator to a `slice' of a vector or an array.
\item [CALL]:
{\tt CALL DAT\_SLICE(loc1,ndim,diml,dimu,loc2,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc1}\>Cloc\>Array locator.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em diml}\>I()\>Lower dimension bounds.\\
{\em dimu}\>I()\>Upper dimension bounds.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc2}\>Cloc\>Slice locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
If any of the upper bounds are zero or negative, the size of the corresponding
dimension in the object is used.
Currently, only 1, 2 or 3-D objects can be sliced.
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_STATE} \hfill Enquire object state \hfill {\bf DAT\_STATE}}
\begin{description}
\item [ACTION]:
Enquire the state of a primitive, ie.\ whether its value is defined or not.
\item [CALL]:
{\tt CALL DAT\_STATE(loc,reply,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em reply}\>L\>`.TRUE.' if defined, otherwise `.FALSE.'.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_STRUC} \hfill Enquire object structure \hfill {\bf DAT\_STRUC}}
\begin{description}
\item [ACTION]:
Enquire if an object is a structure.
\item [CALL]:
{\tt CALL DAT\_STRUC(loc,reply,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em reply}\>L\>`.TRUE.' if structure, otherwise `.FALSE.'.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_TEMP} \hfill Create temporary object \hfill {\bf DAT\_TEMP}}
\begin{description}
\item [ACTION]:
Create an object that exists only for the lifetime of the program run.
This may be used to hold temporary objects --- including those mapped to obtain
scratch space.
\item [CALL]:
{\tt CALL DAT\_TEMP(type,ndim,dim,loc,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em type}\>Ctyp\>Data type.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
If {\em type} matches one of the primitive type names, a primitive of
appropriate type is created; otherwise the object is assumed to be a structure.
If the object is a structure array, {\em loc} will be associated with the
complete array, {\em not} the first cell.
Thus, new components can only be created through another locator which
is explicitly associated with an individual cell (see {\bf DAT\_CELL}).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_THERE} \hfill Enquire component existence \hfill {\bf DAT\_THERE}}
\begin{description}
\item [ACTION]:
Enquire if a component of a structure exists.
\item [CALL]:
{\tt CALL DAT\_THERE(loc,name,reply,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em reply}\>L\>`.TRUE.' if exists, otherwise `.FALSE.'.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_TYPE} \hfill Enquire object type \hfill {\bf DAT\_TYPE}}
\begin{description}
\item [ACTION]:
Enquire the type of an object.
\item [CALL]:
{\tt CALL DAT\_TYPE(loc,type,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em type}\>Ctyp\>Data type.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_UNMAP} \hfill Unmap object \hfill {\bf DAT\_UNMAP}}
\begin{description}
\item [ACTION]:
Unmap an object mapped by another DAT\_ routine.
\item [CALL]:
{\tt CALL DAT\_UNMAP(loc,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_VALID} \hfill Enquire locator valid \hfill {\bf DAT\_VALID}}
\begin{description}
\item [ACTION]:
Enquire if a locator is valid, ie.\ currently associated with an object.
\item [CALL]:
{\tt CALL DAT\_VALID(loc,reply,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em reply}\>L\>`.TRUE.' if valid, otherwise `.FALSE.'.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_VEC} \hfill Vectorise object \hfill {\bf DAT\_VEC}}
\begin{description}
\item [ACTION]:
Address an array as if it were a vector.
\item [CALL]:
{\tt CALL DAT\_VEC(loc1,loc2,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc1}\>Cloc\>Array locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc2}\>Cloc\>Vector locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak

\sstroutine{
   DAT\_WHERE
}{
   Find position of primitive in HDS file
}{
   \sstdescription{
      The routine returns information describing the position in an HDS
      container file at which the data associated with a primitive
      object are stored.
   }
   \sstinvocation{
      CALL DAT\_WHERE( LOC, BLOCK, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Primitive object locator.
      }
      \sstsubsection{
         BLOCK = INTEGER (Returned)
      }{
         Number of the file block in which the object{\tt '}s data start. HDS
         file blocks are 512 bytes long and are numbered from the
         beginning of the file, starting at block 1.
      }
      \sstsubsection{
         OFFSET = INTEGER (Returned)
      }{
         Byte offset (zero based) of the start of data within the file
         block.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The use of this routine is not recommended. It is provided
         solely for use by experienced programmers who are familiar with
         the internal structure of HDS container files and who wish to
         access the file contents directly. Note, however, that changes to
         the format of an HDS file may occur in future.

         \sstitem
         The start of the data associated with a cell or a slice of a
         primitive object may be located with this routine, but the data
         associated with a slice will not, in general, be stored at
         contiguous locations within the file.

         \sstitem
         Care must be taken that no changes are made to adjacent bytes
         within the file which are not part of the requested object{\tt '}s
         data.

         \sstitem
         Note that the data associated with primitive objects may not
         necessarily be stored contiguously in future versions of HDS.
      }
   }
}

\goodbreak

\sstroutine{
   HDS\_COPY
}{
   Copy an object to a new container file
}{
   \sstdescription{
      The routine makes a copy of an HDS object, placing the copy in a
      new container file (which is created), as the top-level object.
      The copying operation is recursive; i.e. all sub-components of a
      structure will also be copied.
   }
   \sstinvocation{
      CALL HDS\_COPY( LOC, FILE, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Locator for the object to be copied.
      }
      \sstsubsection{
         FILE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the new container file to be created.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name which the new top-level object is to have.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to eliminate unused space during the
         copying operation and is therefore a useful method of compressing
         a container file from which components have been deleted.

         \sstitem
         The routine may be used to copy both primitive and structured
         objects, but cannot be used to make a copy of a cell or a slice.
      }
   }
}
\newpage
\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_ERASE} \hfill Erase container file \hfill {\bf HDS\_ERASE}}
\begin{description}
\item [ACTION]:
Mark a container file for deletion and annul the locator associated with the
top-level object.
The container file will not be physically deleted if other primary locators are
still associated with the file --- this is only done when the reference count
drops to zero.
\item [CALL]:
{\tt CALL HDS\_ERASE(loc,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Locator to the container file's top-level object.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak

\sstroutine{
   HDS\_EWILD
}{
   End a wild-card search for HDS container files
}{
   \sstdescription{
      The routine ends a wild-card search for HDS container files begun
      by HDS\_WILD, and annuls the wild-card search context used. It
      should be called after a wild-card search is complete in order to
      release the resources used.
   }
   \sstinvocation{
      CALL HDS\_EWILD( IWLD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWLD = INTEGER (Given and Returned)
      }{
         Identifier for the wild-card search context to be annulled, as
         returned by HDS\_WILD. A value of DAT\_\_NOWLD is returned (as
         defined in the include file DAT\_PAR).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine attempts to execute even if STATUS is set on entry,
      although no further error report will be made if it subsequently
      fails under these circumstances. In particular, it will fail if
      the identifier supplied is not initially valid, but this will
      only be reported if STATUS is set to SAI\_\_OK on entry.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1992 Science \& Engineering Research Council
   }
}

\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_FLUSH} \hfill Flush locator group \hfill {\bf HDS\_FLUSH}}
\begin{description}
\item [ACTION]:
Annul all locators currently assigned to a specified locator group.
\item [CALL]:
{\tt CALL HDS\_FLUSH(group,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em group}\>Cnam\>Group name.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_FREE} \hfill Free container file \hfill {\bf HDS\_FREE}}
\begin{description}
\item [ACTION]:
Release all explicit or implicit locks on a container file, thereby granting
write-access to other processes.
\item [CALL]:
{\tt CALL HDS\_FREE(loc,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Locator to the container file's top-level object.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_GROUP} \hfill Enquire locator group \hfill {\bf HDS\_GROUP}}
\begin{description}
\item [ACTION]:
Return the name of the group to which an object belongs.
\item [CALL]:
{\tt CALL HDS\_GROUP(loc,group,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em group}\>Cnam\>Group name.\\
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak

\sstroutine{
   HDS\_GTUNE
}{
   Obtain tuning parameter value
}{
   \sstdescription{
      The routine returns the current value of an HDS tuning parameter
      (normally this will be its default value, or the value last
      specified using the HDS\_TUNE routine).
   }
   \sstinvocation{
      CALL HDS\_GTUNE( PARAM, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the tuning parameter whose value is required (case
         insensitive).
      }
      \sstsubsection{
         VALUE = INTEGER (Returned)
      }{
         Current value of the parameter.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Tuning parameter names may be abbreviated to 4 characters.
      }
   }
}

\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_LINK} \hfill Link locator group \hfill {\bf HDS\_LINK}}
\begin{description}
\item [ACTION]:
Link a locator to a group.
\item [CALL]:
{\tt CALL HDS\_LINK(loc,group,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.\\
{\em group}\>Cnam\>Group name.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_LOCK} \hfill Lock container file \hfill {\bf HDS\_LOCK}}
\begin{description}
\item [ACTION]:
Lock a container file in `UPDATE' mode; this protects the file from being
accessed by other writers.
The file remains explicitly locked until {\bf HDS\_FREE} is called or until the
file is physically closed.
\item [CALL]:
{\tt CALL HDS\_LOCK(loc,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Locator to the container file's top-level object.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_NEW} \hfill Create container file \hfill {\bf HDS\_NEW}}
\begin{description}
\item [ACTION]:
Create a new container file and return a primary locator to the top-level
object.
\item [CALL]:
{\tt CALL HDS\_NEW(file,name,type,ndim,dim,loc,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em file}\>C\>File specification (may be logical name).\\
{\em name}\>Cnam\>Object name.\\
{\em type}\>Ctyp\>Data type.\\
{\em ndim}\>I\>Number of dimensions.\\
{\em dim}\>I()\>Object dimensions (ignored if {\em ndim} is zero).
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
If a file extension is not specified, `.sdf' is used.
If {\em type} matches one of the HDS primitive type names a primitive of that
type is created, otherwise the object is assumed to be a structure.
If the top-level object is a structure array, {\em loc} will be associated with
the complete array, {\em not} the first cell.
Thus, new components can only be created through another locator which
is explicitly associated with an individual cell (see {\bf DAT\_CELL}).
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_OPEN} \hfill Open container file \hfill {\bf HDS\_OPEN}}
\begin{description}
\item [ACTION]:
Open an existing container file for reading, writing or updating and return
a primary locator to the top-level object.
If the file is currently open in the specified mode, the routine increments
the reference count rather than re-opening the file.
\item [CALL]:
{\tt CALL HDS\_OPEN(file,mode,loc,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em file}\>C\>File specification (may be logical name).\\
{\em mode}\>C\>Access mode (`READ', `WRITE', `UPDATE').
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
If a file extension is not specified, `.sdf' is used.
If the top-level object is a structure array, {\em loc} will be associated with
the complete array, {\em not} the first cell.
Thus, access to any of the structure's components can only be made through
another locator which is explicitly associated with an individual cell
(see {\bf DAT\_CELL}).
\end{description}
\goodbreak

\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_SHOW} \hfill Show HDS statistics \hfill {\bf HDS\_SHOW}}
\begin{description}
\item [ACTION]:
Display statistics about the specified topic on the standard output.
\item [CALL]:
{\tt CALL HDS\_SHOW(topic,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em topic}\>C\>Topic name.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
This facility is provided as an implementation aid only.
The following topics are currently supported:
\begin{itemize}
\item {\bf DATA} --- display details of the representation of primitive data
in use by the host machine.
\item {\bf FILES} --- list all open container files and their associated
attributes in the format:
\begin{verbatim}
        <filename>, disp=[K], mode=[R], refcnt=<reference count>
                         [D]       [U]
\end{verbatim}
where, {\tt disp} denotes the file disposition ([K] for keep or [D] for delete);
{\tt mode} indicates the access mode ([R] for read-only, [U] for update or
write) and {\tt refcnt} specifies the number of primary locators associated
with the file.
\item {\bf LOCATORS} --- display the fully resolved path names of all objects
currently associated with active locators.
\end{itemize}
\end{description}
\goodbreak

\sstroutine{
   HDS\_STATE
}{
   Enquire the current state of HDS
}{
   \sstdescription{
      This routine returns a logical value indicating whether HDS is
      currently active or inactive.
   }
   \sstinvocation{
      CALL HDS\_STATE( STATE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATE = LOGICAL (Returned)
      }{
         The current state of HDS: .TRUE. for active, .FALSE. for
         inactive.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   HDS\_STOP
}{
   Close down HDS
}{
   \sstdescription{
      This routine closes down HDS, annulling all active locators,
      closing all container files and releasing all associated
      resources.  It returns without action if HDS is not active.
   }
   \sstinvocation{
      CALL HDS\_STOP( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set on
         entry, although no further error report will be made if it
         subsequently fails under these circumstances.

         \sstitem
         This routine should not generally be used, since HDS performs the same
         actions itself automatically when a program terminates. Use of
         HDS\_STOP at inappropriate points in a programming environment may
         prevent other components which use HDS from functioning correctly.
      }
   }
}

\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_TRACE} \hfill Trace object path \hfill {\bf HDS\_TRACE}}
\begin{description}
\item [ACTION]:
Trace the path of an object and return the fully resolved name as a text
string.
\item [CALL]:
{\tt CALL HDS\_TRACE(loc,nlev,path,file,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em nlev}\>I\>Number of path levels.\\
{\em path}\>C\>Fully resolved path name.\\
{\em file}\>C\>File specification (may be logical name).\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
The path name is constructed as a sequence of `node' specifications thus:
\begin{verbatim}
        node.node......node.object
\end{verbatim}
such as:
\begin{verbatim}
        NGC1365.SKYPOS.RA.MINUTES
\end{verbatim}
where {\tt MINUTES} is the name of the object associated with the specified locator
and {\tt NGC1365} is the top-level object in the structure.
If any of the nodes are non-scalar the appropriate subscript expression is
included thus:
\begin{verbatim}
        AAO.OBS(6).IMAGE_DATA
\end{verbatim}
If the bottom-level object is a slice or cell of an array, the appropriate
subscript expression is appended thus:
\begin{verbatim}
        M87.MAP(100:412,200:312)    or    CENA(3,2)
\end{verbatim}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_TUNE} \hfill Set HDS tuning parameter \hfill {\bf HDS\_TUNE}}
\begin{description}
\item [ACTION]:
Alter an HDS control setting.
\item [CALL]:
{\tt CALL HDS\_TUNE(param,value,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em param}\>C\>Name of the tuning parameter.\\
{\em value}\>I\>New parameter value.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\end{description}
\goodbreak

\sstroutine{
   HDS\_WILD
}{
   Perform a wild-card search for HDS container files
}{
   \sstdescription{
      The routine searches for HDS container files whose names match a
      given wild-card file specification, and which are accessible
      using a specified mode of access. It is normally called
      repeatedly, returning a locator for the top-level object in a new
      container file on each occasion, and a null locator value
      (DAT\_\_NOLOC) when no more container files remain to be located.

      In normal use, the IWLD argument should be set to the value
      DAT\_\_NOWLD before the first call to HDS\_WILD. The value returned
      through this argument subsequently identifies the search context,
      which is retained between calls. In this way, several wild-card
      searches may be performed concurrently if required.

      A call to HDS\_EWILD should be made to annul the search context
      identifier when the search is complete. This will release any
      resources used.
   }
   \sstinvocation{
      CALL HDS\_WILD( FSPEC, MODE, IWLD, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FSPEC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The wild-card file specification identifying the container
         files required (a default file type extension of {\tt "}.sdf{\tt "} is
         assumed, if not specified). The syntax of this specification
         depends on the host operating system.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The mode of access required to the container files: {\tt '}READ{\tt '},
         {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '} (case insensitive).
      }
      \sstsubsection{
         IWLD = INTEGER (Given and Returned)
      }{
         If a value of DAT\_\_NOWLD is supplied on input, then a new
         wild-card search context will be started, a new value for IWLD
         will be returned, and the first HDS container file matching
         the file specification given in FSPEC will be located. If an
         IWLD value saved from a previous invocation of HDS\_WILD is
         supplied, then the previous search context will be used and
         the next container file appropriate to that context will be
         located. In this case, the value of FSPEC is not used.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         A primary locator to the top-level object in the next
         container file to satisfy the file specification given in
         FSPEC.  A value of DAT\_\_NOLOC will be returned (without error)
         if no further container files remain to be located.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine does not return locators for files which are not
         valid HDS container files or which are not accessible using the
         specified access mode.

         \sstitem
         The routine takes a {\tt "}snapshot{\tt "} of the file system when it is
         first called (with IWLD set to DAT\_\_NOWLD) and subsequently
         returns locators for each of the HDS container files found, one
         at a time. This strategy avoids possible run-away conditions if
         (say) output files created by an application were later to be
         selected by a wild-card search used to identify further input
         files.

         \sstitem
         An error may result if any file matched by an initial call to
         HDS\_WILD (with IWLD set to DAT\_\_NOWLD) cannot be accessed when a
         subsequent call requires that a locator be returned for it. This
         might happen, for instance, if the file has been deleted in the
         intervening time. If the resulting error condition is annulled,
         the offending file may be skipped and subsequent calls to
         HDS\_WILD will continue to locate any remaining files.

         \sstitem
         An error will result and a STATUS value of DAT\_\_FILNF will be
         returned if no HDS container files can be found which match the
         wild-card specification supplied on an initial call to HDS\_WILD.

         \sstitem
         A value of DAT\_\_NOLOC will be returned for the LOC argument if
         this routine is called with STATUS set, or if it should fail for
         any reason. In addition, the value of IWLD will be returned
         unchanged if the routine is called with STATUS set or if failure
         should occur during an initial call (i.e. when IWLD is set to
         DAT\_\_NOWLD on entry).

         \sstitem
         The DAT\_\_NOLOC and DAT\_\_NOWLD constants are defined in the
         include file DAT\_PAR. The DAT\_\_FILNF error code is defined in the
         include file DAT\_ERR.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1992 Science \& Engineering Research Council
   }
}
\normalsize

\newpage
\section{OBSOLETE ROUTINES}
The routines described below have been rendered obsolete by developments in HDS
and should not be used in new software. They are included here simply as an aid
to understanding existing software which uses them, and to allow them to be
replaced with alternative techniques as the opportunity arises. These routines
will eventually be removed from the HDS documentation and may, in some cases,
eventually be eliminated from HDS altogether. Certain of these routines may
already not exist in non-VAX/VMS implementations of HDS.

The reason for obsolescence is indicated in each case.

\small
\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_CONV} \hfill Enquire data conversion \hfill {\bf DAT\_CONV}}
\begin{description}
\item [ACTION]:
Compare the data type of a primitive with the type of data being used by the
program and determine whether conversion is possible.
\item [CALL]:
{\tt CALL DAT\_CONV(loc,type,reply,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Primitive locator.\\
{\em type}\>Ctyp\>Data type used by the program.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em reply}\>L\>`.TRUE.' if conversion possible, otherwise `.FALSE.'.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
{\em This routine is obsolete as HDS now permits all conversions between
primitive types.}
\end{description}
\goodbreak

\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_ERDSC} \hfill Report object error \hfill {\bf DAT\_ERDSC}}
\begin{description}
\item [ACTION]:
Report an error in the form `{\em object\_name : message}' where {\em message}
is the text associated with error number {\em status}.
\item [CALL]:
{\tt CALL DAT\_ERDSC(loc,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
{\em This routine is obsolete as HDS now reports its own errors. Any additional
error reports from applications should be made using the ERR\_ routines
(SUN/104). Error reports from system code should use the EMS\_ routines
(SSN/4).}
\end{description}
\newpage

\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_ERDSN} \hfill Report component error \hfill {\bf DAT\_ERDSN}}
\begin{description}
\item [ACTION]:
Report an error in the form `{\em structure\_name.component\_name : message}'
where {\em message} is the text associated with error number {\em status}.
\item [CALL]:
{\tt CALL DAT\_ERDSN(loc,name,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
{\em This routine is obsolete as HDS now reports its own errors. Any additional
error reports from applications should be made using the ERR\_ routines
(SUN/104). Error reports from system code should use the EMS\_ routines
(SSN/4).}
\end{description}
\goodbreak

\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_ERTXT} \hfill Report error \hfill {\bf DAT\_ERTXT}}
\begin{description}
\item [ACTION]:
Report an error in the form `{\em text : message}' where {\em text} is a
specified character string and {\em message} is the text associated with error
number {\em status}.
\item [CALL]:
{\tt CALL DAT\_ERTXT(text,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em text}\>C\>Character string.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
{\em This routine is obsolete as HDS now reports its own errors. Any additional
error reports from applications should be made using the ERR\_ routines
(SUN/104). Error reports from system code should use the EMS\_ routines
(SSN/4).}
\end{description}
\goodbreak

\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_RCERA} \hfill Recursive erase \hfill {\bf DAT\_RCERA}}
\begin{description}
\item [ACTION]:
Recursively delete a component of a structure.
\item [CALL]:
{\tt CALL DAT\_RCERA(loc,name,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Object locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
{\em This routine is obsolete; its action is now performed by} {\bf DAT\_ERASE}.
\end{description}
\goodbreak

\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_RCOPY} \hfill Recursive copy \hfill {\bf DAT\_RCOPY}}
\begin{description}
\item [ACTION]:
Recursively copy an object into a component of a structure.
\item [CALL]:
{\tt CALL DAT\_RCOPY(loc1,loc2,name,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc1}\>Cloc\>Object locator.\\
{\em loc2}\>Cloc\>Structure locator.\\
{\em name}\>Cnam\>Component name.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
{\em This routine is obsolete; its action is now performed by} {\bf DAT\_COPY}.
\end{description}
\goodbreak

\rule{\textwidth}{0.3mm}
{\Large {\bf DAT\_TUNE} \hfill Set HDS parameter \hfill {\bf DAT\_TUNE}}
\begin{description}
\item [ACTION]:
Specify a value for an HDS control parameter.
\item [CALL]:
{\tt CALL DAT\_TUNE(param,value,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em param}\>C\>Parameter name.\\
{\em value}\>I\>Parameter value.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
{\em This routine is obsolete --- {\bf HDS\_TUNE} should be used instead.}
\end{description}
\goodbreak

\rule{\textwidth}{0.3mm}
{\Large {\bf EXC\_\$LOG} \hfill Log exception \hfill {\bf EXC\_\$LOG}}
\begin{description}
\item [ACTION]:
Logs an error condition.
The supplied text is reported as an error message.
\item [CALL]:
{\tt CALL EXC\_\$LOG(msg,status)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em msg}\>C\>Message.\\
{\em status}\>I\>Status value.
\end{tabbing}
\item[NOTES]:
{\em This routine is obsolete as HDS now reports its own errors. Any additional
error reports from applications should be made using the ERR\_ routines
(SUN/104). Error reports from system code should use the EMS\_ routines
(SSN/4).}
\end{description}
\goodbreak

\rule{\textwidth}{0.3mm}
{\Large {\bf EXC\_\$MSG} \hfill Translate error value \hfill {\bf EXC\_\$MSG}}
\begin{description}
\item [ACTION]:
Translate an error status value to a text string.
\item [CALL]:
{\tt CALL EXC\_\$MSG(status,len,msg)}
\item [INPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [OUTPUT PARAMETERS]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em len}\>I\>Length of {\em msg}.\\
{\em msg}\>C\>Message.
\end{tabbing}
\item [NOTES]:
{\em This routine is obsolete --- {\bf DAT\_ERMSG} should be used instead.}
\end{description}
\goodbreak
\rule{\textwidth}{0.3mm}
{\Large {\bf HDS\_CLOSE} \hfill Close container file \hfill {\bf HDS\_CLOSE}}
\begin{description}
\item [ACTION]:
Annul the locator associated with the top-level object in a container file,
decrement the container file reference count by one and close the file if the
reference count reaches zero. If the file is closed, all other locators
associated with it (both primary and secondary) will also be annulled.
\item [CALL]:
{\tt CALL HDS\_CLOSE(loc,status)}
\item [INPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em loc}\>Cloc\>Locator to the container file's top-level object.
\end{tabbing}
\item [OUTPUT PARAMETER]:
\begin{tabbing}
descrxxx\=descrxxx\=\kill
{\em status}\>I\>Status value.
\end{tabbing}
\item [NOTES]:
{\em This routine is obsolete --- its behaviour is flawed because it does not
recognise that some top-level locators are not associated with a container file
reference count (those created with DAT\_CLONE, for instance). HDS\_CLOSE will
always decrement the reference count and, hence, may close a container file
while it is still in use via other locators. The dependence on top-level
locators to hold a container file open has been superceded by the more general
primary/secondary locator attribute (see DAT\_PRMRY) and the role previously
played by HDS\_CLOSE is now incorporated in DAT\_ANNUL.}
\end{description}
\goodbreak

\sstroutine{
   HDS\_RUN
}{
   Run an HDS application subroutine
}{
   \sstdescription{
      This routine starts up HDS, runs an application subroutine which
      uses HDS, and then closes HDS down again.
   }
   \sstinvocation{
      CALL HDS\_RUN( APP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         APP = SUBROUTINE (Given)
      }{
         The subroutine to be executed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      {\em This routine is obsolete as there is no longer any need to start and
      stop HDS explicitly. The routine to be executed may therefore be called
      directly.}
   }
}

\sstroutine{
   HDS\_START
}{
   Start up HDS
}{
   \sstdescription{
      This routine may be called to start up HDS prior to making
      calls to other HDS routines. It ensures that HDS is active,
      returning without action if it is already active.
   }
   \sstinvocation{
      CALL HDS\_START( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      {\em This routine is obsolete as HDS is now self-starting.}
   }
}
\normalsize

\newpage
\section {ERROR CODES}
\label{appendix:errors}

An error status value (not equal to SAI\_\_OK) is returned by any HDS routine
which detects an error condition. If a program is to perform specific tests on
these status values, then the HDS-supplied symbolic names described below
should be used rather than explicit numerical values. These symbolic status
names are prefixed either with `DAT' (for error codes returned by the DAT\_ and
HDS\_ routines) or `CMP' (for error codes returned by the CMP\_ routines) and a
double underscore. The appropriate symbol definitions are contained in the
include files DAT\_ERR (for the DAT\_\_ error codes) and CMP\_ERR (for the
CMP\_\_ error codes). The symbols defined in these two files are shown in the
following table and described in more detail below.

\small
\begin{center}
\begin{tabular}{|l|l|} \hline
{\em Symbolic Name} & {\em Meaning}\\ \hline \hline
{\bf CMP\_\_DIMIN} & Dimensions invalid\\
{\bf CMP\_\_FATAL} & Fatal internal error\\
{\bf CMP\_\_ISMAP} & Data currently mapped\\
{\bf CMP\_\_NOMAP} & Not mapped\\
{\bf CMP\_\_TYPIN} & Type invalid\\[2ex]
{\bf DAT\_\_ACCON} & Access conflict\\
{\bf DAT\_\_BOUND} & Outside bounds of object\\
{\bf DAT\_\_COMEX} & Component already exists\\
{\bf DAT\_\_CONER} & Conversion error\\
{\bf DAT\_\_DELIN} & Deletion invalid\\
{\bf DAT\_\_DIMIN} & Dimensions invalid\\
{\bf DAT\_\_FATAL} & Fatal internal error\\
{\bf DAT\_\_FILCK} & File locking error\\
{\bf DAT\_\_FILCL} & File close error\\
{\bf DAT\_\_FILCR} & File create error\\
{\bf DAT\_\_FILIN} & File invalid\\
{\bf DAT\_\_FILMP} & File mapping error\\
{\bf DAT\_\_FILND} & File not deleted\\
{\bf DAT\_\_FILNF} & File not found\\
{\bf DAT\_\_FILNX} & File not extended\\
{\bf DAT\_\_FILPR} & File protected\\
{\bf DAT\_\_FILRD} & File read error\\
{\bf DAT\_\_FILWR} & File write error\\
{\bf DAT\_\_GRPIN} & Group invalid\\
{\bf DAT\_\_INCHK} & Integrity check\\
{\bf DAT\_\_ISMAP} & Data currently mapped\\
{\bf DAT\_\_LOCIN} & Locator invalid\\
{\bf DAT\_\_MODIN} & Mode invalid\\
{\bf DAT\_\_NAMIN} & Name invalid\\
{\bf DAT\_\_NOMEM} & Insufficient memory available\\
{\bf DAT\_\_OBJIN} & Object invalid\\
{\bf DAT\_\_OBJNF} & Object not found\\
{\bf DAT\_\_PRMAP} & Primitive data mapped\\
{\bf DAT\_\_SUBIN} & Subscripts invalid\\
{\bf DAT\_\_TRUNC} & Text truncated\\
{\bf DAT\_\_TYPIN} & Type invalid\\
{\bf DAT\_\_UNSET} & Primitive data undefined\\
{\bf DAT\_\_VERMM} & Version mismatch\\
{\bf DAT\_\_WLDIN} & Wild-card search context invalid \\
\hline
\end{tabular}
\end{center}
\normalsize

\begin{description}

\item [ACCON:]
A write operation has been rejected because the container file was originally
opened for read-only access.

\item [BOUND:]
An array specification is outside the permitted dimension bounds.

\item [COMEX:]
An attempt to create a new component of a structure has failed because a
component of the same name already exists.

\item [CONER:]
One of the following primitive data conversion errors occurred during a 
GET, PUT, MAP or UNMAP operation:

\begin{itemize}

\item Floating point overflow.

\item Integer overflow.

\item Truncation of non-blank characters in a character string.

\end{itemize}

\item [DELIN:]
The object to be deleted was a non-empty structure.

\item [DIMIN:]
One of the following conditions occurred:

\begin{itemize}

\item When creating an object, the number of dimensions specified exceeds the
system-imposed limit (currently 7) or is negative, or one or more of the
dimension sizes is zero or negative.

\item When slicing an object, the number of dimensions specified exceeds the
system-imposed limit (currently 3) or is negative, or an incorrect number of
lower and upper bounds has been specified.

\item An attempt to read, write, or map primitive data has failed because the
dimensions specified do not match the actual shape of the object.

\end{itemize}

\item [FATAL:]
An unrecoverable error has been detected by HDS. This may indicate an internal
programming error within HDS itself, but may also result from the use of a
corrupt container file. The associated error report will contain further
information about the nature of the error.

\item [FILCK:]
An attempt to lock a container file has failed. This is most likely to be
because another process currently has the file locked with a conflicting access
mode.

\item [FILCL:]
An error occurred while closing an HDS file.

\item [FILCR:]
An error occurred while creating an HDS file.

\item [FILMP:]
An error occurred while mapping data in an HDS file.

\item [FILND:]
An error occurred while deleting an HDS file.

\item [FILNX:]
An error occurred while extending the size of an HDS file.

\item [FILIN:]
One of the following conditions occurred:
\begin{itemize}

\item A file to be opened does not conform to the structure of an HDS container
file.

\item The name given for a file to be created matches the name of a file which
is already in use by HDS.

\item The name given for a file to be created matches the name of an existing
file which cannot be removed because it is not a regular file (it may be a
directory, for instance).

\end{itemize}

\item [FILNF:]
The specified file cannot be found, or the syntax of the file name has been
rejected as invalid by the host operating system.

\item [FILPR:]
The file is protected from being accessed in the specified mode (or from being
deleted).

\item [FILRD:]
An error occurred while reading data from an HDS file.

\item [FILWR:]
An error occurred while writing data to an HDS file.

\item [GRPIN:]
The supplied character string does not conform to the syntax of a group
specification.

\item [INCHK:]
Typically, an attempt to access an object has failed because the object has
been deleted or moved through another locator, either in the same program or in
another process. This error may also be produced through the use of a corrupt
container file.

\item [ISMAP:]
An object is currently mapped.

\item [LOCIN:]
One of the following conditions occurred:

\begin{itemize}
\item A non-character variable has been specified as a locator (or a character
variable of the wrong length).

\item The specified locator is not currently valid, {\em i.e.}\ not associated
with an object.

\item The specified locator was generated by an HDS routine which did not run
to successful completion.

\end{itemize}

\item [MODIN:]
The supplied character string is not a valid access mode.

\item [NAMIN:]
The supplied character string does not conform to the syntax of a name
specification.

\item [NOMEM:]
HDS was unable to dynamically allocate sufficient memory to perform the
requested operation.

\item [OBJIN:]
An input locator points to an object which is not suitable for the type of
operation requested. Specifically, when the locator is associated with one of
the following:

\begin{itemize}

\item A structure object where a primitive is required (and vice versa).

\item An n-D object where a scalar (or cell) is required.

\item A slice or cell of an n-D object where the complete array is required.

\item A top-level object where a component object is required (and vice versa).

\end{itemize}

\item [OBJNF:]
A request to locate a component of a structure, by name or position, has failed
because the object does not exist.

\item [PRMAP:]
A GET, PUT or MAP operation has been rejected because primitive data are
currently mapped to the specified locator.

\item [SUBIN:]
An attempt to locate a slice or cell of an n-D object has failed because the
subscript information references an element which is outside the array bounds
of the object (or a lower bound exceeds an upper bound).

\item [TRUNC:]
A character string has been corrupted through the truncation of significant
(non-blank) characters. Typically this indicates that a program has not
supplied a character string of sufficient length as an argument to an HDS
routine.

\item [TYPIN:]
The supplied character string does not conform to the syntax of a type
specification.

\item [UNSET:]
An attempt to read primitive object data has failed because the values are
currently undefined.

\item [VERMM:]
The HDS file format version number of a container file exceeds the version
number recognised by the HDS software. Typically, this signifies that the file
has been created or modified by a new version of HDS and cannot be handled by a
program linked with an older version.

\item [WLDIN:]
The wild-card search context identifier supplied has not been generated by a
previous successful call to an HDS routine and is not equal to the null value
(DAT\_\_NOWLD).

\end{description}

\paragraph{Obsolete Error Codes.}
The following error codes are no longer used by HDS, although their values
remain defined:

\begin{quote}
\begin{center}
\begin{tabular}{l}
{\bf DAT\_\_ACTIV}\\
{\bf DAT\_\_CONIN}\\
{\bf DAT\_\_ERACT}\\
{\bf DAT\_\_EREXH}\\
{\bf DAT\_\_EXCPA}\\
{\bf DAT\_\_ISOPN}\\
{\bf DAT\_\_RELIN}\\
{\bf DAT\_\_STKOF}\\
{\bf DAT\_\_UNKPA}\\
{\bf DAT\_\_WEIRD}
\end{tabular}
\end{center}
\end{quote}

\newpage
\section{MACHINE-DEPENDENT FEATURES}

Although the implementations of HDS on different computer systems have been
made as similar as possible, there are necessarily some differences in
behaviour due to the underlying operating system. This appendix describes
these. It is organised by topic, with a comparison of the behaviour on each
system being given under each topic heading.

\subsection{File Naming}
\label{sect:system_files}

This section describes the naming rules for files when opening and closing
individual HDS container files. The rules used when searching for container
files using the ``wild-carding'' facilities provided by HDS\_WILD may differ
slightly (see \S\ref{sect:system_wild}).

\paragraph{UNIX systems.} File names may contain characters of either case on
UNIX systems and HDS therefore does not perform any case conversion on file
names. All leading and trailing white space on file names is ignored.

If a file name does not have an extension ({\em i.e.} does not have a period in
the last field of its UNIX pathname), then HDS provides a default extension by
appending `.sdf' to the name. This occurs both when searching for existing files
and when creating new ones. To make it possible to create file names without a
period if required, HDS will also remove exactly one period (if present) from
the end of a file name before using it.

If a file name contains any ``special'' characters\footnote{That is, anything
except alphanumeric characters, slash `/', period `.', underscore `\_' and minus
`$-$'.} and the value of the SHELL tuning parameter
(\S\ref{sect:tuning_parameters}) indicates that a shell is to be used for
interpreting such file names, then the name will be passed to a process running
the required shell for expansion before use. Thus any shell expression resulting
in a valid file name may be used, such as:

\small
\begin{verbatim}
   $MY_DIR/datafile
   ~/reduce/data
   `cat myfilelist`
\end{verbatim}
\normalsize

(the precise syntax and capabilities depending on which shell is selected). The
actual algorithm used for expanding file names is described in
\S\ref{sect:system_wild}. If expansion results in more than one file name, then
only the first one is used.

There are no file version numbers on UNIX systems. If an existing file name
is given as the name of a new output file, then the original file will be
over-written. It is an error to specify a file which has already been opened
by HDS ({\em e.g.}\ for input) as the name of a new output file. 

\paragraph{VMS systems.} All file names on VMS systems are necessarily in upper
case and HDS follows this convention. All leading and trailing white space on
file names is ignored.

When creating new container files, or searching for existing ones, a default
file type of `.SDF' is used. Normal VMS file name defaulting conventions apply,
so this default file type may be over-ridden by specifying a different type
explicitly if required. If VMS wild-card characters are present in a file name,
then the normal VMS pattern-matching behaviour applies; if more than one match
is found, then the first one is used.

When searching for an existing file, the file version number defaults to the
highest existing version unless specified explicitly. When creating new files,
the version number defaults to one more than the highest existing version unless
given explicitly. It is an error to specify an existing version of a file as the
name of a new file.

\subsection{Wild-Card File Searching}
\label{sect:system_wild}

When searching for HDS container files using the ``wild-card'' facilities
provided by HDS\_WILD and HDS\_EWILD, the following rules apply.

\paragraph{UNIX systems.} Traditional UNIX systems do not generally provide
callable pattern-matching facilities for finding files, nor do they support the
concept of default file type extensions, so HDS implements these by passing
wild-card file names to a shell process and expanding them using the following
algorithm:

\begin{enumerate}
\item
The string supplied (which may also be a list of files or file specifications
separated by white space) is first expanded with the shell's file name expansion
facility turned off. This performs operations such as environment variable
substitution and execution of embedded shell commands, but leaves
pattern-matching characters in place.

\item
The resulting string is then scanned as a list of file specifications separated
by white space.

\item
If any element of this list does not contain a file type extension, as indicated
by the absence of a period in the final field (fields being separated by slash
characters `/'), then an extension of `.sdf' is appended to it. If an element
initially ends in a period, then this is removed and no extension is added. This
stage performs file type defaulting on all elements of the list consistent with
the rules applied to individual file names (\S\ref{sect:system_files}).

\item
The resulting list of file specifications is then expanded with the shell's file
name expansion facility turned on, resulting in the final list of files.
\end{enumerate}

\paragraph{VMS systems.} On VMS systems, file searching is performed by the
run-time library functions LIB\$FIND\_FILE and LIB\$FIND\_FILE\_END. These
implement the standard pattern-matching rules used by nearly all VMS utilities,
with which HDS is therefore consistent.

On all systems, HDS will further filter the list of files found to exclude any
which appear not to exist, cannot be accessed, or are not valid HDS container
files. 

\subsection{File Mapping}
\label{sect:system_map}

\paragraph{SUN and VAX/VMS systems.} The SUN Sparcstation and VAX/VMS
implementations of HDS currently provide a choice between the use of file
mapping to perform I/O operations on primitive objects and the use of direct
read/write operations. This is selectable via the `MAP' tuning parameter (see
\S\ref{sect:tuning_parameters}). The default is to use file mapping on both
systems.

\paragraph{Other systems.} Only read/write operations are currently supported on
other systems, regardless of the setting of the `MAP' tuning parameter.

\subsection{Scratch Files}

\paragraph{UNIX systems.} The environment variable HDS\_SCRATCH is used on UNIX
systems to define the directory in which HDS will create scratch container files
to hold temporary objects created with DAT\_TEMP. When creating a scratch file,
HDS will use the file name:

\begin{quote}
\$HDS\_SCRATCH/$<$filename$>$
\end{quote}

where \$HDS\_SCRATCH is the translation of this environment variable. If
HDS\_SCRATCH is undefined, then the file name will be used alone, so that
scratch files will then be created in the current working directory.

\paragraph{VMS systems.} The logical name HDS\_SCRATCH is used on UNIX systems
to define the directory in which HDS will create scratch container files to hold
temporary objects created with DAT\_TEMP. When creating a scratch file, HDS will
use the file name:

\begin{quote}
HDS\_SCRATCH:$<$filename$>$
\end{quote}

The HDS\_SCRATCH logical name must therefore exist; by default it is set to
``\verb#[]#'', so that scratch files will be created in the current default
directory.

\subsection{File Locking}

\paragraph{UNIX systems.} HDS file locking is not currently implemented on UNIX
systems. This means that any number of processes may access a container file
simultaneously. This should not be allowed to happen, however (apart from shared
read access), because modifications to the file will not be propagated
consistently between the file and the separate processes. The result will be a
corrupted container file and/or hung or crashed processes.

Note that HDS supports access to container files over the Network File System
(NFS), but does not provide file locking.

\paragraph{VMS systems.} HDS makes use of the system lock manager on VMS to
implement file locking. Locking is provided on a ``per file'' basis, so that
only one process may access a container file at once (except that shared read
access is always permitted).

\newpage
\section{CHANGES AND NEW FEATURES IN V4.1}

The following describes the most significant changes which have occurred in HDS
since the previous version (V4.0).

\begin{enumerate}

\item
The C source code of HDS now complies with the ANSI C standard, and UNIX
implementations of HDS use a new ``makefile''. Both of these changes are
designed to make it relatively straightforward to implement HDS on new
platforms.

\item
HDS now contains routines which automatically determine the primitive data
representation used by common types of computer hardware ({\em e.g.} the
floating point number format and byte storage order). This also makes it easier
to implement HDS on new platforms, since changes to the source code are not
normally required.

\item
A DECstation implementation of HDS has been added. An implementation on Silicon
Graphics hardware is also in use, although this is not currently supported by
Starlink.

\item
The SUN Sparcstation implementation of HDS now uses file mapping as its default
mode of file access. This can give appreciable performance gains, largely, it
appears, as a result of reduced memory usage which may allow better buffering of
file contents.

\item
The VMS version of HDS has been made less dependent on the system page file.
When accessing data by file mapping (and so long as no data type conversion or
broken slices are involved), HDS now makes no use of the page file to hold
mapped data. This means that for many purposes it is no longer necessary to have
a large page file quota for accessing large arrays of data. The relevant VMS
quota is now the VIRTUALPAGECNT, which determines the total amount of address
space available to a process.

\item
The directory in which HDS resides now contains a file called {\tt
hds\_datestamp} which holds information about how the HDS system was built. This
includes details of the primitive data representation used by the host machine
which may sometimes be of use to programmers.

\item
A bug has been fixed which could cause the length of new \_CHAR objects to
exceed the length actually requested. Typically, an extra digit was being
appended to the length as a result of an un-terminated internal C string. For
some reason, this problem was more apparent on VMS systems and seems to have
become more prevalent recently, possibly as a result of changes to VMS (it was
not seen despite explicitly being tested at the V4.0 release of HDS).

\item
A bug has been fixed which caused HDS not to recognise primitive data values
written in big-endian IEEE double precision format ({\em i.e.} typically written
on a SUN) which have the ``bad'' data value due to a previous format conversion
error. The result of this bug was that a data conversion error could result if
the data were read on a machine (typically a VAX) with a more restricted double
precision number range. The correct behaviour is for the bad SUN value to be
converted silently to the corresponding bad VAX value. This now occurs.

\item
A bug has been fixed which could corrupt a mapped slice of a primitive object
because only a single byte of data was being transferred for the final element.
This could happen both when reading and writing the data, although not in all
circumstances.

\item
A bug has been fixed which could cause floating point overflow on VAX systems
due to an attempt to convert large double precision numbers to single precision
when mapping or unmapping data. Such values are now trapped,  converted to an
appropriate ``bad'' value, and STATUS is set to DAT\_\_CONER.

\item
A problem has been fixed which typically resulted in ``bus errors'' on SUN
systems when attempting to access primitive data as double precision values
where format conversion was also required. This resulted from an inability to
handle double precision values passed from Fortran to C, where the value may be
badly aligned in memory ({\em i.e.} on a 4-byte rather than an 8-byte boundary).
This problem was not always repeatable, in the sense that it depended on where
the Fortran compiler placed the relevant variable in memory.

\item
A workaround has been installed for a problem sometimes encountered when writing
to a file served by a VMS machine using the Network File System (NFS) from a
SUN. Depending on the file size and the amount of data written, a failure to
extend the file can sometimes occur. This seems to happen only when the new file
size requested by the SUN lies between the current end of file and the physical
file size allocated by VMS as a result of clustering of disk blocks. This
problem seems to have arisen since the previous version of HDS due to changes to
the VMS UCX software. The workaround involves repeating the file extend call if
it fails on the first attempt.

\item
A bug has been fixed which occasionally caused errors on VMS if a container file
had been extended beyond its original length by some external means (typically
through copying to another disk with a different cluster size).

\item
A bug has been fixed in the queue handling facility used internally by HDS. This
could cause regions of memory to be over-written. It is not clear what adverse
consequences this may have had.

\item
An error in the documentation concerning the order in which character arguments
should appear when passing mapped character values using the \%VAL facility has
been corrected (see \S\ref{sect:charmapping}).

\item
The description of the DAT\_BASIC routine has been improved to make it clear
that this routine accesses bytes of primitive data {\em as written}, and does
not perform conversion to/from the data representation of the host machine.

\item
Several minor typos in error messages have been corrected.

\item
Use of the routine HDS\_START is no longer necessary in order to start up HDS
before using it. The system is now self-starting, typically when the first
routine which accesses a locator is called. HDS\_START has been documented as
obsolete, but its use remains optional.

\item
Use of the routine HDS\_STOP at the end of a program is now optional, since its
action will be performed automatically by an exit handler. Examples showing its
use have been modified appropriately. Note that HDS\_STOP is not obsolete, as it
remains the only method of closing down HDS in the middle of a program. In
practice, the need to do this is likely to be limited.

\item
Since HDS\_START and HDS\_STOP are now both optional, the routine HDS\_RUN no
longer serves a useful purpose and has been documented as obsolete.

\item
The method by which HDS determines how long a container file should be held open
has been rationalised. This no longer depends on the existence of a
``top-level'' locator. Instead, the concept of ``primary'' and ``secondary''
locators has been introduced (see \ref{sect:primary}) and a container file
remains open for as long as at least one primary locator is associated with it.
Any locator may be designated as primary by means of the new routine DAT\_PRMRY,
thus removing the special status of top-level locators in this context. Routines
which previously incremented the container file ``reference count'' now issue
primary locators (all other locators are secondary by default), so that existing
behavior is retained.

This change has been introduced to remove the requirement that all software
using HDS maintain its own table of top-level locators in order to prevent
container files being closed. It also opens the way for future improvements to
the programming interface of HDS, which should allow objects to be identified by
their pathname as well as by locator.

\item
All routines which annul locators will now also close the associated container
file if there are no longer any primary locators associated with it. Any
outstanding secondary locators associated with a closed container file are now
correctly annulled (previously they were simply left ``dangling''). The main
implication of this is that DAT\_ANNUL will now close a container file which
is no longer in use, removing the need to do this explicitly.

\item
As a result of the above changes, the HDS\_CLOSE routine is now redundant, and
has been documented as obsolete. Its continued use is not recommended. Its
behaviour has always been flawed, since it decrements the reference count for a
container file regardless of whether the top-level locator it annuls originally
caused this count to be incremented when it was created. Since several methods
exist for generating top-level locators without incrementing this count, it is
possible for a container file to be prematurely closed if HDS\_CLOSE is used.

HDS\_CLOSE may still be useful as an emergency measure to close a file in the
presence of a programming error which has left it open.

\item
A new routine DAT\_REFCT has been introduced to return the current reference
count for a container file. This makes it possible to predict when a file will
actually be closed.

\item
The temporary limit on the number of simultaneously open container files imposed
in V4.0 of HDS has been removed. HDS now imposes no restrictions on the number
of open files beyond those set by the host operating system.

\item
On UNIX systems, HDS now reports an error if the name of a container file which
is already in use is given as the name of a new container file to be created.
This avoids the fairly common problem on UNIX, where the user of an application
supplies the same name for both the input file and the output file, and ends up
with no file at all because the output over-writes the input before it has been
read.

\item
When creating new container files on UNIX systems, HDS will now check before
over-writing an existing file to ensure that it is a regular file and not a
directory or FIFO, {\em etc.} An error results if it is not a regular file.

\item
HDS now consistently ignores all leading and trailing white space on file names
passed to it.

\item
On UNIX systems, HDS now uses the full (absolute) pathnames of all files when
referring to them in messages and when returning file names {\em via} routine
arguments.

\item
On UNIX systems, HDS will now pass file names which contain ``special''
characters (anything except alphanumerics, `.', `/', `-' and `\_') to a shell
for interpretation. This means that normal UNIX shell syntax may be used to
construct file names, thus allowing environment variable expansion, {\em etc.}
In fact, any shell command can, in principle, be used to construct a file name.
Pattern-matching characters are also accepted -- if more than one file matches,
then the first match is used.

\item
Two new routines HDS\_WILD and HDS\_EWILD have been introduced to permit
``wild-card'' searching for HDS container files specified using pattern-matching
characters.

\item
A new tuning parameter `SHELL' has been introduced (see
\ref{sect:tuning_parameters}) to allow a choice of which UNIX shell is used to
interpret file names (this includes wild-carding of file names using HDS\_WILD
and HDS\_EWILD). By default, the ``sh'' shell is used but, if available, the
``csh'' and ``tcsh'' shells may also be selected. It is also possible to turn
shell expansion of file names off.

\item
It is now possible to modify the default tuning profile of HDS by means of
environment variables (or logical names on VMS), which are read and interpreted
by HDS at startup (see \S\ref{sect:tuning}). For instance, on VMS systems, the
definition:

\small
\begin{verbatim}
   $ DEFINE HDS_MAP 0
\end{verbatim}
\normalsize

could be used to disable file mapping in favour of I/O in any application which
uses HDS. This particular example might improve performance on heavily-loaded
VMS systems (but beware of other side effects, particularly increased page file
usage - \S\ref{sect:tuning_parameters}).

\item
A call to HDS\_GTUNE will now only return the value 1 for the `MAP' tuning
parameter (corresponding to file mapping being used as the file access mode) if
this mode has previously been requested and if it is actually implemented on the
host machine. This makes it possible for the caller to determine whether file
mapping is implemented or not.

\item
Three new special values ($-$1, $-$2 and $-$3) may now be given for the `MAP'
tuning parameter in order to select the file access mode best suited for a given
type of access. These options select (in order) the file access method which
gives fastest sequential access, fastest random (sparse) access, or minimum
usage of memory (see \ref{sect:tuning_parameters}). The value returned by
HDS\_GTUNE may be used to determine which file access mode was actually
selected, as this will depend on the host operating system.

\item
Some of the values returned by the routine DAT\_CLEN describing the number of
digits required to format floating point numbers have been changed to reflect
the recommendations of the IEEE floating point standard. These changes also
affect VAX values, which have been modified to reflect the relative precision of
the VAX and IEEE floating point number formats.

\item
The HDS\_SHOW routine now has a new `DATA' option which displays details of the
primitive data representation in use by the host machine.

\item
Internal changes have been made which allow HDS ``container records'' (which
contain information about the components which reside within an HDS structure)
to be reduced in size when components are erased. Some hysteresis is allowed in
this process. This typically gives a slight performance improvement and saves a
little file space.

\item
The NBLOCKS tuning parameter is now actually used at several places within HDS.
Previously its value had no effect.

\item
A new script called {\tt hds\_dev} has been provided on UNIX systems to create
and remove symbolic links to the HDS public include files within the current
working directory. This allows the same INCLUDE statements to be used in Fortran
code on both UNIX and VMS systems.

\item
The new error code DAT\_\_WLDIN and the symbolic constant DAT\_\_NOWLD have been
introduced.

\item
This document (SUN/92) has been updated and produced using a larger font.

\end{enumerate}

\end{document}
