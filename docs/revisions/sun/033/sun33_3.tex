\documentstyle[11pt]{article} 
\pagestyle{headings}

%------------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocnumber}    {33.3}
\newcommand{\stardocauthors}   {R.F. Warren-Smith}
\newcommand{\stardocdate}      {3rd December 1991}
\newcommand{\stardoctitle}     {NDF \\ [1ex]
                                Routines for Accessing the\\
                                Extensible N-Dimensional Data Format}
\newcommand{\stardocversion}   {Version 1.2}
\newcommand{\stardocmanual}    {Programmer's Manual}
%------------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

\renewcommand{\_}{{\tt\char'137}}
\renewcommand{\thepage}{\roman{page}}

\begin{document}

\thispagestyle{empty}
SCIENCE \& ENGINEERING RESEARCH COUNCIL \hfill \stardocname\\
RUTHERFORD APPLETON LABORATORY\\
{\large\bf Starlink Project\\}
{\large\bf \stardoccategory\ \stardocnumber}
\begin{flushright}
\stardocauthors\\
\stardocdate
\end{flushright}
\vspace{-4mm}
\rule{\textwidth}{0.5mm}
\vspace{5mm}
\begin{center}
{\Huge\bf  \stardoctitle \\ [2.5ex]}
{\LARGE\bf \stardocversion \\ [4ex]}
{\Huge\bf  \stardocmanual}
\end{center}
\vspace{15mm}

%------------------------------------------------------------------------------
%  Package Description
\begin{center}
{\Large\bf Description}
\end{center}

The {\em Extensible N-Dimensional Data Format\/} (NDF) is the Starlink format
for storing bulk data in the form of N-dimensional arrays of numbers. It is
typically used for storing spectra, images and similar datasets with higher
dimensionality. The NDF format is based on the {\em Hierarchical Data System\/}
HDS (SUN/92) and is extensible; not only does it provide a comprehensive set of
standard ancillary items to describe the data, it can also be extended
indefinitely to handle additional user-defined information of any type.

This document describes the routines provided for accessing NDF data objects. It
also discusses all the important NDF concepts and includes a selection of simple
example applications.

%------------------------------------------------------------------------------
%  Add this part if you want a table of contents
\newpage
\markright{\stardocname}
\null\vspace {5mm}
\begin {center}
\rule{80mm}{0.5mm} \\ [1ex]
{\Large\bf \stardoctitle \\ [2.5ex]
           \stardocversion} \\ [2ex]
\rule{80mm}{0.5mm}
\end{center}

\setlength{\parskip}{0mm}
\tableofcontents
\setlength{\parskip}{\medskipamount}

%------------------------------------------------------------------------------
%  Introduction page
\newpage
\markright{\stardocname}
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\null\vspace {5mm}
\begin {center}
\rule{80mm}{0.5mm} \\ [1ex]
{\Large\bf \stardoctitle \\ [2.5ex]
           \stardocversion} \\ [2ex]
\rule{80mm}{0.5mm}
\end{center}
\vspace{30mm}


\section{INTRODUCTION}

\subsection{What is an NDF?}

``NDF'' stands for {\em Extensible N-Dimensional Data Format}. 
It is the Starlink standard file format for storing data which represent
N-dimensional arrays of numbers, such as spectra, images, {\em etc}.\ and it
therefore forms the basis of most Starlink spectral and image-processing
applications. 
This document describes a subroutine library for accessing data stored in
this form from applications written to run within the Starlink ADAM
programming environment (SUN/101 \& SG/4).
For applications which do not require ADAM facilities, a non-ADAM, or
``stand-alone'', version of the library is also available (see 
\S\ref{ss:compilingandlinking}). 

\subsection{The NDF Philosophy and Extensibility}

The main reason for using NDF data structures as a standard method of
storing astronomical data on Starlink is to simplify the exchange of data
between separate applications packages. 
In principle, this should make it possible for a software user to process
the same data using software drawn from any Starlink package. 

In practice, previous attempts to define a standard data format for this
purpose have met with two serious obstacles. 
First, different authors of software have interpreted the meaning of data
items differently, so that although several software packages might be
capable of reading the same data files, the different packages actually
performed incompatible operations on the data. 
Secondly, many software authors have found a pre-defined data format to be
too restrictive, and have simply chosen not to use it. 

The NDF data structure has therefore had to satisfy two apparently quite
contradictory requirements: 

\begin{enumerate}

\item Its interpretation should be closely defined, so that different
(usually geographically separated) programmers can write software which
processes it in consistent and mutually compatible ways. 

\item It should be very adaptable, so that it can be used to hold data
associated with a wide variety of software systems, whose detailed
requirements may vary considerably. 

\end{enumerate}

The solution to this problem has been to introduce the concept of {\em
extensibility}, and to divide the NDF data structure into two parts -- a set
of {\em standard components\/} and a set of {\em extensions\/} -- each of which
individually satisfies one of these two requirements. 
An NDF data structure therefore consists of a central ``core'' of
information, whose interpretation is well-defined and for which
general-purpose software can be written with wide applicability, together
with an arbitrary number of extensions which may be used by specialist
software but whose interpretation is not otherwise defined. 
Those who wish to know more of the background to this philosophy can find a 
detailed discussion in SGP/38.

Most of the present document is concerned with the facilities provided by
the fixed ``core'' of standard components, although a few general routines
for handling extensions are also included. 

\subsection{The Relationship with HDS}

The NDF file format is based upon the Starlink Hierarchical Data System HDS
(SUN/92) and NDF data structures are stored in HDS {\em container files\/}
(which by convention have a file type of .SDF for {\em Starlink Data File\/}). 
However, this does not necessarily mean that all applications which can read
HDS files can also handle data stored in NDF format. 

To understand why, you must appreciate that HDS provides only a rather
low-level set of facilities for storing and handling astronomical data.
These include the ability to store primitive data objects (such as arrays of
numbers, character strings, {\em etc.}) in a convenient and self-describing
way within {\em container files}.
However, the most important aspect of HDS is its ability to group these
primitive objects together to build larger, more complex structures. 
In this respect, HDS can be regarded as a construction kit which other
higher-level software can use to build even more sophisticated data formats.

The NDF is a higher-level data format which has been built in this way out 
of the more primitive facilities provided by HDS.
Thus, in HDS terms, an NDF is a data structure constructed according to a
particular set of conventions to facilitate the storage of typical
astronomical data (such as spectra, images, or similar objects of higher
dimensionality). 

While HDS can be used to access such structures, it does not contain any of
the interpretive knowledge needed to assign astronomical meanings to the
various components of an NDF, whose details can become quite complicated. 
In practice it is therefore cumbersome to process NDF data structures using
HDS directly. 
Instead, the NDF access routines described in this document are provided.
These routines ``know'' about how NDF data structures are build within HDS,
so they can hide these details from the writers of astronomical
applications.
This results in a subroutine library which deals in higher-level concepts
more closely related to the work which typical astronomical applications
need to perform, and which emphasises the data concepts which an NDF is
designed to represent, rather than the details of its implementation. 

\subsection{Background Reading}

It is assumed that the reader of this document is already familiar with the
facilities of the Starlink ADAM programming environment (SUN/101 \& SG/4) and
with some of the basic concepts used by HDS (SUN/92). 

A knowledge of the method by which the NDF is implemented using HDS (SGP/38)
may also be useful as background reading, but is not essential for
understanding the present document which is intended to be self-contained in
its description of NDF concepts and facilities. 

\subsection{Scope of the Current Implementation}

This document describes version 1.2 of the NDF\_ subroutine library. The main
difference between this version and the previous one (version 1.1) is the
addition of new facilities for handling NDF sections. More complete details of
the changes which have occurred can be found in  Appendix~\ref{ss:changes}.

A small number of the basic facilities described in SGP/38 still remain
to be supported. 
Most importantly, no facilities for accessing an NDF's {\em history\/}
component are provided in this version. 
However, this component is correctly {\em propagated\/} by the current
system (see \S\ref{ss:propagate}) and will be fully supported in a future
version. 

In general, the presence or absence of a description of an NDF facility in
this document should be taken as indicating the extent of the current
implementation. 


\section{OVERVIEW}

This section presents an overview of what NDF data structures are, and the
facilities which the NDF\_ system provides for manipulating them. 

\subsection{Overview of an NDF}
\label{ss:componentnames}

The simplest way of regarding an NDF is to view it as a collection of those
items which might typically be required in an astronomical image or
spectrum. 
The main part is an N-dimensional array of {\em data\/} (where N is 1 for a
spectrum, 2 for an image, {\em etc.}), but this may also be accompanied by a
number of other items which are conveniently categorised as follows: 

\small
\begin{quote}
\begin{center}
\begin{tabular}{rl@{ --- }l}
    {\em Character components:} & {\bf TITLE} & NDF title\\
                                & {\bf LABEL} & Data label\\
                                & {\bf UNITS} & Data units\\[1ex]
        {\em Array components:} & {\bf DATA}  & Data pixel values\\
                                & {\bf VARIANCE} & Pixel variance estimates\\
                                & {\bf QUALITY} & Pixel quality values\\[1ex]
{\em Miscellaneous components:} & {\bf AXIS}  & Coordinate axes\\
                                & {\bf HISTORY} & Processing 
                                                  history\footnotemark\\[1ex]
              {\em Extensions:} & {\bf EXTENSION} & Provides extensibility
\end{tabular}
\end{center}
\end{quote}
\normalsize
\footnotetext{The {\em history\/} component is not fully supported by the
present version of the NDF access routines.} 

The names of these components are significant, since they are used by the
NDF access routines to identify the component(s) to which certain operations
should be applied.\footnote{Note that the name ``DATA'' used by the NDF\_
routines to refer to an NDF's {\em data\/} component differs from the actual
name of the HDS object in which it is stored, which is ``DATA\_ARRAY''.} 
The following describes the purpose and interpretation of each component in 
slightly more detail.

{\large \em Character components:}

\begin{description}

\item[{\bf TITLE}] -- This is a character string, whose value is
intended for general use as a heading for such things as graphical output;
{\em e.g.}\ `M51 in good seeing'. 

\item[{\bf LABEL}] -- This is a character string, whose value is
intended to be used on the axis of graphs to describe the quantity in the
NDF's {\em data\/} component; {\em e.g.}\ `Surface brightness'. 

\item[{\bf UNITS}] -- This is a character string, whose value
describes the physical units of the quantity stored in the NDF's {\em data\/}
component; {\em e.g.}\ `J/(m$**$2$*$Ang$*$s)'. 

\end{description}

{\large \em Array components:}

\begin{description}

\item[{\bf DATA}] -- This is an N-dimensional array of pixel values
representing the spectrum, image, {\em etc.}\ stored in the NDF. 
This is the only NDF component which must always be present.
All the others are optional. 

\item[{\bf VARIANCE}] -- This is an array of the same shape and size
as the {\em data\/} array, and represents the measurement errors or
uncertainties associated with the individual {\em data\/} values. 
If present, these are always stored as {\em variance\/} estimates for each
pixel. 

\item[{\bf QUALITY}] -- This is an array of the same shape and size as
the {\em data\/} array, and holds a set of unsigned byte values. 
These are used to assign additional ``quality'' attributes to each pixel
(for instance, whether it is part of the active area of a detector). 
Quality values may be used to influence the way in which the NDF's {\em
data\/} and {\em variance\/} components are processed, both by general-purpose
software and by specialised applications. 

\end{description}

{\large \em Miscellaneous components:}

\begin{description}

\item[{\bf AXIS}] -- This component name represents a group of {\em axis\/}
components which may be used to describe the shape and position of the NDF's
pixels in a rectangular coordinate system. 
The physical units and a label for each axis of this coordinate system may 
also be stored.
(Note that the ability to associate {\em extensions\/} with an NDF's {\em
axis\/} coordinate system, although described in SGP/38, is not yet
available via the NDF access routines described here.) 

\item[{\bf HISTORY}] -- This component may be used to keep a record of
the processing history which the NDF undergoes. 
If present, this component should be updated by any applications which
modify the data structure. 
Support for this component is not yet provided by the NDF access routines.

\end{description}

\newpage
{\large \em Extensions:}

\begin{description}

\item[{\bf EXTENSIONs}] are user-defined HDS structures associated with the
NDF, and are used to give the data format flexibility by allowing it to be
extended. 
Their formulation is not covered by the NDF definition, but a few simple
routines are provided for accessing and manipulating named extensions, and
for reading and writing the values of components stored within them. 

\end{description}

\subsection{Overview of the NDF\_ Routines}

The NDF access routines described in this document all have names of the 
form:

\small
\begin{quote}
NDF\_$<$name$>$
\end{quote}
\normalsize

where $<$name$>$ identifies the operation which the routine performs.
These routines provide facilities for performing the following types of
operation on NDF data structures: 

\begin{itemize}
\item
Obtaining access to NDFs, for both input and output.

\item
Creating and deleting NDFs.

\item
Enquiring about the attributes of NDFs, including their shape and size.

\item
Enquiring about the attributes of NDF components. 

\item
Reading, writing and resetting NDF component values.

\item
Enquiring about (and flagging) the presence of {\em bad\/} pixels in NDF
components.

\item
Accessing and handling {\em quality\/} information associated with NDFs.

\item
Modifying the attributes of NDFs (including their shape and size) and the
attributes of their components (such as their numeric type). 

\item
Reading, writing and resetting the values of {\em axis\/} arrays and other
{\em axis\/} components associated with NDFs. 

\item
Modifying the attributes of NDF {\em axis} components (such as the numeric
type of {\em axis\/} arrays). 

\item
Controlling the propagation of NDF components to output data structures.

\item
Creating, deleting and enquiring about NDF extensions, and obtaining access
to components stored within extensions. 

\item
Controlling the propagation of NDF extensions to output data structures. 

\item
Selection and management of {\em sections\/} which refer to subsets or 
super-sets of NDFs.

\item
Merging the attributes of NDFs to match the processing capabilities of 
specific applications.

\item
Importing and finding NDFs held in HDS container files and copying of NDFs
between different HDS locations. 

\item
Constructing messages about NDFs.

\item
Controlling access to NDFs.

\end{itemize}

A full description of each routine can be found in
Appendix~\ref{ss:routinedescriptions} of this document. 
Programming support for these routines, including on-line help, is also
provided by the Starlink language sensitive editor STARLSE (see SUN/105). 

\subsection{Error Handling}
\label{ss:errorhandling}

The NDF\_ routines adhere throughout to the Starlink error-handling strategy
described in SUN/104. 
Most of the routines therefore carry an integer inherited status argument
called STATUS and will return without action unless this is set to the value
SAI\_\_OK\footnote{The symbolic constant SAI\_\_OK is defined in the include
file SAE\_PAR.} when they are invoked. 
When necessary, error reports are made through the ERR\_ routines in the
manner described in SUN/104. 
Where exceptions to this general behaviour exist, they are noted in the
appropriate subroutine descriptions in
Appendix~\ref{ss:routinedescriptions}. 

\subsection{Overview of a Typical Application}
\label{ss:applicationoverview}

The following contains an example of a simple application which uses the
NDF\_ routines to add the {\em data\/} arrays of two NDF data structures to
produce a new NDF. 
This is not quite the simplest ``add'' application which could be written,
but is close to it. 
Nevertheless, it will do a good job, and will respond correctly to unforseen
circumstances or conditions which it is not designed to handle by issuing
sensible error messages. 

The intention here is simply to give a flavour of how the NDF\_ routines are
used, so don't worry if you don't understand all the details. 
The example is followed by some brief programming notes which include 
references to other relevant sections of this document which can be
consulted if necessary. 
If you are interested, a more sophisticated ``add'' application with extra
commentary can also be found in \S\ref{ss:addexample}. 

\small
\begin{quote}
\begin{tabbing} % Not clear why this is needed, but leading spaces get
                % lost otherwise.

\verb#      SUBROUTINE ADD( STATUS )                                # \fbox{1}\\
\verb#      INCLUDE 'SAE_PAR'                                       # \fbox{2}\\
\verb#      INTEGER STATUS, EL, NDF1, NDF2, NDF3, PNTR1( 1 ), PNTR2( 1 ), PNTR3( 1 )#\\
\verb#                                                              #\\
\verb#*  Check inherited global status and begin an NDF context.    #\\
\verb#      IF ( STATUS .NE. SAI__OK ) RETURN                       # \fbox{3}\\
\verb#      CALL NDF_BEGIN                                          # \fbox{4}\\
\verb#                                                              #\\
\verb#*  Obtain identifiers for the two input NDFs and trim their pixel-index#\\
\verb#*  bounds to match.                                           #\\
\verb#      CALL NDF_ASSOC( 'IN1', 'READ', NDF1, STATUS )           # \fbox{5}\\
\verb#      CALL NDF_ASSOC( 'IN2', 'READ', NDF2, STATUS )           #\\
\verb#      CALL NDF_MBND( 'TRIM', NDF1, NDF2, STATUS )             # \fbox{6}\\
\verb#                                                              #\\
\verb#*  Create a new output NDF based on the first input NDF.      #\\
\verb#      CALL NDF_PROP( NDF1, 'Axis,Quality', 'OUT', NDF3, STATUS )# \fbox{7}\\
\verb#                                                              #\\
\verb#*  Map the input and output data arrays.                      #\\
\verb#      CALL NDF_MAP( NDF1, 'Data', '_REAL', 'READ', PNTR1, EL, STATUS )# \fbox{8}\\
\verb#      CALL NDF_MAP( NDF2, 'Data', '_REAL', 'READ', PNTR2, EL, STATUS )#\\
\verb#      CALL NDF_MAP( NDF3, 'Data', '_REAL', 'WRITE', PNTR3, EL, STATUS )#\\
\verb#                                                              #\\
\verb#*  Check that the input arrays do not contain bad pixels.     #\\
\verb#      CALL NDF_MBAD( .FALSE., NDF1, NDF2, 'Data', .TRUE., BAD, STATUS )# \fbox{9}\\
\verb#                                                              #\\
\verb#*  Add the data arrays.                                       #\\
\verb#      CALL ADDIT( EL, %VAL( PNTR1( 1 ) ), %VAL( PNTR2( 1 ) ), # \fbox{10}\\
\verb#     :            %VAL( PNTR3( 1 ) ), STATUS )                #\\
\verb#                                                              #\\
\verb#*  End the NDF context.                                       #\\
\verb#      CALL NDF_END( STATUS )                                  # \fbox{12}\\
\verb#      END                                                     #\\
\verb#                                                              #\\
\verb#                                                              #\\
\verb#*  Subroutine to perform the addition.                        #\\
\verb#      SUBROUTINE ADDIT( EL, A, B, C, STATUS )                 # \fbox{11}\\
\verb#      INCLUDE 'SAE_PAR'                                       #\\
\verb#      INTEGER EL, STATUS, I                                   #\\
\verb#      REAL A( EL ), B( EL ), C( EL )                          #\\
\verb#                                                              #\\
\verb#      IF ( STATUS .NE. SAI__OK ) RETURN                       #\\
\verb#                                                              #\\
\verb#      DO 1 I = 1, EL                                          #\\
\verb#         C( I ) = A( I ) + B( I )                             #\\
\verb#1     CONTINUE                                                #\\
\verb#      END                                                     #
\end{tabbing}
\end{quote}
\normalsize

{\bf Programming notes:}

\begin{enumerate}

\item Note that the application is actually a subroutine, called ADD, with a
single integer argument called STATUS. 
This is the standard ADAM method of writing applications (see SUN/101).

\item The INCLUDE statement is used to define standard ``symbolic
constants'', such as the value SAI\_\_OK which is used in this routine. 
ADAM makes widespread use of such constants, which should always be defined
in this way rather than by using actual numerical values. 
The file SAE\_PAR is almost always needed, and should be included as
standard in every application. 

\item The value of the STATUS argument is checked.
This is because the application uses the Starlink error handling strategy 
(see SUN/104), which requires that a subroutine should do nothing unless its 
STATUS argument is set to the value SAI\_\_OK on entry.
Here, we simply return without action if STATUS has the wrong value.

\item An NDF {\em context\/} is now opened, by calling NDF\_BEGIN. 
This call matches the corresponding NDF\_END call at the end of the ADD
routine. 
When the NDF\_END call is reached, the NDF\_ system will ``clean up'' by
closing down everything which has been used since the matching call to
NDF\_BEGIN (see \S\ref{ss:beginend}). 
Since we want to clean up everything in the application at this point, the 
initial call to NDF\_BEGIN is put right at the start. 

\item The two input NDFs which we want to add are now obtained using the
ADAM parameters `IN1' and `IN2'. 
Lots of things happen behind the scenes at this point, possibly involving
prompting the user to supply the names of the data structures to be added,
and a pair of integer values NDF1 and NDF2 are returned. 
These values are {\em NDF identifiers\/} and are used to refer to the NDFs
throughout the rest of the application (see \S\ref{ss:identifiers}).

\item The first thing we do with these identifiers is to pass them to
NDF\_MBND. 
This routine ensures that the two NDFs are the same shape and size, which is 
what we require.
The details of how this is done are explained much later (in
\S\ref{ss:mbnd}). 
For now, just accept that it works. 

\item An output NDF is created next by calling NDF\_PROP, which uses the
ADAM parameter `OUT' to get the new data structure (probably prompting the
user for its name) and returns another identifier for it in NDF3. 
NDF\_PROP bases the new NDF on the first input NDF (see \S\ref{ss:prop}).
This ensures that it's the right size, {\em etc.}, and also that it contains
any ancillary information which can legitimately be copied from the input. 

\item The {\em data\/} arrays in the input and output NDFs are then accessed
by calling NDF\_MAP. 
Rather than returning actual data values, this routine returns {\em
pointers\/} for the {\em data\/} values in PNTR1, PNTR2 and PNTR3 (see
\S\ref{ss:map}). 
Note that we want to `READ' the input arrays and `WRITE' to the output array.

\item Since this is a very simple application, it cannot handle the special
{\em bad\/}-pixel values which may be present in some NDF data structures. 
The call to NDF\_MBAD at this point checks that there are none present (see 
\S\ref{ss:mbad}).
If there are, then an appropriate error message will result and the application
will abort. 

\item The subroutine ADDIT which performs the work is now called. 
The pointer values returned by NDF\_MAP are turned into actual Fortran
arrays at this point, which ADDIT can access. 
This is done by using the \%VAL function in the call to ADDIT (see
\S\ref{ss:map}). 

\item ADDIT itself is a very simple subroutine.
Since all the arrays it will be passed are the same size (we have ensured 
this), there is no need to worry about their dimensions.
They are all handled as if they were 1-dimensional, and simply added.
The application could easily be altered to perform a different function by
changing this routine.

\item Finally, NDF\_END is called.
As already explained, this shuts everything down, ensuring that all NDF data
files are closed, {\em etc.}\ before the application finishes. 

\end{enumerate}


\section{OBTAINING AND USING NDF IDENTIFIERS}

Having given an overview of the NDF\_ system, the mechanism by which NDF data
structures are accessed by an application and subsequently referred to by means
of {\em identifiers\/} is now discussed in detail. 

\subsection{Accessing NDFs for Input}
\label{ss:associnput}

The first task to perform before any processing of NDF data can take place is
to gain access to an NDF data structure.
The creation of new NDFs ({\em e.g.}\ to contain output from an application)
is left until later (see \S\ref{ss:creatingndfs}), when some of the concepts
involved should be clearer. 
To start with, we assume that an NDF structure exists and that we are  going to
write an ADAM application which needs to access it.

The normal method of obtaining access to an NDF for input is via the ADAM
parameter system, using the routine NDF\_ASSOC which {\em associates\/} an NDF
with an ADAM parameter: 

\small
\begin{verbatim}
      INTEGER INDF

      ...

      CALL NDF_ASSOC( 'IN', 'READ', INDF, STATUS )
\end{verbatim}
\normalsize

Here, the ADAM parameter `IN' is being used to obtain `READ' access to an
NDF data structure. 
This means that we will be able to read values from the NDF, but not to
modify it.
An integer variable INDF is supplied to receive the returned NDF identifier 
value.

The effect of this call to NDF\_ASSOC is that the ADAM environment will
attempt to find a suitable pre-existing NDF data structure, most probably by
prompting the person running the application to type in its name. 
ADAM allows considerable control over exactly how the data structure is 
obtained, but none of this need be specified in the application.
Instead, a separate {\em interface file\/} (with a file type of .IFL) is used
for this purpose.
Interface files are discussed in SUN/101 and full details can be found in the
reference document SUN/115. 
Here, only a very simple interface file is given as an example:

\small
\begin{verbatim}
   interface PROG              # The name of the application

      parameter IN             # The name of the ADAM parameter
         prompt   'Input NDF data structure'
      endparameter

   endinterface
\end{verbatim}
\normalsize

Other parameter entries may also be present in the same file (the text
beginning with the `\#' signs on the right is commentary and need not be
included). 
In combination with the call to NDF\_ASSOC, this interface file would result in
a prompt, to which the user could respond with the name of an  NDF data
structure, most probably simply the name of an HDS  container file, as follows: 

\small
\begin{verbatim}
   IN - Input NDF data structure > DATAFILE
\end{verbatim}
\normalsize

Assuming that the data structure is a valid NDF, NDF\_ASSOC will return an
identifier for it via its INDF argument and  this may then be passed to other
NDF\_ routines to access the NDF's values.
If the data structure is not valid, then an error message will appear and the 
prompt will be repeated until a valid response is given or the user decides 
to give up ({\em e.g.}\ by typing `!!' -- the ADAM {\em abort\/} response).
In this latter case, NDF\_ASSOC will return with its STATUS argument set to
an error value and INDF will be set to the value of the symbolic constant
NDF\_\_NOID, a universal value (defined in the include file NDF\_PAR) which
indicates that an NDF identifier is not valid. 

Note that the routine NDF\_EXIST may also be used to access NDF data 
structures for input, but is more typically used during the creation of new 
NDFs.
Its use is described later in \S\ref{ss:exist}.

\subsection{NDF Identifiers}
\label{ss:identifiers}

As has been illustrated above, the NDF\_ routines refer to NDFs by means of
values held in integer variables called {\em NDF identifiers}. 
Of course, these integers are not NDF data structures themselves; they simply
identify the data structures, the internal details of which are hidden within
the NDF\_ system.
This idea of identifiers is widely used within the ADAM environment.

Each NDF identifier has a unique value which will not be re-used, and this
property makes it possible to tell at any time whether an integer value is a
valid NDF identifier or not. 
An identifier's validity depends on a number of things, such as its actual
value (the value NDF\_\_NOID is never valid for instance) and the previous
history and current state of the NDF\_ system (an identifier which refers to
a data structure which has been deleted will no longer be valid). 
Note that identifier values should not be explicitly altered by
applications, as this may also cause them to become invalid. 

Identifier validity can be determined by using the routine NDF\_VALID, which
returns a logical value of .TRUE.\ via its VALID argument if the identifier
supplied is valid: 

\small
\begin{verbatim}
      CALL NDF_VALID( INDF, VALID, STATUS )
\end{verbatim}
\normalsize

This is the only NDF\_ routine to which an invalid identifier may be passed
without provoking an error.

\subsection{Annulling Identifiers}
\label{ss:annul}

The number of NDF identifiers available at any time is quite large but is,
nevertheless, limited. 
Each identifier also consumes various computer resources which may
themselves be limited, so it is important to ensure that identifiers are
{\em annulled\/} once they have been finished with, {\em i.e.}\ when access
to the associated NDF data structure is no longer required. 
This is particularly important when an application is to be run from the ADAM
command language ICL. 
Failure to annul every NDF identifier before the application finishes can
result in the task eventually being unable to continue, an event which may be 
accompanied by strange error messages.

Annulling an NDF identifier renders it invalid and resets its value to
NDF\_\_NOID. 
It differs from simply setting the identifier's variable to this value, however,
because it ensures that all resources associated with it are released and made
available for re-use. 
An identifier is annulled using the routine NDF\_ANNUL, as follows:

\small
\begin{verbatim}
      CALL NDF_ANNUL( INDF, STATUS )
\end{verbatim}
\normalsize

Note that annulling an invalid identifier will produce an error, but this will
be ignored if the STATUS argument is not set to SAI\_\_OK when NDF\_ANNUL is
called ({\em i.e.}\ indicating that a previous error has occurred).
This means that it is not usually necessary to check whether an identifier
is valid before annulling it, so long as the only possible reason for it being
invalid is a previous error which has set a STATUS value. 

\subsection{NDF Contexts: BEGIN and END}
\label{ss:beginend}

Unfortunately, it is all too easy to neglect to annul an identifier,  especially
if the number of NDFs used by an application is large.
It is a particular problem if an application is fairly complex and can
potentially terminate at many points with an unknown number of NDF identifiers
allocated.
In such cases, it is often far easier simply to say ``annul all the
identifiers I've used in this part of the program''. 
The NDF\_BEGIN and NDF\_END routines allow this.

These routines are used in pairs to delimit a section of an application, rather
like a Fortran~77 IF...END~IF block, although often they will enclose the
entire application. 
When NDF\_END is called, it will annul all the NDF identifiers issued since
the matching call to NDF\_BEGIN, for example: 

\small
\begin{verbatim}
      CALL NDF_BEGIN
      CALL NDF_ASSOC( 'IN1', ... )
      CALL NDF_ASSOC( 'IN2', ... )

      <allocate more NDF identifiers>

      CALL NDF_END( STATUS )
\end{verbatim}
\normalsize

As with IF...END~IF blocks, matching pairs of calls to NDF\_BEGIN and NDF\_END
may be nested, every call to NDF\_END being accompanied by a corresponding call
to NDF\_BEGIN. 
This makes it possible to annul only those identifiers acquired within a 
certain part of an application if required.
So long as no NDF identifiers are acquired outside the outermost BEGIN...END
block, this type of program structure provides a complete safeguard against
forgetting to annul an identifier. 
Explicit calls to NDF\_ANNUL can then largely be eliminated.

\subsection{Cloning Identifiers}

Since an NDF identifier only refers to an NDF data structure and is not
itself a data structure, it is possible to have several identifiers
referring to the same NDF. 
A duplicate identifier for an NDF may be derived from an existing one by a
process called {\em cloning}, which is performed by the routine NDF\_CLONE, as
follows:

\small
\begin{verbatim}
      CALL NDF_CLONE( INDF1, INDF2, STATUS )
\end{verbatim}
\normalsize

This returns a second identifier INDF2 which refers to the same NDF data 
structure as INDF1.

Cloning is not required frequently, but it can occasionally be useful in
allowing an application to ``hold on'' to an NDF when an identifier is passed to
a routine which will annul it; {\em i.e.}\ you simply pass the original
identifier and keep the cloned copy.
An example of this can be found in the section on matching NDF attributes 
(\S\ref{ss:mbnd}).


\section{NDF SHAPE AND SIZE INFORMATION}

This section describes the attributes which determine an NDF's shape and
size, and shows how the values of these attributes can be obtained and used.

\subsection{Dimensionality and Bounds}

An NDF's {\em shape\/} is determined by its {\em dimensionality\/} ({\em
i.e.}\ its number of dimensions) and the lower and upper bound of each
dimension. 
In this respect, an NDF is exactly like a Fortran~77 array.
It may have between 1 and 7 dimensions, each indexed by an integer lying between
the lower and upper {\em pixel-index bounds\/} of that dimension. 
These bounds may take any integer values, so long as the lower bound does not
exceed the upper bound. 
Each element of the array is termed a {\em pixel}.

All the array components of an NDF ({\em i.e.}\ its {\em data}, {\em variance\/} and
{\em quality\/} components) have the same shape, so an NDF may either be
regarded as a set of up to three matching N-dimensional arrays, or as an
N-dimensional array of pixels each of which has a {\em data\/} (and optionally
a {\em variance\/} and {\em quality\/}) value associated with it. In general,
other non-array components may also be present, of course.

The usual notation can be used to refer to an NDF's shape.
For instance: 

\small
\begin{quote}
\begin{center}
(0:255, -1:1, 3)
\end{center}
\end{quote}
\normalsize

describes the shape of a 3-dimensional NDF with pixel indices ranging from 0
to 255 in the first dimension, from $-$1 to 1 in the second dimension, and
from 1 to 3 in the third dimension. 
The lower bound is taken to be 1 if not specified.

An NDF's pixel-index bounds and dimensionality may be determined from its 
identifier with the routine NDF\_BOUND, as follows:

\small
\begin{verbatim}
      INTEGER NDIMX, LBND( NDIMX ), UBND( NDIMX ), NDIM

      ...

      CALL NDF_BOUND( INDF, NDIMX, LBND, UBND, NDIM, STATUS )
\end{verbatim}
\normalsize

Here, the integer arrays LBND and UBND are supplied to receive the lower and
upper bounds of each dimension, and the number of dimensions is returned via the
NDIM argument. 
The size of the LBND and UBND arrays is specified by the NDIMX argument and
should normally be sufficiently large to ensure that all the NDF's bounds can be
accommodated.
The symbolic constant NDF\_\_MXDIM (defined in the include file NDF\_PAR)
specifies the maximum number of dimensions which an NDF may have, and is
often used when declaring the size of such arrays. 

If the value of NDIMX is larger than the actual number of NDF dimensions,
then any unused elements in the LBND and UBND arrays will be filled with the
value 1. 
This allows an application to ``pretend'' that an NDF has more dimensions than
it actually has, if that is convenient. 
For instance, suppose an application expects a 2-dimensional NDF and determines 
the pixel-index bounds as follows:

\small
\begin{verbatim}
      INTEGER LBND( 2 ), UBND( 2 ), NDIM

      ...

      CALL NDF_BOUND( INDF, 2, LBND, UBND, NDIM, STATUS )
      NDIM = 2

      ...
\end{verbatim}
\normalsize

Although this application simply asserts that the NDF is 2-dimensional, it
will nevertheless be able to handle 1-dimensional NDFs as well, because they
will appear to the rest of the application as if their second dimension has
pixel-index bounds (1:1). 

Sometimes, this deception can also be practiced if the NDF has more
dimensions than expected. 
In this case, NDF\_BOUND will return the expected number of pixel-index
bounds and will discard the bounds information for any extra dimensions
which are non-significant ({\em i.e.}\ for which the lower and upper bounds
are equal). 
In the above example, the NDF would therefore appear 2-dimensional to the rest
of the application.
However, if any of the extra dimensions are significant ({\em i.e.}\ have
unequal lower and upper bounds), then NDF\_BOUND will report an error
explaining the problem and return with its STATUS argument set to
NDF\_\_XSDIM (too many dimensions), as defined in the include file NDF\_ERR.
In the normal course of events, the application would then terminate and the
error message would be delivered to the user. 

The above simple program fragment will therefore ensure that an NDF is made
to appear 2-dimensional if at all possible, and will correctly handle any
difficulties which may arise. 

\subsection{Dimension Sizes}

In many applications, knowledge of the pixel-index bounds of an NDF may be
unnecessary and it is sufficient to know the dimension sizes ({\em i.e.}\ how
many pixels there are along each dimension). 
This will normally be the case when converting an application that was
originally written for a different data system, where typically the dimension
size is the only shape information used. 

The dimension size D is related to the lower and upper bounds of each
dimension, L and U, by: 

\small
\begin{quote}
\begin{center}
$D = U - L + 1$
\end{center}
\end{quote}
\normalsize

but may be obtained more directly using the routine NDF\_DIM, as follows: 

\small
\begin{verbatim}
      INTEGER NDIMX, DIM( NDIMX ), NDIM

      ...

      CALL NDF_DIM( INDF, NDIMX, DIM, NDIM, STATUS )
\end{verbatim}
\normalsize

As with NDF\_BOUND, an integer array DIM is provided to receive the returned
dimension sizes, and any unused elements in this array will be assigned the
value 1. 
If the array size NDIMX is less than the actual number of NDF dimensions, then
information for extra non-significant dimensions ({\em i.e.}\ dimensions with
sizes equal to 1) will be discarded.
However, if any of the discarded dimensions would be significant ({\em 
i.e.}\ have a size greater than 1), then an error will result.

This again allows an application to make an NDF appear to have the number 
of dimensions it requires if at all possible.
For instance, a smoothing application might expect an NDF to contain a
2-dimensional image, and could obtain the dimension sizes it requires, NX
and NY, as follows: 

\small
\begin{verbatim}
      INTEGER DIM( 2 ), NDIM, NX, NY

      ...

      CALL NDF_DIM( INDF, 2, DIM, NDIM, STATUS )
      NX = DIM( 1 )
      NY = DIM( 2 )

      ...
\end{verbatim}
\normalsize

No explicit check on the number of NDF dimensions would be necessary. 

\subsection{NDF Size}

The {\em size\/} of an NDF is the total number of pixels lying within its
bounds, and is given by the product of the sizes of all its dimensions. 
Many applications require only this information about an NDF's  shape and can
conveniently obtain it using the routine NDF\_SIZE, as  follows:

\small
\begin{verbatim}
      CALL NDF_SIZE( INDF, NPIX, STATUS )
\end{verbatim}
\normalsize

This routine returns the total number of pixels via its integer argument 
NPIX.
Note, however, that this same quantity is also returned as a by-product of most
routines which directly access the array components of an NDF (see
\S\ref{ss:map}, for example), so a call to NDF\_SIZE can often be avoided.

\subsection{``Safe'' Dimension Sizes under Error Conditions}
\label{ss:safedimensions}

A common pitfall which can affect software using the inherited status
error-handling strategy employed by all the NDF\_ routines (see
\S\ref{ss:errorhandling}) arises from the way in which the Fortran~77
``adjustable array'' facility behaves. 

Consider the following example, where a call to the NDF\_SIZE routine is 
used to obtain the number of pixels in an NDF, and the returned result is 
then passed to another routine where it specifies the size of an adjustable 
array, A:

\small
\begin{verbatim}
      CALL NDF_SIZE( INDF, NPIX, STATUS )
      CALL DOIT( NPIX, A, STATUS )
\end{verbatim}
\normalsize

Normally, this will cause no problems.
However, if there has been a previous error so that STATUS is no longer set
to SAI\_\_OK, then NDF\_SIZE will not execute. 
If no further precautions were taken, the returned value of NPIX would be
undefined and could easily have a value (zero, perhaps) which is invalid as
an adjustable array dimension. 
In such cases, the application would probably terminate ({\em i.e.}\ crash)
with a run-time error. 

To prevent this happening, all NDF\_ routines which return array size or
dimensionality information will provide a ``safe'' value of 1 under error
conditions. 
This applies both to the case where STATUS is set before the routine is
called, as well as to the case where the NDF\_ routine itself fails.
This generally means that no extra precautions need to be taken to prevent 
run-time errors from this cause.


\section{GENERAL PROPERTIES OF NDF COMPONENTS}

This section describes how to refer to the components of an NDF and outlines 
the general concept of a component's {\em state}.

\subsection{Specifying Component Names}
\label{ss:componentnamespec}

Many NDF\_ routines are capable of operating on more than one NDF component
and use a character string holding one of the component names given in
\S\ref{ss:componentnames} to identify the component to be used.
If required, these names may be abbreviated (to no less than 3  characters) and
may be written using both upper- and lower-case characters.
Thus:

\small
\begin{quote}
\begin{center}
`DATA', `Data', `Variance', `Var', `UNIT' {\em and\/} `hist'
\end{center}
\end{quote}
\normalsize

could all be passed to NDF\_ routines as valid component names.
To avoid confusion between component names and other character strings which may
occasionally have the same value, all component names in programming examples in
this document are given with a capitalised first  letter followed by lower-case,
{\em e.g.}\ `Quality'.

Some NDF\_ routines will also accept a list of components, in which the
component names should be separated by commas, for instance: 

\small
\begin{quote}
\begin{center}
`Data,Variance,Title'
\end{center}
\end{quote}
\normalsize

Spaces may be included before and after component names, but may not be 
embedded within them.

\subsection{Component State}

Although the {\em state\/} of an NDF component is strictly an attribute of
each individual component, it is nevertheless convenient to discuss it here
because all components behave similarly in this respect, and the
descriptions of component access which follow depend on understanding it. 

A component's state is a logical value which indicates whether or not that 
component has a value or is available for use.
If a component's state is .TRUE., then the component is said to be {\em
defined\/} or in a {\em defined state}, whereas if its state is .FALSE., it is
{\em undefined\/} or in an {\em undefined state}.\footnote{A component's state
as defined by the NDF\_ system should not be confused with the state of data
objects as defined by the underlying data system HDS. An ``HDS-undefined''
primitive object is normally regarded as illegal by the NDF\_ system and
provokes an error. The ``NDF-state'' of a component is instead related to
the existence or non-existence of HDS objects, although not always in an
obvious fashion.} 
The state of any NDF component can be determined from its identifier by 
specifying the component name in a call to the routine NDF\_STATE.
For example:

\small
\begin{verbatim}
      LOGICAL STATE

      ...

      CALL NDF_STATE( INDF, 'Variance', STATE, STATUS )
\end{verbatim}
\normalsize

will return a .TRUE.\ value if the NDF's {\em variance\/} component is defined,
{\em i.e.}\ if there are variance values available in the NDF which could be read
into an application and used if required. 
An attempt to read values from an undefined component can result in an
error, although the NDF\_ system may take other appropriate action in some
circumstances, depending on the component. 

In common with most NDF\_ routines which take a component name as an input
argument, a list of components may also be supplied to NDF\_STATE, for
example: 

\small
\begin{verbatim}
      CALL NDF_STATE( INDF, 'Dat,Var,Lab', STATE, STATUS )
\end{verbatim}
\normalsize

In this case, the routine will return the logical ``AND'' of the values
which would have been obtained for each component alone, so in this example
a .TRUE.\ value will be returned via the STATE argument only if all three of
the {\em data}, {\em variance\/} and {\em label\/} components are available. 

\subsection{Factors Determining a Component's State}
\label{ss:reset}

When an NDF is first created, all its components start out in an undefined
state and they become defined only when values have been assigned to them. 
Note that there is no separate concept of component ``creation'' in the
NDF\_ system, {\em i.e.}\ there is no need to ``create'' a component before
assigning a value to it.
The process of assigning the value causes all necessary actions to occur, so a
component cannot ``exist'' without also having a value. 
The method by which values are assigned depends on the individual component,
and is discussed in later sections. 

The opposite process, {\em i.e.}\ of resetting a component to become
undefined, is more straightforward and is the same for all components. 
It is performed by the routine NDF\_RESET, which takes the name of a
component or a list of components in the same way as NDF\_STATE. 
For example:

\small
\begin{verbatim}
      CALL NDF_RESET( INDF, 'Data,Variance,Units', STATUS )
\end{verbatim}
\normalsize

would reset the state of the three named components, making their values 
unavailable and therefore effectively erasing them.

\subsection{Restrictions on the Data Component's State}

So long as an NDF data structure is accessible to the NDF\_ system ({\em
i.e.}\ so long as at least one valid NDF identifier still refers to it) the
state of its components can be manipulated freely by assigning values and
making calls to NDF\_RESET. 
However, when the final identifier referring to an NDF is annulled, that NDF
is {\em released\/} from the NDF\_ system. 
At this point, the resulting data structure must be a valid NDF if it is
subsequently to be accessed by other applications.

This requires that at least the {\em data\/} component should be in a defined
state at this point (all other NDF components are optional, but the {\em
data\/} component must be present if the data structure as a whole is to be
valid). 
An error will result if this is not the case, since this probably indicates
a programming fault which has resulted in failure to assign values to the {\em
data\/} component. 
However, this error will not result if the NDF\_ system does not have the
right to modify the data structure ({\em i.e.}\ if it was accessed only for
reading) because the fault could not then have been in the current application. 


\section{ACCESSING CHARACTER COMPONENTS}
\label{ss:accessingcharcomponents}

The NDF {\em character components}, {\em title}, {\em label\/} and {\em units},
are all accessed through the same set of routines, which are described in this
section.

\subsection{Reading and Displaying Character Values}
\label{ss:cmsg}

The routine NDF\_CGET may be used to obtain the values of NDF character
components.
For instance:

\small
\begin{verbatim}
      CHARACTER * ( 80 ) VALUE

      ...

      VALUE = 'Default label'
      CALL NDF_CGET( INDF, 'Label', VALUE, STATUS )
\end{verbatim}
\normalsize

will obtain the value of the {\em label\/} component, if defined, and return
it via the VALUE argument. 
If the component is undefined, then no value will be returned so the
default value established before the subroutine call would be used instead. 

If the value of a character component is needed as part of a message, then
it may be assigned directly to an MSG\_ message token using the NDF\_CMSG
routine. 
Thus an application might generate a message about the {\em title\/} of an NDF as
follows: 

\small
\begin{verbatim}
      CALL NDF_CMSG( 'TITLE', INDF, 'Title', STATUS )
      CALL MSG_OUT( 'PROG_TITLE', 'NDF title: ^TITLE', STATUS )
\end{verbatim}
\normalsize

Here, `TITLE' is the name of a message token (see SUN/104).

\subsection{Writing Character Values}

The routine NDF\_CPUT may be used to assign new values to character
components. 
For instance:

\small
\begin{verbatim}
      CALL NDF_CPUT( 'Surface Brightness', INDF, 'Lab', STATUS )
\end{verbatim}
\normalsize

will assign the value `Surface Brightness' to the {\em label\/} component, 
overwriting any previous value which this component had.
Note that the entire character string (including trailing blanks if present)
will be assigned, and the length of the NDF's character component will be
adjusted to match the new value. 
After a successful call to NDF\_CPUT, the character component's state 
becomes defined.

It is quite common for an application to obtain a new value for a character
component via the ADAM parameter system and then to store this value in an
NDF. 
The routine NDF\_CINP is therefore provided to do this directly.
For instance, the following will obtain new values for all three character
components via the ADAM parameter system and write the values to an NDF: 

\small
\begin{verbatim}
      CALL NDF_CINP( 'LABEL', INDF, 'Label', STATUS )
      CALL NDF_CINP( 'TITLE', INDF, 'Title', STATUS )
      CALL NDF_CINP( 'UNITS', INDF, 'Units', STATUS )
\end{verbatim}
\normalsize

The first argument to NDF\_CINP specifies the ADAM parameter to be used, while
the third argument is the name of the NDF character component whose value is to
be replaced. 
If a {\em null\/} parameter value is specified (by the user entering `!' in
response to a prompt, for instance), then NDF\_CINP will return without
action, {\em i.e.}\ without setting a new value for the character component. 
A suitable default value for the component should therefore be established
before NDF\_CINP is called. 

An example of an ADAM interface file parameter entry suitable for use with 
NDF\_CINP can be found in \S\ref{ss:titleexample}.

\subsection{Character Component Length}

The length of an NDF character component ({\em i.e.}\ the number of
characters it contains) is determined by the last assignment made to it,
{\em e.g.}\ by NDF\_CPUT, and may be obtained using the routine NDF\_CLEN. 
For instance:

\small
\begin{verbatim}
      INTEGER LENGTH

      ...

      CALL NDF_CLEN( INDF, 'Units', LENGTH, STATUS )
\end{verbatim}
\normalsize

will return the number of characters in the {\em units\/} component via the
LENGTH argument. 
If the specified component is undefined, then a value of zero will be 
returned.

\subsection{Resetting Character Components}

As described in \S\ref{ss:reset}, the value of a character component may be
reset, thereby causing it to become undefined, by using the routine NDF\_RESET.
This routine will also accept a list of components.
For instance:

\small
\begin{verbatim}
      CALL NDF_RESET( INDF, 'Title,Label,Units', STATUS )
\end{verbatim}
\normalsize

will reset all three character components, effectively erasing them.


\section{ARRAY COMPONENT TYPES}

This section introduces the concept of the numerical precision of an NDF's array
components and shows how the value of this attribute may be obtained and
modified.

\subsection{Numeric Types}
\label{ss:numerictypes}

Each of an NDF's array components ({\em i.e.}\ its {\em data}, {\em
quality\/} and {\em variance\/}) has an attribute termed its {\em numeric
type}, which refers to the numerical precision used to store its pixel
values. 
The NDF\_ system allows array components to be stored using any of seven
numeric types which correspond with the seven primitive numeric types
provided by the underlying data system HDS. 
It also uses the same character strings as HDS to refer to these types, as
follows: 

\small
\begin{quote}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
{\bf Character String} & {\bf Numeric Type} & {\bf Fortran Type}\\
\hline \hline
{\tt '\_DOUBLE'} & Double-precision & {\tt DOUBLE PRECISION}\\
{\tt '\_REAL'} & Single-precision & {\tt REAL}\\
{\tt '\_INTEGER'} & Integer & {\tt INTEGER}\\
{\tt '\_WORD'} & Word & {\tt INTEGER * 2}\\
{\tt '\_UWORD'} & Unsigned word & {\tt INTEGER * 2}\\
{\tt '\_BYTE'} & Byte & {\tt BYTE}\\
{\tt '\_UBYTE'} & Unsigned byte & {\tt BYTE}\\
\hline
\end{tabular}
\end{center}
\end{quote}
\normalsize

The HDS documentation (SUN/92) should be consulted for details of the range
and precision of each of these numeric types, which may depend on the
computer hardware in use. 
Note that character and logical types are not provided.

The numeric type of an array component is defined regardless of that component's
state.
The numeric type of the {\em data\/} component is specified when the NDF is
created and the numeric type of its {\em variance\/} component will normally
default to the same value, although both of these types may subsequently be
altered (see \S\ref{ss:stype}). 
In contrast, the data type of the {\em quality\/} component is always
`\_UBYTE' and cannot be changed. 

The numeric type of any NDF array component can be determined using the 
routine NDF\_TYPE.
For instance:

\small
\begin{verbatim}
      INCLUDE 'NDF_PAR'
      CHARACTER * ( NDF__SZTYP ) TYPE

      ...

      CALL NDF_TYPE( INDF, 'Data', TYPE, STATUS )
\end{verbatim}
\normalsize

will return the numeric type of an NDF's {\em data\/} component as an upper
case character string via the TYPE argument. 
Note how the symbolic constant NDF\_\_SZTYP (defined in the include file
NDF\_PAR) should be used to declare the size of the character variable which
is to receive the returned numeric type string. 

The NDF\_TYPE routine will also accept a list of array components.
In this case, it will determine the numeric type of each component in the
list and return the lowest-precision numeric type to which all these
components can be converted without unnecessary loss of information. 
For instance, if values from the {\em data\/} and {\em variance\/} components of
an NDF were to be combined, then a suitable numeric type for performing the
processing could be obtained as follows: 

\small
\begin{verbatim}
      CALL NDF_TYPE( INDF, 'Data,Variance', TYPE, STATUS )
\end{verbatim}
\normalsize

If the {\em data\/} component held `\_WORD' values and the {\em variance\/}
component held `\_REAL' values, then a value of `\_REAL' would be returned
indicating that both components could be accessed for processing using
single-precision arithmetic without losing information. 
The question of type conversion during array component access is discussed
later (see \S\ref{ss:implicitconversion}).

\subsection{Complex Values}

In addition to its numeric type, each NDF array component also has a logical
{\em complex value flag\/} associated with it, which indicates whether it
holds complex values. 
If so, then each pixel of that array is a complex number, with separate real
and imaginary parts. 
Both parts share the same numeric type.

The complex value flag for an NDF's {\em data\/} component is established when the
NDF is created and the {\em variance\/} component will normally adopt the same
value by default, although both may subsequently be altered (see
\S\ref{ss:stype}).
In contrast, the {\em quality\/} component can never hold complex values, so its 
complex value flag remains set to .FALSE.\ and cannot be changed.

It is possible to determine whether an array component holds complex values 
by using the routine NDF\_CMPLX.
For instance:

\small
\begin{verbatim}
      CALL NDF_CMPLX( INDF, 'Variance', CMPLX, STATUS )
\end{verbatim}
\normalsize

would return a logical .TRUE.\ result via the CMPLX argument if the NDF's
{\em variance\/} component held complex values. 
As with NDF\_TYPE, a list of components may also be specified, in which case
the logical ``OR'' of the results for each component will be returned. 
Thus:

\small
\begin{verbatim}
      CALL NDF_CMPLX( INDF, 'Data,Variance', CMPLX, STATUS )
\end{verbatim}
\normalsize

will return a .TRUE.\ result if either the {\em data\/} or {\em variance\/} component
holds complex values. 

\subsection{Full Type Specifications}

The combination of the seven numeric types and a complex value flag gives rise
to a further seven complex types, which are conveniently  expressed by prefixing
the character string `COMPLEX' to the numeric type, as follows:

\small
\begin{quote}
\begin{center}
\begin{tabular}{c}
{\tt 'COMPLEX\_DOUBLE'}\\
{\tt 'COMPLEX\_REAL'}\\
{\tt 'COMPLEX\_INTEGER'}\\
{\tt 'COMPLEX\_WORD'}\\
{\tt 'COMPLEX\_UWORD'}\\
{\tt 'COMPLEX\_BYTE'}\\
{\tt 'COMPLEX\_UBYTE'}
\end{tabular}
\end{center}
\end{quote}
\normalsize

Strings such as these, which represent both the numeric type and the complex
value flag, are termed the {\em full type specification\/} of an NDF's array
component. 
Note that a string such as `\_REAL' can also be considered as a special case
of a full type specification in which the ``complex'' field is blank. 

The full type of an array component can be derived if necessary, but the
routine NDF\_FTYPE will return it directly. 
For instance:

\small
\begin{verbatim}
      INCLUDE 'NDF_PAR'
      CHARACTER * ( NDF__SZFTP ) FTYPE

      ...

      CALL NDF_FTYPE( INDF, 'Data', FTYPE, STATUS )
\end{verbatim}
\normalsize

will return the full type of an NDF's {\em data\/} component as an upper-case
character string via the FTYPE argument.
Note how the symbolic constant NDF\_\_SZFTP (defined in the include file
NDF\_PAR) should be used to declare the size of the character variable which
is to receive the returned full type specification.

As might be expected, NDF\_FTYPE will also accept a list of array
components, returning a full type specification which combines the numeric
types and the complex value flags of the individual components in the same
way as the routines NDF\_TYPE and NDF\_CMPLX would have done individually. 
Thus:

\small
\begin{verbatim}
      CALL NDF_FTYPE( INDF, 'Data,Variance', FTYPE, STATUS )
\end{verbatim}
\normalsize

will combine the full type specifications of both the {\em data\/} and {\em
variance\/} components of an NDF, and return the resultant string. 

\subsection{Setting Component Types}
\label{ss:stype}

So long as the necessary access is available (see
\S\ref{ss:restrictingaccess}), the full type of an NDF's {\em data\/} and {\em
variance\/} components may be explicitly set when required, thereby altering
the precision with which their values are stored. 
This may be done using the routine NDF\_STYPE.
For instance:

\small
\begin{verbatim}
      CALL NDF_STYPE( '_REAL', INDF, 'Data', STATUS )
\end{verbatim}
\normalsize

would change the type of an NDF's {\em data\/} component to `\_REAL'.
This process will retain pixel values which may already be stored in the
affected component; {\em i.e.}\ if these values are defined, then they will be
converted to the new type and will not be lost. 
Of course, this may not always be needed, so it is possible to arrange for
existing values to be disposed of, if necessary, in order to avoid the cost of
converting the pixel values.
This is done by calling NDF\_RESET to reset the component's  values to an
undefined state prior to changing its type, thus:

\small
\begin{verbatim}
      CALL NDF_RESET( INDF, 'Data', STATUS )
      CALL NDF_STYPE( '_REAL', INDF, 'Data', STATUS )
\end{verbatim}      
\normalsize

No attempt will then be made by NDF\_STYPE to convert individual pixel values,
so changing the type of an array component becomes a relatively inexpensive
operation.
Note that no harm is done by calling NDF\_RESET in this way even if the
component's state is already undefined. 

NDF\_STYPE will also accept a list of components and will set them all to 
the same type.
For instance:

\small
\begin{verbatim}
      CALL NDF_STYPE( 'COMPLEX_DOUBLE', INDF, 'Data,Variance', STATUS )
\end{verbatim}
\normalsize

would set both the {\em data\/} and {\em variance\/} components of an NDF to be
of type `COMPLEX\_DOUBLE' ({\em i.e.}\ to have real and imaginary parts, both
stored as double-precision numbers). 
Changes may be made freely between non-complex and complex types, and
conversion of pixel values will be performed if these values are defined;
either an imaginary part filled with zeros will be supplied, or the
imaginary part will be discarded, as appropriate. 


\section{ACCESSING ARRAY COMPONENTS}
\label{ss:accessingarraycomponents}

This section explains how to access the array components of an NDF ({\em 
i.e.}\ its {\em data,}\ {\em quality\/} and {\em variance\/} components) in 
order to read values from them, or to write new values to them.

\subsection{Overview of Mapped Access to Array Components}

The NDF\_ system provides access to the values in an NDF's array components
by means of a technique known as {\em mapping}. 
In this, an array is created in a region of the computer's memory and a {\em
pointer\/}\footnote{A memory address in the case of VAX Fortran.} to it is
returned to the calling routine. 
Access to a selected NDF array component then takes place by means of the
application reading and writing values to and from this array. 
For instance, if the component's values are to be read, then the array would 
be filled with the requested values, which the application can then access. 

The array of values stored in memory is usually made to appear to an
application as if it were a normal Fortran array (with an appropriate
numeric type and shape) so that the NDF component's values may be accessed
merely by referring to this {\em mapped array\/} in the normal Fortran way. If
appropriate, modifications may also be made to the values in the array and
these will be returned to the appropriate NDF component, updating it, when
it is {\em unmapped\/} -- a process which completes the transfer of values. At
this point, the allocated memory is released and no further reference to
the mapped values can be made unless the array is mapped again. 

\subsection{Mapping and Unmapping}
\label{ss:map}

The process of mapping one of an NDF's array components for access may be
performed using the routine NDF\_MAP. 
For instance:

\small
\begin{verbatim}
      INTEGER PNTR( 1 ), EL

      ...

      CALL NDF_MAP( INDF, 'Data', '_REAL', 'READ', PNTR, EL, STATUS )
\end{verbatim}
\normalsize

will map an NDF's {\em data\/} component as an array of `\_REAL' ({\em i.e.}\ 
single-precision) values so that the calling routine can `READ' them. 
NDF\_MAP returns an integer pointer to the mapped values via its PNTR
argument and a count of the number of array elements which were mapped via
its EL argument. 
(PNTR is actually a 1-dimensional integer array, so the pointer value in
this example will be returned in its first element.) 

An application can access the mapped values as if they were a Fortran array of
real numbers by passing the pointer to a subroutine. 
On a VAX computer, this should be done using the \%VAL facility (see below).
Afterwards, access is relinquished by {\em unmapping\/} the NDF component
using the routine NDF\_UNMAP. 
The following illustrates the process:

\small
\begin{verbatim}
      INTEGER PNTR( 1 ), EL
      REAL SUM

      ...

      CALL NDF_MAP( INDF, 'Data', '_REAL', 'READ', PNTR, EL, STATUS )
      CALL SUMIT( EL, %VAL( PNTR( 1 ) ), SUM )
      CALL NDF_UNMAP( INDF, 'Data', STATUS )

      ...

      END


      SUBROUTINE SUMIT( EL, ARRAY, SUM )
      INTEGER EL, I
      REAL ARRAY( EL ), SUM

      SUM = 0.0
      DO 1 I = 1, EL
         SUM = SUM + ARRAY( I )
1     CONTINUE
      END
\end{verbatim}
\normalsize

Here, the call to NDF\_MAP maps the NDF's {\em data\/} component and returns a
pointer to the mapped values. 
This pointer is passed to the subroutine SUMIT using \%VAL, where it
appears as a normal Fortran real array with EL elements.\footnote{Note that
the NDF\_MAP routine (together with NDF\_AMAP, NDF\_MAPQL and NDF\_MAPZ
which also obtain mapped access to arrays) will return a ``safe'' value of 1
via its EL argument under error conditions. 
This is intended to avoid possible run-time errors due to invalid
adjustable array dimensions (see \S\ref{ss:safedimensions}).}
SUMIT can then access the mapped values, in this case summing them, before 
it returns.
Finally NDF\_UNMAP is called to unmap the {\em data\/} component, thereby
releasing the resources that were used. 

In the above example, the array was treated as if it were 1-dimensional,
since its actual dimensionality was not important. 
This is sometimes the case, but if the shape of the array is significant,
then a call to a routine such as NDF\_DIM would be used to obtain the
necessary dimension size information, which would then be passed to the
subroutine which accesses the mapped values, for instance: 

\small
\begin{verbatim}
      INTEGER PNTR( 1 ), EL, DIM( 2 ), NDIM
      REAL SUM

      ...

      CALL NDF_MAP( INDF, 'Data', '_REAL', 'READ', PNTR, EL, STATUS )

      CALL NDF_DIM( INDF, 2, DIM, NDIM, STATUS )
      CALL SUMIT( DIM( 1 ), DIM( 2 ), %VAL( PNTR( 1 ) ), SUM )

      CALL NDF_UNMAP( INDF, 'Data', STATUS )

      ...

      END
\end{verbatim}
\normalsize

In this case, the routine SUMIT would declare the array to have the
appropriate shape, and access it accordingly, as follows: 

\small
\begin{verbatim}
      SUBROUTINE SUMIT( NX, NY, ARRAY, SUM )
      INTEGER NX, NY, I
      REAL ARRAY( NX, NY ), SUM

      SUM = 0.0
      DO 2 J = 1, NY
         DO 1 I = 1, NX
            SUM = SUM + ARRAY( I, J )
1        CONTINUE
2     CONTINUE
      END
\end{verbatim}
\normalsize

The routine NDF\_MAP will also accept a list of component names and will map
all of them in the same way ({\em i.e.}\ with the same type and mapping mode). 
Pointers to each mapped array will be returned via the PNTR argument, which
must have sufficient elements to accommodate the returned values. 
The following shows how both the {\em data\/} and {\em variance\/} components of an
NDF  might be mapped for access, passed to a subroutine DOIT for processing, and
then unmapped: 

\small
\begin{verbatim}
      INTEGER PNTR( 2 ), EL

      ...

      CALL NDF_MAP( INDF, 'Data,Variance', '_REAL', 'READ', PNTR, EL, STATUS )
      CALL DOIT( EL, %VAL( PNTR( 1 ) ), %VAL( PNTR( 2 ) ), STATUS )
      CALL NDF_UNMAP( INDF, 'Data,Variance', STATUS )

      ...
\end{verbatim}
\normalsize

Note how NDF\_UNMAP is also provided with a list of components to unmap. 
An alternative would be to specify a component name of `$*$', which would
cause NDF\_UNMAP to unmap all components which had previously been mapped
using the specified NDF identifier. 

\subsection{Implicit Unmapping}
\label{ss:implicitunmapping}

It is always necessary for an array component to be unmapped when access to
it is complete.
Failure to do this could result in an application running out of some resource,
or failing to re-access the component at a later time. 
In the case where values are being written to an NDF component (described
below), failure to unmap that component afterwards may also result in the
new values being lost. 

However, the need to call NDF\_UNMAP explicitly can often be avoided because
several other routines will perform this operation implicitly if necessary. 
For instance, if NDF\_ANNUL is used to annul an NDF identifier (see
\S\ref{ss:annul}), then any components which were mapped through that
identifier will first be implicitly unmapped. 
The effect is as if:

\small
\begin{verbatim}
      CALL NDF_UNMAP( INDF, '*', STATUS )
\end{verbatim}
\normalsize

had been executed first.

Unmapping is also performed implicitly by the routine NDF\_END as part of
the ``cleaning-up'' service it provides (see \S\ref{ss:beginend}). 
Any NDF identifiers which are implicitly annulled by NDF\_END will also have
any associated components unmapped at the same time. 
Careful use of the routines NDF\_BEGIN and NDF\_END can therefore eliminate many
calls  both to NDF\_UNMAP and NDF\_ANNUL. 

\subsection{Writing and Modifying Array Component Values}
\label{ss:writingandmodifying}

The {\em mapping modes\/} `WRITE' and `UPDATE' may be specified in calls to
NDF\_MAP in place of `READ' to indicate that new values are to be written to
an NDF's array component, or that its existing values are to be updated
({\em i.e.}\ modified), respectively. 
The mapped values can then be accessed in exactly the same was as for read
access, except that any modifications made to the mapped values will be
reflected in the actual values stored in the data structure. 
The transfer of these new values back to the NDF is completed when the
array is unmapped, for instance:

\small
\begin{verbatim}
      CALL NDF_MAP( INDF, 'Variance', '_REAL', 'WRITE', PNTR, EL, STATUS )
      CALL SETVAR( EL, %VAL( PNTR( 1 ) ), STATUS )
      CALL NDF_UNMAP( INDF, 'Variance', STATUS )
\end{verbatim}
\normalsize

Here, an NDF's {\em variance\/} component is mapped for `WRITE' access and 
passed to a routine SETVAR which assigns values to it.
When NDF\_UNMAP is called, these new values are transferred to the NDF.
If the {\em variance\/} component was previously in an undefined state, it now
becomes defined. 

\subsection{More About Mapping Modes}
\label{ss:moreaboutmapping}

The {\em mapping mode\/} argument of NDF\_MAP is used to
indicate how the transfer of mapped values should be handled when an array 
component is accessed.
The three basic mapping modes `READ', `UPDATE' and `WRITE' each has a
separate use, and the following describes how they operate in detail: 

\begin{description}

\item[{\bf `READ' --}] When an array component is mapped for `READ'
access, its pre-existing values are read into memory and made available to
the calling routine (if the component's state is undefined, then an error
will result since there will be no values to read). 
When the component is unmapped, the mapped values are discarded.
If any have been modified they do not result in a permanent change to the
data structure (in fact the values should not be modified, because the
region of memory used may sometimes be write-protected and this will result
in a run-time error). 

\item[{\bf `UPDATE' --}] When an array component is mapped for `UPDATE' access,
its pre-existing values are read into memory exactly as for `READ' access (an
error will similarly be produced if the component is in an undefined state). 
When the component is unmapped, any modifications made to the mapped values
are written back to the NDF, which is therefore permanently modified. 

\item[{\bf `WRITE' --}] When an array component is mapped for `WRITE'
access, an array is created to receive new values, but no pre-existing
values are read in. 
Since the mapped array is un-initialised it may contain garbage at this
point. 
All elements of the array must therefore be assigned values by the
application before the component is unmapped, at which point these values
will be written to the data structure to become permanent. 
`WRITE' access will succeed even if the component is initially in an
undefined state, and the component's state will become defined once the
unmapping operation has completed successfully. 

\end{description}

\subsection{Initialisation Options}
\label{ss:initialisationoptions}

Variations on the above basic mapping modes may be obtained by appending
either of the two {\em initialisation options\/} `/BAD' or `/ZERO' to the
mapping mode argument passed to NDF\_MAP. 
These options specify the value to be supplied as ``initialisation'' in the
absence of defined values. 
For instance, if `READ/ZERO' is specified, thus:

\small
\begin{verbatim}
      CALL NDF_MAP( INDF, 'Data', '_REAL', 'READ/ZERO', PNTR, EL, STATUS )
\end{verbatim}
\normalsize

then NDF\_MAP will read the component's values if available, but instead of
producing an error if its state is undefined, it will supply an array full
of zeros instead. 
In similar circumstances, the access mode `READ/BAD' would supply an array
full of the {\em bad\/}-pixel value appropriate to the numeric type in
use.\footnote{To understand this fully it may be necessary to read the later
section on {\em bad pixels\/} (\S\ref{ss:badpixels}).} 
The same technique applied to update access ({\em e.g.}\ a mapping mode of
`UPDATE/BAD') has a similar effect, except that in this case the values, with
possible subsequent modifications, will be written back to the array component
when it is unmapped, causing its state to become defined. 

The effect of initialisation options on write access ({\em e.g.}\ a mapping
mode of `WRITE/ZERO') is slightly different. 
In this case the initial state of the component is irrelevant, and any
initialisation option is always used to initialise the array's values when
it is first mapped. 
These values, with subsequent modifications, are then written back to the
NDF component when it is unmapped. 
Note that there is generally no point in using an initialisation option with
write access if an application will subsequently assign values to all of
the array's pixels, but it may be useful if only certain pixels will
subsequently be assigned values as it can save having to explicitly assign
default values to all the others. 

\subsection{Implicit Type Conversion}
\label{ss:implicitconversion}

An application seeking access to an NDF array component will not usually be
concerned with the actual numeric type used to store the values and will
request a type which suits whatever processing is to be performed. 
Single-precision ({\em i.e.}\ `\_REAL') values are normally most appropriate and
have  been specified in previous examples.

Nevertheless the (3rd) TYPE argument to NDF\_MAP may be used to specify any
of the seven numeric types supported by the NDF\_ system (see
\S\ref{ss:numerictypes}) and a mapped array of values having the requested
type will be made available. 
For instance:

\small
\begin{verbatim}
      CALL NDF_MAP( INDF, 'Data', '_WORD', 'READ', PNTR, EL, STATUS )
\end{verbatim}
\normalsize

will map an array of `\_WORD' ({\em i.e.}\ Fortran INTEGER$*$2) values,
performing type conversion automatically if required. 
If the component's values are being written or modified, then type
conversion will also be performed, in reverse, when it is unmapped. 
The resulting ``back-converted'' values are used to update the NDF. 

Unfortunately, type conversion takes time, so it may sometimes be worth
avoiding if possible.
This can be done, although only at the expense of some additional
programming effort, by calling NDF\_TYPE to determine the numeric type of a
component which is to be mapped and using the same type for access, so that
type conversion becomes unnecessary, for instance: 

\small
\begin{verbatim}
      INCLUDE 'NDF_PAR'
      CHARACTER * ( NDF__SZTYP ) TYPE

      ...

      CALL NDF_TYPE( INDF, TYPE, STATUS )
      CALL NDF_MAP( INDF, 'Variance', TYPE, 'READ', PNTR, EL, STATUS )
\end{verbatim}
\normalsize

The application must then be prepared to explicitly process whatever numeric 
type is supplied, which will normally mean duplicating the main processing 
algorithm for each possible type.
Such steps are not justified for normal use, but may sometimes be adopted
for general-purpose software which will be heavily used. 
The GENERIC compiler (see SUN/7) can be useful for generating the necessary 
multiple copies of suitably-written algorithms if this approach is to be 
used.

\subsection{Accessing Complex Values}
\label{ss:complexaccess}

Array components which hold complex values may be accessed using the
routine NDF\_MAPZ, which is identical to NDF\_MAP except that it returns a
pair of pointers for each component mapped; one for each of the real and
imaginary parts. 
For instance: 

\small
\begin{verbatim}
      INTEGER RPNTR( 1 ), IPNTR( 1 )

      ...

      CALL NDF_MAPZ( INDF, 'Data', '_DOUBLE', RPNTR, IPNTR, EL, STATUS )
\end{verbatim}
\normalsize

will return pointers to the real ({\em i.e.}\ non-imaginary\/) and imaginary parts
of an NDF's {\em data\/} component, as double-precision values, via the arguments
RPNTR and IPNTR. 
As with the routine NDF\_MAP, a list of components may also be supplied and
the RPNTR and IPNTR arguments must then have sufficient elements to accommodate
the returned pointers. 
Unmapping of components mapped using NDF\_MAPZ is performed in exactly  the same
manner as if NDF\_MAP had been used.

Implicit type conversion can be performed between non-complex and complex types
(and {\em vice versa\/}) if required, so the use of NDF\_MAPZ is not restricted to
array components which hold complex values.
Equivalent comments also apply to NDF\_MAP.
A non-complex component accessed via NDF\_MAPZ will be converted to have an
imaginary part of zero, while a complex component accessed using NDF\_MAP
will have its imaginary part discarded. 

\subsection{Mapping the Variance Component as Standard Deviations}
\label{ss:stddev}

The values held in an NDF's {\em variance\/} component are estimates of the
mean square error expected on the corresponding values stored in its {\em
data\/} component. 
This particular method of storage is chosen because it allows more efficient
computation in the common situation where errors from two or more sources
are to be combined. 
For instance, errors are usually combined by adding the contribution from
each source {\em in quadrature}, {\em i.e.}\ if $\sigma_{A}$ and
$\sigma_{B}$ are the errors associated with two independent values, then the
error $\sigma$ in their sum is given by: 

\small
\begin{quote}
\begin{center}
$\sigma = \sqrt{ \sigma_{A}^{2} + \sigma_{B}^{2} }$
\end{center}
\end{quote}
\normalsize

The corresponding {\em variance\/} values therefore combine by simple
addition: 

\small
\begin{quote}
\begin{center}
$V = V_{A} + V_{B}$
\end{center}
\end{quote}
\normalsize

and this is a considerably faster computation to perform.

Nevertheless, the {\em variance\/} values stored in an NDF are unsuitable
for direct use for such purposes as plotting error bars on graphs. 
In this case the square root of each {\em variance\/} estimate must be
taken, in order to obtain an estimate of the {\em standard deviation}, which
is the value normally employed. 
This can be done explicitly, but it is also possible to instruct the
NDF\_MAP routine to provide an array of standard deviation values directly
by specifying a special component name of `Error'. 
For example:

\small
\begin{verbatim}
      CALL NDF_MAP( INDF, 'Error', '_REAL', 'READ', PNTR, EL, STATUS )
\end{verbatim}
\normalsize

would return a pointer to a mapped array of single-precision standard
deviation (or ``error'') values, obtained by taking the square root of the
values stored in the NDF's {\em variance\/} component. 
These values should later be unmapped in the usual way, either implicitly,
or by an explicit call to NDF\_UNMAP, thus: 

\small
\begin{verbatim}
      CALL NDF_UNMAP( INDF, 'Variance', STATUS )
\end{verbatim}
\normalsize

If a mapping mode of `UPDATE' or `WRITE' had been specified, then the mapped
values would be squared before being written back to the NDF's {\em
variance\/} component. 
(Note a component name of `Variance' should be specified when unmapping an 
array of standard deviation values; it is only during the mapping operation 
that the name `Error' may be used.)

The same procedure may also be used when obtaining mapped access to complex
values using the routine NDF\_MAPZ (\S\ref{ss:complexaccess}). 
In this case, the process of taking the square root (or of squaring during
the subsequent unmapping operation) will be applied separately to the real
({\em i.e.}\ non-imaginary) and imaginary parts. 

\subsection{Restrictions on Mapped Access}
\label{ss:restrictionsonmapping}

Certain restrictions are imposed on mapped access to NDF components, the
most important being that each array component may only be mapped for access
\underline{once} through any NDF identifier. 
Thus, two successive calls to NDF\_MAP (or NDF\_MAPZ) specifying the same
identifier and array component will result in an error. 
Of course, the component may later be re-mapped if it has first been
unmapped, either by an intervening call to NDF\_UNMAP, or implicitly.

One way of avoiding this restriction is to {\em clone\/} a duplicate identifier
using NDF\_CLONE so that a component can be mapped twice, once through each
identifier. 
However, a more fundamental restriction exists if a possible access conflict may
occur.
Update and write access to NDF components is always exclusive, so the NDF\_
system will reject any attempt to access a component twice if one of the
attempts involves update or write access, although the same component may be
accessed any number of times (through different identifiers) for read access
alone.


\section{BAD PIXELS}
\label{ss:badpixels}

This section discusses the need to handle pixels whose values may be
unknown, and describes the NDF facilities which support this concept. 

\subsection{The Need for Bad Pixels}

The NDF\_ system provides support for the concept of {\em bad\/} pixels
(sometimes called ``magic values'' or ``flagged values'') which may be present
in the array components of an NDF. 
{\em Bad\/} pixels are pixels whose actual value may be unknown, and which
have therefore been assigned a special ``null'' or {\em bad\/} value. 
They can arise in a wide variety of ways, for instance:

\begin{itemize}

\item
In an image-processing algorithm, arithmetic problems, such as attempts to
divide by zero, might prevent values being calculated for certain output
pixels. 
These missing pixels could be designated as {\em bad}.

\item
In an interactive editing application, deleted pixel values might be denoted as
{\em bad}, indicating that they no longer have a useful value. 

\item
{\em Bad\/} pixels might be introduced into array components during the
process of type conversion ({\em e.g.}\ using the routine NDF\_STYPE -- see
\S\ref{ss:stype}) if values are encountered which cannot be represented
using the component's new type. 
The same situation can also arise if type conversion takes place implicitly
when an array component is accessed by mapping and unmapping it (see
\S\ref{ss:implicitconversion}). 

\item
If the shape of an NDF is altered (see \S\ref{ss:sbnd}), then new pixels may
be introduced by changes in its pixel-index bounds. 
Such pixels will usually be marked as {\em bad}, since they will never have
had a value assigned to them. 

\end{itemize}

Many other examples exist where pixel values cannot be meaningfully
assigned, and the {\em bad pixel\/} concept is designed to handle this general
problem. 

\subsection{Recognition and Processing of Bad Pixels}

Having been introduced into an array, {\em bad\/} pixels must be recognisable
by subsequent algorithms, which must be capable of taking suitable action to
allow for the missing pixel values (normally, this will mean disregarding
them in an appropriate manner). 

For purposes of recognition, {\em bad\/} pixels are assigned a unique value,
appropriate to their numeric type and reserved for this purpose. 
This value is identified by a symbolic name of the form VAL\_\_BADx, where
``x'' identifies the numeric type, as follows: 

\small
\begin{quote}
\begin{center}
\begin{tabular}{l@{ --- }l}
VAL\_\_BADD & {\em Bad double-precision pixel value}\\
VAL\_\_BADR & {\em Bad single-precision pixel value}\\
VAL\_\_BADI & {\em Bad integer pixel value}\\
VAL\_\_BADW & {\em Bad word pixel value}\\
VAL\_\_BADUW & {\em Bad unsigned word pixel value}\\
VAL\_\_BADB & {\em Bad byte pixel value}\\
VAL\_\_BADUB & {\em Bad unsigned byte pixel value}
\end{tabular}
\end{center}
\end{quote}
\normalsize

(note the use of a double underscore character in this naming convention).
These symbolic constants, along with others relating to the HDS
primitive numeric types, are defined in the include file
PRM\_PAR\footnote{Non-ADAM users may need to execute the \$PRM\_DEV
command in order to access this include file.} (see SUN/39).
The appropriate symbolic name should be used for the numeric type being
processed. 


To give an example of how the need for {\em bad\/} pixels inevitably arises in
practice, consider the following simple algorithm to divide one
single-precision ({\em i.e.}\ `\_REAL') array A by another B, to give a result
in the array C: 

\small
\begin{verbatim}
      INTEGER I, EL
      REAL A( EL ), B( EL ), C( EL )

      ...

      DO 1 I = 1, EL
         C( I ) = A( I ) / B( I )
1     CONTINUE
\end{verbatim}
\normalsize

This algorithm is obviously flawed, because if any element of B is zero,
then it will fail. 
However, we can test for this case, and assign {\em bad\/} pixels to affected
elements of the output array as follows: 

\small
\begin{verbatim}
*  Define the VAL__BADx constants.
      INCLUDE 'PRM_PAR'

      ...

      DO 1 I = 1, EL

*  Test for division by zero and assign a bad value to the output array.
         IF ( B( I ) .EQ. 0.0 ) THEN
            C( I ) = VAL__BADR

*  Otherwise, calculate the result normally.
         ELSE
            C( I ) = A( I ) / B( I )
         END IF
1     CONTINUE
\end{verbatim}
\normalsize

Subsequent algorithms will then need to recognise these {\em bad\/} pixels and
take appropriate action. 
Normally, if a {\em bad\/} pixel is encountered as input to an algorithm, it 
should automatically generate a corresponding {\em bad\/} pixel for output, a 
process known as {\em bad pixel propagation}.
The above algorithm could therefore be adapted to recognise {\em bad\/} pixels
in either of the input arrays (A and B) and to propagate them, as follows: 

\small
\begin{verbatim}
      INCLUDE 'PRM_PAR'

      ...

      DO 1 I = 1, EL

*  If either input pixel is bad, then so is the output pixel.
         IF ( A( I ) .EQ. VAL__BADR .OR. B( I ) .EQ. VAL__BADR ) THEN
            C( I ) = VAL__BADR

*  Check for division by zero.
         ELSE IF ( B( I ) .EQ. 0.0 ) THEN
            C( I ) = VAL__BADR

*  Otherwise, calculate the result normally.
         ELSE
            C( I ) = A( I ) / B( I )
         END IF
1     CONTINUE
\end{verbatim}
\normalsize

Different action may be required in other algorithms, but the process
illustrated here is typical. 

\subsection{The Bad-Pixel Flag}
\label{ss:noexplicitchecks}

The need to handle {\em bad\/} pixels inevitably adds to the amount of
programming required when writing an application and can also adversely
affect the execution time (although usually not as badly as might be
feared). 
Nevertheless, most programmers recognise the need to handle {\em bad\/} pixels
as an unfortunate fact of life that often has to be catered for. 

When possible, however, it can be useful to determine whether or not {\em
bad\/} pixels are actually present in an array, so that a more streamlined
algorithm can be used if there is no need to check each pixel explicitly for
a {\em bad\/} value. 
Indeed, in some cases, an algorithm may depend upon the absence of {\em bad\/}
pixels, so a method of checking for this condition is required. 
Each array component of an NDF therefore has a logical value associated with
it called its {\em bad pixel flag}, which is intended to indicate whether or
not {\em bad\/} pixels may be present in that component. 

Unfortunately, certainty in this matter comes at a price, because there are
many operations (including those performed by the NDF\_ system) which
\underline{might} introduce {\em bad\/} pixels into an array component, but
there is no way of being completely sure without performing additional
checks. 
In many cases this will involve examining every array element, and the time
taken to do this may mean that the test is hardly worth performing if the
resulting knowledge only results in a small saving of execution time in the
main algorithm. 

The NDF\_ system takes a pragmatic approach to this problem, by allowing a
slightly ``fuzzy'' interpretation of the {\em bad\/}-pixel flag's value, but
providing the option to make it more precise (at additional cost) if
required. 
The normal interpretation of the {\em bad\/}-pixel flag's value is therefore
as follows: 

\small
\begin{quote}
\begin{center}
\begin{tabular}{rcl}
{\bf .FALSE.} & $\Rightarrow$ & {\em There are definitely no bad pixels 
present}\\
{\bf .TRUE.} & $\Rightarrow$ & {\em There \underline{may} be bad pixels
present} 
\end{tabular}
\end{center}
\end{quote}
\normalsize

(See \S\ref{ss:explicitchecks} for how this may be changed.)
The NDF\_ system goes to some lengths to keep track of {\em bad\/} pixels, but if
any doubt exists it will cautiously set the {\em bad\/}-pixel flag to .TRUE.. 
Thus, a .FALSE.\ {\em bad\/}-pixel flag value expresses a definite fact, while
a .TRUE.\ value only ``suggests'' the presence of {\em bad\/}
pixels.\footnote{Note that a {\em bad\/}-pixel flag value of .FALSE.\ does not
ensure that the numerical value normally used to represent {\em bad\/} pixels
will be absent, but it does indicate that such numbers are to be interpreted
literally ({\em i.e.}\ as ``good'' values) and not as {\em bad\/} pixels.} 

\subsection{Obtaining and Using the Bad-Pixel Flag}
\label{ss:usingbadpixflag}

The {\em bad\/}-pixel flag value for an array component of an NDF may be
obtained using the routine NDF\_BAD. 
For instance:

\small
\begin{verbatim}
      LOGICAL BAD

      ...

      CALL NDF_BAD( INDF, 'Data', .FALSE., BAD, STATUS )
\end{verbatim}
\normalsize

will return the logical {\em bad\/}-pixel flag for an NDF's {\em data\/} component
via the BAD argument.
This value might then be used to control the choice of algorithm for
processing the {\em data\/} values. 
The selected algorithm must be prepared to handle {\em bad\/} pixels unless a
.FALSE.\ value of BAD has been returned, in which case further checks for {\em
bad\/} pixels can be omitted. 

For example, a very simple algorithm to add 1 to each element of an integer
array IA might be written to adapt to the absence or possible presence of
{\em bad\/} pixels as follows: 

\small
\begin{verbatim}
      INCLUDE 'PRM_PAR'
      INTEGER EL, IA( EL ), I
      LOGICAL BAD

      ...

*  There are definitely no bad pixels present.
      IF ( .NOT. BAD ) THEN
         DO 1 I = 1, EL
            IA( I ) = IA( I ) + 1
1        CONTINUE

*  There may be bad pixels, so check for them.
      ELSE
         DO 2 I = 1, EL
            IF ( IA( I ) .NE. VAL__BADI ) THEN
               IA( I ) = IA( I ) + 1
            END IF
2        CONTINUE
      END IF
\end{verbatim}
\normalsize

Note that this example is provided to illustrate the principle only, and
does not imply that all applications should be capable of performing such 
processing.
In fact, it is expected that many applications may choose not to support the
processing of {\em bad\/} pixels at all, and this is considered in more detail
in \S\ref{ss:badpixelabort} and \S\ref{ss:mbad}. 

Like other routines, NDF\_BAD will also accept a list of array components,
in which case it will return the logical ``OR'' of the {\em bad\/}-pixel flag
values for each component. 
For instance:

\small
\begin{verbatim}
      CALL NDF_BAD( INDF, 'Data,Variance', .FALSE., BAD, STATUS )
\end{verbatim}
\normalsize

would return a logical value indicating whether there may be {\em bad\/}
pixels in either the {\em data\/} or {\em variance\/} component of an NDF. 

Finally, note that the {\em quality\/} component of an NDF also has a {\em
bad\/}-pixel flag, but that its value is currently always .FALSE.. 
This behaviour may change in future.

\subsection{Requesting Explicit Checks for Bad Pixels}
\label{ss:explicitchecks}
\label{ss:badpixelabort}

In the above examples, the 3rd (CHECK) argument to NDF\_BAD was set to
.FALSE., indicating that no additional checks for {\em bad\/} pixels were to
be performed. 
In this case, the normal interpretation of the returned {\em bad\/}-pixel flag
value (as described in \S\ref{ss:noexplicitchecks}) applies. 
However, if this CHECK argument is set to .TRUE., then NDF\_BAD will perform
any additional checks necessary to determine whether {\em bad\/} pixels are
actually present, for instance:

\small
\begin{verbatim}
      CALL NDF_BAD( INDF, 'Data', .TRUE., BAD, STATUS )
\end{verbatim}
\normalsize

This may involve explicitly examining every pixel, which could take a
significant time to perform, although this will not always be necessary. 
If explicit checking is requested in this manner, the meaning of a .FALSE.\
{\em bad\/}-pixel flag value is unchanged, but the interpretation of a .TRUE.\
value changes to become: 

\small
\begin{quote}
\begin{center}
\begin{tabular}{rcl}
{\bf .TRUE.} & $\Rightarrow$ & {\em There is definitely \underline{at least one}
bad pixel present} 
\end{tabular}
\end{center}
\end{quote}
\normalsize

Requesting an explicit check in this way can therefore convert an otherwise
.TRUE.\ value for the {\em bad\/}-pixel flag into a .FALSE.\ value, but the
opposite effect cannot occur. 

The main value if this feature arises whenever there is a substantial cost
involved in dealing with {\em bad\/} pixels within a processing algorithm. 
For instance, a considerably less efficient algorithm may be required to
take account of {\em bad\/} pixels, or a suitable algorithm may not even exist
(such as in a Fourier transform application).
In this case, the extra cost of explicitly checking whether {\em bad\/} pixels
are actually present will probably be worthwhile.
In the following example, an application which cannot handle {\em bad\/} 
pixels checks whether there are any present, and aborts with an appropriate 
error message if there are:

\small
\begin{verbatim}
      INCLUDE 'SAE_PAR'
      CALL NDF_BEGIN

      ...

      CALL NDF_BAD( INDF, 'Data,Variance', .TRUE., BAD, STATUS )
      IF ( BAD .AND. ( STATUS .EQ. SAI__OK ) ) THEN
         STATUS = SAI__ERROR
         CALL NDF_MSG( 'DATASTRUCT', INDF )
         CALL ERR_REP( 'FFT_NOBAD',
     :   'The NDF structure ^DATASTRUCT contains bad pixels which this ' //
     :   'application cannot handle.', STATUS )
         GO TO 99
      END IF

      ...

99    CONTINUE
      CALL NDF_END( STATUS )
      END
\end{verbatim}
\normalsize

Here, the cost of an explicit check is justified, because the cost of not
performing the check ({\em i.e.}\ of the application having to abort) is even
greater. 
Note that if the {\em bad\/}-pixel flag is .FALSE., then NDF\_BAD will not
need to check all the pixel values, so this approach does not hinder the
normal case where {\em bad\/} pixels are flagged as absent. 
A simpler method of performing the same check is given in \S\ref{ss:mbad}. 

\subsection{Setting the Bad-Pixel Flag}
\label{ss:settingbadpixflag}

When an NDF is first created, all its components are in an undefined state and
the {\em bad\/}-pixel flag values of the {\em data\/} and {\em variance\/} components
are set to .TRUE.. 
They remains set to .TRUE.\ until evidence is presented that values have been
assigned to either of these components which do not contain any {\em bad\/}
pixels. 
This information can normally only come from the application which assigns the
values, so the routine NDF\_SBAD is provided to explicitly set the {\em
bad\/}-pixel flag value when appropriate. 
For instance:

\small
\begin{verbatim}
      CALL NDF_SBAD( .FALSE., INDF, 'Data', STATUS )
\end{verbatim}
\normalsize

constitutes a declaration by the calling routine that the {\em data\/} component
of an NDF does not currently contain any {\em bad\/} pixels. 
It is entirely the calling routine's responsibility to ensure that this
declaration is accurate, since subsequent applications which access the NDF may
otherwise be mislead. 
In practice, this means that it must either have generated the values itself
or have checked them in some way to be sure of the absence of {\em bad\/}
pixels. 

The converse situation may also arise, where an application is forced to 
introduce {\em bad\/} pixels into an array component which previously did not 
contain any.
In this case, it must also declare this fact if subsequent applications are not
to be mislead. 
This time, the 1st (BAD) argument to NDF\_BAD would be set to .TRUE..
For instance:

\small
\begin{verbatim}
      CALL NDF_SBAD( .TRUE., INDF, 'Data,Variance', STATUS )
\end{verbatim}
\normalsize

Here, a simultaneous declaration for both the {\em data\/} and {\em variance\/}
components has been made by specifying both component names.

If an application is uncertain whether {\em bad\/} pixels may have been
introduced or not, then it should always err on the side of caution and set the
{\em bad\/}-pixel flag value to .TRUE.. 
This is not irreversible, since separate general-purpose applications will
exist to allow a user to explicitly check for {\em bad\/} pixels in an NDF and
to adjust the {\em bad\/}-pixel flag if required. 

Finally, note that the {\em bad\/}-pixel flag for the {\em data\/} and {\em
variance\/} components always reverts to .TRUE.\ if the component is reset to
an undefined state, {\em e.g.}\ by a call to NDF\_RESET. 
If a component is in this state, then NDF\_SBAD will return without action
and the {\em bad\/}-pixel flag will remain set to .TRUE.. 

\subsection{Interaction with Mapping and Unmapping}
\label{ss:mappinginteract}

An important processes which can introduce {\em bad\/} pixels into an array
component is that of accessing the component's values. 
This can occur for a number of reasons, but most obviously because type
conversion may take place implicitly when an array component is mapped and
unmapped (see \S\ref{ss:map}).
This conversion has the potential to fail if the value being converted
cannot be represented using the new type. 
No error will result in such cases, but the affected pixels will be assigned
the appropriate {\em bad\/}-pixel value. 

In consequence, the effective {\em bad\/}-pixel flag value for an array
component may change when that array is accessed by mapping it, and may
change again when it is later unmapped. 
If type conversion errors occur when mapping or unmapping an array component
which is being modified or written, then the {\em bad\/}-pixel flag will end
up set to .TRUE.\ due to the resulting {\em bad\/} pixels being written back to
the data structure. 

What this means in practice is that, on input, the {\em bad\/}-pixel flag
value should normally be checked \underline{after} any mapping operation
has been performed. 
Similarly, if the {\em bad\/}-pixel flag is to be changed using NDF\_SBAD
following the assignment of new values to an output array, then this should
be done \underline{before} the component is unmapped.
See \S\ref{ss:badpixeltemplate} for an example.

\subsection{Interaction with Initialisation Options}

Normally, there is no way for the NDF\_ system to know what values have been 
assigned to an array component, so responsibility for setting the {\em 
bad\/}-pixel flag rests entirely with the application.
One exception to this occurs, however, if an initialisation option of
`/ZERO' is used and results in an array full of zeros being mapped (see
\S\ref{ss:initialisationoptions}). 
In this case, the {\em bad\/}-pixel flag will be set to .FALSE.\ reflecting the
resulting absence of {\em bad\/} pixels. 

\subsection{A Practical Template for Handling the Bad-Pixel Flag}
\label{ss:badpixeltemplate}

The detailed discussion of the {\em bad\/}-pixel flag above will probably have
obscured what needs to be done in practice when writing a simple application,
so this section is intended to redress the balance. 
The overall message is that the NDF\_ system will look after all 
the details.
The only golden rule to be followed is:

\small
\begin{quote}
\begin{center}
{\em If you alter the values in an array component, then use NDF\_SBAD to 
update the bad-pixel flag before unmapping it.}
\end{center}
\end{quote}
\normalsize

The following program fragment shows what action is typically required:

\small
\begin{verbatim}
      INTEGER PNTR1( 1 ), PNTR( 1 ), EL, NBAD
      LOGICAL BAD

      ...

*  Map the input array for reading and the output array for writing.
      CALL NDF_MAP( INDF1, 'Data', '_REAL', 'READ', PNTR1, EL, STATUS )
      CALL NDF_MAP( INDF2, 'Data', '_REAL', 'WRITE', PNTR2, EL, STATUS )

*  See if the mapped input array may contain bad pixels.
      CALL NDF_BAD( INDF1, 'Data', .FALSE., BAD, STATUS )

      ...

      <process the data, counting new bad pixels in NBAD>

      ...

*  See if there may be bad pixels in the output array and declare their
*  presence/absence.
      BAD = BAD .OR. ( NBAD .NE. 0 )
      CALL NDF_SBAD( BAD, INDF2, 'Data', STATUS )

*  Unmap the arrays.
      CALL NDF_UNMAP( INDF1, 'Data', STATUS )
      CALL NDF_UNMAP( INDF2, 'Data', STATUS )
\end{verbatim}
\normalsize

In this example, a single input {\em data\/} array is being processed to produce a
single output array and the application proceeds as follows:

\begin{enumerate}

\item
After mapping the arrays as required, it enquires whether the mapped input
values may contain {\em bad\/} pixels. 

\item
The main processing stage then takes place, during which additional {\em
bad\/} pixels may be introduced. 
Some indication is needed of whether this has occurred; in this case a count
of the number of new {\em bad\/} pixels is assumed to be returned in NBAD. 

\item
The {\em bad\/}-pixel flag for the output array is updated, taking account of
{\em bad\/} pixels which were present initially, and those introduced by the
processing performed above. 

\item
The arrays are then unmapped.

\end{enumerate}

In cases where the processing algorithm provides no clear indication of
whether {\em bad\/} pixels may have been introduced, the application would need
to err on the side of caution and set the output {\em bad\/}-pixel flag to
.TRUE.. 


\section{THE QUALITY COMPONENT IN MORE DETAIL}

\subsection{Purpose of the Quality Component}

The {\em quality\/} component of an NDF is provided to allow individual pixels
to be flagged as having certain properties which applications may wish to take
into account when processing them. 
In general, these properties are expected to be of a binary or logical
character, such as membership of a set, rather than being quantitative, 
although combining several binary values to construct a simple numerical 
scale is not excluded.

To give a simple practical example, it might be useful to flag all the
pixels in an image which are contaminated by defects in the detector system
from which it originates. 
It might also be useful to classify each pixel as lying either in the 
``sky'' background, or in the observed ``object''.
Armed with this sort of information, it then becomes possible to perform 
operations like:

\begin{itemize}
\item Fit a surface to the sky signal, excluding contaminated pixels.
\item Count the number of pixels in the object.
\item Replace all the contaminated pixels by interpolation.
\end{itemize}

An NDF's {\em quality\/} component allows up to eight such binary conditions to be
flagged, so numerous other applications and possibilities obviously exist. 

If this appears too complicated for the sort of work you have in mind, then  the
good news is that the {\em quality\/} component can be almost entirely ignored  by
most applications and the default action of the NDF\_ system will take  care of
it automatically.
However, for applications which wish to exploit the possibilities that the 
{\em quality\/} component offers, a set of NDF\_ routines is provided to access
and  control it explicitly.
Their use is described here.

\subsection{Accessing the Quality Array Directly}

The main part of the {\em quality\/} component is an array containing an 8-bit 
(unsigned byte) value for each NDF pixel.
Each of the bits in these pixels can be thought of as providing a 1-bit 
logical mask extending over all pixels and can be used to signify the 
presence or absence of a particular property at that location.

Thus, if bit 1 (value 1) indicated a contaminated pixel, and bit 2 (value 2) 
indicated membership of the set of ``sky'' pixels, then a value of 3 ({\em
i.e.}\ 1+2) would indicate a contaminated sky pixel, while a value of 0
would indicate an uncontaminated ``object'' pixel. 
With 8 bits available, {\em quality\/} values can range from 0 to 255.

An application may access the {\em quality\/} array directly by means of the
routine  NDF\_MAP.
For instance, the following call maps it for read access in exactly the same 
way that the NDF's {\em data\/} component might be accessed:

\small
\begin{verbatim}
      CALL NDF_MAP( INDF, 'Quality', '_UBYTE', 'READ', PNTR, EL STATUS )
\end{verbatim}
\normalsize

Note that when accessing the {\em quality\/} array in this way a numeric type
of `\_UBYTE' must \underline{always} be used. 
The outcome of using any other type is unspecified, although a meaning might
be assigned to such an operation in future. 

`WRITE' and `UPDATE' access is also available.
When an NDF is first created its {\em quality\/} component is in an undefined
state.
As with other components, it becomes defined once values have been written
to it.
Either of the initialisation options `/BAD' or `/ZERO' may also be appended to
the mapping mode specification (see \S\ref{ss:initialisationoptions}), where
`/BAD' causes initialisation to the value 255 (all bits set) and `/ZERO'
causes initialisation to zero (all bits clear). 

\subsection{The Bad-bits Mask}

The significance attached to each bit of the {\em quality\/} values is arbitrary,
and it is expected that specialised software packages which need to exploit the
full capabilities of the {\em quality\/} component will make a particular choice
of bit assignments and interpret these to influence the processing they perform,
possibly in quite subtle ways. 
Such applications can never be truly general-purpose, however, because the
number of possible bit assignments is unlimited, so agreement between
writers of different software packages about how to interpret each bit
cannot be achieved. 

Nevertheless, some way of taking account of {\em quality\/} values in
general-purpose software is very desirable. 
To allow this, an additional part of the {\em quality\/} component, termed the
{\em  bad-bits mask\/} is provided.
This is a single 8-bit (unsigned byte) value, whose purpose is to allow the 
8-bit {\em quality\/} value associated with each pixel to be converted into a
single logical value, which can then be interpreted in the same way by all 
general-purpose software.

The value of the bad-bits mask for an NDF is obtained by calling the routine 
NDF\_BB:

\small
\begin{verbatim}
      BYTE BADBIT

      ...

      CALL NDF_BB( INDF, BADBIT, STATUS )
\end{verbatim}
\normalsize

The returned result BADBIT is an {\em unsigned byte\/} number.
If the NDF's {\em quality\/} component is undefined and/or a bad-bits value has
not previously been set, then a value of zero is returned. 

A new value for the bad-bits mask may be set with the routine NDF\_SBB:

\small
\begin{verbatim}
      CALL NDF_SBB( BADBIT, INDF, STATUS )
\end{verbatim}
\normalsize

By definition, the {\em quality\/} value of an individual pixel QUAL is
converted into a logical value by forming the bit-wise ``AND'' with the
bad-bits mask BADBIT and testing if the result is zero. 
In effect, this means that each bit which is set in BADBIT acts as a switch to
activate detection of the corresponding bit in QUAL.
If detection of a particular bit is activated \underline{and} that bit is
set in the QUAL value, then the corresponding NDF pixel is to be regarded as
{\em bad}, and should be omitted from processing in much the same way as any
pixel which has been explicitly assigned the {\em bad\/}-pixel value (see 
\S\ref{ss:usingbadpixflag}). 

In VAX Fortran, the logical value would be computed as follows:

\small
\begin{verbatim}
      OK = IIAND( IZEXT( QUAL ), IZEXT( BADBIT ) ) .EQ. 0
\end{verbatim}
\normalsize

where a .FALSE.\ result indicates a {\em bad\/} pixel.
This operation clearly requires non-standard Fortran functions and is
potentially non-portable, so a function NDF\_QMASK is provided to perform
this task and to hide the implementation details. 
NDF\_QMASK is a statement function and is defined by putting the following
include statement into an application, normally immediately after any local
variable declarations:\footnote{The use of a single include file to declare
and define a statement function and its arguments is normally satisfactory. 
However, it sometimes makes it impossible to satisfy Fortran~77 statement
order restrictions. 
For instance, if several such functions were defined in this way from
separate subroutine libraries, it would not be possible to place all the
declaration statements in front of all the function definition statements,
as Fortran~77 requires. 
To cope with such problems, the single NDF\_FUNC file may be replaced if 
necessary with the equivalent two separate include files NDF\_FUNC\_DEC and
NDF\_FUNC\_DEF (in this order) which respectively declare and define the
function.}

\small
\begin{verbatim}
      INCLUDE 'NDF_FUNC'
\end{verbatim}
\normalsize

Conversion of the {\em quality\/} value into a logical value is then performed by 
the function as follows:

\small
\begin{verbatim}
      OK = NDF_QMASK( QUAL, BADBIT )
\end{verbatim}
\normalsize

The following example shows how a simple loop to find the average value of
a pixel in an image array DATA might be written so as to take account of
associated {\em quality\/} values, and exclude affected pixels: 

\small
\begin{verbatim}
      BYTE QUAL( NX, NY )
      INTEGER NGOOD, NX, NY, I, J
      REAL DATA( NX, NY ), SUM, AVERAG
      INCLUDE 'NDF_FUNC'

      ...

      SUM = 0.0
      NGOOD = 0
      DO 2 J = 1, NY
         DO 1 I = 1, NX
            IF ( NDF_QMASK( QUAL( I, J ), BADBIT ) ) THEN
               SUM = SUM + DATA( I, J )
               NGOOD = NGOOD + 1
            END IF
1        CONTINUE
2     CONTINUE

      IF ( NGOOD .GT. 0 ) AVERAG = SUM / REAL( NGOOD )
\end{verbatim}      
\normalsize

As an alternative to the above explicit conversion of {\em quality\/} values into 
logical values, it is also possible to gain access to the {\em quality\/} array 
already converted into this form by calling the routine NDF\_MAPQL, as 
follows:

\small
\begin{verbatim}
      CALL NDF_MAPQL( INDF, PNTR, EL, BAD, STATUS )
\end{verbatim}
\normalsize

This routine returns a pointer to a mapped array of logical values which are 
derived from the {\em quality\/} array and the current value of the bad-bits mask 
following the prescription above.
Only read access is obtained by this routine and any modifications made to 
the mapped values will not result in a permanent change to the {\em quality\/}
component.
If the {\em quality\/} component is undefined, then an array of .TRUE.\ values is
returned. 

NDF\_MAPQL also has an additional argument BAD, which indicates whether 
there are any .FALSE.\ values in the mapped array it returns.
If BAD is returned .FALSE., then all the mapped values will have the value 
.TRUE., so {\em quality\/} information is either absent or, in combination with
the bad-bits mask, has no effect.
In such cases it may be possible to omit handling of {\em quality\/} values 
altogether and affect an improvement in algorithmic efficiency as a result.

Finally, it should be noted that while the use of NDF\_MAPQL may appear more
convenient than explicitly handling the {\em quality\/} values and bad-bits
mask, it nevertheless involves an additional pass through the {\em quality\/}
array and will therefore be a less efficient option. 

\subsection{Why Ignoring the Quality Component Works}

Since the purpose of the {\em quality\/} component in general-purpose software is
to indicate (in conjunction with the bad-bits mask) whether each pixel is
``good'' or {\em bad}, it is natural to ask whether {\em quality\/} component 
information can be handled in the same way as {\em bad\/} pixels.
The answer is ``yes''.
In fact the NDF\_ routines assume by default that {\em quality\/} information
will be handled in this way, and this makes it legitimate simply to ignore
the presence of {\em quality\/} information in most cases. 

What actually happens to make this possible is that by default all access to
an NDF's {\em data\/} and {\em variance\/} components implicitly takes account
of the possible  presence of an associated {\em quality\/} component. 
For instance, if NDF\_BAD is called to determine if {\em bad\/} pixels may be
present in an NDF's {\em data\/} array (see \S\ref{ss:usingbadpixflag}), then an
implicit check will also be made (if necessary) to see whether a {\em quality\/}
component is also present. 
A further check on the bad-bits value may also be made, and all this
information will be combined to determine whether {\em bad\/} pixels may be
present. 

When values are read from the {\em data\/} array (by mapping it for read or update 
access), a similar process takes place.
In this case, if {\em quality\/} information is present, it is combined with the 
bad-bits value and used to insert {\em bad\/} pixels into the mapped {\em data\/}
wherever the {\em quality\/} masking function evaluates to .FALSE..
The application accessing the {\em data\/} array need not know that this is
happening, and can process the resulting mapped values as normal (but taking
due account of the {\em bad\/}-pixel values). 
Note that no similar process takes place when values are written back to an
NDF component ({\em i.e.}\ when any component accessed in update or write
mode is unmapped); in this case the array values are transferred without
interference from the {\em quality\/} component.

The same {\em automatic quality masking\/} also takes place by default when 
values are read from the {\em variance\/} component.
This indicates why it may be more efficient to map both the {\em data\/} and
{\em variance\/} components in a single call to NDF\_MAP, e.g:

\small
\begin{verbatim}
      INTEGER PNTR( 2 ), EL

      ...

      CALL NDF_MAP( INDF, 'Data,Variance', '_REAL', 'READ', PNTR, EL, STATUS )
\end{verbatim}
\normalsize

which returns a pair of pointers in the PNTR array.
By doing this, it becomes possible for NDF\_MAP to access the {\em quality\/}
array (if it exists) only once, and insert {\em bad\/} pixels into both mapped
arrays simultaneously. 

\subsection{Controlling Automatic Quality Masking}

The automatic {\em quality\/} masking action described above is controlled by a
logical {\em quality masking flag\/} associated with each NDF identifier, and
this flag can be manipulated if necessary to modify the default behaviour. 

When an NDF identifier is first issued, its {\em quality\/} masking flag is set to 
.TRUE..
In this state, all access to the NDF's {\em data\/} and {\em variance\/} components
via this identifier will implicitly take account of any {\em quality\/}
information present, as described above. 
So long as no explicit access to the NDF's {\em quality\/} array is made, the
{\em quality\/} masking flag remains set to .TRUE.. 
Thus, an application which chooses to completely ignore {\em quality\/} values
will obtain the desired automatic {\em quality\/} masking action.

However, if explicit access to the {\em quality\/} array is obtained ({\em
e.g.}\ by using the routines NDF\_MAP or NDF\_MAPQL), the flag will
simultaneously be reset to .FALSE.. 
It is then assumed that the application intends to process {\em quality\/} values
explicitly, so access to other NDF components will no longer take account of
{\em quality\/} values. 
The {\em quality\/} masking flag returns to .TRUE.\ once direct access to the
{\em quality\/} array is relinquished (by unmapping it using NDF\_UNMAP).
An application which intends to process {\em quality\/} values explicitly should 
therefore normally map the {\em quality\/} array first, so that subsequent access
to  other NDF components does not involve further implicit access to the {\em
quality\/} component.
The following sequence of operations might be typical:

\small
\begin{verbatim}
      CALL NDF_MAP( INDF, 'Quality', '_UBYTE', 'READ', QPNTR, EL, STATUS )
      CALL NDF_MAP( INDF, 'Data', '_REAL', 'READ', DPNTR, EL, STATUS )

      ...

      <process the data and quality information>

      ...

      CALL NDF_UNMAP( INDF, 'Quality,Data', STATUS )
\end{verbatim}
\normalsize

Here, the {\em quality\/} masking flag is set to .FALSE.\ by the first call to
NDF\_MAP,  which accesses the {\em quality\/} component explicitly. 
The subsequent call to map the {\em data\/} component therefore ignores the
{\em quality\/} values.
Finally, the {\em quality\/} masking flag is returned to .TRUE.\ by the final call
to  NDF\_UNMAP which unmaps the {\em quality\/} array.

The value of the {\em quality\/} masking flag associated with an NDF identifier
may be determined at any time with the routine NDF\_QMF:

\small
\begin{verbatim}
      LOGICAL QMF

      ...

      CALL NDF_QMF( INDF, QMF, STATUS )
\end{verbatim}
\normalsize

and a new value may be set with the routine NDF\_SQMF:

\small
\begin{verbatim}
      CALL NDF_SQMF( QMF, INDF, STATUS )
\end{verbatim}
\normalsize

This allows the normal behaviour to be over-ridden if necessary.
For instance, if direct access to an NDF's {\em data\/} component is required 
without automatic {\em quality\/} masking occurring, then masking could be
disabled as follows:

\small
\begin{verbatim}
      CALL NDF_SQMF( .FALSE., INDF, STATUS )
      CALL NDF_MAP( INDF, 'Data', '_REAL', 'UPDATE', PNTR, EL, STATUS )
\end{verbatim}
\normalsize

\S\ref{ss:tracingndf} contains an example of this technique in use.


\section{EXTENSIONS}

\subsection{Extensibility}

It will be evident from the rest of this document that the standard components
of an NDF ({\em title}, {\em data}, {\em quality}, {\em etc.}) have rather
well-defined meanings and rules associated with them which govern their
interpretation and processing. 
This is necessary in order to allow items of general-purpose software to be
written (often by independent authors) in such a way that they can be used
together co-operatively and without the different authors having interpreted
the meanings of the various components in different ways. 

In contrast, {\em extensions\/} are the means by which the information stored
in an NDF may be extended to suit local or personal requirements.
For instance, an extension may be used to hold information specific to a
particular form of processing, a particular software package, a particular
author, or a particular astronomical instrument. 
In this case, universal agreement about how to process the information is
not necessary, so no restrictions are imposed on the information which may
be stored in extensions. 
As a consequence, a clear distinction has to be maintained between the
processing of standard NDF components and of extensions, since truly
general-purpose software can only be written to process the standard
components of an NDF, whose interpretation is universally defined. 
If an NDF contains extension information, then this can only be successfully
processed by more specialised software. 

\subsection{Extension Names and Software Packages}

An NDF may contain any number of extensions which are distinguished
by unique names.
An extension name may consist of up to 15 characters.
It must start with an alphabetic character, and may contain only
alphanumeric characters (including underscore `\_'). 

Extensions are normally associated with particular software packages which
may use a particular extension name to identify additional information
stored in an NDF in a form which only they understand.\footnote{While the
sharing of extensions between software packages and/or authors is not
excluded, this is entirely the responsibility of those concerned. Since the
requirements are so diverse, no specific recommendations can be made except
to note that some documentary provision is normally necessary to ensure that
separate authors interpret extension information in a consistent way.} 
For instance, a software package for analysing IRAS data might ``own'' the
extension name `IRAS' and use it to store additional information in NDF data
structures relating to the processing of IRAS data. 
All the applications in that package would then be expected to recognise
this extension in all NDF structures and correctly process the information
it contains so that it remains valid throughout. 
However, there is no requirement for other software to be aware of this
extension, other than to avoid using the same name.

In general, software which does not recognise an extension need do no more
than {\em propagate\/} it ({\em i.e.}\ copy it), if appropriate, to any output
data structure. 
Normally, this will be performed automatically by the NDF\_ system and is
considered in more detail in \S\ref{ss:propagate}. 

\subsection{The Contents of Extensions}

An NDF extension is an HDS object, normally a structure, whose contents are
entirely at the discretion of the extension's designer. 
Although some simple NDF\_ routines are described below for identifying and
accessing extensions, the contents of extensions are generally unknown and
their interpretation lies outside the scope of the NDF\_ system.
This information must therefore normally be handled by means of HDS
routines, so anyone planning to use NDF extensions in their software will
need to be familiar with the concepts used by HDS (see SUN/92). 

In addition, some general guidelines aimed at minimising the risk of poor
design and eliminating name clashes between extensions are to be found in
SGP/38. 
These should be consulted by all potential designers of NDF extensions. 
The following additional recommendation should perhaps also be added:

\begin{quote}
\begin{center}
{\em Do not design over-elaborate extensions.}
\end{center}
\end{quote}

The freedom allowed by HDS is a great temptation to do so, but the cost of
writing software to support the extension must always be kept in mind. 

\subsection{Accessing Existing Extensions}

The existence or non-existence of a specified extension in an NDF can be
determined using the routine NDF\_XSTAT. 
For instance:

\small
\begin{verbatim}
      CALL NDF_XSTAT( INDF, 'IRAS', THERE, STATUS )
\end{verbatim}
\normalsize

will return a .TRUE.\ value via the logical argument THERE if an extension 
called `IRAS' is present in an NDF.
If it is, then it can be accessed using the routine NDF\_XLOC.
For instance:

\small
\begin{verbatim}
      CHARACTER * ( DAT__SZLOC ) LOC

      ...

      CALL NDF_XLOC( INDF, 'IRAS', 'READ', LOC, STATUS )
\end{verbatim}
\normalsize

will return an HDS locator to the extension (which is an HDS object) via the 
LOC argument.

Note that an access mode of `READ' was specified in this call to NDF\_XLOC,
indicating that the extension's contents would be read but not modified. 
An access mode of `UPDATE' would be used if the contents were to be
modified, while `WRITE' access would only be used in order to {\em re-\/}write
the extension's contents; in this case the NDF\_ system will erase any
previous contents before returning a locator to the extension. 

The contents of an extension can be accessed by passing the resulting
locator to suitable HDS routines. 
For instance, the value of an integer component called OFFSET within the 
`IRAS' extension could be obtained as follows:

\small
\begin{verbatim}
      CHARACTER * ( DAT__SZLOC ) LOC
      INTEGER OFFSET

      ...

      CALL NDF_XLOC( INDF, 'IRAS', 'READ', LOC, STATUS )
      CALL CMP_GET0I( LOC, 'OFFSET', OFFSET, STATUS )
      CALL DAT_ANNUL( LOC, STATUS )
\end{verbatim}
\normalsize

Note that the extension locator LOC must be annulled using the routine
DAT\_ANNUL when it is no longer required, since the NDF\_ system will not 
perform this task itself. 

This process of reading a scalar value from a component within an NDF
extension is sufficiently common that a set of routines is provided to do it
directly. 
These routines have names of the form NDF\_XGT0x, where the (lower-case)
``x'' represents one of the standard Fortran~77 types and should be replaced
by I, R, D, L or C, according to the type of value required. 
For instance, the above operation of reading an integer value from an `IRAS'
extension could also be performed with a single call to NDF\_XGT0I, as
follows: 

\small
\begin{verbatim}
      CALL NDF_XGT0I( INDF, 'IRAS', 'OFFSET', OFFSET, STATUS )
\end{verbatim}
\normalsize

\subsection{Creating New Extensions}

New extensions are created by calling the routine NDF\_XNEW and specifying
the extension name together with its HDS type and shape. 
For instance:

\small
\begin{verbatim}
      CHARACTER * ( DAT__SZLOC ) LOC

      ...

      CALL NDF_XNEW( INDF, 'IRAS', 'IRAS_EXTENSION', 0, 0, LOC, STATUS )
\end{verbatim}
\normalsize

would create a new scalar `IRAS' extension with an HDS type of
`IRAS\_EXTENSION' and return a locator for it via the LOC argument.
In practice, extensions will almost always be scalar HDS structures, but
this routine allows for other possibilities if required. 
An error will result if the named extension already exists. 

Once an extension structure has been created, components may be created
within it and values assigned to them using HDS routines, as before.
For instance, to create and assign a value of 30.5 to a real component
called ANGLE in a newly-created `IRAS' extension, the following calls might
be used: 

\small
\begin{verbatim}
      CHARACTER * ( DAT__SZLOC ) LOC
      REAL ANGLE

      ...

      CALL NDF_XNEW( INDF, 'IRAS', 'IRAS_EXTENSION', 0, 0, LOC, STATUS )
      CALL CMP_MOD( LOC, 'ANGLE', '_REAL', 0, 0, STATUS )
      CALL CMP_PUT0R( LOC, 'ANGLE', 30.5, STATUS )
      CALL DAT_ANNUL( LOC, STATUS )
\end{verbatim}
\normalsize

Here, the call to CMP\_MOD ensures that the required ANGLE component exists,
creating it if necessary.
CMP\_PUT0R then assigns a value to it. 
The extension locator LOC must be annulled when it is no longer required,
since the NDF\_ system will not perform this task. 

Again, this process of creating a scalar component within an NDF extension
and writing a value to it is sufficiently common that a set of routines is
provided to do it directly. 
In this case, the routines have names of the form NDF\_XPT0x, where the
(lower-case) ``x'' should be replaced by I, R, D, L or C, according to the
type of value being written. 
The above operation of writing a real value into a component of an `IRAS'
extension can therefore be performed with a single call to NDF\_XPT0R, as
follows: 

\small
\begin{verbatim}
      CALL NDF_XPT0R( ANGLE, INDF, 'IRAS', 'ANGLE', STATUS )
\end{verbatim}
\normalsize

\subsection{Accessing Array Information in Extensions}
\label{ss:extnarrays}

It is relatively common to store quite large amounts of information in NDF
extensions and this may include arrays whose size and shape matches that of the
main NDF {\em data}\ array itself. In this case, the close association between
the NDF\_ routines and the ARY\_ library (SUN/11) provides a number of
convenient features for accessing this information.

For example, suppose that an astronomical instrument produces data in NDF format
and also produces a measure of (say) temperature for each pixel of the NDF. This
temperature information might conveniently be stored as an array within an NDF
extension, so that it is available during data reduction. The ARRAY data
structure which is handled by the ARY\_ routines (a primitive HDS array is an
example) would be convenient for this purpose since it also allows arbitrary
pixel-index bounds, which may be chosen to match those of the associated NDF.

To access the temperature information, we could use the techniques discussed
above to locate the array within its extension and then to import it into the
ARY\_ system. This system provides analogous facilities to the NDF\_ routines
except that it applies to ARRAY data structures. In particular, the ARY\_MAP
routine may be used to obtain mapped access to an array, so that the process of
accessing the temperature data might be as follows:

\small
\begin{verbatim}
*  Obtain a locator to the extension.
      CALL NDF_XLOC( INDF, 'INSTR_EXTN', 'READ', LOC, STATUS )

*  Find the array within the extension.
      CALL ARY_FIND( LOC, 'TEMPERATURE', IARY, STATUS )

*  Map the array for access.
      CALL ARY_MAP( IARY, '_REAL', 'READ', PNTR, EL, STATUS )

      <access the mapped array values>

*  Clean up.
      CALL ARY_ANNUL( IARY, STATUS )
      CALL DAT_ANNUL( LOC, STATUS )
\end{verbatim}
\normalsize

Here, the integer value IARY is an ARY\_ system identifier, analogous to an NDF
identifier.

A more convenient method of achieving the same result would be to call the
routine NDF\_XIARY, which combines the process of locating the extension and
finding the array into a single call, as follows:

\small
\begin{verbatim}
      CALL NDF_XIARY( INDF, 'INSTR_EXTN', 'TEMPERATURE', 'READ', IARY, STATUS )
      CALL ARY_MAP( IARY, '_REAL', 'READ', PNTR, EL, STATUS )

      <access the mapped array values>

      CALL ARY_ANNUL( IARY, STATUS )
\end{verbatim}
\normalsize

An additional advantage of this latter method is that NDF\_XIARY will check
whether the NDF identifier refers to an NDF section and will, if necessary, 
select a matching section from the temperature array (for a discussion of NDF
sections, see \S\ref{ss:ndfsections}).

\subsection{Deleting Extensions}

Specific extensions may be deleted from an NDF using the routine NDF\_XDEL.
For instance:

\small
\begin{verbatim}
      CALL NDF_XDEL( INDF, 'IRAS', STATUS )
\end{verbatim}
\normalsize

would delete the `IRAS' extension, if present, together with its contents.
No error would result if the extension did not exist. 

\subsection{Enumerating an NDF's Extensions}

The routine NDF\_STATE may be used to determine whether an NDF contains any 
extensions by specifying a component name of `Extension'.
Thus:

\small
\begin{verbatim}
      LOGICAL STATE

      ...

      CALL NDF_STATE( INDF, 'Extension', STATE, STATUS )
\end{verbatim}
\normalsize

will return a .TRUE.\ value via the STATE argument if one or more extensions 
are present in the NDF.
The actual number of extensions present can be determined using the routine
NDF\_XNUMB. 
For instance:

\small
\begin{verbatim}
      INTEGER NEXTN

      ...

      CALL NDF_XNUMB( INDF, NEXTN, STATUS )
\end{verbatim}
\normalsize

will return the number of extensions via the NEXTN argument.
The names of any extensions present can also be obtained, in this case 
using the routine NDF\_XNAME.
For instance:

\small
\begin{verbatim}
      CHARACTER * ( NDF__SZXNM ) XNAME
      INTEGER N

      ...

      CALL NDF_XNAME( INDF, N, XNAME, STATUS )
\end{verbatim}
\normalsize

will return the name of the N'th extension in upper-case via the XNAME
argument. 
A blank name will be returned if no such extension exists. 
Note the use of the NDF\_\_SZXNM symbolic constant (defined in the include
file NDF\_PAR) to declare the size of the character string which is to
receive the extension name. 

As an example, the following loop will list the names of all the extensions
in an NDF: 

\small
\begin{verbatim}
      NEXTN = 0
      CALL NDF_XNUMB( INDF, NEXTN, STATUS )
      DO 1 I = 1, NEXTN
         CALL NDF_XNAME( INDF, I, XNAME, STATUS )
         CALL MSG_SETC( 'NAME', XNAME )
         CALL MSG_OUT( 'NAME', '^NAME', STATUS )
1     CONTINUE
\end{verbatim}
\normalsize


\section{ARRAY COMPONENT STORAGE FORM}
\label{ss:storageform}

\subsection{General}

An NDF data structure allows for the possibility of storing the values of 
its array components in a variety of different ways within the underlying 
data system HDS.
The reasons for this are various, but have to do with maintaining
compatibility with previous data formats and optimising disk space or access
time for certain kinds of information.
The options are described in SGP/38, where they correspond with the various
{\em variants\/} of the ARRAY structure, which is one of the building-blocks
from which an NDF is constructed. 

In the present document, the terminology has been changed slightly.
In particular, the term {\em storage form\/} is used in preference to {\em 
variant\/} to avoid possible confusion with {\em variance}, although the 
meaning is unchanged.

\subsection{Obtaining the Storage Form}

The storage form of an NDF array component may be determined using the 
routine NDF\_FORM.
For instance:

\small
\begin{verbatim}
      INCLUDE 'NDF_PAR'
      CHARACTER * ( NDF__SZFRM ) FORM

      ...

      CALL NDF_FORM( INDF, 'Data', FORM, STATUS )
\end{verbatim}
\normalsize

will return the storage form of an NDF's {\em data\/} component as an upper-case 
character string via the FORM argument.
Note how the symbolic constant NDF\_\_SZFRM (defined in the include file 
NDF\_PAR) should be used to declare the size of the character variable which 
is to receive the returned storage form information.

The storage form is established when an NDF is first created (see
\S\ref{ss:creatingndfs}).
At present there is no way of explicitly changing it, but in some
circumstances it may be changed implicitly (see \S\ref{ss:implicitformchange}). 
At present, only two storage forms are supported, so only the values
`SIMPLE' and `PRIMITIVE' can be returned by NDF\_FORM. 
These are described below.

\subsection{Simple Storage Form}
\label{ss:simpleform}

In this form of storage, the values of an NDF's array component 
are stored in their simplest possible form, {\em i.e.}\ as a sequence of
pixels in an N-dimensional array with (optionally) a similar imaginary
component. 
This, together with other ancillary information is held in a single ARRAY
structure within HDS. 

There are no special restrictions on the use of {\em simple\/} arrays and most
applications will not need to be aware of the use of this storage form. 

\subsection{Primitive Storage Form}
\label{ss:primitiveform}
\label{ss:implicitformchange}

This storage form is provided primarily to maintain compatibility with
previous data formats. 
In this case, the array's values are held as a sequence of pixels in an
N-dimensional array, but in a {\em primitive\/} HDS object. 
This means that no ancillary information can be associated with such a
component and this imposes a number of restrictions on the properties of
such arrays: 

\begin{itemize}

\item
The lower pixel-index bounds of all dimensions of an NDF in which primitive
arrays are used must be equal to 1 (strictly, this only applies to {\em
base\/} NDFs, since any NDF {\em sections\/} derived from them may still have
arbitrary lower bounds -- see \S\ref{ss:creatingsections}). 

\item
Primitive array components cannot hold complex values.

\item
The {\em bad\/}-pixel flag for primitive arrays is always regarded as .TRUE.\
in the case of an NDF's {\em data\/} and {\em variance\/} components. 

\end{itemize}

In most situations, these restrictions are unimportant and {\em primitive\/}
storage form may be used to maintain compatibility with existing datasets
and software. 
In the longer term, it is expected that a gradual transition will take
place, replacing {\em primitive\/} arrays by equivalent {\em simple\/} arrays
and this latter approach should be taken by all new software.
However, there is usually little harm in creating NDFs with {\em
primitive\/} array components, because any change made to the NDF which
would violate one of the restrictions above will cause any affected {\em
primitive\/} array component to implicitly change its storage form to become
{\em simple}. 
This is a straightforward change which costs little, and a subsequent call
to NDF\_FORM will show if this has occurred. 
Only one possible complication may arise: if the array is mapped for access
when its storage form is implicitly changed, then an error will result. 
This is unlikely to be a problem in practice.

\paragraph{Warning -- possible pitfall:} A case which occasionally causes
problems can arise if a {\em primitive\/} NDF is created ({\em e.g.}\ by
calling NDF\_CREP -- see \S\ref{ss:crep}) and an array component is then
mapped for access using an access mode such as `WRITE/ZERO'. 
This access mode will cause the component's {\em bad}-pixel flag to be set
to .FALSE.\ (see \S\ref{ss:mappinginteract}). 
When the component is unmapped, this, in turn, will cause its storage form
to be implicitly converted to {\em simple}. 

This behaviour is correct, but it is not always what is expected, or wanted.
It can be avoided by setting the {\em bad}-pixel flag value back to .TRUE.\
(see \S\ref{ss:settingbadpixflag}) before unmapping the component concerned,
or by performing the initialisation to zero explicitly rather than via an
initialisation option on the mapping mode. 


\section{ACCESSING NDFS FOR OUTPUT}

\subsection{Using Existing NDFs}

An NDF data structure which is to be used for output from an application can
be obtained in a number of ways. 
Most simply, an existing NDF may be acquired by using the NDF\_ASSOC routine
(\S\ref{ss:associnput}) and specifying `UPDATE' or `WRITE' access (in both the
call to the routine and the associated ADAM interface file). 
New values, or new components, may then be added to the NDF, as in the
following simple example which obtains a new value for an NDF's {\em title\/}
component: 

\small
\begin{verbatim}
      SUBROUTINE TITLE( STATUS )
      INTEGER STATUS, INDF

      IF ( STATUS .NE. SAI__OK ) RETURN
      CALL NDF_ASSOC( 'OUT', 'UPDATE', INDF, STATUS )
      CALL NDF_CINP( 'TITLE', INDF, 'Title', STATUS )
      CALL NDF_ANNUL( INDF, STATUS )
      END
\end{verbatim}
\normalsize

The same principle would also be used to write a new NDF {\em data\/}
component by mapping it for `WRITE' access and assigning new values to its
pixels, as described in \S\ref{ss:writingandmodifying}. 

Note that `UPDATE' access has been used used here in the call to NDF\_ASSOC
because we want other NDF components to retain their previous values. 
If `WRITE' access had been specified, then the NDF's components would have
been automatically reset to an undefined state, as the NDF\_ system
interprets this access mode as a request to {\em re-\/}write the data
structure. 

\subsection{Creating New NDFs via the ADAM Parameter System}
\label{ss:creatingndfs}

An alternative method of obtaining an NDF for output is to create an
entirely new one. 
The NDF\_CREAT routine will perform this task.
For instance:

\small
\begin{verbatim}
      INTEGER NDIM, LBND( NDIM ), UBND( NDIM )

      ...

      CALL NDF_CREAT( 'OUT', '_REAL', NDIM, LBND, UBND, INDF, STATUS )
\end{verbatim}
\normalsize

will create a new NDF and associate it with the ADAM parameter `OUT'.
A similar ADAM interface file entry to that in \S\ref{ss:associnput} would
be required, except that `WRITE' access would be specified in this case. 

This example will create a {\em simple, real\/} NDF; {\em i.e.}\ one whose
{\em data\/} and {\em variance\/} components will be stored as `\_REAL'
arrays, and whose array components will have a storage form of `SIMPLE' (see
\S\ref{ss:simpleform}). 
Its dimensionality and pixel-index bounds are specified by the NDIM, LBND
and UBND arguments. 
Initially, all its components will be in an undefined state.

\subsection{Conditional NDF Creation}
\label{ss:exist}

It is sometimes necessary to determine whether an NDF exists before deciding
to create a new one. 
The routine NDF\_EXIST is provided to allow this by associating an existing
NDF with an ADAM parameter and returning an NDF identifier for it, if it
exists. 
If the NDF does not exist, then no error results, but the routine returns
with a ``null'' identifier value of NDF\_\_NOID (defined in the include file
NDF\_PAR). 
In effect, this routine behaves identically to NDF\_ASSOC, except that if
the NDF does not exist, control is returned to the calling routine rather
than re-prompting the user to supply a new name. 
The following illustrates how NDF\_EXIST might be used:

\small
\begin{verbatim}
      INCLUDE 'NDF_PAR'

      ...

      CALL NDF_EXIST( 'OUT', 'UPDATE', INDF, STATUS )
      IF ( INDF .EQ. NDF__NOID ) THEN
         CALL NDF_CREAT( 'OUT', '_INTEGER', NDIM, LBND, UBND, INDF, STATUS )
      END IF
\end{verbatim}
\normalsize

Here, an existing NDF is accessed if it exists, otherwise a new structure
is created and used instead. 

\subsection{Creating Primitive NDFs}
\label{ss:crep}

The routine NDF\_CREP is provided for creating {\em primitive\/} NDFs; {\em 
i.e.}\ NDFs whose array components will have a storage form of `PRIMITIVE'.
NDF\_CREAT should normally be used to create a new NDF, but use of NDF\_CREP
may sometimes be necessary in order to maintain compatibility with existing
software (see \S\ref{ss:primitiveform}). 
Because of the restrictions inherent in the primitive form of array storage,
the lower pixel-index bounds of primitive NDFs must be set to 1 in all
dimensions, so NDF\_CREP lacks the LBND argument of NDF\_CREAT, the
appropriate lower bounds being assumed: 

\small
\begin{verbatim}
      CALL NDF_CREP( 'OUT', '_REAL', NDIM, UBND, INDF, STATUS )
\end{verbatim}
\normalsize

Its use is otherwise identical to NDF\_CREAT.


\section{COMPONENT PROPAGATION}
\label{ss:propagate}

\subsection{General}

New output NDFs may also be generated by a process termed {\em propagation},
in which a new structure is created based on an existing {\em template\/} NDF.
This is the most common method of creating an NDF to contain output from a
processing algorithm, and is typically used whenever an application draws
input from one or more NDFs and produces a new output NDF as a result. 

As far as the user of such applications is concerned, the output dataset
would typically be based upon one of the input datasets; {\em i.e.}\ it might
inherit its shape and component type, storage form and possibly values from
an input dataset.\footnote{Where there is more than one input NDF, one of
them should be designated the {\em primary\/} input dataset and be used as the
template for the output dataset. By convention, this should be the first
input NDF acquired by the application and the first to be described in
documentation.} 
Of course, the output data structure would also incorporate whatever changes
the processing algorithm is designed to perform. 

Seen from within such an application, the purpose of propagation is to
create a ``skeleton'' output NDF based on an input structure, but containing
``blank'' ({\em i.e.}\ undefined) components into which calculated results
can be inserted. 
Usually, there will also be ``non-blank'' ({\em i.e.}\ defined) components
in the newly-created NDF, which derive their values directly, without
change, from one of the input datasets. 
Such components are said to have been {\em propagated}.

The way in which components (and extensions) are selected for propagation is
central to the philosophy of the NDF and it is important to understand the 
principles if you are to write applications which process NDFs consistently.
There are two sets of {\em propagation rules\/} which apply separately to
standard NDF components and to extensions. 
The distinction between them is explained in the following two sections,
after which the way in which these ideas are implemented in practice using 
NDF\_ routines is described. 

\subsection{Propagation Rules for Standard NDF Components}
\label{ss:propstandard}

Because the meaning and interpretation of the standard NDF components ({\em
data}, {\em variance}, {\em quality}, {\em etc.}) is well-defined, it is always
possible to decide into which of three categories each of these components falls
when writing an application. 
This then dictates the action which should be taken, as follows:

\begin{enumerate}

\item {\bf Process it.}
{\em Any component which an application is capable of processing must be
processed in such a way that its validity is maintained.} 

\small
\begin{quote}
For instance, if an operation is to be performed on the {\em data\/} component,
then an appropriate operation must usually also be performed on the {\em
variance\/} component (if defined) so that it continues to represent the variance
of the data in the output NDF.
If the application cannot perform the necessary operation, then any
component which would become invalid as a result falls into category 3
below (and is simply ignored).
\end{quote}
\normalsize

\item {\bf Propagate it.}
{\em Any components which will not be rendered invalid by the processing
can be propagated without change.}

\small
\begin{quote}
For instance, the special case of adding a constant to the {\em data\/} component
would not render the {\em variance\/} component invalid. 
It may therefore simply be propagated ({\em i.e.}\ copied) to the output NDF 
unchanged.
Most applications which perform pixel-to-pixel processing and do not change 
the shape of an NDF can also propagate the {\em axis\/} and {\em quality\/}
components in the same way. 
\end{quote}
\normalsize

\item {\bf Ignore it.}
{Any remaining components whose subsequent validity is in any doubt
\underline{must} be ignored, \underline{never} propagated.} 

\small
\begin{quote}
It may not be possible to ensure that some NDF components will retain their 
validity after processing.
This may simply be because an application (or perhaps an entire software
package) chooses not to support certain NDF components; this is quite
acceptable behaviour.
Alternatively, the meaning of certain components may be destroyed by certain
types of processing; for instance the validity of the {\em quality\/} component
cannot possibly survive a Fourier transform operation applied to the {\em data\/}
component no matter how sophisticated the software.
In either case, the affected component(s) must be ignored and not 
propagated.
This means that they will be lost from the output NDF.

\end{quote}
\normalsize

\end{enumerate}

The purpose of these rules is to ensure that the validity of all the
standard NDF components is retained throughout all stages of processing, and
that all defined components in an NDF always have valid values. 
If an application cannot guarantee this for any component, then it must
ignore that component so that it remains undefined in the output data 
structure.

\subsection{Propagation Rules for Extensions}

The propagation of extensions is necessarily different from the propagation of 
standard NDF components, because only certain pieces of software may
recognise any particular extension.
There is therefore no way in which other applications can judge whether the
processing they are performing will render the information in the extension
invalid. 
This is an unavoidable consequence of extensibility.

Rather than taking a pessimistic view and automatically deleting all
unrecognised extensions, propagation of extensions proceeds along more
optimistic lines, as follows: 

\begin{enumerate}

\item {\bf Process it.}
{\em If an application recognises an extension, and can process it, then it
should ensure that its validity is maintained.} 

\small
\begin{quote}
For instance, an application in a software package which recognised an
`IRAS' extension should always check for the existence of such an extension
and ensure that its contents were not invalidated by the processing it
performs, making changes to the extension to achieve this if necessary. 
\end{quote}
\normalsize

\item {\bf Suppress it.}
{\em If an application recognises an extension but cannot process it, then 
propagation should be suppressed.}

\small
\begin{quote}
For instance, an application may recognise an extension but be unable to 
ensure its continued validity after processing, either due to a limited 
implementation or more fundamental causes.
In either event, the application should suppress propagation of that 
extension so that it is lost from the output data structure.
\end{quote}
\normalsize

\item {\bf Propagate it.}
{\em Any extension which is not recognised will be propagated by default.} 

\small
\begin{quote}
There may be any number of extensions present in an NDF which a particular 
application does not recognise.
These should be ignored, and the default action of the NDF\_ system will 
then be to propagate ({\em i.e.}\ copy) them to the output NDF.
\end{quote}
\normalsize


\end{enumerate}

The purpose of these rules is to ensure that extension information is always
retained unless it is certain that it will no longer be valid.
This contrasts with the rules for processing standard NDF components
(\S\ref{ss:propstandard}) which are retained only if it is certain that they
will still be valid. 

Of course, the rules for propagating extensions carry the risk that an
application which does not recognise an extension will inadvertently render
it invalid.
However, if all applications within a software package recognise the same
extension(s), then this can only happen if software from several packages is
intermixed. 
It then becomes the user's responsibility to check the validity of
information held in extensions. 

\subsection{Creating New NDFs by Propagation}
\label{ss:prop}

Fortunately, the rules above are far easier to apply in practice than they
might appear, and typically amount simply to deciding which NDF components
(or extensions) will not need any processing performed on them.
These components are then propagated and any that remain (and which the
application chooses to support) are then processed. 
All others are ignored.

Propagation is performed by the routine NDF\_PROP, which creates a new NDF
structure via the ADAM parameter system based on a template NDF which
already exists. 
At the same time, it will selectively copy components and extensions present
in the template structure and use them to initialise the corresponding
components (and extensions) in the new NDF. 
For example:

\small
\begin{verbatim}
      CALL NDF_PROP( INDF1, ' ', 'OUT', INDF2, STATUS )
\end{verbatim}
\normalsize

will create a new output NDF, associate it with the ADAM parameter `OUT' and
return an identifier for it via the INDF2 argument. 
The new NDF is based on the template structure with identifier INDF1, and
inherits its shape and the type and storage form of its components.
Subsequent changes may be applied to any of these inherited attributes if
required, {\em e.g.}\ by calling NDF\_STYPE to change the numeric type of any
of the new NDF's array components (see \S\ref{ss:stype}). 

\subsection{Default Propagation of Components and Extensions}

The 2nd (CLIST) argument to NDF\_PROP specifies a list of
components and extensions which are to have their values propagated ({\em 
i.e.}\ copied) to initialise the new NDF. 
The default (blank) value specified above causes all extensions, together
with the {\em title}, {\em label\/}\ and {\em history\/} components to be
propagated, if present. 
These three standard components are considered ``safe'', in that they are
likely to retain their validity through most common types of processing
which takes place on NDFs. 

Note, however, that no {\em axis}, {\em data}, {\em variance}, {\em quality\/}
or {\em units\/} information will be propagated by default. 
This allows an application to explicitly process these components to
generate new versions for the output structure if possible, or simply to
ignore them and have them omitted from the output NDF if the necessary
processing cannot be performed. 

\subsection{Forcing Component Propagation}

If you are certain that a component will not be rendered invalid by the
processing which an application performs (for instance the addition of a
constant to the {\em data\/} component would leave the {\em axis}, {\em
quality\/} and {\em variance\/} components valid), then propagation of these
components can be specified by listing them in the CLIST argument to
NDF\_PROP, thus: 

\small
\begin{verbatim}
      CALL NDF_PROP( INDF1, 'Axis,Qual,Var', 'OUT', INDF2, STATUS )
\end{verbatim}
\normalsize

These components would then be copied to the output NDF and would not need
to be explicitly considered again by the application. 

\subsection {Inhibiting Component Propagation}

Conversely, if any of the standard NDF components which are propagated by
default would be rendered invalid by the processing an application performs,
then propagation may be inhibited by specifying the component name with the
prefix `NO' in the CLIST argument to NDF\_PROP. 
For instance:

\small
\begin{verbatim}
      CALL NDF_PROP( INDF1, 'Quality,NoLab', 'OUT', INDF2, STATUS )
\end{verbatim}
\normalsize

would force propagation of the {\em quality\/} component, but inhibit the
default propagation of the {\em label\/} component. 

\subsection{Controlling Propagation of Extensions}

Propagation of specific extensions may also be inhibited by specifying
`NOEXTENSION()' in the CLIST argument to NDF\_PROP and listing the
extensions to be omitted between the parentheses. 
For instance:

\small
\begin{verbatim}
      CALL NDF_PROP( INDF1, 'Axis,Noext(IRAS,ASTERIX)', 'OUT', INDF2, STATUS )
\end{verbatim}
\normalsize

would force propagation of the {\em axis\/} components, but inhibit the
propagation of any `IRAS' or `ASTERIX' extension which may be present. 
Note that `NOEXTENSION' may be abbreviated but extension names must appear 
in full, although mixed case is permitted.

This mechanism can be useful if an extension may contain a large amount of
information but is not required in the output data structure. 
The alternative (of propagating the extension, then deleting it) is less
efficient and may lead to an unnecessarily large output file. 


\section{NDF SECTIONS}
\label{ss:ndfsections}

\subsection{The Need for NDF Sections}

An important facility provided by the NDF\_ system is the ability to select
a region from an NDF which differs in shape from the original NDF, and to
process it as if it were a complete NDF itself. 
Such regions are termed {\em NDF sections}.
As a simple example, consider a routine which plots a contour map of an
NDF's {\em data\/} component. 
By accessing an appropriate NDF section, the same routine could also be used
to contour only a subset of the data without having to make any change to
the routine itself.

This ability to concentrate on a subset of an NDF can clearly improve
efficiency in many circumstances, but NDF sections are also capable of
referring to {\em super-sets\/} of NDFs; {\em i.e.}\ they may extend beyond the
bounds of the NDF from which they are derived. 
This gives them a number of further uses through their ability to match the
shapes of NDFs of otherwise unequal extent by effectively trimming or
padding them with {\em bad\/} pixels. 
Their use for this type of operation is discussed more fully in 
\S\ref{ss:mbnd}.

\subsection{Creating NDF Sections}
\label{ss:creatingsections}

An NDF section may be created using the routine NDF\_SECT.
For instance:

\small
\begin{verbatim}
      INTEGER NDIM, LBND( NDIM ), UBND( NDIM )

      ...

      CALL NDF_SECT( INDF1, NDIM, LBND, UBND, INDF2, STATUS )
\end{verbatim}
\normalsize

will create an NDF section starting from an NDF with identifier INDF1, and
will return a new identifier INDF2 which refers to the section. 
The set of pixels in the original NDF to which the new section should refer
is determined by the arguments NDIM, LBND and UBND.

However, these arguments not only specify the set of original pixels to
which the new section should refer, but also directly determine the {\em
shape\/} ({\em i.e.}\ the pixel-index bounds and the dimensionality) of the new
section. 
For instance, a call to NDF\_BOUND using the new identifier INDF2 would 
return the same values as had originally been specified in the call to
NDF\_SECT.\footnote{Users familiar with HDS should note the distinction
between the HDS concept of {\em slicing}, in which the pixel indices of an
array slice always start at (1,1\ldots), and the use of {\em sections\/} from
NDFs, where the pixel indices of the original NDF are preserved in any
derived section.} 

\subsection{The Distinction between Base NDFs and Sections}

An NDF identifier which refers to an entire NDF dataset (not just a section
of it) is said to refer to a {\em base\/} NDF.
A base NDF represents a data structure whose shape and other attributes are
uniquely defined. 
Any changes made to the attributes of a base NDF are reflected by actual
changes to the contents of the data file in which the NDF is stored. 
Any such changes are also immediately apparent through any other base NDF
identifiers which refer to the same structure (multiple identifiers for the
same structure can be generated by means of the routine NDF\_CLONE for
instance). 

In contrast, an NDF section simply represents a ``window'' into a base NDF. 
Any number of identifiers may refer to sections derived from the same base
NDF, but each represents a separate window.
As a consequence, the {\em shapes\/} of all NDF sections are completely
independent and may be altered, if required, without affecting each other. 
One consequence of this is that the NDF\_CLONE routine, when applied to an
NDF section, has the effect of producing a duplicate NDF {\em section\/}
rather than simply a duplicate NDF {\em identifier}. 

It is possible to discover if an identifier refers to a base NDF or to an
NDF section using the routine NDF\_ISBAS. 
For instance:

\small
\begin{verbatim}
      CALL NDF_ISBAS( INDF, ISBAS, STATUS )
\end{verbatim}
\normalsize

will return a logical value of .TRUE.\ via the ISBAS argument if the
identifier INDF refers to a base NDF. 
It is also possible to obtain an identifier for the base NDF to which an NDF
section refers by using the routine NDF\_BASE, thus: 

\small
\begin{verbatim}
      CALL NDF_BASE( INDF1, INDF2, STATUS )
\end{verbatim}
\normalsize

However, this routine should be used sparingly because it tends to subvert
the program modularity which the use of NDF sections allows, and permits
access to regions of the base NDF which a well-structured application perhaps
ought not to be touching. 

\subsection{Referring to Subsets and Super-sets}
\label{ss:selectingsupersets}

In describing how to create an NDF section in \S\ref{ss:creatingsections},
there was an implicit assumption that the pixel-index bounds of the section
lay within the bounds of the NDF from which it was derived, and that the
section's dimensionality also matched that of the original NDF. 
In fact, neither of these restrictions need apply.

First consider the case where the dimensionality of the initial NDF and the
derived section are the same, but the new pixel-index bounds extend outside
those of the original NDF.
This would be the case if an NDF section with shape:

\small
\begin{quote}
\begin{center}
(1:256, 1:512)
\end{center}
\end{quote}
\normalsize

were to be created from an original NDF with shape:

\small
\begin{quote}
\begin{center}
(0:511, 10:300)
\end{center}
\end{quote}
\normalsize

In this case the section refers to a {\em subset\/} of the pixels along the
first dimension but a {\em super-set\/} of the pixels along the second
dimension. 
As a consequence, there are some pixels in the new section which do not
exist in the original NDF. 

When values are read from an array component of such a section, the NDF\_
system will respond by {\em padding\/} the original NDF with {\em bad\/} pixels;
{\em i.e.}\ by assigning the appropriate {\em bad\/}-pixel value to all the
``new'' pixels which did not exist in the original NDF. 
The value of the {\em bad\/}-pixel flag returned for the new section by the 
routine NDF\_BAD would reflect the presence of these {\em bad\/} pixels.

\subsection{The Transfer Window}

The set of pixels which lie within the bounds of a base NDF and also within
the bounds of a section derived from it is termed the {\em transfer window\/}
for that section. 
This transfer window comes into play when new values are assigned to the
section's pixels. 
Although new values may be assigned to any of these pixels, only those lying
within the transfer window will have their values transferred back to the
base NDF to cause a permanent change to the data structure. 
The transfer takes place when access to a mapped array component of a
section is relinquished ({\em e.g.}\ by calling NDF\_UNMAP), at which point
all pixel values outside the transfer window are discarded. 

This process is similar in concept to the ``viewport'' used in many graphics
systems where, typically, a program can plot lines at any point, but only
those lying within the viewport will actually appear on the screen ({\em
i.e.}\ plotting done outside the viewport is ``clipped''). 
Using this analogy, an NDF section would correspond with the plotting space
available to a program, the transfer window would correspond with the
viewport, and the base NDF would correspond with the plotting screen. 

Note that it is quite permissible for an NDF section to be derived from
another NDF section without any restriction on their relative pixel-index
bounds. 
In this case, the transfer windows of both sections will be combined, so
that no new section can access a larger region of the associated base NDF
than the section from which it is derived. 
In extreme cases this could result in the transfer window for a section
becoming non-existent, in which case the section will no longer have any
contact with its base NDF, although it will still be a valid section. 

\subsection{Changing Dimensionality}
\label{ss:changingdimensionality}

Now consider the case where the number of dimensions specified for a new NDF
section differs from the dimensionality of the NDF from which it is derived.
The NDF\_ system will handle this in the same way that all dimensionality
mis-matches are handled; {\em i.e.}\ by padding the pixel-index bounds with
1's as necessary. 

For example, suppose a 1-dimensional section with shape:

\small
\begin{quote}
\begin{center}
(3:10)
\end{center}
\end{quote}
\normalsize

were to be derived from a 2-dimensional NDF with shape:

\small
\begin{quote}
\begin{center}
(1:20, 1:20)
\end{center}
\end{quote}
\normalsize

In this case, the 1-dimensional shape would first be padded with 1's to 
become:

\small
\begin{quote}
\begin{center}
(3:10, 1:1)
\end{center}
\end{quote}
\normalsize

which identifies the pixels to which the new section should refer.
The additional 1's will then be discarded before the section is created so
that a 1-dimensional section results. 
A similar process would take place if the relative dimensionalities were
reversed, but it would then be the original NDF's pixel-index bounds which
were padded with 1's in order to identify the pixels to which the section
should refer. 

There are no restrictions on the creation of sections of any dimensionality
up to the maximum of 7 supported by the NDF\_ routines.
Changes of dimensionality may also be freely combined with the selection of
super-sets (see \S\ref{ss:selectingsupersets}).

\subsection{Restrictions on the Use of Sections}
\label{ss:sectionrestrictions}

In general, an identifier for an NDF section can be passed without error to
any routine which will accept an equivalent identifier referring to a base
NDF. 
In certain cases, however, the behaviour of the routine may differ slightly
when an NDF section is supplied in order to adhere to two guiding
principles: 

\begin{enumerate}

\item
It should be straightforward to write applications which process NDFs without
having to know whether the NDFs concerned are base NDFs or NDF sections. 
Having written such an application, it should be able to process either without
modification. 

\item
Applications which access NDF sections should not generally cause changes to the
values of NDF pixels which lie outside the pixel-index bounds (or more
accurately the transfer window) of the sections they are processing. 

\end{enumerate}

The set of operations affected by these principles is rather small because
most NDF components ({\em e.g.}\ {\em label}, {\em units}, {\em title}, {\em
history\/} and {\em extensions\/}) are regarded as {\em global\/} and are equally
accessible via identifiers referring to NDF sections and base NDFs. 
It is mainly operations on array components which behave differently when
applied to NDF sections, and notably those which affect the attributes of
these components. 
For instance, the numeric type of an NDF array component cannot be changed
using NDF\_STYPE (\S\ref{ss:stype}) via a section identifier; instead, this
routine will simply return without action. 
Neither may an NDF be deleted (\S\ref{ss:delet}) via a section identifier.

These, and other differences, are noted in the appropriate routine
descriptions in Appendix~\ref{ss:routinedescriptions} and at other relevant
points in this document. 

\subsection{Restrictions on Mapped Access to Sections}

The restrictions described in \S\ref{ss:restrictionsonmapping} concerning
multiple mapped access to NDF array components also apply to NDF sections if
there is a possibility of an access conflict occurring. 
Thus, if two NDF sections refer to the same base NDF, but the regions to
which they refer (more precisely their transfer windows) intersect, then only
one of these sections may be mapped at any time for write or update access
to the same array component.

If necessary, an application can determine if such a conflict may occur by
using the routine NDF\_SAME. 
For instance:

\small
\begin{verbatim}
      LOGICAL SAME, ISECT

      ...

      CALL NDF_SAME( INDF1, INDF2, SAME, ISECT, STATUS )
\end{verbatim}
\normalsize

will return a .TRUE.\ value via the SAME argument if the two NDF identifiers 
supplied refer to the same base NDF, and will also return a .TRUE.\ result 
via the ISECT argument if their transfer windows intersect.

\subsection{More Advanced Use: Partitioning}
\label{ss:partitioning}

In times gone by, when computers had little memory, it was common for
image-processing applications to read their data one line at a time, and
to operate on that line before passing on to the next. Nowadays, there
is little need for this approach and the programming complications it
causes, because reasonably-sized images can be accommodated entirely in
memory.

Nevertheless, limitations on the available memory can still be important in some
situations. For instance, when processing extremely large files, it is still
possible to find that the memory available (or the memory quota allocated by
your system manager) is insufficient. Even when it appears possible to
accommodate a large array in memory, it is wise to remember that with a {\em
virtual memory\/} operating system the information may not actually reside in
the physical memory of the computer, and this may result in substantial
inefficiencies.

This sort of consideration can be ignored for most types of work, but
steps must sometimes be taken to reduce the amount of memory required
when accessing large NDFs. This will often result in improvements in
efficiency even if actual memory limitations are unimportant, because a
reduction in memory requirements in general tends to make more memory
available for other system activities, which therefore run more
efficiently.

To allow memory usage to be limited, the NDF\_ system provides
facilities for partitioning NDFs so that they may be processed in
pieces. Two partitioning methods are available, termed {\em chunking\/}
and {\em blocking}. {\em Chunking\/} is appropriate when the NDF can be
regarded simply as a 1-dimensional sequence of values ({\em i.e.\/} when
the actual shape is unimportant) while {\em blocking\/} is used if the
shape and positional relationship between the pixels is significant.
Both of these techniques work by dividing an NDF into sections, and they
are described in turn below.

Note that these techniques may also have applications in parallel
processing, where it is often necessary to partition a large array and
then to pass the resulting pieces to separate processors.

\subsection{Chunking}

The technique of {\em chunking\/} is best introduced by an example.
Consider a large \mbox{1-dimensional} NDF (a spectrum, perhaps) which is
to be processed in pieces in order to limit memory usage, and suppose
that the maximum size of one of these pieces is to be 10000 pixels. The
spectrum can be divided into pieces for processing by creating a section
to refer to each piece. Each of these sections should follow on from the
previous one, and each should contain 10000 pixels (except the last one,
which may be smaller if the total number of pixels is not an exact
multiple of 10000). Each of these sections is termed a {\em chunk}.

If we want to process each of these {\em chunks\/} in turn, we need to
know how many there are, and to have a method of creating the
appropriate sections. The NDF\_ system provides these facilities through
the routines NDF\_NCHNK (which determines the number of {\em chunks\/}
available) and NDF\_CHUNK (which creates sections referring to
successive {\em chunks\/}). The following illustrates how these routines
might be used:

\small
\begin{verbatim}
      INTEGER ICHUNK, ICH, MXPIX, NCHUNK
      PARAMETER ( MXPIX = 10000 )

      ...

*  Determine the number of chunks available.
      CALL NDF_NCHNK( INDF, MXPIX, NCHUNK, STATUS )

*  Loop through the chunks, creating a section to refer to each one.
      DO 1 ICHUNK = 1, NCHUNK
         CALL NDF_CHUNK( INDF, MXPIX, ICHUNK, ICH, STATUS )

         <access the resulting section/chunk>

*  Annul the section identifier.
         CALL NDF_ANNUL( ICH, STATUS )
 1    CONTINUE
\end{verbatim}
\normalsize

Here, MXPIX is set equal to the maximum number of pixels which a {\em
chunk\/} is to contain, and NDF\_NCHNK is then called to determine how
many such {\em chunks\/} are available in the NDF (the result is
returned {\em via\/} the NCHUNK argument). The routine NDF\_CHUNK is then
called repeatedly to create a sequence of NDF sections which refer to
each {\em chunk\/} in turn. These {\em chunks\/} are specified by the
{\em chunk index\/} ICHUNK, which varies from 1 to NCHUNK. The NDF
identifier for each section created by NDF\_CHUNK is annulled when it is
no longer required.

In the 1-dimensional case (as here), this process of {\em chunking\/} is
straightforward, and could have been programmed directly without too
much difficulty. However, in the N-dimensional case (with N~$>$~1), the
number of pixels in each NDF section ({\em chunk\/}) must be the product
of N separate dimension sizes. Thus, not all sizes of {\em chunk\/} are
available. In addition, each {\em chunk\/} must fit within the bounds of
the NDF from which it is derived. As a result, the size and shape of
each {\em chunk\/} returned by NDF\_CHUNK may vary (although the sequence of
{\em chunks\/} generated is always repeatable if several NDFs with the same
shape are processed using the same value of MXPIX).

The purpose of {\em chunking\/} is to divide an NDF into pieces, each of which
contains {\em contiguous\/} pixels ({\em i.e.}\ pixels whose storage locations
in the NDF follow one after the other) with the {\em chunks\/} themselves also
following each other contiguously in pixel-storage order.\footnote{The pixels
will be contiguously stored whenever a base NDF is partitioned into {\em
chunks}. However, an NDF section may also be partitioned in the same way. In
this case, the resulting ``{\em chunked\/}'' pixels will only be truely
contiguous if they were stored contiguously in the original NDF section.}
NDF\_CHUNK will accomplish this for any shape of NDF, and for any limit on the
maximum number of pixels in a {\em chunk}. Thus, by appropriately defining
MXPIX, a limit can be set on memory usage regardless of the total size of NDF
being processed.

In fact, by setting MXPIX to certain special values it is possible to partition
an NDF into {\em chunks\/} of pre-determined shape. For instance, if MXPIX is
set equal to the first dimension size, then NDF\_CHUNK will step through the NDF
one ``line'' at a time. Similarly, if MXPIX is set to the product of the first
two dimension sizes, then NDF\_CHUNK will step through each ``plane'' of a
3-dimensional stack of images. The following example shows how this might be
used to apply a smoothing algorithm to each image in a 3-dimensional stack
without needing to access the entire NDF at once:

\small
\begin{verbatim}
*  Obtain the input NDF shape and set MXPIX.
      CALL NDF_DIM( INDF, NDF__MXDIM, DIM, NDIM, STATUS )
      MXPIX = DIM( 1 ) * DIM( 2 )

*  Create the output NDF, using the input NDF as a template.
      CALL NDF_PROP( INDF1, ' ', 'OUT', INDF2, STATUS )

*  Determine the number of chunks (i.e. image planes) and loop through
*  them.
      CALL NDF_NCHNK( INDF1, MXPIX, NCHUNK, STATUS )
      DO 1 ICHUNK = 1, NCHUNK

*  Start a new NDF context and create sections for the input/output
*  image planes.
         CALL NDF_BEGIN
         CALL NDF_CHUNK( INDF1, MXPIX, ICHUNK, ICH1, STATUS )
         CALL NDF_CHUNK( INDF2, MXPIX, ICHUNK, ICH2, STATUS )

*  Access the data.
         CALL NDF_MAP( ICH1, 'Data', '_REAL', 'READ', PNTR1, EL, STATUS )
         CALL NDF_MAP( ICH2, 'Data', '_REAL', 'WRITE', PNTR2, EL, STATUS )

         <perform the smoothing operation>

*  End the NDF context.
         CALL NDF_END( STATUS )
 1    CONTINUE
\end{verbatim}
\normalsize

Note the use of an NDF context to simplify ``cleaning up'' after processing
each {\em chunk}.


\subsection{Blocking}

The concept of {\em blocking\/} is similar to {\em chunking}, except
that it is appropriate when the relative positions of pixels within an
NDF are significant. In one dimension, {\em chunking\/} and {\em
blocking\/} are equivalent, so a 2-dimensional example is required for
illustration.

Suppose that a contour map of a very large \mbox{2-dimensional} image is
to be generated, and that the image must be divided into pieces to limit
memory usage. {\em Chunking\/} would not be appropriate here, because
(depending on its shape) a {\em chunk\/} might work out to be a single
line of the image, and this would result in inefficient contouring.
Rather then setting an upper limit on the total size of each piece, what
we need to limit here is the size of each dimension. This means
that we must ``tile'' the 2-dimensional image with a series of adjacent
rectangular regions, each of which does not exceed a certain size in
each dimension, and each of which can be contoured in turn. This form of
partitioning is what {\em blocking\/} provides, the ``tiles'' (in N
dimensions) being termed {\em blocks}.

{\em Blocking\/} is supported by two routines analogous to those
provided for {\em chunking}. NDF\_NBLOC calculates the number of {\em
blocks\/} available in an NDF (for given limits on the dimension sizes),
while NDF\_BLOCK creates the NDF sections which refer to the individual
{\em blocks}, each of which is identified by a {\em block index}. The
following illustrates the principle:

\small
\begin{verbatim}
      INTEGER IBLOCK, IBL, MXDIM( 2 ), NBLOCK
      DATA MXDIM / 100, 100 /

      ...

*  Determine the number of blocks available.
      CALL NDF_NBLOC( INDF, 2, MXDIM, NBLOCK, STATUS )

*  Loop through the blocks, creating a section to refer to each one.
      DO 1 IBLOCK = 1, NBLOCK
         CALL NDF_BLOCK( INDF, 2, MXDIM, IBLOCK, IBL, STATUS )

         <contour the resulting section/block>

*  Annul the section identifier.
         CALL NDF_ANNUL( IBL, STATUS )
 1    CONTINUE
\end{verbatim}
\normalsize

In this 2-dimensional example, each {\em block\/} is constrained so as not to
exceed 100 pixels in size in each dimension, these limits being specified in the
MXDIM array.

Note that {\em blocking\/} generates sections which lie adjacent to one another,
rather than being contiguously stored, as is the case with {\em chunking}. {\em
Blocks\/} are numbered so that their lower/upper bounds increase in the
conventional sense with increasing {\em block index\/} ({\em i.e.}\ with the
first dimension bound increasing most rapidly and the last bound increasing
least rapidly). As with {\em chunking}, the size of each {\em block\/} generated
by NDF\_BLOCK may vary in order to lie within the original NDF (using the
``tiling'' analogy, there may be some tiles at the edges which must be ``cut''
to fit), but the sequence of {\em blocks\/} generated is always repeatable.

By supplying special values to NDF\_BLOCK for the MXDIM value of each
dimension, it is also possible to step through an NDF in {\em blocks\/}
of a pre-determined shape (as with {\em chunking\/}). For instance, if
the integer array DIM holds the original NDF dimensions, then the
assignment:

\small
\begin{verbatim}
      MXDIM( 1 ) = DIM( 1 )
\end{verbatim}
\normalsize

could be used to step through an image in ``lines'', while the
assignment:

\small
\begin{verbatim}
      MXDIM( 1 ) = DIM( 1 )
      MXDIM( 2 ) = DIM( 2 )
\end{verbatim}
\normalsize

would step through a 3-dimensional image stack in ``planes''. The assignment:

\small
\begin{verbatim}
      MXDIM( 1 ) = 1
      MXDIM( 2 ) = DIM( 2 )
\end{verbatim}
\normalsize

could also be used to step through an image in ``columns'', but note
that this non-sequential mode of access may not be efficient.


\section{USER-ACCESS TO NDF SECTIONS}
\label{ss:usersections}

As well as providing the programmer with facilities to access sections, the
NDF\_ system also allows the user of NDF applications to specify sections (both
subsets and super-sets) when giving the names of NDF data structures to be
processed. To see how this works, consider an application which requests access
to an NDF data structure as follows:

\small
\begin{verbatim}
      CALL NDF_ASSOC( 'IN', 'READ', INDF, STATUS )
\end{verbatim}
\normalsize

and suppose this results in a prompt asking for the name of an NDF:

\small
\begin{verbatim}
   IN - Input NDF data structure > NAME
\end{verbatim}
\normalsize

If you were to respond simply with the name of an HDS object (denoted here by
NAME), then NDF\_ASSOC would return a base NDF identifier for the specified data
structure via its INDF argument. However, if a set of subscripts is also
supplied, thus:

\small
\begin{verbatim}
   IN - Input NDF data structure > NAME(3:256,-8:4)
\end{verbatim}
\normalsize

then NDF\_ASSOC will return an identifier for the specified NDF section
instead.

This process may be applied only when calling NDF\_ASSOC or NDF\_EXIST to access
a pre-existing data structure, but in practice this covers nearly all cases of
interest. An NDF section may be specified in this way in any situation where an
NDF name alone would suffice ({\em e.g.\/} on the command line, or as a default
in an interface file, {\em etc.}).

\subsection{Specifying Lower and Upper Bounds}

The subscript expression appended to an NDF name to specify a section may be
given in several ways. One possible method (corresponding with the example
above) is to give the lower and upper bounds in each dimension, as follows:

\small
\begin{quote}
\begin{center}
{\tt NAME( a:b, c:d, ... )}
\end{center}
\end{quote}
\normalsize

where `{\tt a:b}', `{\tt c:d}' ({\em etc.}) specify the lower and upper bounds.
The bounds specified need not necessarily lie within the actual bounds of the
NDF, because {\em bad\/} pixels will be supplied in the usual way, if required,
to pad out the NDF's array components whenever they are accessed. However, none
of the lower bounds should exceed the corresponding upper bound.

Omitting any of the bounds from the subscript expression will cause the
appropriate (lower or upper) bound of the NDF to be used instead. If the
separating `:' is also omitted, then the lower and upper bounds of the section
will both be set to the same value, so that a single pixel will be selected for
that dimension. Omitting the bounds entirely for a dimension (but still
retaining the comma) will cause the entire extent of that dimension to be used.
Thus,

\small
\begin{quote}
\begin{center}
{\tt IMAGE(,64)}
\end{center}
\end{quote}
\normalsize

could be used to specify row 64 of a 2-dimensional image, while:

\small
\begin{quote}
\begin{center}
{\tt CUBE( 1, 257:, 100 )}
\end{center}
\end{quote}
\normalsize

would specify column 1, pixels 257 onwards, selected from plane number
100 of a 3-dimensional ``data cube''.
Note that specifying:

\small
\begin{quote}
\begin{center}
{\tt IMAGE(,)}
\end{center}
\end{quote}
\normalsize

is just another way of referring to an entire image, except that it actually
generates a {\em section\/} containing all the NDF's pixels.

\subsection{Specifying Centre and Extent}

An alternative form for the subscript expression involves specifying the centre
and extent of the region required along each dimension, as follows:

\small
\begin{quote}
\begin{center}
{\tt NAME( p}$\sim${\tt q, r}$\sim${\tt s, ... )}
\end{center}
\end{quote}
\normalsize

where `{\tt p}$\sim${\tt q}', `{\tt r}$\sim${\tt s}', ({\em etc.}) specify the
centre and extent. Thus,

\small
\begin{quote}
\begin{center}
{\tt NAME(100}$\sim${\tt 11,200}$\sim${\tt 5)}
\end{center}
\end{quote}
\normalsize

would refer to an 11~x~5 pixel region of an image centred on pixel (100,~200).

If the value before the delimiting `$\sim$' is omitted, it will default to the
index of the central pixel in that dimension (rounded downwards if there are an
even number of pixels). If the value following the `$\sim$' is omitted, it will
default to the number of pixels in that dimension. Thus,

\small
\begin{quote}
\begin{center}
{\tt IMAGE( }$\sim${\tt 100, }$\sim${\tt 100)}
\end{center}
\end{quote}
\normalsize

could be used to refer to a 100~x~100 pixel region located centrally within an
image, while

\small
\begin{quote}
\begin{center}
{\tt IMAGE( 10}$\sim${\tt , 20}$\sim$ {\tt )}
\end{center}
\end{quote}
\normalsize

would specify a section which is the same size as the original image, but
displaced so that it is centred on pixel (10,~20).

\subsection{Using Axis Coordinates to Specify Sections}
\label{ss:axissections}

A further variation is that numerical values in subscript expressions may be
specified either as integers, in which case they refer to pixel indices, or as
floating-point numbers,\footnote{Here, a floating-point number is one containing
a decimal point and/or an exponent. Double precision arithmetic is used to
process these values, but either double- or single-precision notation may be
used when supplying them.} in which case they refer to {\em axis\/} coordinates
(for a description of {\em axis\/} coordinates, see \S\ref{ss:axiscoordinates}).
Both linear and non-linear {\em axis\/} coordinates are supported, the values
supplied being automatically converted into the corresponding pixel indices
before use. For instance:

\small
\begin{quote}
\begin{center}
{\tt SPECTRUM(6500.0:7250.0)}
\end{center}
\end{quote}
\normalsize

could be used to select the appropriate region of a spectrum calibrated
in Angstroms, while:

\small
\begin{quote}
\begin{center}
{\tt SPECTRUM(5500.0}$\sim${\tt 21)}
\end{center}
\end{quote}
\normalsize

would select a 21-pixel wide region of the spectrum centred on 5500.0
Angstroms.

\subsection{Changing Dimensionality}

The number of dimensions given when specifying an NDF section need not
necessarily correspond with the actual number of NDF dimensions, although
usually it will do so.

If fewer dimensions are specified than there are NDF dimensions, then any
unspecified bounds will be set to (1:1) for the purposes of identifying the
pixels to which the section should refer. Conversely, if extra dimensions are
given, then the shape of the NDF will be padded with extra bounds set to (1:1)
in order to match the number of dimensions. In all cases, the resulting section
will have the number of dimensions actually specified by the user, the padding
serving only to identify the pixels to which the section should refer.

This process corresponds exactly to that which takes place {\em via\/} the
programming interface when NDF\_SECT is called (see
\S\ref{ss:changingdimensionality}).

\subsection{Mixing Bounds Expressions}

In the last example (in \S\ref{ss:axissections}) both {\em axis\/} coordinates
and pixel indices were mixed in the same subscript expression. In fact, any of
the features described earlier may be combined when specifying an NDF section,
the only restriction being that when the shape of the resulting section is
expressed in pixel indices, the lower bound must not exceed the upper bound in
any dimension. Thus, all the following might be used as valid specifications for
NDF sections:

\small
\begin{quote}
\begin{center}
\begin{tabular}{l}
{\tt NDF(3.7)}\\
{\tt NDF(,5:)}\\
{\tt NDF(-77:13.8,,4)}\\
{\tt NDF(66}$\sim${\tt 9,4:17)}\\
{\tt NDF(}$\sim${\tt 5,6}$\sim${\tt )}\\
{\tt NDF(}$\sim${\tt ,:)}\\
{\tt NDF(5500.0}$\sim${\tt 150,)}\\
{\tt NDF(3.0}$\sim${\tt 1.5,-78.06D-3:13.0545,,,,)}\\
\end{tabular}
\end{center}
\end{quote}
\normalsize

Many other combinations are obviously possible.


\section{THE AXIS COORDINATE SYSTEM}
\label{ss:axiscoordinates}

This section describes the concepts which an NDF's {\em axis\/} coordinate
system represents.
The following section (\S\ref{ss:axiscomponents}) then goes on to consider
how to access an NDF's {\em axis\/} components, which hold information about
this coordinate system. 

\subsection{Pixel Coordinates}
\label{ss:pixelcoordinates}

Hitherto, an NDF has been considered simply as an N-dimensional array of
pixels, addressed by a set of pixel indices.
Since they are integer quantities, these indices cannot represent a
continuous coordinate system, although the information stored in an NDF will
almost always require that positions within it be describable to sub-pixel
accuracy. 
For example, a calculation to determine the centroid position of a star in a
2-dimensional image will inevitably give rise to a non-integer result, for
which a continuous ($x,y$) coordinate system will be required. 

There are a number of ways in which a continuous coordinate system can be
defined for a regular array of pixels. 
In the absence of other information, the Starlink convention is to use a
{\em pixel coordinate system\/} in which a pixel with indices ($i,j$) has
its centre at the position: 

\small
\begin{quote}
\begin{center}
($i-\frac{1}{2},j-\frac{1}{2}$)
\end{center}
\end{quote}
\normalsize

and is taken to be one unit in extent in each dimension.
Pixel (1,1) would therefore be centred at the position (0.5,0.5) and would
have its ``lower'' and ``upper'' corners located at positions (0.0,0.0) and
(1.0,1.0) respectively, as follows: 

\small
\begin{quote}
\begin{center}

\setlength{\unitlength}{1.0mm}
\begin{picture}(15,25)(0,-7.5)

\thicklines
\put(0,0){\line(1,0){10}}
\put(10,0){\line(0,1){10}}
\put(10,10){\line(-1,0){10}}
\put(0,10){\line(0,-1){10}}
\put(5,5){\circle*{0.7}}

\thinlines
\put(0,-4){\vector(0,1){3}}
\put(0,-5){\makebox(0,0)[tr]{(0.0,0.0)}}
\put(10,14){\vector(0,-1){3}}
\put(10,15){(1.0,1.0)}
\put(14,5){\vector(-1,0){8}}
\put(15,5){\makebox(0,0)[l]{(0.5,0.5)}}

\end{picture}
\end{center}
\end{quote}
\normalsize

This makes it possible to refer to fractional pixel positions---in this case
within a 2-dimensional array, although the principle can obviously be
extended to other numbers of dimensions. 

\subsection{Axis Coordinates}

The pixel coordinate system described above defines how to convert pixel
indices into a set of continuous coordinates and therefore introduces a
coordinate {\em axis\/} which runs along each dimension of the NDF, as
follows: 

\small
\begin{quote}
\begin{center}

\setlength{\unitlength}{0.65mm}
\begin{picture}(70,57)(-10,-7)

\multiput(10,10)(0,3){11}{\line(1,0){45}}
\multiput(10,10)(3,0){16}{\line(0,1){30}}
\put(32.5,43){\makebox(0,0)[b]{\scriptsize NDF Pixel Array}}

\thicklines
\put(0,0){\vector(1,0){60}}
\put(25,-5){\bf Axis 1}
\put(0,0){\vector(0,1){45}}
\put(0,48){\makebox(0,0)[b]{\bf Axis 2}}

\end{picture}
\end{center}
\end{quote}
\normalsize

The use of the pixel size to determine the units of these axes is rather
restrictive, however, and in practice we may want to use more realistic
physical units. 
This would allow a spectrum to be calibrated in wavelength, for instance, or
the output from a plate-measuring machine to be related to axes calibrated
in microns. 

Of course, the pixel coordinate system is only the default choice, and is 
intended to be used only in the absence of other information.
The NDF's {\em axis\/} components are designed to hold the extra information
needed to define more useful coordinate systems, so that realistic axes can
be associated with a NDF, along with {\em labels\/} and {\em units\/} for
these axes. 
The method used also allows for the possibility that an NDF's pixels may not
be square and that they may not be contiguous ({\em i.e.}\ that they may
have gaps between them, or may overlap) when their positions are expressed
in {\em axis\/} units. 
Statistical uncertainty in the pixel positions may also be represented, if 
present.

\subsection{Axis Arrays}
\label{ss:axisarrays}

To define the pixel coordinate system in \S\ref{ss:pixelcoordinates}, we
specified the location of each pixel by giving its {\em centre\/} position
and {\em width\/} on each {\em axis}. 
Thus, for a given dimension, the pixel {\em centre\/} position C was derived
from the corresponding pixel index $i$ according to the formula: 

\small
\begin{quote}
\begin{center}
$C(i)=i-\frac{1}{2}$
\end{center}
\end{quote}
\normalsize

and its {\em width\/} W was given by:

\small
\begin{quote}
\begin{center}
$W(i)=1$
\end{center}
\end{quote}
\normalsize

An NDF's {\em axis\/} coordinate system extends this idea by allowing each
of these {\em centre\/} and {\em width\/} functions to be determined by
values stored in a 1-dimensional array. 
These {\em axis arrays\/} then act as ``look-up tables'' which convert pixel
indices into pixel {\em centre\/} coordinates and {\em width\/} values on 
each {\em axis:}

\small
\begin{quote}
\begin{center}
\setlength{\unitlength}{0.65mm}
\begin{picture}(90,80)(-15,-15)

%  Pixel array with label above.
\multiput(20,20)(0,3){11}{\line(1,0){45}}
\multiput(20,20)(3,0){16}{\line(0,1){30}}
\put(42.5,53){\makebox(0,0)[b]{\scriptsize NDF Pixel Array}}

%  Axis 1 arrays.
\multiput(20,0)(0,3){6}{\line(1,0){45}}
\multiput(20,0)(3,0){16}{\line(0,1){3}}
\multiput(20,6)(3,0){16}{\line(0,1){3}}
\multiput(20,12)(3,0){16}{\line(0,1){3}}

%  Axis 1 array labels.
\put(68,12){\scriptsize $C_{1}$ --- {\em Centre}}
\put(68,6){\scriptsize $W_{1}$ --- {\em Width}}
\put(68,0){\scriptsize $V_{1}$ --- {\em Variance}}

%  Left brace grouping axis 1 arrays together.
\put(21,7.5){\makebox(0,0)[r]{$\left\{\rule{0mm}{5.7mm}\right.$}}

%  Axis 2 arrays.
\multiput(0,20)(3,0){6}{\line(0,1){30}}
\multiput(0,20)(0,3){11}{\line(1,0){3}}
\multiput(6,20)(0,3){11}{\line(1,0){3}}
\multiput(12,20)(0,3){11}{\line(1,0){3}}

%  Axis 2 array labels.
\put(0,53){\scriptsize $C_{2}$}
\put(6,53){\scriptsize $W_{2}$}
\put(12,53){\scriptsize $V_{2}$}

%  Under-brace grouping axis 2 arrays together.
\put(7.5,18){\makebox(0,0)[t]{$\underbrace{\rule{9.75mm}{0mm}}$}}

%  Axis array label.
\put(7.5,9.5){\makebox(0,0){\scriptsize Axis}}
\put(7.5,5.5){\makebox(0,0){\scriptsize Arrays}}

%  Axis vectors and labels.
\thicklines
\put(-10,-10){\vector(1,0){80}}
\put(25,-15){\bf Axis 1}
\put(-10,-10){\vector(0,1){65}}
\put(-10,58){\makebox(0,0)[b]{\bf Axis 2}}

\end{picture}
\end{center}
\end{quote}
\normalsize

This allows a wide range of possible coordinate systems to be accommodated. 
A third {\em axis variance\/} array is also provided as a look-up table to
convert pixel indices into {\em variance\/} estimates, which can be used to
represent any possible statistical uncertainty in a pixel's {\em centre\/}
position.

\subsection{Pixel Positions and Dimensions}

If C$_{n}$ and W$_{n}$ represent the {\em axis centre\/} and {\em width\/}
arrays for the n'th dimension of an NDF, then a pixel with index i in this
dimension has its {\em centre\/} at coordinate C$_{n}$(i) and has a {\em
width\/} of W$_{n}$(i) on the corresponding {\em axis}. 
It therefore extends along the {\em axis\/} from the point:

\small
\begin{quote}
\begin{center}
$C_{n}(i) - \frac{1}{2} W_{n}(i)$
\end{center}
\end{quote}
\normalsize

to the point:

\small
\begin{quote}
\begin{center}
$C_{n}(i) + \frac{1}{2} W_{n}(i)$
\end{center}
\end{quote}
\normalsize

In two dimensions the central ($x,y$) coordinate of a pixel with indices
($i,j$) would therefore be given by: 

\small
\begin{quote}
\begin{center}
$(x,\: y) = (\: C_{1}(i),\: C_{2}(j) \: )$
\end{center}
\end{quote}
\normalsize

and its size would be: 

\small
\begin{quote}
\begin{center}
$\Delta x \: \times \: \Delta y = W_{1}(i) \: \times \: W_{2}(j)$
\end{center}
\end{quote}
\normalsize

The {\em axis variance\/} array is used to represent any statistical
uncertainty in a pixel's {\em centre\/} position and hence in the position
of the pixel as a whole.\footnote{There is no corresponding provision for
recording any uncertainty in a pixel's {\em width}.} 
Like the NDF's main {\em variance\/} component (\S\ref{ss:stddev}), its
values are estimates of the mean squared error in the pixel's position, so
the value which would normally be quoted as the positional uncertainly (or
used to plot error bars) is the square root of this value. 
{\em Axis variance\/} arrays may also be accessed directly as standard
deviation values if required (see \S\ref{ss:axisstddev}). 

\subsection{Default Axis Array Values}
\label{ss:axisdefaults}

An important feature of each {\em axis\/} array is a set of default values
which serve to define the {\em axis\/} coordinate system in the absence of
complete information. 
In the simplest case ({\em i.e.}\ no information), this reduces to the pixel
coordinate system discussed in \S\ref{ss:pixelcoordinates}. 
The following describes how default values are obtained for each {\em
axis\/} array: 

\begin{description}

\item[Centre:]
If values are required for an {\em axis centre\/} array and none have been
provided, then its values are set equal to $i-\frac{1}{2}$, where $i$ is the
pixel's index in the relevant dimension. 
Thus, if an NDF had pixel-index bounds (3:10) in a particular dimension, the
default {\em axis centre\/} array values for this dimension would be:

\small
\begin{quote}
\begin{center}
2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5
\end{center}
\end{quote}
\normalsize

\item[Width:]
If values are required for an {\em axis width\/} array and none have been
defined, then its values are derived from the corresponding {\em axis
centre\/} array by forming differences between the {\em centre\/}
coordinates of the neighbouring pixels, {\em i.e.}\ the default {\em 
width\/} values are obtained as follows:\footnote{If either of the
neighbouring {\em centre\/} values does not exist (because the pixel is at
the end of the array) then it is replaced by C$_{n}(i)$ and the
$\frac{1}{2}$ in the formula is dropped. If neither neighbour exists
(because the NDF's dimension size is 1) then the {\em width\/} value is set
to unity. 
Note that the default {\em centre\/} array values will be used if none have
been defined, and this will also result in {\em width\/} values of unity.} 

\small
\begin{quote}
\begin{center}
$W_{n}(i) = \frac{1}{2} |C_n(i+1) - C_{n}(i-1)|$
\end{center}
\end{quote}
\normalsize

This means that the default pixel {\em widths\/} match the local average
spacing between pixel {\em centres\/}, which is usually appropriate. 
Note, however, that this does not guarantee that the pixels will be
contiguous ({\em i.e.}\ that their edges will meet exactly) except in cases
where the pixel {\em centres\/} are uniformly spaced (see
\S\ref{ss:contiguouspixels}). 

\item[Variance:]
If no {\em axis variance\/} array values have been defined, then they
default to zero, implying no uncertainty in the pixel {\em centre\/}
positions. 

\end{description}

\subsection{Contiguous and Non-Contiguous Pixels}
\label{ss:contiguouspixels}

It is important to note that the meanings attached to an NDF's {\em axis\/}
arrays are defined rather precisely. 
In particular, note that the {\em axis centre\/} array specifies the
position of the \underline{geometrical} {\em centre\/} of a pixel, {\em
i.e.}\ the mid-point between its edges, so that a pixel will always extend
by an equal amount on either side of this position. 

The edges of adjacent pixels will therefore only meet exactly ({\em i.e.}\
there will be no overlap or gap) if their {\em centre\/} and {\em width\/}
values are related in the correct way. 
To be precise, adjacent pixels with indices $i$ and $i+1$ must have {\em 
centre\/} positions separated by half the sum of their {\em widths\/} if
they are to be contiguous along a particular {\em axis}, so that: 

\small
\begin{quote}
\begin{center}
$|C_{n}(i+1) - C_{n}(i)| = \frac{1}{2} [W_{n}(i+1) + W_{n}(i)]$
\end{center}
\end{quote}
\normalsize

With contiguous pixels (the normal case), this means that the {\em axis 
centre\/} and {\em width\/} arrays are not independent.
In fact, either could be derived from the other to within a constant,
but since this constant cannot be found without additional information,
it is often necessary to store both arrays. 
However, an important exception occurs if the pixel {\em centres\/} are
evenly spaced, because a convenient method then exists of deriving the {\em
width\/} array from the {\em centre\/} array so that contiguous pixels
always result.
This is the method used to generate default {\em axis width\/} values when
necessary (\S\ref{ss:axisdefaults}). 

To avoid any potential ambiguity about the interpretation of {\em axis\/}
array values and whether an NDF's pixels should be considered contiguous or
not, the following recommendations are given about the information which
should be stored in {\em axis\/} arrays: 

\begin{itemize}

\item If the default NDF pixel coordinate system is satisfactory, then it
should be used and no {\em axis\/} coordinate information should be defined.
In this case the pixels will always be contiguous.

\item Otherwise, if the pixel {\em centres\/} are evenly spaced, then...

\begin{itemize}

\item If the pixels are contiguous, the {\em axis centre\/} array should be
assigned values but the associated {\em width\/} array may be left
undefined. 

\item If the pixels are not contiguous, both the {\em axis centre} and {\em
width\/} arrays should be assigned values. 

\end{itemize}

\item Otherwise, if the pixel {\em centres\/} are un-evenly spaced, then
both the {\em axis centre\/} and {\em width\/} arrays should always be
assigned values. 

\end{itemize}

\subsection{Processing Axis Array Values}

The method by which NDF {\em axis\/} arrays are processed should also
reflect their meanings, as defined above. 
By way of illustration, suppose that a transformation of {\em axis\/} values
is to be performed, so that each {\em axis\/} coordinate is converted to a
new value by means of some non-linear function. 
Rather than simply applying this function to calculate new pixel {\em
centre\/} locations from the old ones, the correct procedure is to transform
the pixel edge locations and to derive new {\em centre\/} positions from
these, as follows: 

\begin{enumerate}

\item Obtain the relevant pixel {\em centre\/} and {\em width\/} arrays,
accepting their default values if necessary. 

\item From these, calculate the positions of the edges of each pixel.

\item Transform the edge positions using the non-linear transformation 
function.

\item Calculate new pixel {\em centre\/} positions (mid-way between the new
edge positions) and store them in the NDF's {\em axis centre\/} array. 

\item Calculate associated pixel {\em width\/} values (from the difference
in the pixel edge positions). 
Since the pixel {\em centres\/} will now be non-uniformly separated, these
new {\em width\/} values should also be stored in the NDF's {\em axis
width\/} array. 

\item If {\em axis variance\/} array values are available, then these should
be propagated through the transformation function using the usual
error-propagation formulae. 

\end{enumerate}

This procedure is necessary to ensure that the pixels remain contiguous 
(or non-contiguous, if appropriate) and that the new {\em centre\/}
positions lie mid-way between the new pixel edge locations. 
Furthermore, the operations above can all be reversed if necessary to
recover the original {\em axis\/} array values. 

\subsection{Axis Normalisation}
\label{ss:axisnormalisation}

One aspect of the {\em axis\/} coordinate system which has not yet been
discussed is the property of {\em axis normalisation}, which is indicated by
a logical {\em normalisation flag\/} associated with each {\em axis}. 
This flag does not affect the interpretation of the {\em axis\/} information
itself, but instead determines how the NDF's {\em data\/} and {\em
variance\/} arrays should behave when the associated {\em axis\/}
information is modified. 

If the normalisation flag for an NDF {\em axis\/} is set to .TRUE., then it
indicates that the NDF's {\em data} values (and by implication its {\em
variance\/} values) are {\em normalised\/} to the pixel {\em width\/} values
for that {\em axis\/}. 
To give an example, suppose that a spectrum contains {\em data\/} values
representing energy accumulated per unit of wavelength, with each pixel
having a known spread in wavelength. 
In this case, the sum of each pixel's {\em data\/} value multiplied by its
{\em width\/} will give the total energy in any part of the spectrum. 
This is an important property which may need to be retained if the {\em axis
width\/} values are altered for any reason ({\em e.g.}\ to apply an
instrumental correction, or to allow for red-shift). 

The {\em axis\/} normalisation flag indicates whether this type of
normalisation should be preserved.
If it is set to .TRUE., and the associated {\em axis width\/} values are
modified, then each NDF {\em data\/} value should be multiplied by an
appropriate factor so that its {\em data\/} $\times$ {\em width\/} product
remains unchanged.
If present, the {\em variance\/} values should also be corrected by
multiplying by the square of this factor. 
In cases where more than one {\em axis\/} normalisation flag is set to
.TRUE., the correction factors for each {\em axis\/} must be applied in
turn. 

If all the {\em axis\/} normalisation flags are set to .FALSE.\ (the default
situation), then no changes to the {\em data\/} or {\em variance\/}
components will be necessary if the {\em axis width\/} values are modified. 


\section{AXIS COMPONENTS}
\label{ss:axiscomponents}

\subsection{Overview of an NDF's Axis Components}

Information about an NDF's {\em axis\/} coordinate system is stored in its
{\em axis components}, which are conveniently categorised as follows: 

\small
\begin{quote}
\begin{center}
\begin{tabular}{rl@{ --- }l}
{\em Axis character components:} & LABEL & Axis labels \\
                                 & UNITS & Axis units \\[1.5ex]
    {\em Axis array components:} & CENTRE & Pixel centre coordinates \\
                                 & WIDTH  & Pixel width values \\
                                 & VARIANCE & Variance estimates for pixel
                                              positions
\end{tabular}
\end{center}
\end{quote}
\normalsize

As with the main components of an NDF, the names of these {\em axis\/}
components are significant,\footnote{Note that the name ``CENTRE'' used by
the NDF\_ routines to refer to an NDF's {\em centre\/} component differs
from the actual name of the HDS object in which it is stored, which is
``DATA\_ARRAY''.} since they are used by the NDF\_ routines to identify the
component(s) to which certain operations should be applied. 
{\em Axis\/} component names are specified in the same way as those of the
main components of an NDF, including the use of abbreviations, mixed case
and comma-separated lists where appropriate (see
\S\ref{ss:componentnamespec} for details). 

Access to an {\em axis\/} component must also specify the number of the NDF
{\em axis} to be used.
This is normally an integer lying between 1 and the number of NDF
dimensions, but many routines will also accept a value of zero, indicating
that an operation is to be applied to \underline{all} of an NDF's {\em
axes}. 
This additional item of information means that a separate set of routines
must be provided for accessing {\em axis\/} components. 
Nevertheless, many of the principles described in earlier sections for
accessing other NDF components are also applicable here, so the descriptions
given below are relatively brief.
References to more complete descriptions are given where appropriate. 

The following describes the purpose and interpretation of each {\em axis\/}
component in slightly more detail. 

{\large \em Axis Character Components:}\nopagebreak
\begin{description}

\item[LABEL --] This is a character string, whose value is intended for 
general use for such things as labelling the axes of graphs or as a heading 
for columns in tabulated output; {\em e.g.}\ `Scanner X offset'.
There is a separate {\em axis label\/} value for each NDF dimension.

\item[UNITS --] This is a character string, whose value describes the 
physical {\em units\/} of the quantity measured along an NDF's {\em axis;\/}
{\em e.g.}\ `micron'. 
There is a separate {\em axis units\/} value for each NDF dimension.

\end{description}

{\large \em Axis Array Components:}\nopagebreak
\begin{description}

\item[CENTRE --] This is a 1-dimensional array which holds the
coordinates of the pixel {\em centres\/} as described in
\S\ref{ss:axisarrays}. The values in this array should either increase
or decrease monotonically with position in the array. There is a
separate 1-dimensional {\em axis centre\/} array for each dimension of
an NDF, whose size matches the size of the corresponding NDF dimension. 

\item[WIDTH --] This is a 1-dimensional array which holds a set of
non-negative {\em width\/} values for the NDF's pixels as described in
\S\ref{ss:axisarrays}.  There is a separate 1-dimensional {\em axis
width\/} array for each dimension of an NDF, whose size matches the
size of the corresponding NDF dimension. These {\em width} values
should be such that no point can lie inside more than two NDF pixels
simultaneously ({\em i.e.}\ although pixels are allowed to overlap with
their neighbours, they may not overlap with more distant pixels).

\item[VARIANCE --] This is a 1-dimensional array which holds a set of
non-negative\footnote{The NDF\_ system does not enforce this restriction at
present, but may do so in future.} {\em variance\/} estimates representing any
statistical uncertainty in the value of the corresponding pixel {\em centre\/}
coordinate, as described in \S\ref{ss:axisarrays}.  There is a separate
1-dimensional {\em axis variance\/} array for each dimension of an NDF, whose
size matches the size of the corresponding NDF dimension. 

\end{description}

\subsection{Axis Component States}

Like all NDF components, each {\em axis\/} component has a logical {\em
state\/} attribute associated with it which indicates whether or not it has
a previously-assigned value. 
The state of an {\em axis\/} component may be determined by using the routine
NDF\_ASTAT, specifying the component name and the number of the {\em axis\/}
about which information is required, as follows: 

\small
\begin{verbatim}
      INTEGER IAXIS
      LOGICAL STATE

      ...

      CALL NDF_ASTAT( INDF, 'Width', IAXIS, STATE, STATUS )
\end{verbatim}
\normalsize

In this example, a .TRUE. result would be returned via the logical STATE
argument if values had previously been assigned to the {\em width\/} array
of the {\em axis\/} identified by the IAXIS argument. 

Unlike other NDF components, no error will result from attempting to read
the value of an {\em axis\/} component while it is in an undefined state.
This is because the NDF\_ system will always supply a default value if
necessary. 
Thus, an {\em axis\/} component's state merely serves to indicate whether a
pre-assigned value will be used, as opposed to an internally-generated
default. 

NDF\_ASTAT will also accept a list of {\em axis\/} component names and will
return the logical ``AND'' of the results for all the specified components. 
An IAXIS value of zero may also be supplied and indicates that all the NDF's
axes should be considered at the same time. 
Thus, the single call:

\small
\begin{verbatim}
      CALL NDF_ASTAT( INDF, 'Label,Units', 0, STATE, STATUS )
\end{verbatim}
\normalsize

could be used to determine whether all the NDF's axes had
previously-assigned values for both their {\em label\/} and {\em units\/}
components. 

\subsection{Restrictions on Axis Component States}
\label{ss:axisstate}

In general, the logical state attribute of each {\em axis\/} component is
independent and may be manipulated freely. 
However, there is one notable and important exception to this: 

\begin{quote}
\begin{center}
{\em If any {\em axis\/} component is to be in a defined state, then the
{\em centre\/} arrays for \underline{all} the NDF's {\em axes} must also be 
defined}
\end{center}
\end{quote}

Thus, all an NDF's {\em axis centre\/} arrays behave as a single unit, and
it is a pre-requisite that all of these arrays should be in a defined state
before any other {\em axis\/} component may be assigned a value. 

Of course, it would be very inconvenient if values had to be explicitly
generated and assigned to all the {\em axis centre\/} arrays before any
other {\em axis\/} values could be defined, so the NDF\_ system has an
implicit mechanism for assigning default values to the {\em axis centre\/}
arrays whenever they are required ({\em i.e.}\ whenever any {\em axis\/}
component is assigned a value but the {\em axis centre\/} arrays are still
undefined). 
A routine is also provided to perform this task explicitly if required, and
is described in the next section. 

If an NDF's {\em axis centre\/} arrays are in a defined state, then the {\em
axis coordinate system\/} of the NDF as a whole is regarded as being
defined. 
Otherwise ({\em i.e.}\ if no {\em axis\/} components are defined at all),
then the {\em axis\/} coordinate system is undefined. 
The routine NDF\_STATE can be used to test whether or not an {\em axis\/}
coordinate system is defined by using a component name of `Axis', thus: 

\small
\begin{verbatim}
      CALL NDF_STATE( INDF, 'Axis', STATE, STATUS )
\end{verbatim}
\normalsize

A .TRUE. value will be returned via the logical STATE argument if the {\em 
axis\/} coordinate system is defined.

\subsection{Defining a Default Axis Coordinate System}
\label{ss:acre}

The routine NDF\_ACRE is provided to assign default values to all of an
NDF's {\em axis\/} arrays, thereby defining a default {\em axis\/}
coordinate system, as follows: 

\small
\begin{verbatim}
      CALL NDF_ACRE( INDF, STATUS )
\end{verbatim}
\normalsize

If the {\em axis\/} coordinate system is already defined, then all the {\em
axis centre\/} arrays will already have values, so this routine will return
without action. 
However, if this coordinate system (and hence each {\em axis centre\/}
array) is undefined, then NDF\_ACRE will assign default values to all the
{\em centre\/} arrays, effectively defining a default {\em axis\/}
coordinate system which is equal to the NDF's pixel coordinate system
(\S\ref{ss:pixelcoordinates}). 

After this operation, the values available from any of the NDF's {\em
axis\/} components will be unchanged.
This is because the NDF\_ system would provide these same {\em axis
centre\/} values as defaults in any case. 
Nevertheless, the definition of a default {\em axis\/} coordinate system is
a significant step because it effectively takes a ``copy'' of the current
pixel coordinate system. 
Any operation which subsequently changes the NDF's pixel indices ({\em
e.g.}\ the application of pixel-index shifts -- see \S\ref{ss:shift}) cannot
then affect the pixel {\em centre\/} values, whereas previously it would
have done. 

\subsection{Resetting Axis Components}

The {\em axis\/} coordinate system of an NDF may be reset by specifying the
component name `Axis' in a call to NDF\_RESET, as follows: 

\small
\begin{verbatim}
      CALL NDF_RESET( INDF, 'Axis', STATUS )
\end{verbatim}
\normalsize

This will cause all the NDF's {\em axis\/} components to become undefined,
so that subsequent attempts to read values from any of them will return
default values appropriate to the NDF's pixel coordinate system. 
A subsequent enquiry about the state of the `Axis' coordinate system using
NDF\_STATE would return a value of .FALSE.. 

The routine NDF\_AREST is also provided for resetting individual {\em
axis\/} components. 
Thus, a particular {\em axis variance\/} array could be reset as follows: 

\small
\begin{verbatim}
      CALL NDF_AREST( INDF, 'Variance', IAXIS, STATUS )
\end{verbatim}
\normalsize

and any subsequent attempt to read from it would result in the default
values being returned. 

A list of component names may also be supplied to NDF\_AREST, along with an
optional IAXIS value of zero to indicate that the resetting operation should
apply to all the NDF's axes at once. 
Thus, the following call:

\small
\begin{verbatim}
      CALL NDF_AREST( INDF, 'Wid,Var', 0, STATUS )
\end{verbatim}
\normalsize

would reset all of an NDF's {\em axis width\/} and {\em variance\/} arrays.

Note that a component name of `Centre' may not be supplied to
NDF\_AREST because all the {\em axis centre\/} arrays behave as a single 
unit and cannot be independently reset.
The only way to remove all {\em axis centre\/} information from an NDF is to
reset the entire {\em axis\/} coordinate system via a call to NDF\_RESET, as 
was done above.

\subsection{Accessing Axis Character Components}
\label{ss:acmsg}

The {\em axis label\/} and {\em units\/} components of an NDF are both
accessed via the same set of routines which behave in a similar manner to
those for accessing an NDF's main character components 
(\S\ref{ss:accessingcharcomponents}). 

The value of either of these {\em axis\/} components may be obtained by
means of the routine NDF\_ACGET, as follows: 

\small
\begin{verbatim}
      CHARACTER * ( 80 ) VALUE

      ...

      VALUE = 'Default label'
      CALL NDF_ACGET( INDF, 'Label', IAXIS, VALUE, STATUS )
\end{verbatim}
\normalsize

This will return the value of the specified component, if it is defined.
If its value is not defined and a non-blank default value has been set for
the VALUE argument beforehand (as here), then this default value will be
returned unchanged. 
However, if a blank VALUE string is provided, then the routine will generate
its own default if necessary, returning either the value `Axis n' for the
{\em axis label\/} component (where n is the axis number) or `pixel' for the
{\em axis units}.

If an {\em axis\/} character component value is to be used in constructing a
message, then it may be assigned directly to an MSG\_ message token by means
of the NDF\_ACMSG routine. 
Thus, a message showing the {\em label\/} and {\em units\/} values for a
particular NDF {\em axis\/} could be generated as follows: 

\small
\begin{verbatim}
      CALL NDF_ACMSG( 'LABEL', INDF, 'Label', IAXIS, STATUS )
      CALL NDF_ACMSG( 'UNITS', INDF, 'Units', IAXIS, STATUS )
      CALL MSG_OUT( 'MESSAGE', '^LABEL (^UNITS)', STATUS )
\end{verbatim}
\normalsize

Here, `LABEL' and `UNITS' are the names of message tokens (see SUN/104).

New values may be assigned to {\em axis\/} character components by using the
routine NDF\_ACPUT. 
For instance:

\small
\begin{verbatim}
      CALL NDF_ACPUT( 'Wavelength', INDF, 'Lab', 1, STATUS )
      CALL NDF_ACPUT( 'nm', INDF, 'Unit', 1, STATUS )
\end{verbatim}
\normalsize

would assign the {\em label\/} value `Wavelength' and the {\em units\/} value 
`nm' to {\em axis\/} 1 of an NDF.
Note that the entire character string will be assigned (including trailing
blanks if present) and the length of the component will be adjusted to match
the new value. 
A value of zero for the 4th (IAXIS) argument would cause the value to be
assigned to all of the NDF's axes. 

After a successful call to NDF\_ACPUT, the {\em axis\/} character
component's state becomes defined. 
So, also, does the NDF's {\em axis\/} coordinate system---this means that
default values will be assigned to all the NDF's {\em axis centre\/} arrays
if these were not previously defined. 
The effect of this is exactly the same as if the routine NDF\_ACRE
(\S\ref{ss:acre}) had been called immediately before the call to NDF\_ACPUT. 

The length of an {\em axis\/} character component ({\em i.e.}\ the number of
characters it contains) is determined by the last assignment made to it,
({\em e.g.}\ by NDF\_ACPUT) and may be obtained using the routine
NDF\_ACLEN. 
For instance:

\small
\begin{verbatim}
      INTEGER LENGTH

      ...

      CALL NDF_ACLEN( INDF, 'Units', IAXIS, LENGTH, STATUS )
\end{verbatim}
\normalsize

will return the number of characters in the specified {\em axis units\/}
component via the LENGTH argument.
If the component does not exist, then NDF\_ACLEN will return the number of
characters in the default value which would be returned by NDF\_ACGET under
these circumstances (see above). 

\subsection{Mapping Axis Arrays for Reading}

Access to {\em axis\/} array components takes place in much the same way as
access to the main array components of an NDF.
It also depends on the concept of {\em mapping}, as described in
\S\ref{ss:accessingarraycomponents}. 

The routine NDF\_AMAP provides mapped access to an {\em axis\/} array.
Thus, to read values from an NDF's {\em axis centre\/} array, the following 
call might be used:

\small
\begin{verbatim}
      INTEGER PNTR( 1 ), EL

      ...

      CALL NDF_AMAP( INDF, 'Centre', IAXIS, '_REAL', 'READ', PNTR, EL, STATUS )
\end{verbatim}
\normalsize

Here, a numeric type of `\_REAL' has been specified to indicate that an
array of single-precision values is required and the mapping mode of `READ'
indicates that values are to be read, but not modified. 
The routine returns an integer pointer to the mapped values via its PNTR
argument and a count of the number of elements mapped via its EL argument
(PNTR is actually a 1-dimensional array, so the pointer value in this
example will be returned in its first element). 
The value returned for EL will be equal to the size of the NDF dimension
being accessed.\footnote{Under error conditions a ``safe'' value of 1 will
be returned for EL, as discussed in \S\ref{ss:safedimensions}.} 
The mapped values may be accessed in the normal way by passing them to a
subroutine using the \%VAL facility (see \S\ref{ss:map}). 

If the {\em axis\/} array being accessed is in an undefined state, then a
set of default values will be returned (see \S\ref{ss:axisdefaults}).
Note that the mapping mode {\em initialisation options\/} available when
mapping the main NDF array components (\S\ref{ss:initialisationoptions})
cannot be applied to {\em axis\/} arrays. 

NDF\_AMAP will also accept a list of {\em axis\/} component names and will
map all of them in the same way ({\em i.e.}\ with the same type and mapping
mode). 
Pointers to each mapped array will be returned via the PNTR argument, which
must have sufficient elements to accommodate the returned values. 
The following example shows how access to all the {\em axis\/} arrays for a
particular NDF dimension could be obtained using this facility, and then
passed to another routine for processing: 

\small
\begin{verbatim}
      INTEGER PNTR( 3 ), EL

      ...

      CALL NDF_AMAP( INDF, 'Cent,Width,Var', IAXIS, '_DOUBLE', 'READ', PNTR, EL,
     :               STATUS )
      CALL DOAXIS( EL, %VAL( PNTR( 1 ) ), %VAL( PNTR( 2 ) ), %VAL( PNTR( 3 ) ),
     :             STATUS )
\end{verbatim}
\normalsize

Note that it is not possible to map {\em axis\/} arrays for all the {\em
axes\/} of an NDF in a single call to NDF\_AMAP, because each would require
a different value of EL to be returned. 
An IAXIS value of zero is therefore not permitted when calling NDF\_AMAP. 

\subsection{Unmapping Axis Arrays}

When access to an {\em axis\/} array is complete, it should be {\em
unmapped\/} in the usual way (\S\ref{ss:map}) and there are a number of
methods by which this can be done. 
Most simply, the cleaning-up action of NDF\_END (\S\ref{ss:beginend}) may be
relied upon to annul an NDF identifier and to unmap any mapped arrays
associated with it as part of this process (\S\ref{ss:implicitunmapping}). 
This will correctly deal with any {\em axis\/} arrays which may be mapped. 

Alternatively, the routine NDF\_UNMAP may be used by specifying a component
name of `Axis', as follows: 

\small
\begin{verbatim}
      CALL NDF_UNMAP( INDF, 'Axis', STATUS )
\end{verbatim}
\normalsize

This will unmap all {\em axis\/} arrays which are mapped.
(A wild-card component name of `$*$' will also affect {\em axis\/} arrays in
the same way.) 

If {\em axis\/} arrays are to be unmapped individually, then the routine
NDF\_AUNMP should be used. 
Thus,

\small
\begin{verbatim}
      CALL NDF_AUNMP( INDF, 'Width', IAXIS, STATUS )
\end{verbatim}
\normalsize

might be used to unmap a particular {\em axis width\/} array.
As usual, a list of {\em axis\/} component names may be supplied to
NDF\_AUNMP and a wild-card {\em axis\/} component name of `$*$' can also be
used. 
In addition, an IAXIS value of zero may be specified to indicate that the
unmapping operation is to be applied to all the NDF's axes. 
Thus,

\small
\begin{verbatim}
      CALL NDF_AUNMP( INDF, '*', 1, STATUS )
\end{verbatim}
\normalsize

would unmap all the {\em axis\/} arrays for {\em axis\/} 1 of an NDF, while:

\small
\begin{verbatim}
      CALL NDF_AUNMP( INDF, 'Centre', 0, STATUS )
\end{verbatim}
\normalsize

would unmap the {\em centre\/} array for all of the axes.

\subsection{Writing and Modifying Axis Arrays}

New values may be written to an {\em axis\/} array by mapping it using
NDF\_AMAP and specifying a mapping mode of `UPDATE' or `WRITE'. 
Any new values assigned to the mapped array (or modifications made in the
case of `UPDATE' access) will then be written back to the NDF when the array
is unmapped, as described in detail in \S\ref{ss:moreaboutmapping}. 
The following example shows how an {\em axis width\/} array might be mapped
for write access, passed to a routine SETVAL which assigns values to it, and
then unmapped: 

\small
\begin{verbatim}
      INTEGER PNTR( 1 ), EL

      ...

      CALL NDF_AMAP( INDF, 'Width', IAXIS, '_REAL', 'WRITE', PNTR, EL, STATUS )
      CALL SETVAL( 3.5, EL, %VAL( PNTR( 1 ) ), STATUS )
      CALL NDF_AUNMP( INDF, 'Width', IAXIS, STATUS )

      ...

*  Routine to assign axis width values.
      SUBROUTINE SETVAL( VALUE, EL, WIDTH, STATUS )
      INCLUDE 'SAE_PAR'
      INTEGER EL, STATUS
      REAL VALUE, WIDTH( EL )

      IF ( STATUS .NE. SAI__OK ) RETURN

      DO 1 I = 1, EL
         WIDTH( I ) = VALUE
 1    CONTINUE
      END
\end{verbatim}
\normalsize

When using update access, NDF\_AMAP will ensure that the mapped array is
filled with the appropriate default values if the {\em axis\/} array is
initially in an undefined state. 

After successfully unmapping an {\em axis\/} array mapped for update or
write access, the array's state will become defined. 
This process of assigning values to an {\em axis\/} array will also cause
the NDF's {\em axis\/} coordinate system to become defined (see
\S\ref{ss:axisstate}), so default values will be assigned to all the NDF's
{\em axis centre\/} arrays if these have not already been defined. 
This process takes place whenever NDF\_AMAP is called with a mapping mode of
`UPDATE' or `WRITE', and is exactly equivalent to calling the routine
NDF\_ACRE (\S\ref{ss:acre}) immediately beforehand. 

\subsection{Accessing Axis Variance Values as Standard Deviations}
\label{ss:axisstddev}

The values of an {\em axis variance\/} array may also be accessed directly
as standard deviation values by specifying the special component name
`Error' in a call to NDF\_AMAP. 
This facility operates in exactly the same way as the equivalent operation
on the main {\em variance\/} component of an NDF (see \S\ref{ss:stddev}) and
causes the square root of the mapped values to be taken before they are
returned. 
If a mapping mode of `UPDATE' or `WRITE' is specified, then the new or
modified values are also squared before being written back to the {\em
axis\/} array when it is unmapped. 

Note that the component name `Error' may only be used with mapping routines.
The name `Variance' should be used when later unmapping values accessed in
this way. 

\subsection{Axis Normalisation Flags}

The value of an {\em axis\/} normalisation flag
(\S\ref{ss:axisnormalisation}) may be obtained by calling the routine
NDF\_ANORM, as follows: 

\small
\begin{verbatim}
      LOGICAL NORM

      ...

      CALL NDF_ANORM( INDF, IAXIS, NORM, STATUS )
\end{verbatim}
\normalsize

This will return the normalisation flag value for the specified {\em axis\/}
via the logical NORM argument. 
An IAXIS value of zero may also be given, in which case the routine will 
return the logical ``OR'' of the results for each NDF {\em axis}.
By default, the value returned will be .FALSE., indicating that no
corrections to preserve {\em data\/} normalisation need be applied.

A new value for an {\em axis\/} normalisation flag may be set by using the
NDF\_ASNRM routine, as follows: 

\small
\begin{verbatim}
      CALL NDF_ASNRM( NORM, INDF, IAXIS, STATUS )
\end{verbatim}
\normalsize

The new flag value is supplied via the NORM argument.
A value of zero for the IAXIS argument will cause the same normalisation 
flag value to be set for all the NDF's {\em axes}.

Note that the {\em axis\/} normalisation flag is regarded as an {\em axis\/}
attribute (like numeric type and storage form) rather than an {\em axis\/}
component, so setting a new normalisation flag value does not automatically
cause the {\em axis\/} coordinate system to become defined. 
Normalisation flag values will only be retained if the {\em axis\/}
coordinate system is in a defined state when the NDF is finally released
from the NDF system ({\em i.e.}\ when the last identifier which refers to it
is annulled). 

\subsection{The Numeric Type of Axis Arrays}

An NDF's {\em axis\/} array values may be stored using any of the seven
non-complex numeric types described in \S\ref{ss:numerictypes}, and may also
be accessed using any of these types. 
Type conversion will be performed automatically when required. 
By default, all {\em axis\/} arrays use a numeric type of `\_REAL', although
this may be changed if required (see below). 

The routine NDF\_ATYPE is provided for determining the numeric type of an
{\em axis\/} array, as follows: 

\small
\begin{verbatim}
      INCLUDE 'NDF_PAR'
      CHARACTER * ( NDF__SZTYP ) TYPE

      ...

      CALL NDF_ATYPE( INDF, 'Centre', IAXIS, TYPE, STATUS )
\end{verbatim}
\normalsize

This will return the numeric type as an upper-case character string ({\em
e.g.}\ `\_REAL') via the TYPE argument. 
Note the use of the symbolic constant NDF\_\_SZTYP (as defined in the 
include file NDF\_PAR) to define the length of the character variable which 
is to receive the returned value.

NDF\_ATYPE will also accept a list of {\em axis\/} array names, and a value
of zero may be given for the IAXIS argument to indicate that all the NDF's
axes should be considered at once. 
In this case, the routine will return the lowest-precision numeric type to
which all the specified {\em axis\/} arrays may be converted without
unnecessary loss of information. 

So long as suitable access is available (see \S\ref{ss:restrictingaccess}),
the numeric type of an {\em axis\/} array may be changed at any time. 
If the array is in a defined state when this occurs, its values will be
converted to the new type and will not be lost---the array may be reset
beforehand ({\em e.g.}\ using NDF\_AREST) if its values are not to be
retained. 
A component list and/or an IAXIS value of zero may also be used.
Thus, the following call would ensure that all of an NDF's {\em axis
centre\/} and {\em width\/} values were stored in double-precision
arrays: 

\small
\begin{verbatim}
      CALL NDF_ASTYP( '_DOUBLE', INDF, 'Cen,Wid', 0, STATUS )
\end{verbatim}
\normalsize

Note that the numeric type attribute of an {\em axis\/} array exists 
regardless of the array's state. 
A call such as that above can therefore be made before any {\em axis\/}
values are assigned and will ensure that arrays of the required type are
used when values are later assigned to them. 

\subsection{The Storage Form of Axis Arrays}

An NDF's {\em axis\/} arrays may be stored using either {\em simple\/} or
{\em primitive\/} storage form (see \S\ref{ss:storageform}), the default
being chosen to match that of the NDF's main {\em data\/} component. 
The storage form of an {\em axis\/} array may be obtained by using the
routine NDF\_AFORM, as follows: 

\small
\begin{verbatim}
      INCLUDE 'NDF_PAR'
      CHARACTER * ( NDF__SZFRM ) FORM

      ...

      CALL NDF_AFORM( INDF, 'Centre', IAXIS, FORM, STATUS )
\end{verbatim}
\normalsize

This example would return the storage form of the specified {\em axis
centre\/} array ({\em e.g.}\ `SIMPLE') as an upper-case character string via
the FORM argument. 
Note the use of the symbolic constant NDF\_\_SZFRM (defined in the include
file NDF\_PAR) to define the size of the character variable which is to
receive the returned storage form information. 

As with other NDF array components, the {\em primitive\/} storage form
places certain restrictions on the use to which an {\em axis\/} array may be
put (see \S\ref{ss:primitiveform}). 
In practice, however, there is usually little need to be aware of this,
because the NDF\_ system will implicitly convert the storage form of {\em
primitive axis\/} arrays to become {\em simple\/} whenever one of these
restrictions would be violated.
This is a straightforward operation which costs little. 
Since {\em bad\/}-pixel flags are not relevant to {\em axis\/} arrays, the
only changes which can precipitate such a storage form conversion are those
which modify the NDF's pixel-index bounds. 
The lower bound of an {\em axis\/} array is conceptually equal to the lower
bound of the corresponding NDF dimension, so a {\em primitive axis\/} array
will be converted to {\em simple\/} storage form if the lower bound of the
relevant NDF dimension ceases to be equal to 1. 

\subsection{Accessing Axis Components via NDF Sections}

The values of {\em axis\/} components and their attributes may be obtained
({\em i.e.}\ read) freely via identifiers which refer to NDF sections (see
\S\ref{ss:ndfsections}). 
In fact, in the case of {\em axis\/} character components there is no
difference between using NDF sections and base NDFs for this purpose. 
With {\em axis\/} arrays, however, it is necessary that the appropriate
part of each array be selected so that it correctly matches the NDF pixels
to which the section refers. 
This operation is performed automatically by the NDF\_ system.

In contrast, the writing or modification of {\em axis\/} component values
and attributes has to be handled very differently when NDF sections are
involved, in order to adhere to the principles described in
\S\ref{ss:sectionrestrictions}. 
Accordingly, the following major restriction is placed on such operations:

\begin{quote}
\begin{center}
{\em No changes to axis component values or attributes may be made via an 
NDF section}
\end{center}
\end{quote}

This restriction is necessary so that an application which is applied to an
NDF section is prevented from modifying axis values which may affect the
interpretation of NDF pixels lying outside the section in question. 

Applications should, nevertheless, still be able to operate on NDF sections
with the possible limitation that {\em axis\/} modifications may be lost. 
To allow this, the NDF\_ system permits attempts to modify axis values or
attributes via NDF sections to proceed without error. 
However, all the relevant routines will simply return without action under
these circumstances, so the attempted changes to the {\em axis\/} components
will be disregarded, leaving the components unaffected. 

\subsection{Axis Extrapolation}

When using NDF sections, the possibility also exists of reading {\em axis\/}
array values from sections which refer to super-sets of the associated base
NDF (\S\ref{ss:selectingsupersets}).
Although the section's {\em axis\/} arrays may be in a defined state (values
having previously been assigned via the base NDF), parts of them will still
lie outside the bounds of the base NDF, and so cannot have any values. 
In such cases, {\em axis\/} arrays must be {\em extrapolated\/} in order to
return useful values. 
This process uses a set of {\em axis extrapolation rules\/} which are an
extension of the rules normally used to generate the default {\em axis\/}
values (\S\ref{ss:axisdefaults}), as follows: 

\begin{description}

\item[Centre:] {\em Axis centre\/} arrays are linearly extrapolated from the
{\em centre\/} values of the two nearest base-NDF pixels on the same axis.
If only one of these pixels exists, then the extrapolation assumes unit
spacing between pixel {\em centres}. 

\item[Width:] If an {\em axis width\/} array is in a defined state, it is
extrapolated by duplicating the nearest base-NDF {\em width} value on the
same {\em axis}. 
If it is in an undefined state, its new values are derived from the
corresponding extrapolated {\em centre\/} values by employing the usual
method for generating default {\em axis width\/} values
(\S\ref{ss:axisdefaults})---this normally gives rise to {\em width\/}
values which match the pixel {\em centre\/} spacing of the two nearest
base-NDF  pixels on the same axis.

\item[Variance:] {\em Axis variance\/} arrays are always extrapolated by
padding with the value zero. 

\end{description}

There is also the possibility that an NDF section may have more dimensions
than its associated base NDF (see \S\ref{ss:changingdimensionality}), in
which case associated {\em axis\/} components will also exist. 
These ``virtual'' {\em axis\/} components may be accessed in the same way as
those associated with other dimensions, but they are always regarded as
being in an undefined state. 
Default values will be supplied for them, if necessary, using the normal
defaulting rules (see \S\ref{ss:axisdefaults}), but any new values assigned
will simply be discarded. 


\section{MERGING AND MATCHING NDF ATTRIBUTES}

\subsection{The Problem}

A problem which immediately surfaces when you start to write applications to
process NDFs is how to cope with the wide variety of data structures which
may be encountered.
Taking account of all possible shapes and sizes, all feasible types and storage
forms for NDF components, the presence or absence of {\em bad\/} pixels and the
state (defined or undefined) of each component, the number of combinations is
clearly enormous.
So how can simple general-purpose applications be written to cope with all 
this?

In simple cases ({\em e.g.}\ only a single input NDF) it is possible for an
application to enquire about certain NDF attributes and adapt to some extent
to take account of them. 
In the example in \S\ref{ss:usingbadpixflag}, for instance, separate
algorithms were used depending on whether {\em bad\/} pixels might be present
or not. 
However, even this modest degree of adaption can rapidly become complicated
if there are two or more NDFs (and hence four or more combinations of {\em
bad\/}-pixel flags) to consider. 

For general-purpose software which will be heavily used, some attempt to 
adapt will probably be worthwhile if it leads to significantly better
performance. 
However, it is often necessary to write very simple or ``one off''
applications with little knowledge of NDF data structures, where any need to
adapt to an incoming NDF would impose an unwelcome programming burden. 
Such applications should nevertheless make a consistently good job of
processing NDF data structures. 

The problem, therefore, is how to reconcile the very diverse requirements
imposed by the complicated nature of NDF data structures with the variable,
but generally far more modest capabilities of real applications. 
The solution lies in various conversion processes which allow the attributes
of NDFs to be {\em merged\/} and {\em matched\/} to the capabilities of
applications, to arrive at a compromise method of processing the information
in any particular set of NDF data structures. 
As this description suggests, some loss of efficiency or information will
inevitably be involved, but this will usually be acceptably small.
In cases where the penalty is unacceptable, an application naturally has the
option of aborting with an appropriate error message. 

\subsection{Merging and Matching Bad-Pixel Flags}
\label{ss:mbad}

First consider processing the {\em data\/} arrays of two input NDFs.
Under what circumstances should checks for {\em bad\/} pixels be made? 

The capabilities of real applications in this area usually fall into one of
the following categories: 

\begin{enumerate}

\item No ability to handle {\em bad\/} pixels at all.

\item The ability to check all arrays for {\em bad\/} pixels, regardless of
the {\em bad\/}-pixel flag(s). 

\item The ability to adapt the processing algorithm according to whether
{\em bad\/}-pixels may be present or not. 

\end{enumerate}

It is expected that the majority of applications will fall into categories 1
and 2, since only a few general-purpose software items are likely to obtain
worthwhile benefit from attempting to optimise their behaviour when {\em
bad\/} pixels are known to be absent (category 3). 
Nevertheless, it is instructive to consider this last and most complicated
category first. 

As already noted, there are four possible combinations of {\em bad\/}-pixel
flags if we consider the {\em data\/} components of a pair of NDFs (there
would be considerably more if we wanted to include the {\em variance\/}
components as well). 
For all practical purposes, however, the number of combinations can be
reduced to two by {\em merging\/} the {\em bad\/}-pixel flags of the separate 
array components using a logical ``OR'', for instance: 

\small
\begin{verbatim}
      LOGICAL BAD1, BAD2, BAD

      ...

      CALL NDF_BAD( INDF1, 'Data', .FALSE., BAD1, STATUS )
      CALL NDF_BAD( INDF2, 'Data', .FALSE., BAD2, STATUS )
      BAD = BAD1 .OR. BAD2

      ...
\end{verbatim}
\normalsize

The resulting value of BAD could then be used to determine whether checks
for {\em bad\/}-pixel values are necessary. 
For instance, if the two {\em data\/} arrays were to be added, the main
processing algorithm might look like this: 

\small
\begin{verbatim}
      SUBROUTINE ADDIT( BAD, EL, A, B, C, STATUS )
      INCLUDE 'SAE_PAR'
      INCLUDE 'PRM_PAR'

      LOGICAL BAD
      INTEGER EL, STATUS, I
      REAL A( EL ), B( EL ), C( EL )

      IF ( STATUS .NE. SAI__OK ) RETURN

*  No bad-pixel checks needed, so add the arrays.
      IF ( .NOT. BAD ) THEN
         DO 1 I = 1, EL
            C( I ) = A( I ) + B( I )
1        CONTINUE

*  Bad pixel checks needed, so check and assign a bad result if necessary.
      ELSE
         DO 2 I = 1, EL
            IF ( A( I ) .EQ. VAL__BADR .OR. B( I ) .EQ. VAL__BADR ) THEN
               C( I ) = VAL__BADR

*  Otherwise add the array elements normally.
            ELSE
               C( I ) = A( I ) + B( I )
            END IF
 2       CONTINUE
      END IF
      END
\end{verbatim}
\normalsize

Although this is the most sophisticated response to the presence of {\em 
bad\/} pixels which we will consider, two compromises have nevertheless
still been made here. 
First, the main processing algorithm will sometimes run slightly more slowly
than is absolutely necessary, because taking the logical ``OR'' means that
checks will occasionally be made for {\em bad\/} pixels in arrays which do not
contain any. 
Secondly, as a result of this, some ``good'' pixels may accidentally be
identified as {\em bad\/} and a small fraction of valid pixels might therefore
be lost. 
In practice, both of these penalties are usually acceptably small, given the
alternative (of writing many versions of the main processing algorithm to
cater for every combination of {\em bad\/}-pixel flags). 

So what should happen if the main processing algorithm is very simple and
cannot handle any {\em bad\/} pixels at all (category 1 above)? 
In this case, it is not possible to compromise, because attempting to ignore
the situation and process an array containing {\em bad\/} pixels without
checking for them will give a completely wrong result (as well as causing
severe numerical problems which will probably cause the application to
crash). 
In this situation, the limitations of the application are paramount, and the
correct response is to report an error and abort (see 
\S\ref{ss:badpixelabort}). 
A user would then have the option of running a separate application to
``repair'' the data by replacing {\em bad\/} pixels with an acceptable
alternative. 

The need to handle {\em bad\/}-pixel flags in any of the ways described above
is very common, so the prototype {\em merging and matching\/} routine
NDF\_MBAD is provided to simplify the process.
This routine merges the {\em bad\/}-pixel flags of a pair of NDFs and matches
them to the capabilities of an application.
Its (1st) BADOK argument is supplied with a logical value indicating whether
the calling application can handle {\em bad\/} pixels or not, for instance: 

\small
\begin{verbatim}
      LOGICAL BADOK, CHECK, BAD

      ...

      CALL NDF_MBAD( BADOK, INDF1, INDF2, 'Data', CHECK, BAD, STATUS )
\end{verbatim}
\normalsize

If the BADOK argument is set to .TRUE., then NDF\_MBAD simply returns
the logical ``OR'' of the {\em bad\/}-pixel flags for each of the two NDFs via 
its BAD argument.
In this case it behaves in most respects exactly like its simpler relative
NDF\_BAD (see \S\ref{ss:usingbadpixflag}). 
However, if BADOK is set to .FALSE., but the returned BAD value would
nevertheless be .TRUE.\ (indicating that {\em bad\/} pixels may be present in
one of the NDFs), then an error results. 
NDF\_MBAD then makes an appropriate error report, explaining that the
application cannot handle the {\em bad\/} pixels, and returns with its STATUS
argument set to NDF\_\_BADNS (bad values not supported), as defined in the
include file NDF\_ERR. 
In the normal course of events, the application would then abort and this
message would be delivered to the user. 

A call to NDF\_MBAD therefore allows an application to declare whether it
can handle {\em bad\/} pixels, and then determines whether checks for {\em bad\/}
pixels should actually be made. 
At the same time, it will handle any problems which may arise. 

If more than two NDF's are involved, then the routine NDF\_MBADN may be 
used instead of NDF\_MBAD.
This routine exists for merging the {\em bad}-pixel flag values of an
arbitrary number of NDFs, whose identifiers are supplied in an integer
array. 
For instance: 

\small
\begin{verbatim}
      INTEGER N, NDFS( N )

      ...

      CALL NDF_MBADN( .FALSE., N, NDFS, 'Data', .TRUE., BAD, STATUS )
\end{verbatim}
\normalsize

could be used by an application which was incapable of handling {\em bad\/}
pixels in order to check for their existence in a whole sequence of NDFs at
once. 

Finally, if only a single NDF is being used, then there is a choice. 
The routine NDF\_MBADN may be called with N set to 1, but NDF\_MBAD may also
be used by passing the same identifier value twice, as follows: 

\small
\begin{verbatim}
      CALL NDF_MBAD( BADOK, INDF1, INDF1, COMP, CHECK, BAD, STATUS )
\end{verbatim}
\normalsize

NDF\_MBAD is designed to expect this kind of usage, and will detect it and
behave appropriately without any loss of efficiency. 
All the other equivalent matching and merging routines described in
subsequent sections also have this capability. 

\subsection{Matching NDF Bounds}
\label{ss:mbnd}

The common situation where an application takes two or more input NDFs and
combines their array component values pixel-by-pixel ({\em e.g.}\ to
multiply their {\em data\/} arrays together) raises a similar problem of how
to cope with the diversity of NDF shapes which could be encountered. 
In this case the capabilities of the application are generally not an issue,
because most applications will be written to process NDFs of arbitrary size. 
However, what steps should be taken if the NDFs supplied as input turn out
to have different sizes? 

A simple approach might be to check whether the shapes of the input NDFs
match and to report an error and abort if they do not. 
This straightforward (but unfriendly) approach requires a significant number
of Fortran statements and quickly becomes a chore if it has to be performed
explicitly in every application. 
However, by making use of NDF {\em sections\/} (see
\S\ref{ss:creatingsections}) to change the apparent pixel-index bounds of an
NDF, it is possible to do considerably better than this, and to allow
processing of NDFs whose bounds may not initially match. 

To understand the principle, consider two NDFs with shapes which do not 
match, such as:

\small
\begin{quote}
\begin{center}
(15:115,-5,10)
\end{center}
\end{quote}
\normalsize

and

\small
\begin{quote}
\begin{center}
(1:200,1:30)
\end{center}
\end{quote}
\normalsize

It would clearly be meaningless to attempt to multiply the {\em data\/} arrays
of these two NDFs together pixel-by-pixel as they stand, since there are
some pixels in the first one which do not exist in the second one, and {\em
vice versa}. 
However, the pixels within the region:

\small
\begin{quote}
\begin{center}
(15:115,1:10)
\end{center}
\end{quote}
\normalsize

do exist within both NDFs and can be multiplied together if we decide to 
discard the rest.
This can be done by creating an appropriate section from each NDF which 
selects only these common pixels for further processing.
This task, of calculating which pixels to use and of selecting the
appropriate NDF sections, may be performed using the routine NDF\_MBND,
which matches the bounds of a pair of NDFs, as follows: 

\small
\begin{verbatim}
      CALL NDF_MBND( 'TRIM', INDF1, INDF2, STATUS )
\end{verbatim}
\normalsize

If necessary, NDF\_MBND will annul the NDF identifiers supplied and replace
them with identifiers to appropriate NDF sections with matching shapes. 
The array components of these sections may then be accessed and compared
pixel-by-pixel, since they will be of equal size. 
If the two NDFs have no pixels in common, then NDF\_MBND will report an
appropriate error message and set a STATUS value. 

In cases where more than two NDFs are involved, the similar routine 
NDF\_MBNDN may be used.
This will match the bounds of an arbitrary number of NDFs, whose
identifiers should be held in an integer array, for instance:

\small
\begin{verbatim}
      INTEGER N, NDFS( N )

      ...

      CALL NDF_MBNDN( 'TRIM', N, NDFS, STATUS )
\end{verbatim}
\normalsize

This routine will create sections with matching bounds from each NDF
supplied, selecting only those pixels which exist in \underline{all} of the
NDFs. 
Once again, an appropriate error report will be made, and a STATUS value
set, if this cannot be achieved. 

If access to any of the original NDFs is still required, then the routine
NDF\_CLONE may be used to retain an identifier for it before calling
NDF\_MBND or NDF\_MBNDN, since either of these latter routines may annul the
identifiers passed to them. 
For example:

\small
\begin{verbatim}
      CALL NDF_CLONE( INDF1, INDFK, STATUS )
      CALL NDF_MBND( 'TRIM', INDF1, INDF2, STATUS )
\end{verbatim}
\normalsize

would ensure that an identifier INDFK is retained for the NDF whose original
identifier was held in INDF1, even although NDF\_MBND may alter the INDF1
variable so that it refers only to a sub-section of the NDF.

An alternative method of matching NDF bounds is by {\em padding}, in which 
each NDF is padded out with {\em bad\/} pixels rather than by discarding 
pixels at the edges.
It may be employed by specifying `PAD' for the 1st (OPTION) argument to
NDF\_MBND or NDF\_MBNDN. 
For instance:

\small
\begin{verbatim}
      CALL NDF_MBND( 'PAD', INDF1, INDF2, STATUS )
\end{verbatim}
\normalsize

In this case, the NDF sections produced may represent super-sets of the
original NDFs (see \S\ref{ss:selectingsupersets}). 
This option is needed less often, but it has the advantage that no pixels
will be lost. 
It is generally used in cases where an output pixel should be assigned a
value even if one of the input pixels is missing (or has a {\em bad\/} value). 
For instance, an application to merge the {\em data\/} arrays of two
non-congruent NDFs by averaging their pixel values might use the `PAD'
option to match the bounds of the input NDFs.
It could then generate an output array using an algorithm along the
following lines, where an output pixel value is generated if either or both
input pixels are valid: 

\small
\begin{verbatim}
      INTEGER EL, I
      REAL A( EL ), B( EL ), C( EL )
      INCLUDE 'PRM_PAR'

      ...

*  Loop to process each array element.
      DO 1 I = 1, EL

*  If both input pixels are good, then take the average.
         IF ( A( I ) .NE. VAL__BADR .AND. B( I ) .NE. VAL__BADR ) THEN
            C( I ) = 0.5 * ( A( I ) + B( I ) )

*  Otherwise, if the first one is good, then use it.
         ELSE IF ( A( I ) .NE. VAL__BADR ) THEN
            C( I ) = A( I )

*  Otherwise use the second one.
         ELSE
            C( I ) = B( I )
         END IF
1     CONTINUE
\end{verbatim}
\normalsize

When using the `TRIM' option, the output NDF may be smaller than either of
the two input NDFs, and when using the `PAD' option, it may be larger. 
However, the application usually need not be aware of this. 

\subsection{Merging and Matching Numeric Types}

The variety of possible numeric types which may be used to store the values
of NDF array components (see \S\ref{ss:numerictypes}) poses another problem
for the applications programmer. 
What type of arithmetic should be chosen to process the values?

The simplest option, and the one which is recommended for normal use, is:

\begin{quote}
\begin{center}
{\em Use single-precision floating point arithmetic for calculations
wherever possible...} 
\end{center}
\end{quote}

and access all array components (other than {\em quality\/}) as `\_REAL'
values, taking advantage of the implicit type conversion provided by the
NDF\_ routines if necessary (see \S\ref{ss:implicitconversion}). 

However, when writing general-purpose software which may be heavily used,
the possibility of duplicating the main processing algorithm so that
calculations can be performed using several alternative types of arithmetic
might also be considered. 
This allows applications to support the processing of unusual numeric types
({\em e.g.}\ double-precision), while normally using less computationally
expensive arithmetic ({\em e.g.}\ single-precision) when that is adequate. 
The ability to explicitly handle values with a variety of numeric types also
makes it less likely that an expensive type conversion will have to be
performed implicitly by the NDF\_ routines (see
\S\ref{ss:implicitconversion}). 
Of course, the disadvantages of this approach are that extra work is
involved in duplicating the main processing algorithm. 
The magnitude of this extra work should not be underestimated, although the
use of the GENERIC compiler (SUN/7) can simplify the task to some extent. 

To give a concrete example, suppose you decide to duplicate the main
processing algorithm in an application so that it can perform calculations
using either single- or double-precision arithmetic. 
Input NDFs with numeric array types of `\_REAL' or `\_DOUBLE' can then be
processed directly, although with other numeric types (or with mixed types)
implicit type conversion will still need to occur. 
This can get rather complicated to sort out, so a simple routine NDF\_MTYPE
is provided to make the decision about which version of an algorithm to
invoke in a particular case, depending on the declared capabilities of an
application, for instance:

\small
\begin{verbatim}
      INCLUDE 'NDF_PAR'
      CHARACTER ITYPE * ( NDF__SZTYP ), DTYPE * ( NDF__SZFTP )

      ...

      CALL NDF_MTYPE( '_REAL,_DOUBLE', INDF1, INDF2, 'Data', ITYPE, DTYPE, STATUS )
\end{verbatim}
\normalsize

The 1st (TYPLST) argument is a list of the numeric types which the
application can process explicitly (`\_REAL' and `\_DOUBLE') supplied in
order of preference, {\em i.e.}\ in order of increasing computational cost in
this instance. 
NDF\_MTYPE will examine the two NDFs supplied and select a numeric type from
this list to which the {\em data\/} component values should be converted for
processing so that no unnecessary loss of information occurs.
The conversion from `\_REAL' to `\_DOUBLE' would be acceptable, for
instance, whereas the opposite conversion process would lose information. 

The resulting {\em implementation type\/} is returned as an upper-case
character string via the ITYPE argument, and may be used both as an input
argument to NDF\_MAP for accessing the NDFs' values, as well as for deciding
which version of the main algorithm to invoke, for instance: 

\small
\begin{verbatim}
      CALL NDF_MTYPE( '_REAL,_DOUBLE', INDF1, INDF2, 'Data', ITYPE, DTYPE, STATUS )

*  Access the input array values using the selected implementation type.
      CALL NDF_MAP( INDF1, 'Data', ITYPE, PNTR1, EL, STATUS )
      CALL NDF_MAP( INDF2, 'Data', ITYPE, PNTR2, EL, STATUS )

*  Invoke the appropriate version of the processing algorithm.
      IF ( ITYPE .EQ. '_REAL' ) THEN
         <invoke the single-precision algorithm>
      ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
         <invoke the double-precision algorithm>
      END IF
\end{verbatim}
\normalsize

The NDF\_MTYPE routine also addresses the question of how to store the
results of the calculation since, ideally, the numeric type used for the
output array(s) should preserve the precision of the calculation without
unnecessarily increasing the storage space required. 
A suitable numeric type is therefore returned as an upper-case character
string via the DTYPE argument and may be used as an input argument to a
routine such as NDF\_CREAT which creates an output NDF. 
More commonly, however, it will be used to change the numeric type of an NDF
which has already been created by a call to NDF\_PROP (see \S\ref{ss:prop}),
for instance: 

\small
\begin{verbatim}
      CALL NDF_PROP( INDF1, ' ', 'OUT', INDF3, STATUS )
      CALL NDF_MTYPE( '_REAL,_DOUBLE', INDF1, INDF2, 'Dat,Var', ITYPE, DTYPE, STATUS )
      CALL NDF_STYPE( DTYPE, INDF3, 'Dat,Var', STATUS )
\end{verbatim}
\normalsize

Here, a new output NDF is created based on the first input NDF by using
NDF\_PROP, and an identifier INDF3 is obtained for it.
NDF\_MTYPE is then called to determine an appropriate numeric type for
storing the output {\em data\/} and {\em variance\/} components, and NDF\_STYPE
is invoked to set the output components' type appropriately. 
In a typical application, the input and output arrays would probably then be
accessed and passed to the appropriate version of the main processing
algorithm.
A complete example of this sequence of events can be found in 
\S\ref{ss:addexample}, where its integration with the handling of the {\em
bad\/}-pixel flag and matching of the NDFs' bounds is also demonstrated. 

Note that an equivalent routine NDF\_MTYPN also exists for merging and
matching the numeric types of an arbitrary number of NDFs, whose identifiers
are supplied in an integer array, as follows: 

\small
\begin{verbatim}
      INTEGER N, NDFS( N )

      ...

      CALL NDF_MTYPN( '_INTEGER,_REAL', N, NDFS, 'Data', ITYPE, DTYPE, STATUS )
\end{verbatim}
\normalsize

Both this routine and NDF\_MTYPE will report an error and set STATUS to
NDF\_\_TYPNI (processing of data type not implemented), as defined in the
include file NDF\_ERR, if it is not possible to select an implementation
type from the list supplied without leading to loss of information. 
This would be the case for instance, if one of the NDFs had a {\em data\/}
component with a numeric type of `\_DOUBLE' but the application could only
perform single-precision arithmetic. 
In this case, the values returned via the ITYPE and DTYPE arguments would be
the ``best compromise'' values and could still be used, if required, by
ignoring the error condition. 
For instance:

\small
\begin{verbatim}
      INCLUDE 'NDF_ERR'

      ...

      CALL ERR_MARK
      CALL NDF_MTYPE( '_REAL', INDF1, INDF1, 'Data', ITYPE, DTYPE, STATUS )
      IF ( STATUS .EQ. NDF__TYPNI ) CALL ERR_FLUSH( STATUS )
      CALL ERR_RLSE
\end{verbatim}      
\normalsize

Here, the error system routine ERR\_FLUSH has been used to deliver the error 
message to the user and reset STATUS (see SUN/104).
The user would then receive a warning message explaining that `\_DOUBLE'
data could not be handled without loss of information, and that conversion
to `\_REAL' would have to be used. 
The application could then perform the conversion and processing, having
warned the user about the unavoidable loss if information which will occur. 


\section{CONNECTING WITH THE DATA SYSTEM}

\subsection{Finding and Importing NDFs}
\label{ss:findingandreporting}

So far, examples of obtaining access to NDF data structures has depended on
routines which use the ADAM parameter system. 
However, it is also possible to use NDF\_ routines in non-ADAM applications and
hence to access NDF structures whose location within the underlying data system
(HDS) is known directly. 
To do this, the location of the structure must first be made known to the
NDF\_ system. 

Suppose LOC is a locator to an HDS structure, one of whose components
(called NGC1999, say) is an NDF data structure.
The routine NDF\_FIND may be used to find this component and make it
known to the NDF\_ system, as follows:

\small
\begin{verbatim}
      CALL NDF_FIND( LOC, 'NGC1999', INDF, STATUS )
\end{verbatim}
\normalsize

An NDF identifier will be returned via the INDF argument and the data
structure may then be manipulated using NDF\_ routines. 
A compound component name, consisting of a sequence of component names
separated by `.' may also be given to NDF\_FIND in order find an NDF which
is a sub-component (or a sub-sub-component, {\em etc.}) of the structure
identified by the locator LOC. 
Array subscripts may also be included in this component name.
For example, if LOC is associated with the HDS structure DATAFILE.STRUCT,
then:

\small
\begin{verbatim}
      CALL NDF_FIND( LOC, 'A.B(2).IMAGE', INDF, STATUS )
\end{verbatim}
\normalsize

would attempt to find the NDF data structure called 
DATAFILE.STRUCT.A.B(2).IMAGE and import it into the NDF\_ system.

In some cases, an HDS locator may be available for the NDF data structure
itself, rather than for the parent structure which contains the NDF as a 
component.
In this case, the NDF can be made known (or {\em imported\/}) into the NDF\_
system using the routine NDF\_IMPRT, thus: 

\small
\begin{verbatim}
      CALL NDF_IMPRT( LOC, INDF, STATUS )
\end{verbatim}
\normalsize

Once again, an NDF identifier is returned via the INDF argument.
The same effect could also be achieved by supplying a blank component name 
to NDF\_FIND.

Note that the locator passed to NDF\_FIND or NDF\_IMPRT may usually be
annulled afterwards without affecting the behaviour of the NDF\_ system, but
care must be exercised if it may be a {\em top-level\/} HDS locator, in
which case annulling it may cause HDS to close the container file. 

\subsection{Obtaining an HDS Locator for an NDF}
\label{ss:gettingalocator}

The NDF\_ system allows you to obtain an HDS locator for a data structure whose
NDF identifier you supply. In effect, this is the reverse of the importation
process described above. It is performed by the NDF\_LOC routine, as follows:

\small
\begin{verbatim}
      CALL NDF_LOC( INDF, MODE, LOC, STATUS )
\end{verbatim}
\normalsize

The MODE argument specifies the mode of access required (`READ', `UPDATE' or
`WRITE') and LOC returns the resulting HDS locator. Note that you should annul
this locator ({\em e.g.}\ using DAT\_ANNUL) when it is no longer required, as
the NDF\_ system will not perform this task itself.

\subsection{NDF Placeholders}

Routines are also provided for the creation of NDFs at specified locations
within the data system, rather than indirectly via the ADAM parameter
system.
These routines depend on the concept of a {\em placeholder\/} for their
operation. 

In many ways, a placeholder is similar to an NDF identifier; {\em i.e.}\ it
is an integer value which the NDF\_ system issues to identify an entity
about which it holds information.
In this case, however, the entity is not a data structure, but a position
within the data system at which an NDF will be created at some later time.

An NDF placeholder may be obtained by calling the routine NDF\_PLACE,
specifying a locator to an existing HDS structure along with the name of a
component which is to be used to hold the NDF, thus:

\small
\begin{verbatim}
      CALL NDF_PLACE( LOC, 'MY_NEW_NDF', PLACE, STATUS )
\end{verbatim}
\normalsize

The integer value PLACE returned is an NDF placeholder.

As with NDF\_FIND (\S\ref{ss:findingandreporting}), a compound component
name may also be passed to NDF\_PLACE in order to create an NDF which is a
sub-component (or a sub-sub-component, {\em etc.}) of the structure
identified by the locator LOC, for example:

\small
\begin{verbatim}
      CALL NDF_PLACE( LOC, 'A.B(2).IMAGE', PLACE, STATUS )
\end{verbatim}
\normalsize

In such cases, all the HDS structures residing at levels above the actual
NDF object to be created must already exist, otherwise NDF\_PLACE will fail.

Sometimes, it is more convenient if an object is already in existence at the
location in the data system for which a placeholder is to be issued. 
For instance, this allows placeholders to refer to the individual elements
of an array of structures which has previously been created, so that arrays
of NDFs may be built. 
Any pre-existing object for which an NDF placeholder is to be issued must be
a scalar structure and must have an HDS type of `NDF'. 
It must also be empty ({\em i.e.}\ it must have no components). 
NDF\_PLACE is then called in the usual way.
In the following example, for instance, a 1-dimensional array of structures
is created with 5 elements, and a placeholder is then obtained for the
second element: 

\small
\begin{verbatim}
      INCLUDE 'SAE_PAR'
      CHARACTER * ( DAT__SZLOC ) LOC
      INTEGER DIM( 1 ), PLACE

      ...

      DIM( 1 ) = 5
      CALL DAT_NEW( LOC, 'NDF_ARRAY', 'NDF', 1, DIM, STATUS )
      CALL NDF_PLACE( LOC, 'NDF_ARRAY(2)', PLACE, STATUS )
\end{verbatim}
\normalsize

As with NDF\_FIND, a blank component name may also be supplied to NDF\_PLACE
to indicate that the data system location to be used is identified directly
by the locator; this mode of use is only applicable when an object already
exists at that location. 

\subsection{Creating NDFs via Placeholders}

The only valid thing that can be done with an NDF placeholder is to pass it
to a routine which creates an NDF. 
Thus, to create a new simple NDF by this means, the routine NDF\_NEW might
be used along with NDF\_PLACE, as follows: 

\small
\begin{verbatim}
      CALL NDF_PLACE( LOC, 'MY_NEW_NDF', PLACE, STATUS )
      CALL NDF_NEW( '_INTEGER', NDIM, LBND, UBND, PLACE, INDF, STATUS )
\end{verbatim}
\normalsize

The call to NDF\_NEW will create the required new simple NDF (in this case
with a type of `\_INTEGER') in place of the placeholder PLACE; {\em i.e.}\ in
component MY\_NEW\_NDF of the HDS structure with locator LOC. 
This act of creation automatically {\em annuls\/} the placeholder, whose value
is reset to NDF\_\_NOPL (this value is defined in the include file NDF\_PAR
and is reserved for indicating that a variable is not a valid placeholder). 

A similar routine NDF\_NEWP also exists by analogy with NDF\_CREP (see
\S\ref{ss:crep}) to create a primitive NDF via a placeholder in exactly the
same way. 

Note that placeholders are only intended for local use within an
application and only a limited number of them are available simultaneously.
They are always annulled as soon as they are passed to a routine which 
creates an NDF, where they are effectively exchanged for an NDF identifier.
Since this is the only valid fate for a placeholder, there is no routine for
annulling them explicitly.
However, the routine NDF\_END will annul any which are left outstanding as
part of the ``cleaning up'' role it performs at the end of an NDF context
(see \S\ref{ss:beginend}). 

\subsection{Temporary NDFs}

Placeholders also provide a convenient means of obtaining ``scratch'' NDFs
for temporary use within an application.
In this case, exactly the same NDF creation routine can be used, but the
placeholder is obtained using the routine NDF\_TEMP, which returns a
placeholder for a {\em temporary\/} NDF. 
To create a temporary simple NDF, the following calls might be used:

\small
\begin{verbatim}
      CALL NDF_TEMP( PLACE, STATUS )
      CALL NDF_NEW( '_INTEGER', NDIM, LBND, UBND, PLACE, INDF, STATUS )
\end{verbatim}
\normalsize

The resulting NDF identifier INDF may be used in exactly the same way as an
identifier for a permanent NDF, except that the data structure it is
associated with will not be retained after it has been finished with. 
More specifically, a temporary NDF will be deleted as soon as the last NDF
identifier associated with it is annulled, either explicitly ({\em i.e.}\ with
NDF\_ANNUL) or implicitly ({\em e.g.}\ as part of the cleaning up performed by
NDF\_END). 

It is possible to determine whether an existing NDF identifier refers to a 
temporary NDF using the routine NDF\_ISTMP:

\small
\begin{verbatim}
      CALL NDF_ISTMP( INDF, ISTMP, STATUS )
\end{verbatim}
\normalsize

A logical value of .TRUE.\ is returned via the ISTMP argument if the NDF is 
temporary.

\subsection{Copying NDFs}

Placeholders also play a role in the copying of NDF data structures from one 
location to another within the data system.
In this case they are used to identify the destination for the copying 
operation, which is performed by the routine NDF\_COPY.
This should be preceded by a call which generates a suitable placeholder. 
For instance:

\small
\begin{verbatim}
      CALL NDF_PLACE( LOC, 'MY_NDF_COPY', PLACE, STATUS )
      CALL NDF_COPY( INDF1, PLACE, INDF2, STATUS )
\end{verbatim}
\normalsize

Here, the placeholder causes NDF\_COPY to copy the NDF with identifier INDF1
to form a new NDF in the component MY\_NDF\_COPY of the HDS structure with
locator LOC. 
As usual, the placeholder is annulled by the copying operation and a new NDF 
identifier INDF2 is issued to refer to the new data structure.
This new structure contains all the information which was present in the 
original.
It is possible to copy both base NDFs and NDF sections in this way, but the
copying operation always creates a new base NDF. 

Naturally, it is also possible to create a temporary copy of an NDF by using
NDF\_TEMP to obtain the placeholder, as follows:

\small
\begin{verbatim}
      CALL NDF_TEMP( PLACE, STATUS )
      CALL NDF_COPY( INDF1, PLACE, INDF2, STATUS )
\end{verbatim}
\normalsize

\subsection{Deleting NDFs}
\label{ss:delet}

Deletion of an NDF may be performed by calling the routine NDF\_DELET, thus:

\small
\begin{verbatim}
      CALL NDF_DELET( INDF, STATUS )
\end{verbatim}
\normalsize

If the necessary access is available (see \S\ref{ss:restrictingaccess}), the
associated data structure will be erased and a value of NDF\_\_NOID will be
returned for the INDF argument. 
Any other identifiers associated with the same data structure will also become
invalid at this point.
Note that deletion cannot be performed via an identifier which refers to an 
NDF section.
In this case, NDF\_DELET will simply annul the identifier as if NDF\_ANNUL 
had been called (see \S\ref{ss:annul}).


\section{ALTERING BOUNDS AND PIXEL INDICES}

\subsection{Setting New Pixel-Index Bounds and Dimensionality}
\label{ss:sbnd}

The pixel-index bounds of an NDF may be altered when required by explicitly
setting them to new values using the routine NDF\_SBND. 
The dimensionality of the NDF may also be changed at the same time. 
For instance:

\small
\begin{verbatim}
      INTEGER NDIM, LBND( NDIM ), UBND( NDIM )

      ...

      CALL NDF_SBND( NDIM, LBND, UBND, INDF, STATUS )
\end{verbatim}
\normalsize

will change an NDF's dimensionality to the value specified by the NDIM
argument, and set its lower and upper pixel-index bounds to the values
specified in the LBND and UBND arrays. 
When an NDF's shape is changed in this way, the pixel values of any array
component which is in a defined state may be affected, as follows: 

\begin{description}

\item[{\bf Retained Pixels}] -- These are pixels with indices which lie
within both the initial and final NDF pixel-index bounds. 
The values of these pixels are retained.

\item[{\bf New Pixels}] -- These are pixels with indices which lie within
the new pixel-index bounds, but did not exist within the initial bounds. 
These pixels will be assigned the appropriate {\em bad\/}-pixel value (see 
\S\ref{ss:badpixels}).
If such pixels are introduced, then the {\em bad\/}-pixel flag of affected NDF 
components will be updated to reflect this fact.

\item[{\bf Lost Pixels}] -- These are pixels with indices which lie within
the initial NDF pixel-index bounds, but outside the new bounds. 
The values of such pixels are lost and cannot be recovered, even by changing
the NDF's bounds back to their original values. 

\end{description}

In cases where the dimensionality of the NDF also changes, the association
between pixel indices before and after the change is established in the same
way as when creating NDF sections (see \S\ref{ss:changingdimensionality}),
{\em i.e.}\ by padding the bounds with 1's to match the dimensionalities. 

Note that altering the shape of an NDF section using NDF\_SBND is a
relatively inexpensive operation which merely involves changing the shape of
the ``window'' into the NDF which the section describes. 
In contrast, altering the shape of a base NDF causes changes to be made to
the actual data structure and can take considerably longer, especially if one
or more of the NDF's array components are in a defined state and contain
values which may need to be shuffled to accommodate the change. 
Consequently, if the values of any array components need not be retained,
they should be reset to an undefined state before changing the shape of a
base NDF. 
For instance:

\small
\begin{verbatim}
      CALL NDF_RESET( INDF, 'Data,Variance,Quality', STATUS )
      CALL NDF_SBND( NDIM, LBND, UBND, INDF, STATUS )
\end{verbatim}
\normalsize

would ensure that no array values are retained and that no time is
unnecessarily wasted as a result.

\subsection{Applying Pixel-Index Shifts}
\label{ss:shift}

An alternative way of changing the pixel-index bounds of an NDF is to apply
shifts to its pixel indices using the routine NDF\_SHIFT. 
For instance:

\small
\begin{verbatim}
      INTEGER NSHIFT, SHIFT( NSHIFT )

      ...

      CALL NDF_SHIFT( NSHIFT, SHIFT, INDF, STATUS )
\end{verbatim}
\normalsize

would apply a set of NSHIFT shifts to an NDF (one to each dimension) as
specified in the integer array SHIFT. 
As a result, the pixel-index bounds and the indices of each pixel in the NDF
would be changed by the amount of shift applied to the corresponding
dimension. 
The shifts applied may be positive or negative. 
Thus, if the set of shifts (10,1,$-$3) were applied to an NDF with shape:

\small
\begin{quote}
\begin{center}
(10:20, 7, 0:5)
\end{center}
\end{quote}
\normalsize

then its shape would change to become:

\small
\begin{quote}
\begin{center}
(20:30, 2:8, $-$3:2)
\end{center}
\end{quote}
\normalsize

Note that the behaviour of NDF\_SHIFT and NDF\_SBND is quite different.
With NDF\_SBND (\S\ref{ss:sbnd}) the pixel indices remain fixed while the NDF
bounds move, so that pixels can be lost from the edges of the NDF and new
ones can be introduced. 
With NDF\_SHIFT, however, the pixel indices move with the bounds, so that 
no pixels can ever be lost and no new ones are introduced.
NDF\_SHIFT also preserves the dimension sizes of the NDF.

The application of pixel-index shifts with NDF\_SHIFT is a relatively
inexpensive operation. 
When applied to an NDF section, the change in pixel indices applies only to
that section (and any identifiers subsequently derived from it) and causes
no permanent change to the base NDF or to other sections.
When applied to a base NDF, however, the actual data structure is altered and
this will be apparent through any other base NDF identifiers which refer to
it.
Note, however, that sections previously derived from a base NDF are not
affected if NDF\_SHIFT is applied to the base NDF ({\em i.e.}\ such sections
will retain their original pixel indices and values). 


\section{MISCELLANEOUS FACILITIES}

\subsection{Restricting Access via NDF Identifiers}
\label{ss:restrictingaccess}

Access restrictions may be imposed on any NDF identifier in order to
constrain the operations which can be performed by NDF\_ routines via that
identifier. 
The act of disabling a particular type of access is performed by the routine
NDF\_NOACC. 
For instance:

\small
\begin{verbatim}
      CALL NDF_NOACC( 'DELETE', INDF, STATUS )
\end{verbatim}
\normalsize

would disable {\em delete\/} access for the identifier INDF.
As a result, any subsequent attempt to delete the NDF via that identifier
would fail, and the resulting error message would indicate that access had
been disabled. 
Access restrictions imposed on NDF identifiers are propagated to all new
identifiers derived from them ({\em e.g.}\ by cloning or creation of an NDF
section).
Once imposed, they cannot be revoked. 

The following types of access may be disabled, either singly or in
combination (by means of repeated calls to NDF\_NOACC), in order to impose
the corresponding restriction on NDF access: 

\begin{description}

\item{\bf `BOUNDS' --} Disabling {\em bounds\/} access prevents the
pixel-index bounds of a base NDF from being altered ({\em e.g.}\ with the
routine NDF\_SBND -- \S\ref{ss:sbnd}). 
The pixel-index bounds of an NDF {\em section\/} can always be altered
regardless of this access restriction, but the restriction will be
propagated to any new identifier obtained from an NDF section via the
routine NDF\_BASE. 

\item{\bf `DELETE' --} Disabling {\em delete\/} access prevents the NDF from
being deleted ({\em e.g.}\ with the routine NDF\_DELET -- \S\ref{ss:delet}).

\item{\bf `SHIFT' --} Disabling {\em shift\/} access prevents pixel-index
shifts from being applied to a base NDF ({\em e.g.}\ with the routine
NDF\_SHIFT -- \S\ref{ss:shift}). 
Pixel-index shifts may always be applied to an NDF section regardless of
this access restriction, but the restriction will be propagated to any new
identifier obtained from an NDF section via the routine NDF\_BASE. 

\item{\bf `TYPE' --} Disabling {\em type\/} access prevents the type of any
NDF component from being altered ({\em e.g.}\ with the routine NDF\_STYPE --
\S\ref{ss:stype}). 

\item{\bf `WRITE' --} Disabling {\em write\/} access prevents new values from 
being written to any of the NDF's components.
It also prevents the state of any of its components from being reset ({\em
e.g.}\ with the routine NDF\_RESET -- \S\ref{ss:reset}). 

\end{description}

In addition, specifying an access type of `MODIFY' in a call to NDF\_NOACC 
will disable \underline{all} the forms of access described above.

You can enquire whether a specified type of access is available via any 
identifier by using the routine NDF\_ISACC. 
For instance: 

\small
\begin{verbatim}
      CALL NDF_ISACC( INDF, 'WRITE', ISACC, STATUS )
\end{verbatim}
\normalsize

will return a logical value ISACC indicating whether {\em write\/} access is
available for the identifier INDF. 

\subsection{Message System Routines}

Several of the NDF\_ routines are dedicated to generating components of 
messages, either for information or as part of an error report.
These routines use the Starlink error and message reporting system and
integrate with the ERR\_ and MSG\_ routines (SUN/104). 

The routine NDF\_MSG may be used to assign the name of an NDF to a message
token, so that references to NDFs can form part of a message, as follows: 

\small
\begin{verbatim}
      CALL NDF_MSG( 'NAME', INDF )
      CALL MSG_OUT( 'MESS_DEMO',
     :              'This NDF structure is called ^NAME', STATUS )
\end{verbatim}
\normalsize

Here, `NAME' is the message token name.

The routine NDF\_CMSG may be used in a similar way to assign the value of an
NDF character component to a message token, while NDF\_ACMSG may be used to
assign the value of an {\em axis\/} character component (such as an {\em
axis label\/}) to a message token. 
Their use is illustrated in \S\ref{ss:cmsg} and \S\ref{ss:acmsg}
respectively. 

\subsection{Controlling Error Reporting}

All the NDF\_ routines use the standard Starlink strategy for handling and
reporting errors which occur during program execution (see SUN/104). 
As a result, when any NDF\_ routine fails, and sets its STATUS argument to
an error value, an error report will be made.
This will contain information about the circumstances of the error and
should normally be adequate to indicate what has caused it. 

Very occasionally, however, unexpected errors may occur whose cause is not 
immediately obvious.
In such cases, the NDF\_ system allows an additional level of error 
reporting to be invoked so that such problems can be traced and, if 
necessary, debugged.
This facility can be turned on and off by calling the routine NDF\_TRACE, as
follows: 

\small
\begin{verbatim}
      LOGICAL NEWFLG, OLDFLG

      ...

      CALL NDF_TRACE( NEWFLG, OLDFLG )
\end{verbatim}
\normalsize

This allows a new logical value to be set for the internal NDF\_ system {\em
error tracing flag}, and returns the old value at the same time. 

If this flag is set to .TRUE., then any error occurring within the NDF\_
system (or within a routine which it calls) will be accompanied by
additional error reports which trace the sequence of internal NDF\_ routines
which have terminated abnormally as a result.
This indicates the sequence of internal calls which led to the error. 
If the error tracing flag is reset to .FALSE.\ (its default value), then
normal error reporting will be re-established. 

\subsection{Tuning the NDF\_ System}
\label{ss:tuning}

The routine NDF\_TUNE is provided to allow other features of the NDF\_ system to
be configured for individual needs if the default behaviour is not appropriate.
This process is referred to as {\em tuning} the system, and is performed as in
the following example:

\small
\begin{verbatim}
      CALL NDF_TUNE( 0, 'WARN', STATUS )
\end{verbatim}
\normalsize

Here, a new value of zero is specified for the {\em tuning parameter} called
`WARN' (at present this is the only parameter available -- see below). The
current setting of a tuning parameter may be determined using the related
routine NDF\_GTUNE which returns the parameter's value via its VALUE argument,
as follows:

\small
\begin{verbatim}
      INTEGER VALUE

      ...

      CALL NDF_GTUNE( 'WARN', VALUE, STATUS )
\end{verbatim}
\normalsize

By using these two routines in pairs it is possible to determine the original
setting of a tuning parameter, modify it locally, and then return it to its
original value if necessary.

Each tuning parameter controls one aspect of the NDF\_ system's behaviour
according to the value which has been set for it, as follows:

\begin{description}

\item[{\bf WARN:}]\mbox{}\\
Controls the issuing of warning messages when certain non-fatal errors in the
structure of NDF data objects are detected. If WARN is set to 1 (the default),
then a warning message is issued. If WARN is set to 0, then no message is
issued.  In both cases normal execution continues and no STATUS value is set.

\end{description}


\section{COMPILING AND LINKING}
\label{ss:compilingandlinking}

ADAM users need take no special steps in order to access routines from
the NDF\_ library. The normal ADAM startup commands:

\small
\begin{verbatim}
   $ ADAMSTART
   $ ADAMDEV
\end{verbatim}
\normalsize

will ensure that all necessary definitions are made, and the standard
ADAM link commands will automatically access the appropriate version of
the NDF\_ library. Thus, for instance, an ADAM A-task which calls NDF\_
routines might be linked simply as follows:

\small
\begin{verbatim}
   $ FORTRAN ADAMPROG
   $ ALINK ADAMPROG
\end{verbatim}
\normalsize

For non-ADAM users, the initialisation command:

\small
\begin{verbatim}
   $ NDF_DEV
\end{verbatim}
\normalsize

must first be executed before compiling or linking an application which
calls NDF\_ routines. This will define all the logical names required
for accessing include files and linker options files.

The preferred method of linking ``stand-alone'' ({\em i.e.}\ non-ADAM)
applications which use the NDF\_ library is via the standard STAR\_LINK
options file. Thus, to compile and link a stand-alone application, the
following might be used:

\small
\begin{verbatim}
   $ FORTRAN PROG
   $ LINK PROG,STAR_LINK/OPT
\end{verbatim}
\normalsize

If, for any reason, you wish to link explicitly with the NDF\_ library,
rather than via the STAR\_LINK library, then the options file NDF\_LINK
may be used instead, thus:

\small
\begin{verbatim}
   $ LINK PROG,NDF_LINK/OPT
\end{verbatim}
\normalsize

The ADAM and stand-alone versions of the NDF\_ system differ, in that those
routines which use ADAM facilities ({\em i.e.}\ those listed in
\S\ref{ss:adamroutinelist}) are not available in the stand-alone version. 
Note, also, that when using the stand-alone version, it is necessary to 
ensure that HDS\_START is called to activate HDS prior to making any calls 
to the NDF\_ system.
This is not necessary with the ADAM version.

\newpage
\appendix
\section{EXAMPLE APPLICATIONS}
\label{ss:exampleapplications}

This section contains a few simple example applications which demonstrate the
use of NDF\_ routines in real-life situations. These bring together many of the
facilities which are described in relative isolation in other parts of the
document.

All the following applications are written as ADAM A-tasks (see
\S\ref{ss:compilingandlinking} for details of how to compile and link an A-task
which calls NDF\_ routines), and each may be extracted and used directly from
the source of this document if required. On Starlink systems, this can be found
in the file DOCSDIR:SUN33.TEX.

Readers who require a tutorial introduction to ADAM should consult SUN/101.

\subsection{SHOW --- Display the size of an NDF}

This first example is trivial and simply serves to show the overall structure of
an ADAM application which calls the NDF\_ library. It outputs a message showing
how many pixels there are in an NDF.

\small
\begin{verbatim}
      SUBROUTINE SHOW( STATUS )
*+
*  Name:
*     SHOW

*  Purpose:
*     Show the size of an NDF.

*  Description:
*     This routine outputs a message showing how many pixels there are
*     in an NDF.

*  ADAM Parameters:
*     NDF = NDF (Read)
*        The NDF whose size is to be displayed.

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      INTEGER INDF               ! NDF identifier
      INTEGER NPIX               ! Number of NDF pixels

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Obtain the input NDF and inquire its size.
      CALL NDF_ASSOC( 'NDF', 'READ', INDF, STATUS )
      CALL NDF_SIZE( INDF, NPIX, STATUS )

*  Display the size.
      CALL MSG_SETI( 'NPIX', NPIX )
      CALL MSG_OUT( 'SHOW_SIZE', 'This NDF has ^NPIX pixels.', STATUS )

*  Annul the NDF identifier.
      CALL NDF_ANNUL( INDF, STATUS )

      END
\end{verbatim}
\normalsize

The following is an example ADAM interface file (SHOW.IFL) for the application
above. 

\small
\begin{verbatim}
interface SHOW

   parameter NDF                 # NDF to be inspected
      position 1
      prompt   'NDF data structure'
   endparameter

endinterface
\end{verbatim}
\normalsize

\newpage
\subsection{SETTITLE --- Assign a New NDF Title}
\label{ss:titleexample}

The following example is a simple application which sets a new {\em title\/} for
an existing NDF. Note the use of `UPDATE' access since an existing NDF is being
modified, rather than creating a new one.

\small
\begin{verbatim}
      SUBROUTINE SETTITLE( STATUS )
*+
*  Name:
*     SETTITLE

*  Purpose:
*     Set a new title for an NDF data structure.

*  Description:
*     This routine sets a new value for the title component of an
*     existing NDF data structure. The NDF is accessed in update mode
*     and any pre-existing title is over-written with a new value.
*     Alternatively, if a "null" value (!) is given for the TITLE
*     parameter, then the NDF's title will be erased.

*  ADAM Parameters:
*     NDF = NDF (Read and Write)
*        The NDF data structure whose title is to be modified.
*     TITLE = LITERAL (Read)
*        The value to be assigned to the NDF's title component. [!]

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      INTEGER NDF                ! NDF identifier

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Obtain an identifier for the NDF to be modified.
      CALL NDF_ASSOC( 'NDF', 'UPDATE', NDF, STATUS )

*  Reset any existing title.
      CALL NDF_RESET( NDF, 'Title', STATUS )

*  Obtain a new title.
      CALL NDF_CINP( 'TITLE', NDF, 'Title', STATUS )

*  Annul the NDF identifier.
      CALL NDF_ANNUL( NDF, STATUS )

      END
\end{verbatim}
\normalsize

The following is an example ADAM interface file (SETTITLE.IFL) for the
application above. 

\small
\begin{verbatim}
   interface SETTITLE

      parameter NDF                 # NDF to be modified
         position 1
         prompt   'Data structure'
      endparameter

      parameter TITLE               # New title value
         position 2
         type     'LITERAL'
         prompt   'New NDF title'
      endparameter

   endinterface
\end{verbatim}
\normalsize

\newpage
\subsection{GETMAX --- Obtain the Maximum Pixel Value}

The following application calculates and displays the maximum pixel value in an
NDF's {\em data\/} array. It is typical of a class of applications which read a
single NDF as input, but do not produce any output data structure.

In this example, the choice has been made to handle all values using single
precision (\_REAL) arithmetic and not to handle {\em bad\/} pixel values at all.
Strictly speaking, the call to NDF\_MBAD to check for the presence of {\em
bad\/} pixels is not essential, but it does help by producing an error message
if someone should inadvertently use this program on data which does contain {\em
bad\/} pixels.

\small
\begin{verbatim}
      SUBROUTINE GETMAX( STATUS )
*+
*  Name:
*     GETMAX

*  Purpose:
*     Obtain the maximum pixel value.

*  Description:
*     This routine finds the maximum pixel value in the data array of
*     an NDF and displays the result.

*  ADAM Parameters:
*     NDF = NDF (Read)
*        The NDF data structure whose data array is to be examined.

*  Implementation Status:
*     This routine deliberately does not handle NDFs whose data arrays
*     contain bad pixels. Real arithmetic is used to compute the
*     maximum.

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      INTEGER EL                 ! Number of mapped pixels
      INTEGER INDF               ! NDF identifier
      INTEGER PNTR( 1 )          ! Pointer to mapped values
      LOGICAL BAD                ! Bad pixels present? (junk variable)
      REAL HIGH                  ! Maximum pixel value

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Obtain the input NDF and map its data array as _REAL values for
*  reading.
      CALL NDF_ASSOC( 'NDF', 'READ', INDF, STATUS )
      CALL NDF_MAP( INDF, 'Data', '_REAL', 'READ', PNTR, EL, STATUS )

*  Check that there are no bad pixels present.
      CALL NDF_MBAD( .FALSE., INDF, INDF, 'Data', .TRUE., BAD, STATUS )

*  Find the maximum pixel value and display the result.
      CALL MAXIT( EL, %VAL( PNTR( 1 ) ), HIGH, STATUS )
      CALL MSG_SETR( 'HIGH', HIGH )
      CALL MSG_OUT( 'GETMAX_HIGH', '   Maximum value is ^HIGH', STATUS )

*  Annul the NDF identifier.
      CALL NDF_ANNUL( INDF, STATUS )

      END

      SUBROUTINE MAXIT( EL, ARRAY, HIGH, STATUS )
*+
*  Name:
*     MAXIT

*  Purpose:
*     Find the maximum value in a real array.

*  Invocation:
*     CALL MAXIT( EL, ARRAY, HIGH, STATUS )

*  Description:
*     The routine returns the maximum element value in a real array.

*  Arguments:
*     EL = INTEGER (Given)
*        Number of array elements.
*     ARRAY( EL ) = REAL (Given)
*        The real array.
*     HIGH = REAL (Returned)
*        Maximum element value.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants

*  Arguments Given:
      INTEGER EL
      REAL ARRAY( * )

*  Arguments Returned:
      REAL HIGH

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      INTEGER I                  ! Loop counter

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Find the maximum array value.
      HIGH = ARRAY( 1 )
      DO 1 I = 2, EL
         IF ( ARRAY( I ) .GT. HIGH ) HIGH = ARRAY( I )
 1    CONTINUE

      END
\end{verbatim}
\normalsize

The following is an example ADAM interface file (GETMAX.IFL) for the application
above. 

\small
\begin{verbatim}
interface GETMAX

   parameter NDF                 # NDF to be examined
      position 1
      prompt   'Data structure'
   endparameter

endinterface
\end{verbatim}
\normalsize

\newpage
\subsection{GETSUM --- Sum the Pixel Values}

This application is a logical extension of the previous one, except that it sums
the pixel values in an NDF's data array, rather than finding the maximum pixel
value. In this example, however, we first check to determine whether or not
there may be {\em bad\/} pixel values in the input NDF, and then adapt the
algorithm to accommodate either case. Any {\em bad\/} pixels are excluded from
the result.

Simple error reporting is also introduced in this example; an error report is
generated if the input data array does not contain any good ({\em i.e.\/}
non-{\em bad\/}) pixels.

\small
\begin{verbatim}
      SUBROUTINE GETSUM( STATUS )
*+
*  Name:
*     GETSUM

*  Purpose:
*     Sum the pixels in an NDF's data array.

*  Description:
*     This routine sums the values of the pixels in an NDF's data array
*     and displays the result. Any bad pixels which may be present are
*     excluded from the sum.

*  ADAM Parameters:
*     NDF = NDF (Read)
*        The NDF data structure whose data array is to be examined.

*  Implementation Status:
*     This routine can handle data with or without bad pixels (and
*     hence can also handle a quality array if present). Real
*     arithmetic is used for forming the pixel sum.

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      INTEGER EL                 ! Number of mapped pixels
      INTEGER INDF               ! NDF identifier
      INTEGER NGOOD              ! Number of good pixels
      INTEGER PNTR( 1 )          ! Pointer to mapped values
      LOGICAL BAD                ! Bad pixel present?
      REAL SUM                   ! Pixel sum

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Obtain the input NDF and map its data array as _REAL values for
*  reading.
      CALL NDF_ASSOC( 'NDF', 'READ', INDF, STATUS )
      CALL NDF_MAP( INDF, 'Data', '_REAL', 'READ', PNTR, EL, STATUS )

*  See if bad pixel values are present.
      CALL NDF_BAD( INDF, 'Data', .FALSE., BAD, STATUS )

*  Sum the pixel values and display the result.
      CALL SUMIT( BAD, EL, %VAL( PNTR( 1 ) ), SUM, NGOOD, STATUS )
      IF ( NGOOD .GT. 0 ) THEN
         CALL MSG_SETR( 'SUM', SUM )
         CALL MSG_OUT( 'GETSUM_SUM',
     :                 '   Sum of pixels is ^SUM', STATUS )

*  Report an error if there are no good pixels present.
      ELSE
         STATUS = SAI__ERROR
         CALL NDF_MSG( 'NDF', INDF )
         CALL ERR_REP( 'GETSUM_ALLBAD',
     :   'GETSUM: All the data pixels in the NDF ^NDF are bad.',
     :   STATUS )
      END IF

*  Annul the NDF identifier.
      CALL NDF_ANNUL( INDF, STATUS )

      END

      SUBROUTINE SUMIT( BAD, EL, ARRAY, SUM, NGOOD, STATUS )
*+
*  Name:
*     SUMIT

*  Purpose:
*     Sum the elements of a real array, allowing for bad values.

*  Invocation:
*     CALL SUMIT( BAD, EL, ARRAY, SUM, NGOOD, STATUS )

*  Description:
*     The routine returns the sum of the elements of a real array,
*     excluding any which have the bad value.

*  Arguments:
*     BAD = LOGICAL (Given)
*        Whether bad pixel values may be present.
*     EL = INTEGER (Given)
*        Number of array elements.
*     ARRAY( EL ) = REAL (Given)
*        The real array.
*     SUM = REAL (Returned)
*        Sum of the elements.
*     NGOOD = INTEGER (Returned)
*        Number of good (non-bad) elements.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'PRM_PAR'          ! Define the VAL__BADR constant

*  Arguments Given:
      LOGICAL BAD
      INTEGER EL
      REAL ARRAY( * )

*  Arguments Returned:
      REAL SUM
      INTEGER NGOOD

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      INTEGER I                  ! Loop counter

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  If there are no bad values, simply sum the array elements.
      IF ( .NOT. BAD ) THEN
         SUM = 0.0
         NGOOD = EL
         DO 1 I = 1, EL
            SUM = SUM + ARRAY( I )
 1       CONTINUE

*  Otherwise, test each element before using it.
      ELSE
         SUM = 0.0
         NGOOD = 0
         DO 2 I = 1, EL
            IF ( ARRAY( I ) .NE. VAL__BADR ) THEN
               SUM = SUM + ARRAY( I )
               NGOOD = NGOOD + 1
            END IF
 2       CONTINUE
      END IF

      END
\end{verbatim}
\normalsize

The following is an example ADAM interface file (GETSUM.IFL) for the application
above. 

\small
\begin{verbatim}
interface GETSUM

   parameter NDF                 # NDF to be examined
      position 1
      prompt   'Data structure'
   endparameter

endinterface
\end{verbatim}
\normalsize

\newpage
\subsection{READIMG -- Read an image into an NDF}

The following is a simple example of how to create a new NDF data structure from
scratch, in this case starting with image data read from am unformatted
sequential Fortran file. This is typical of how the NDF-based half of a format
conversion application (designed to read data from another format into an NDF)
might look. This example could be modified to read other formats by
appropriately replacing the routine which reads the data from the file.

In this example, use has been made of the FIO\_ package (APN/9) to allocate a
Fortran I/O unit.\footnote{For a short period it may be necessary to include
ADAM\_LIB:FIOLINK/OPT on the linker command line in order to link with these
routines.} Some moderately elaborate error reporting is also illustrated; this
gives helpful error messages in response to I/O errors and a final contextual
report at the end of the application.

\small
\begin{verbatim}
      SUBROUTINE READIMG( STATUS )
*+
*  Name:
*     READIMG

*  Purpose:
*     Read an image into an NDF.

*  Description:
*     This routine reads a 2-dimensional real image into an NDF data
*     structure from an unformatted sequential Fortran file. The image
*     data are assumed to be stored one line per record in the file.

*  ADAM Parameters:
*     FILE = LITERAL (Read)
*        Name of the input file.
*     NDF = NDF (Write)
*        The output NDF data structure.
*     NX = INTEGER (Read)
*        Number of pixels per image line.
*     NY = INTEGER (Read)
*        Number of lines in the image.

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'FIO_PAR'          ! Define FIO__SZFNM constant

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      CHARACTER * ( FIO__SZFNM ) FILE ! Input file name
      INTEGER DIM( 2 )           ! Image dimension sizes
      INTEGER EL                 ! Number of mapped values
      INTEGER INDF               ! NDF identifier
      INTEGER IOERR              ! I/O error status
      INTEGER IOUNIT             ! Fortran I/O unit number
      INTEGER PNTR( 1 )          ! Pointer to mapped values

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Obtain the name of the input file and allocate an I/O unit on which
*  to open it.
      CALL PAR_GET0C( 'FILE', FILE, STATUS )
      CALL FIO_GUNIT( IOUNIT, STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Open the file, trapping and reporting any errors.
      OPEN( FILE = FILE, UNIT = IOUNIT, STATUS = 'OLD',
     :      FORM = 'UNFORMATTED', IOSTAT = IOERR )
      IF ( IOERR .NE. 0 ) THEN
         STATUS = SAI__ERROR
         CALL MSG_SETC( 'FILE', FILE )
         CALL MSG_SETI( 'IOUNIT', IOUNIT )
         CALL ERR_FIOER( 'MESSAGE', IOERR )
         CALL ERR_REP( 'READIMG_OPEN',
     :   'Unable to open file ^FILE on Fortran unit ^IOUNIT - ' //
     :   '^MESSAGE', STATUS )
         GO TO 99
      END IF

*  Obtain the dimension sizes of the image to be read and check the
*  values obtained for validity.
      CALL PAR_GET0I( 'NX', DIM( 1 ), STATUS )
      CALL PAR_GET0I( 'NY', DIM( 2 ), STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 99
      IF ( ( DIM( 1 ) .LT. 1 ) .OR. ( DIM( 2 ) .LT. 1 ) ) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP( 'READIMG_BADDIM',
     :   'Image dimensions must be positive.', STATUS )
         GO TO 99
      END IF

*  Create an output NDF of the correct size and map its data array as
*  _REAL values for writing.
      CALL NDF_CREP( 'NDF', '_REAL', 2, DIM, INDF, STATUS )
      CALL NDF_MAP( INDF, 'Data', '_REAL', 'WRITE', PNTR, EL, STATUS )

*  Read the image values from the input file into the mapped array.
      CALL READIT( IOUNIT, DIM( 1 ), DIM( 2 ), %VAL( PNTR( 1 ) ),
     :             STATUS )

*  Annul the NDF identifier, close the input file and deallocate the I/O
*  unit.
 99   CONTINUE     
      CALL NDF_ANNUL( INDF, STATUS )
      CLOSE( UNIT = IOUNIT )
      CALL FIO_PUNIT( IOUNIT, STATUS )

*  If an error occurred, then report contextual information.
      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'READIMG_ERR',
     :   'READIMG: Error reading an image into an NDF from a ' //
     :   'Fortran file.', STATUS )
      END IF      

      END

      SUBROUTINE READIT( IOUNIT, NX, NY, ARRAY, STATUS )
*+
*  Name:
*     READIT

*  Purpose:
*     Read an image from a file.

*  Invocation:
*     CALL READIT( IOUNIT, NX, NY, ARRAY, STATUS )

*  Description:
*     The routine reads a real image from an unformatted sequential
*     Fortran file, one image line per record.

*  Arguments:
*     IOUNIT = INTEGER (Given)
*        The Fortran I/O unit on which to read the (previously opened)
*        file.
*     NX = INTEGER (Given)
*        Number of pixels per image line.
*     NY = INTEGER (Given)
*        Number of lines in the image.
*     ARRAY( NX, NY ) = REAL (Returned)
*        The image array to be read.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'FIO_PAR'          ! Define FIO__SZFNM constant

*  Arguments Given:
      INTEGER IOUNIT
      INTEGER NX
      INTEGER NY

*  Arguments Returned:
      REAL ARRAY( NX, NY )

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      CHARACTER * ( FIO__SZFNM ) FILE ! File name
      INTEGER IGNORE             ! Inquire status (ignored)
      INTEGER IOERR              ! I/O error status
      INTEGER IX                 ! Loop counter for image pixels
      INTEGER IY                 ! Loop counter for image lines

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Read each line of the image from the file, trapping any errors.
      DO 1 IY = 1, NY
         READ( IOUNIT, IOSTAT = IOERR ) ( ARRAY( IX, IY ), IX= 1, NX )

*  If an error occurred, then construct a helpful error report and
*  abort.
         IF ( IOERR .NE. 0 ) THEN
            STATUS = SAI__ERROR
            INQUIRE ( UNIT = IOUNIT, NAME = FILE, IOSTAT = IGNORE )
            CALL MSG_SETC( 'FILE', FILE )
            CALL MSG_SETI( 'IOUNIT', IOUNIT )
            CALL ERR_FIOER( 'MESSAGE', IOERR )
            CALL ERR_REP( 'READIT_ERR',
     :      'Error reading file ^FILE on Fortran unit ^IOUNIT - ' //
     :      '^MESSAGE', STATUS )
            GO TO 99
         END IF
 1    CONTINUE

*  Jump to here if an error occurs.
 99   CONTINUE     
      END
\end{verbatim}
\normalsize

The following is an example ADAM interface file (READIMG.IFL) for the
application above. 

\small
\begin{verbatim}
interface READIMG

   parameter FILE                # Input file name
      position 1
      type     LITERAL
      prompt   'Input file'
   endparameter

   parameter NDF                 # Output NDF
      position 4
      prompt   'Output NDF'
   endparameter

   parameter NX                  # Number of pixels per line
      position 2
      type     _INTEGER
      prompt   'X dimension of image'
   endparameter

   parameter NY                  # Number of lines in image
      position 3
      type     _INTEGER
      prompt   'Y dimension of image'
   endparameter

endinterface
\end{verbatim}
\normalsize

\newpage
\subsection{ZAPPIX --- ``Zap'' Prominent Pixels in an Image}

The following example is based around a simple algorithm which detects prominent
pixels ({\em e.g.\/} data spikes) in a 2-dimensional image and replaces them with
{\em bad\/} pixels. It is typical of applications which take a single NDF as
input and produce a new NDF with the same size as output. It illustrates the use
of {\em propagation\/} (NDF\_PROP) in producing the new output NDF using the input
as a template. Note that this application modifies the {\em data\/} array but
does not handle the {\em variance \/} array, which will therefore become invalid
and is not propagated.

This example also illustrates how {\em bad\/} pixels might be handled in a
reasonably realistic image-processing algorithm. No attempt is made here to
distinguish cases where {\em bad\/} pixels are present from those where they are
not, and we do not really know afterwards if there are any {\em bad\/} pixels in
the output image (although a check for this could easily be added). The output
{\em bad\/}-pixel flag is therefore left with its default value of
.TRUE..

\small
\begin{verbatim}
      SUBROUTINE ZAPPIX( STATUS )
*+
*  Name:
*     ZAPPIX

*  Purpose:
*     Zap prominent pixels.

*  Description:
*     This routine "zaps" prominent pixels in a 2-dimensional image
*     (stored in the data array of an NDF). It searches for pixels
*     which deviate by more than a specified amount from the mean of
*     their nearest neighbours, and replaces them with bad pixels.

*  ADAM Parameters:
*     IN = NDF (Read)
*        Input NDF data structure.
*     OUT = NDF (Write)
*        The output NDF data structure.
*     THRESH = _REAL (Read)
*        Threshold for zapping pixels; pixels will be set bad if they
*        deviate by more than this amount from the mean of their
*        nearest neighbours (the absolute value of THRESH is used).

*  Implementation Status:
*     This routine correctly handles bad pixels but does not handle NDF
*     variance arrays. Real arithmetic is used.

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      INTEGER DIM( 2 )           ! Image dimension sizes
      INTEGER EL                 ! Number of mapped values
      INTEGER INDF1              ! Input NDF identifier
      INTEGER INDF2              ! Output NDF identifier
      INTEGER NDIM               ! Number of NDF dimensions (junk)
      INTEGER PNTR1( 1 )         ! Pointer to mapped input values
      INTEGER PNTR2( 1 )         ! Pointer to mapped output values
      REAL THRESH                ! Threshold for zapping pixels

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Begin an NDF context.
      CALL NDF_BEGIN

*  Obtain the input NDF and obtain its first two dimension sizes.
      CALL NDF_ASSOC( 'IN', 'READ', INDF1, STATUS )
      CALL NDF_DIM( INDF1, 2, DIM, NDIM, STATUS )

*  Obtain a threshold value.
      CALL PAR_GET0R( 'THRESH', THRESH, STATUS )

*  Create an output NDF based on the input one. Propagate the AXIS,
*  QUALITY and UNITS components.
      CALL NDF_PROP( INDF1, 'Axis,Quality,Units', 'OUT', INDF2, STATUS )

*  Map the input and output data arrays for reading and writing
*  respectively.
      CALL NDF_MAP( INDF1, 'Data', '_REAL', 'READ', PNTR1, EL, STATUS )
      CALL NDF_MAP( INDF2, 'Data', '_REAL', 'WRITE', PNTR2, EL, STATUS )
      
*  Process the input array, writing the new values to the output array.
      CALL ZAPIT( ABS( THRESH ), DIM( 1 ), DIM( 2 ), %VAL( PNTR1( 1 ) ),
     :            %VAL( PNTR2( 1 ) ), STATUS )

*  End the NDF context (this cleans everything up).
      CALL NDF_END( STATUS )

*  If an error occurred, then report a contextual message.
      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'ZAPPIX_ERR',
     :   'ZAPPIX: Error zapping prominent pixels in an image.',
     :   STATUS )
      END IF

      END

      SUBROUTINE ZAPIT( THRESH, NX, NY, A, B, STATUS )
*+
*  Name:
*     ZAPIT

*  Purpose:
*     Zap prominent pixels in an image.

*  Invocation:
*     CALL ZAPIT( THRESH, NX, NY, A, B, STATUS )

*  Description:
*     The routine finds all pixels in a 2-dimensional image which
*     deviate by more than a specified amount from the mean of their
*     nearest neighbours and replaces them with the bad pixel value.
*     Bad pixels in the input image are correctly handled.

*  Arguments:
*     THRESH = REAL (Given)
*        The threshold for zapping pixels.
*     NX = INTEGER (Given)
*        X dimension of image.
*     NY = INTEGER (Given)
*        Y dimension of image.
*     A( NX, NY ) = REAL (Given)
*        The input image.
*     B( NX, NY ) = REAL (Returned)
*        The output image.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'PRM_PAR'          ! Define VAL__BADR constant

*  Arguments Given:
      REAL THRESH
      INTEGER NX
      INTEGER NY
      REAL A( NX, NY )

*  Arguments Returned:
      REAL B( NX, NY )

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      INTEGER IIX                ! Loop counter for neighbours
      INTEGER IIY                ! Loop counter for neighbours
      INTEGER IX                 ! Loop counter for image pixels
      INTEGER IY                 ! Loop counter for image pixels
      INTEGER N                  ! Number of good neighbours
      REAL DIFF                  ! Deviation from mean of neighbours
      REAL S                     ! Sum of good neighbours

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Loop through all the pixels in the image.
      DO 4 IY = 1, NY
         DO 3 IX = 1, NX

*  If the input pixel is bad, then so is the output pixel.
            IF ( A( IX, IY ) .EQ. VAL__BADR ) THEN
               B( IX, IY ) = VAL__BADR

*  Otherwise, loop to find the average of the nearest neighbours.
            ELSE
               S = 0.0
               N = 0
               DO 2 IIY = MAX( 1, IY - 1 ), MIN( NY, IY + 1 )
                  DO 1 IIX = MAX( 1, IX - 1 ), MIN( NX, IX + 1 )

*  Only count neighbours which are not bad themselves.
                     IF ( A( IIX, IIY ) .NE. VAL__BADR ) THEN
                        S = S + A( IIX, IIY )
                        N = N + 1
                     END IF
 1                CONTINUE
 2             CONTINUE

*  If all the neighbours were bad, then just copy the central pixel.
               IF ( N .EQ. 0 ) THEN
                  B( IX, IY ) = A( IX, IY )

*  Otherwise, see if the central pixel deviates by more than THRESH from
*  the average. If not, copy it. If so, set it bad.
               ELSE
                  DIFF = A( IX, IY ) - ( S / REAL( N ) )
                  IF ( ABS( DIFF ) .LE. THRESH ) THEN
                     B( IX, IY ) = A( IX, IY )
                  ELSE
                     B( IX, IY ) = VAL__BADR
                  END IF
               END IF
            END IF
 3       CONTINUE
 4    CONTINUE

      END
\end{verbatim}
\normalsize

The following is an example ADAM interface file (ZAPPIX.IFL) for the
application above. 

\small
\begin{verbatim}
interface ZAPPIX

   parameter IN                  # Input NDF
      position 1
      prompt   'Input NDF'
   endparameter

   parameter OUT                 # Output NDF
      position 3
      prompt   'Output NDF'
   endparameter

   parameter THRESH              # Zapping threshold
      position 2
      type     _REAL
      prompt   'Threshold'
   endparameter

endinterface
\end{verbatim}
\normalsize


\newpage
\subsection{ADD --- Add Two NDF Data Structures}
\label{ss:addexample}

The following application adds two NDF data structures pixel-by-pixel. It is a
fairly sophisticated ``add'' application, which will handle both the {\em
data\/} and {\em variance\/} components, as well as coping with NDFs of any
shape and data type.  A much simpler example is given in
\S\ref{ss:applicationoverview}.

\small
\begin{verbatim}
      SUBROUTINE ADD( STATUS )
*+
*  Name:
*     ADD

*  Purpose:
*     Add two NDF data structures.

*  Description:
*     This routine adds two NDF data structures pixel-by-pixel to produce
*     a new NDF.

*  ADAM Parameters:
*     IN1 = NDF (Read)
*        First NDF to be added.
*     IN2 = NDF (Read)
*        Second NDF to be added.
*     OUT = NDF (Write)
*        Output NDF to contain the sum of the two input NDFs.
*     TITLE = LITERAL (Read)
*        Value for the title of the output NDF. A null value will cause
*        the title of the NDF supplied for parameter IN1 to be used
*        instead. [!]

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'NDF_PAR'          ! NDF_ public constants

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      CHARACTER * ( 13 ) COMP    ! NDF component list
      CHARACTER * ( NDF__SZFTP ) DTYPE ! Type for output components
      CHARACTER * ( NDF__SZTYP ) ITYPE ! Numeric type for processing
      INTEGER EL                 ! Number of mapped elements
      INTEGER IERR               ! Position of first error (dummy)
      INTEGER NDF1               ! Identifier for 1st NDF (input)
      INTEGER NDF2               ! Identifier for 2nd NDF (input)
      INTEGER NDF3               ! Identifier for 3rd NDF (output)
      INTEGER NERR               ! Number of errors
      INTEGER PNTR1( 2 )         ! Pointers to 1st NDF mapped arrays
      INTEGER PNTR2( 2 )         ! Pointers to 2nd NDF mapped arrays
      INTEGER PNTR3( 2 )         ! Pointers to 3rd NDF mapped arrays
      LOGICAL BAD                ! Need to check for bad pixels?
      LOGICAL VAR1               ! Variance component in 1st input NDF?
      LOGICAL VAR2               ! Variance component in 2nd input NDF?

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Begin an NDF context.
      CALL NDF_BEGIN

*  Obtain identifiers for the two input NDFs.
      CALL NDF_ASSOC( 'IN1', 'READ', NDF1, STATUS )
      CALL NDF_ASSOC( 'IN2', 'READ', NDF2, STATUS )

*  Trim their pixel-index bounds to match.
      CALL NDF_MBND( 'TRIM', NDF1, NDF2, STATUS )

*  Create a new output NDF based on the first input NDF. Propagate the
*  axis and quality components, which are not changed. This program
*  does not support the units component.
      CALL NDF_PROP( NDF1, 'Axis,Quality', 'OUT', NDF3, STATUS )

*  See if a variance component is available in both input NDFs and
*  generate an appropriate list of input components to be processed.
      CALL NDF_STATE( NDF1, 'Variance', VAR1, STATUS )
      CALL NDF_STATE( NDF2, 'Variance', VAR2, STATUS )
      IF ( VAR1 .AND. VAR2 ) THEN
         COMP = 'Data,Variance'
      ELSE
         COMP = 'Data'
      END IF

*  Determine which numeric type to use to process the input arrays and
*  set an appropriate type for the corresponding output arrays. This
*  program supports integer, real and double-precision arithmetic.
      CALL NDF_MTYPE( '_INTEGER,_REAL,_DOUBLE',
     :                NDF1, NDF2, COMP, ITYPE, DTYPE, STATUS )
      CALL NDF_STYPE( DTYPE, NDF3, COMP, STATUS )

*  Map the input and output arrays.
      CALL NDF_MAP( NDF1, COMP, ITYPE, 'READ', PNTR1, EL, STATUS )
      CALL NDF_MAP( NDF2, COMP, ITYPE, 'READ', PNTR2, EL, STATUS )
      CALL NDF_MAP( NDF3, COMP, ITYPE, 'WRITE', PNTR3, EL, STATUS )

*  Merge the bad pixel flag values for the input data arrays to see if
*  checks for bad pixels are needed.
      CALL NDF_MBAD( .TRUE., NDF1, NDF2, 'Data', .FALSE., BAD, STATUS )

*  Select the appropriate routine for the data type being processed and
*  add the data arrays.
      IF ( STATUS .EQ. SAI__OK ) THEN
         IF ( ITYPE .EQ. '_INTEGER' ) THEN
            CALL VEC_ADDI( BAD, EL, %VAL( PNTR1( 1 ) ),
     :                     %VAL( PNTR2( 1 ) ), %VAL( PNTR3( 1 ) ),
     :                     IERR, NERR, STATUS )

         ELSE IF ( ITYPE .EQ. '_REAL' ) THEN
            CALL VEC_ADDR( BAD, EL, %VAL( PNTR1( 1 ) ),
     :                     %VAL( PNTR2( 1 ) ), %VAL( PNTR3( 1 ) ),
     :                     IERR, NERR, STATUS )

         ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
            CALL VEC_ADDD( BAD, EL, %VAL( PNTR1( 1 ) ),
     :                     %VAL( PNTR2( 1 ) ), %VAL( PNTR3( 1 ) ),
     :                     IERR, NERR, STATUS )
         END IF

*  Flush any messages resulting from numerical errors.
         IF ( STATUS .NE. SAI__OK ) CALL ERR_FLUSH( STATUS )
      END IF

*  See if there may be bad pixels in the output data array and set the
*  output bad pixel flag value accordingly.
      BAD = BAD .OR. ( NERR .NE. 0 )
      CALL NDF_SBAD( BAD, NDF3, 'Data', STATUS )

*  If variance arrays are also to be processed (i.e. added), then see
*  if bad pixels may be present.
      IF ( VAR1 .AND. VAR2 ) THEN
         CALL NDF_MBAD( .TRUE., NDF1, NDF2, 'Variance', .FALSE., BAD,
     :                  STATUS )

*  Select the appropriate routine to add the variance arrays.
	 IF (STATUS .EQ. SAI__OK ) THEN
            IF ( ITYPE .EQ. '_INTEGER' ) THEN
               CALL VEC_ADDI( BAD, EL, %VAL( PNTR1( 2 ) ),
     :                        %VAL( PNTR2( 2 ) ), %VAL( PNTR3( 2 ) ),
     :                        IERR, NERR, STATUS )

            ELSE IF ( ITYPE .EQ. '_REAL' ) THEN
               CALL VEC_ADDR( BAD, EL, %VAL( PNTR1( 2 ) ),
     :                        %VAL( PNTR2( 2 ) ), %VAL( PNTR3( 2 ) ),
     :                        IERR, NERR, STATUS )

            ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
               CALL VEC_ADDD( BAD, EL, %VAL( PNTR1( 2 ) ),
     :                        %VAL( PNTR2( 2 ) ), %VAL( PNTR3( 2 ) ),
     :                        IERR, NERR, STATUS )
            END IF

*  Flush any messages resulting from numerical errors.
            IF ( STATUS .NE. SAI__OK ) CALL ERR_FLUSH( STATUS )
         END IF

*  See if bad pixels may be present in the output variance array and
*  set the bad pixel flag accordingly.
         BAD = BAD .OR. ( NERR .NE. 0 )
         CALL NDF_SBAD( BAD, NDF3, 'Variance', STATUS )
      END IF

*  Obtain a new title for the output NDF.
      CALL NDF_CINP( 'TITLE', NDF3, 'Title', STATUS )
      
*  End the NDF context.
      CALL NDF_END( STATUS )

*  If an error occurred, then report context information.
      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'ADD_ERR',
     :   'ADD: Error adding two NDF data structures.', STATUS )
      END IF

      END
\end{verbatim}
\normalsize

The following is an example ADAM interface file (ADD.IFL) for the application
above. 

\small
\begin{verbatim}
   interface ADD

      parameter IN1                 # First input NDF
         position 1
         prompt   'First input NDF'
      endparameter

      parameter IN2                 # Second input NDF
         position 2
         prompt   'Second input NDF'
      endparameter

      parameter OUT                 # Output NDF
         position 3
         prompt   'Output NDF'
      endparameter

      parameter TITLE               # Title for output NDF
         type     'LITERAL'
         prompt   'Title for output NDF'
         vpath    'DEFAULT'
         default  !
      endparameter

   endinterface
\end{verbatim}
\normalsize

\newpage
\subsection{NDFTRACE --- Trace an NDF Structure}
\label{ss:tracingndf}

The following rather long example is an application to display the attributes of
an NDF data structure. 
It is probably not typical of the use to which the NDF\_ routines will be
put, but it demonstrates the use of most of the enquiry routines and
provides a ``guided tour'' of the NDF components.

\small
\begin{verbatim}
      SUBROUTINE NDFTRACE( STATUS )
*+
*  Name:
*     NDFTRACE

*  Purpose:
*     Display the attributes of an NDF data structure.

*  Description:
*     This routine displays the attributes of an NDF data structure
*     including its name, the values of its character components, its
*     shape and the attributes of its data array and of any other array
*     components present. A list of any extensions present, together
*     with their HDS data types, is also included.

*  ADAM Parameters:
*     NDF = NDF (Read)
*        The NDF data structure whose attributes are to be displayed.

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'NDF_PAR'          ! NDF_ public constants
      INCLUDE 'PRM_PAR'          ! PRIMDAT primitive data constants

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      BYTE BADBIT                ! Bad-bits mask
      CHARACTER * ( 8 ) BINSTR   ! Binary bad-bits mask string
      CHARACTER * ( NDF__MXDIM * ( 2 * VAL__SZI + 3 ) - 2 ) BUF
                                 ! Text buffer for shape information
      CHARACTER * ( DAT__SZLOC ) XLOC ! Extension locator
      CHARACTER * ( DAT__SZTYP ) TYPE ! Extension type
      CHARACTER * ( NDF__SZFRM ) FORM ! Storage form
      CHARACTER * ( NDF__SZFTP ) FTYPE ! Full data type
      CHARACTER * ( NDF__SZXNM ) XNAME ! Extension name
      INTEGER BBI                ! Bad-bits value as an integer
      INTEGER DIGVAL             ! Binary digit value
      INTEGER DIM( NDF__MXDIM )  ! Dimension sizes
      INTEGER I                  ! Loop counter for dimensions
      INTEGER IAXIS              ! Loop counter for axes
      INTEGER IDIG               ! Loop counter for binary digits
      INTEGER INDF               ! NDF identifier
      INTEGER LBND( NDF__MXDIM ) ! Lower pixel-index bounds
      INTEGER N                  ! Loop counter for extensions
      INTEGER NC                 ! Character count
      INTEGER NDIM               ! Number of dimensions
      INTEGER NEXTN              ! Number of extensions
      INTEGER SIZE               ! Total number of pixels
      INTEGER UBND( NDF__MXDIM ) ! Upper pixel-index bounds
      LOGICAL BAD                ! Bad pixel flag
      LOGICAL THERE              ! Whether NDF component is defined

*  Internal References:
      INCLUDE 'NUM_DEC_CVT'      ! NUM_ type conversion routines
      INCLUDE 'NUM_DEF_CVT'

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Obtain an identifier for the NDF structure to be examined.
      CALL NDF_ASSOC( 'NDF', 'READ', INDF, STATUS )

*  Display the NDF's name.
      CALL MSG_OUT( 'BLANK', ' ', STATUS )
      CALL NDF_MSG( 'NDF', INDF )
      CALL MSG_OUT( 'HEADER', '   NDF structure ^NDF:', STATUS )

*  Character components:
*  ====================
*  See if the title component is defined. If so, then display its
*  value.
      CALL NDF_STATE( INDF, 'Title', THERE, STATUS )
      IF ( THERE ) THEN
         CALL NDF_CMSG( 'TITLE', INDF, 'Title', STATUS )
         CALL MSG_OUT( 'TITLE', '      Title:  ^TITLE', STATUS )
      END IF

*  See if the label component is defined. If so, then display its
*  value.
      CALL NDF_STATE( INDF, 'Label', THERE, STATUS )
      IF ( THERE ) THEN
         CALL NDF_CMSG( 'LABEL', INDF, 'Label', STATUS )
         CALL MSG_OUT( 'LABEL', '      Label:  ^LABEL', STATUS )
      END IF

*  See if the units component is defined. If so, then display its
*  value.
      CALL NDF_STATE( INDF, 'Units', THERE, STATUS )
      IF ( THERE ) THEN
         CALL NDF_CMSG( 'UNITS', INDF, 'Units', STATUS )
         CALL MSG_OUT( 'UNITS', '      Units:  ^UNITS', STATUS )
      END IF

*  NDF shape:
*  =========
*  Obtain the dimension sizes.
      CALL NDF_DIM( INDF, NDF__MXDIM, DIM, NDIM, STATUS )

*  Display a header for this information.
      CALL MSG_OUT( 'BLANK', ' ', STATUS )
      CALL MSG_OUT( 'SHAPE_HEADER', '   Shape:', STATUS )

*  Display the number of dimensions.
      CALL MSG_SETI( 'NDIM', NDIM )
      CALL MSG_OUT( 'DIMENSIONALITY',
     : '      No. of dimensions:  ^NDIM', STATUS )

*  Construct a string showing the dimension sizes.
      NC = 0
      DO 1 I = 1, NDIM
          IF ( I .GT. 1 ) CALL CHR_PUTC( ' x ', BUF, NC )
          CALL CHR_PUTI( DIM( I ), BUF, NC )
 1    CONTINUE
      CALL MSG_SETC( 'DIMS', BUF( : NC ) )

*  Display the dimension size information.
      CALL MSG_OUT( 'DIMENSIONS',
     : '      Dimension size(s):  ^DIMS', STATUS )

*  Obtain the pixel-index bounds.
      CALL NDF_BOUND( INDF, NDF__MXDIM, LBND, UBND, NDIM, STATUS )

*  Construct a string showing the pixel-index bounds.
      NC = 0
       DO 2 I = 1, NDIM
         IF ( I .GT. 1 ) CALL CHR_PUTC( ', ', BUF, NC )
         CALL CHR_PUTI( LBND( I ), BUF, NC )
         CALL CHR_PUTC( ':', BUF, NC )
         CALL CHR_PUTI( UBND( I ), BUF, NC )
 2    CONTINUE
      CALL MSG_SETC( 'BNDS', BUF( : NC ) )

*  Display the pixel-index bounds information.
      CALL MSG_OUT( 'BOUNDS',
     : '      Pixel bounds     :  ^BNDS', STATUS )

*  Obtain the NDF size and display this information.
      CALL NDF_SIZE( INDF, SIZE, STATUS )
      CALL MSG_SETI( 'SIZE', SIZE )
      CALL MSG_OUT( 'SIZE',
     : '      Total pixels     :  ^SIZE ', STATUS )

*  Axis component:
*  ==============
*  See if the axis coordinate system is defined. If so then output a header
*  for it.
      CALL NDF_STATE( INDF, 'Axis', THERE, STATUS )
      IF ( THERE ) THEN
         CALL MSG_OUT( 'BLANK', ' ', STATUS )
         CALL MSG_OUT( 'AXIS_HEADER', '   Axes:', STATUS )

*  Loop to obtain the label and units for each axis and display them.
         DO 3 IAXIS = 1, NDIM
            CALL MSG_SETI( 'IAXIS', IAXIS )
            CALL NDF_ACMSG( 'LABEL', INDF, 'Label', IAXIS, STATUS )
            CALL NDF_ACMSG( 'UNITS', INDF, 'Units', IAXIS, STATUS )
            CALL MSG_OUT( 'AXIS_LABEL',
     :      '      ^IAXIS: ^LABEL (^UNITS)', STATUS )
 3       CONTINUE
      END IF

*  Data component:
*  ==============
*  Obtain the data component attributes.
      CALL NDF_FTYPE( INDF, 'Data', FTYPE, STATUS )
      CALL NDF_FORM( INDF, 'Data', FORM, STATUS )

*  Display the data component attributes.
      CALL MSG_OUT( 'BLANK', ' ', STATUS )
      CALL MSG_OUT( 'DATA_HEADER', '   Data Component:', STATUS )
      CALL MSG_SETC( 'FTYPE', FTYPE )
      CALL MSG_OUT( 'DATA_TYPE', '      Type        :  ^FTYPE', STATUS )
      CALL MSG_SETC( 'FORM', FORM )
      CALL MSG_OUT( 'DATA_FORM', '      Storage form:  ^FORM', STATUS )

*  Determine if the data values are defined. Issue a warning message if
*  they are not.
      CALL NDF_STATE( INDF, 'Data', THERE, STATUS )
      IF ( .NOT. THERE ) THEN
         CALL MSG_OUT( 'DATA_UNDEF',
     :   '      WARNING: the Data component values are not defined',
     :                 STATUS )

*  Disable automatic quality masking and see if the data component may
*  contain bad pixels. If so, then display an appropriate message.
      ELSE
         CALL NDF_SQMF( .FALSE., INDF, STATUS )
         CALL NDF_BAD( INDF, 'Data', .FALSE., BAD, STATUS )
         IF ( BAD ) THEN
            CALL MSG_OUT( 'DATA_ISBAD',
     :      '      Bad pixels may be present', STATUS )

*  If there were no bad pixels present, then re-enable quality masking
*  and test again. Issue an appropriate message.
         ELSE
            CALL NDF_SQMF( .TRUE., INDF, STATUS )
            CALL NDF_BAD( INDF, 'Data', .FALSE., BAD, STATUS )
            IF ( .NOT. BAD ) THEN
               CALL MSG_OUT( 'DATA_NOBAD',
     :         '      There are no bad pixels present', STATUS )
            ELSE
               CALL MSG_OUT( 'DATA_QBAD',
     :         '      Bad pixels may be introduced via the Quality ' //
     :         'component', STATUS )
            END IF
         END IF
      END IF

*  Variance component:
*  ==================
*  See if the variance component is defined.  If so, then obtain its
*  attributes.
      CALL NDF_STATE( INDF, 'Variance', THERE, STATUS )
      IF ( THERE ) THEN
         CALL NDF_FTYPE( INDF, 'Variance', FTYPE, STATUS )
         CALL NDF_FORM( INDF, 'Variance', FORM, STATUS )

*  Display the variance component attributes.
         CALL MSG_OUT( 'BLANK', ' ', STATUS )
         CALL MSG_OUT( 'VAR_HEADER', '   Variance Component:', STATUS )
         CALL MSG_SETC( 'FTYPE', FTYPE )
         CALL MSG_OUT( 'VAR_TYPE', '      Type        :  ^FTYPE',
     :                 STATUS )
         CALL MSG_SETC( 'FORM', FORM )
         CALL MSG_OUT( 'VAR_FORM', '      Storage form:  ^FORM',
     :                 STATUS )

*  Disable automatic quality masking and see if the variance component
*  may contain bad pixels. If so, then display an appropriate message.
         CALL NDF_SQMF( .FALSE., INDF, STATUS )
         CALL NDF_BAD( INDF, 'Variance', .FALSE., BAD, STATUS )
         IF ( BAD ) THEN
            CALL MSG_OUT( 'VAR_ISBAD',
     :      '      Bad pixels may be present', STATUS )

*  If there were no bad pixels present, then re-enable quality masking
*  and test again. Issue an appropriate message.
         ELSE
            CALL NDF_SQMF( .TRUE., INDF, STATUS )
            CALL NDF_BAD( INDF, 'Variance', .FALSE., BAD, STATUS )
            IF ( .NOT. BAD ) THEN
               CALL MSG_OUT( 'VAR_NOBAD',
     :         '      There are no bad pixels present', STATUS )
            ELSE
               CALL MSG_OUT( 'VAR_QBAD',
     :         '      Bad pixels may be introduced via the Quality ' //
     :         'component', STATUS )
            END IF
         END IF
      END IF

*  Quality component:
*  =================
*  See if the quality component is defined. If so, then obtain its
*  attributes.
      CALL NDF_STATE( INDF, 'Quality', THERE, STATUS )
      IF ( THERE ) THEN
         CALL NDF_FORM( INDF, 'Quality', FORM, STATUS )

*  Display the quality component attributes.
         CALL MSG_OUT( 'BLANK', ' ', STATUS )
         CALL MSG_OUT( 'QUALITY_HEADER', '   Quality Component:',
     :                 STATUS )
         CALL MSG_SETC( 'FORM', FORM )
         CALL MSG_OUT( 'QUALITY_FORM', '      Storage form :  ^FORM',
     :                  STATUS )

*  Obtain the bad-bits mask value.
         CALL NDF_BB( INDF, BADBIT, STATUS )

*  Generate a binary representation in a character string.
         BBI = NUM_UBTOI( BADBIT )
         DIGVAL = 2 ** 7
         DO 4 IDIG = 1, 8
            IF ( BBI .GE. DIGVAL ) THEN
               BINSTR( IDIG : IDIG ) = '1'
               BBI = BBI - DIGVAL
            ELSE
               BINSTR( IDIG : IDIG ) = '0'
            END IF
            DIGVAL = DIGVAL / 2
 4       CONTINUE

*  Display the bad-bits mask information.
         CALL MSG_SETI( 'BADBIT', NUM_UBTOI( BADBIT ) )
         CALL MSG_SETC( 'BINARY', BINSTR )
         CALL MSG_OUT( 'QUALITY_BADBIT',
     :   '      Bad-bits mask:  ^BADBIT (binary ^BINARY)', STATUS )
      END IF

*  Extensions:
*  ==========
*  Determine how many extensions are present.
      CALL NDF_XNUMB( INDF, NEXTN, STATUS )

*  Display a heading for the extensions.
      IF ( NEXTN .GT. 0 ) THEN
         CALL MSG_OUT( 'BLANK', ' ', STATUS )
         CALL MSG_OUT( 'EXTN_HEADER', '   Extensions:', STATUS )

*  Loop to obtain the name and HDS data type of each extension.
         DO 5 N = 1, NEXTN
            CALL NDF_XNAME( INDF, N, XNAME, STATUS )
            CALL NDF_XLOC( INDF, XNAME, 'READ', XLOC, STATUS )
            CALL DAT_TYPE( XLOC, TYPE, STATUS )
            CALL DAT_ANNUL( XLOC, STATUS )
            XLOC = ' '

*  Display the information for each extension.
            CALL MSG_SETC( 'TYPE', TYPE )
            CALL MSG_OUT( 'EXTN',
     :      '      ' // XNAME // '  <^TYPE>', STATUS )
 5       CONTINUE
      END IF
      CALL MSG_OUT( 'BLANK', ' ', STATUS )

*  Clean up:
*  ========
*  Annul the NDF identifier.
      CALL NDF_ANNUL( INDF, STATUS )

*  If an error occurred, then report context information.
      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'NDFTRACE_ERR',
     :   'NDFTRACE: Error displaying the attributes of an NDF ' //
     :   'data structure.', STATUS )
      END IF

      END
\end{verbatim}
\normalsize

The following is an example ADAM interface file (NDFTRACE.IFL) for the
application above. 

\small
\begin{verbatim}
   interface NDFTRACE

      parameter NDF                 # NDF to be inspected
         position 1
         prompt   'Data structure'
      endparameter

   endinterface
\end{verbatim}
\normalsize

\newpage
\section{ALPHABETICAL LIST OF ROUTINES}

Note that the argument lists of all the following routines, together with
on-line help information, are available within the Starlink language sensitive
editor STARLSE (SUN/105).

% Command for displaying routines in routine lists:
% =================================================

\newcommand{\noteroutine}[2]{{\small \bf #1} \nopagebreak \\
                             \hspace*{3em} {\em #2} \\[1.5ex]}

% List of routines:
% =================

\small
\noteroutine{NDF\_ACGET( INDF, COMP, IAXIS, VALUE, STATUS )}
            {Obtain the value of an NDF axis character component}
\noteroutine{NDF\_ACLEN( INDF, COMP, IAXIS, LENGTH, STATUS )}
            {Determine the length of an NDF axis character component}
\noteroutine{NDF\_ACMSG( TOKEN, INDF, COMP, IAXIS, STATUS )}
            {Assign the value of an NDF axis character component to a message token}
\noteroutine{NDF\_ACPUT( VALUE, INDF, COMP, IAXIS, STATUS )}
            {Assign a value to an NDF axis character component}
\noteroutine{NDF\_ACRE( INDF, STATUS )}
            {Ensure that an axis coordinate system exists for an NDF}
\noteroutine{NDF\_AFORM( INDF, COMP, IAXIS, FORM, STATUS )}
            {Obtain the storage form of an NDF axis array}
\noteroutine{NDF\_AMAP( INDF, COMP, IAXIS, TYPE, MMOD, PNTR, EL, STATUS )}
            {Obtain mapped access to an NDF axis array}
\noteroutine{NDF\_ANNUL( INDF, STATUS )}
            {Annul an NDF identifier}
\noteroutine{NDF\_ANORM( INDF, IAXIS, NORM, STATUS )}
            {Obtain the logical value of an NDF axis normalisation flag}
\noteroutine{NDF\_AREST( INDF, COMP, IAXIS, STATUS )}
            {Reset an NDF axis component to an undefined state}
\noteroutine{NDF\_ASNRM( NORM, INDF, IAXIS, STATUS )}
            {Set a new value for an NDF axis normalisation flag}
\noteroutine{NDF\_ASSOC( PARAM, MODE, INDF, STATUS )}
            {Associate an existing NDF with an ADAM parameter}
\noteroutine{NDF\_ASTAT( INDF, COMP, IAXIS, STATE, STATUS )}
            {Determine the state of an NDF axis component (defined or undefined)}
\noteroutine{NDF\_ASTYP( TYPE, INDF, COMP, IAXIS, STATUS )}
            {Set a new numeric type for an NDF axis array}
\noteroutine{NDF\_ATYPE( INDF, COMP, IAXIS, TYPE, STATUS )}
            {Obtain the numeric type of an NDF axis array}
\noteroutine{NDF\_AUNMP( INDF, COMP, IAXIS, STATUS )}
            {Unmap an NDF axis array component}
\noteroutine{NDF\_BAD( INDF, COMP, CHECK, BAD, STATUS )}
            {Determine if an NDF array component may contain bad pixels}
\noteroutine{NDF\_BASE( INDF1, INDF2, STATUS )}
            {Obtain an identifier for a base NDF}
\noteroutine{NDF\_BB( INDF, BADBIT, STATUS )}
            {Obtain the bad-bits mask value for the quality component of an NDF}
\noteroutine{NDF\_BEGIN}
            {Begin a new NDF context}
\noteroutine{NDF\_BLOCK( INDF1, NDIM, MXDIM, IBLOCK, INDF2, STATUS )}
            {Obtain an NDF section containing a block of adjacent pixels}
\noteroutine{NDF\_BOUND( INDF, NDIMX, LBND, UBND, NDIM, STATUS )}
            {Enquire the pixel-index bounds of an NDF}
\noteroutine{NDF\_CGET( INDF, COMP, VALUE, STATUS )}
            {Obtain the value of an NDF character component}
\noteroutine{NDF\_CHUNK( INDF1, MXPIX, ICHUNK, INDF2, STATUS )}
            {Obtain an NDF section containing a chunk of contiguous pixels}
\noteroutine{NDF\_CINP( PARAM, INDF, COMP, STATUS )}
            {Obtain an NDF character component value via the ADAM parameter system}
\noteroutine{NDF\_CLEN( INDF, COMP, LENGTH, STATUS )}
            {Determine the length of an NDF character component}
\noteroutine{NDF\_CLONE( INDF1, INDF2, STATUS )}
            {Clone an NDF identifier}
\noteroutine{NDF\_CMPLX( INDF, COMP, CMPLX, STATUS )}
            {Determine whether an NDF array component holds complex values}
\noteroutine{NDF\_CMSG( TOKEN, INDF, COMP, STATUS )}
            {Assign the value of an NDF character component to a message token}
\noteroutine{NDF\_COPY( INDF1, PLACE, INDF2, STATUS )}
            {Copy an NDF to a new location}
\noteroutine{NDF\_CPUT( VALUE, INDF, COMP, STATUS )}
            {Assign a value to an NDF character component}
\noteroutine{NDF\_CREAT( PARAM, FTYPE, NDIM, LBND, UBND, INDF, STATUS )}
            {Create a new simple NDF via the ADAM parameter system}
\noteroutine{NDF\_CREP( PARAM, FTYPE, NDIM, UBND, INDF, STATUS )}
            {Create a new primitive NDF via the ADAM parameter system}
\noteroutine{NDF\_DELET( INDF, STATUS )}
            {Delete an NDF}
\noteroutine{NDF\_DIM( INDF, NDIMX, DIM, NDIM, STATUS )}
            {Enquire the dimension sizes of an NDF}
\noteroutine{NDF\_END( STATUS )}
            {End the current NDF context}
\noteroutine{NDF\_EXIST( PARAM, MODE, INDF, STATUS )}
            {See if an existing NDF is associated with an ADAM parameter.}
\noteroutine{NDF\_FIND( LOC, NAME, INDF, STATUS )}
            {Find an NDF in an HDS structure and import it into the NDF\_ system}
\noteroutine{NDF\_FORM( INDF, COMP, FORM, STATUS )}
            {Obtain the storage form of an NDF array component}
\noteroutine{NDF\_FTYPE( INDF, COMP, FTYPE, STATUS )}
            {Obtain the full data type of an NDF array component}
\noteroutine{NDF\_GTUNE( TPAR, VALUE, STATUS )}
            {Obtain the value of an NDF\_ system tuning parameter}
\noteroutine{NDF\_IMPRT( LOC, INDF, STATUS )}
            {Import an NDF into the NDF\_ system from HDS}
\noteroutine{NDF\_ISACC( INDF, ACCESS, ISACC, STATUS )}
            {Determine whether a specified type of NDF access is available}
\noteroutine{NDF\_ISBAS( INDF, ISBAS, STATUS )}
            {Enquire if an NDF is a base NDF}
\noteroutine{NDF\_ISTMP( INDF, ISTMP, STATUS )}
            {Determine if an NDF is temporary}
\noteroutine{NDF\_LOC( INDF, MODE, LOC, STATUS )}
            {Obtain an HDS locator for an NDF}
\noteroutine{NDF\_MAP( INDF, COMP, TYPE, MMOD, PNTR, EL, STATUS )}
            {Obtain mapped access to an array component of an NDF}
\noteroutine{NDF\_MAPQL( INDF, PNTR, EL, BAD, STATUS )}
            {Map the quality component of an NDF as an array of logical values}
\noteroutine{NDF\_MAPZ( INDF, COMP, TYPE, MMOD, RPNTR, IPNTR, EL, STATUS )}
            {Obtain complex mapped access to an array component of an NDF}
\noteroutine{NDF\_MBAD( BADOK, INDF1, INDF2, COMP, CHECK, BAD, STATUS )}
            {Merge the bad-pixel flags of the array components of a pair of NDFs}
\noteroutine{NDF\_MBADN( BADOK, N, NDFS, COMP, CHECK, BAD, STATUS )}
            {Merge the bad-pixel flags of the array components of a number of NDFs}
\noteroutine{NDF\_MBND( OPTION, INDF1, INDF2, STATUS )}
            {Match the pixel-index bounds of a pair of NDFs}
\noteroutine{NDF\_MBNDN( OPTION, N, NDFS, STATUS )}
            {Match the pixel-index bounds of a number of NDFs}
\noteroutine{NDF\_MSG( TOKEN, INDF )}
            {Assign the name of an NDF to a message token}
\noteroutine{NDF\_MTYPE( TYPLST, INDF1, INDF2, COMP, ITYPE, DTYPE, STATUS )}
            {Match the types of the array components of a pair of NDFs}
\noteroutine{NDF\_MTYPN( TYPLST, N, NDFS, COMP, ITYPE, DTYPE, STATUS )}
            {Match the types of the array components of a number of NDFs}
\noteroutine{NDF\_NBLOC( INDF, NDIM, MXDIM, NBLOCK, STATUS )}
            {Determine the number of blocks of adjacent pixels in an NDF}
\noteroutine{NDF\_NCHNK( INDF, MXPIX, NCHUNK, STATUS )}
            {Determine the number of chunks of contiguous pixels in an NDF}
\noteroutine{NDF\_NEW( FTYPE, NDIM, LBND, UBND, PLACE, INDF, STATUS )}
            {Create a new simple NDF}
\noteroutine{NDF\_NEWP( FTYPE, NDIM, UBND, PLACE, INDF, STATUS )}
            {Create a new primitive NDF}
\noteroutine{NDF\_NOACC( ACCESS, INDF, STATUS )}
            {Disable a specified type of access to an NDF}
\noteroutine{NDF\_PLACE( LOC, NAME, PLACE, STATUS )}
            {Obtain an NDF placeholder}
\noteroutine{NDF\_PROP( INDF1, CLIST, PARAM, INDF2, STATUS )}
            {Propagate NDF information to create a new NDF via the ADAM parameter system}
\noteroutine{NDF\_QMASK( QUAL, BADBIT )}
            {Combine an NDF quality value with a bad-bits mask to give a logical result}
\noteroutine{NDF\_QMF( INDF, QMF, STATUS )}
            {Obtain the value of an NDF's quality masking flag}
\noteroutine{NDF\_RESET( INDF, COMP, STATUS )}
            {Reset an NDF component to an undefined state}
\noteroutine{NDF\_SAME( INDF1, INDF2, SAME, ISECT, STATUS )}
            {Enquire if two NDFs are part of the same base NDF}
\noteroutine{NDF\_SBAD( BAD, INDF, COMP, STATUS )}
            {Set the bad-pixel flag for an NDF array component}
\noteroutine{NDF\_SBB( BADBIT, INDF, STATUS )}
            {Set a bad-bits mask value for the quality component of an NDF}
\noteroutine{NDF\_SBND( NDIM, LBND, UBND, INDF, STATUS )}
            {Set new pixel-index bounds for an NDF}
\noteroutine{NDF\_SECT( INDF1, NDIM, LBND, UBND, INDF2, STATUS )}
            {Create an NDF section}
\noteroutine{NDF\_SHIFT( NSHIFT, SHIFT, INDF, STATUS )}
            {Apply pixel-index shifts to an NDF}
\noteroutine{NDF\_SIZE( INDF, NPIX, STATUS )}
            {Determine the size of an NDF}
\noteroutine{NDF\_SQMF( QMF, INDF, STATUS )}
            {Set a new logical value for an NDF's quality masking flag}
\noteroutine{NDF\_SSARY( IARY1, INDF, IARY2, STATUS )}
            {Create an array section, using an NDF section as a template}
\noteroutine{NDF\_STATE( INDF, COMP, STATE, STATUS )}
            {Determine the state of an NDF component (defined or undefined)}
\noteroutine{NDF\_STYPE( FTYPE, INDF, COMP, STATUS )}
            {Set a new type for an NDF array component}
\noteroutine{NDF\_TEMP( PLACE, STATUS )}
            {Obtain a placeholder for a temporary NDF}
\noteroutine{NDF\_TRACE( NEWFLG, OLDFLG )}
            {Set the internal NDF\_ system error-tracing flag}
\noteroutine{NDF\_TUNE( VALUE, TPAR, STATUS )}
            {Set an NDF\_ system tuning parameter}
\noteroutine{NDF\_TYPE( INDF, COMP, TYPE, STATUS )}
            {Obtain the numeric data type of an NDF array component}
\noteroutine{NDF\_UNMAP( INDF, COMP, STATUS )}
            {Unmap an NDF or a mapped NDF array}
\noteroutine{NDF\_VALID( INDF, VALID, STATUS )}
            {Determine whether an NDF identifier is valid}
\noteroutine{NDF\_XDEL( INDF, XNAME, STATUS )}
            {Delete a specified NDF extension}
\noteroutine{NDF\_XGT0x( INDF, XNAME, CMPT, VALUE, STATUS )}
            {Read a scalar value from a component within a named NDF extension}
\noteroutine{NDF\_XIARY( INDF, XNAME, CMPT, MODE, IARY, STATUS )}
            {Obtain access to an array stored in an NDF extension}
\noteroutine{NDF\_XLOC( INDF, XNAME, MODE, LOC, STATUS )}
            {Obtain access to a named NDF extension via an HDS locator}
\noteroutine{NDF\_XNAME( INDF, N, XNAME, STATUS )}
            {Obtain the name of the N'th extension in an NDF}
\noteroutine{NDF\_XNEW( INDF, XNAME, TYPE, NDIM, DIM, LOC, STATUS )}
            {Create a new extension in an NDF}
\noteroutine{NDF\_XNUMB( INDF, NEXTN, STATUS )}
            {Determine the number of extensions in an NDF}
\noteroutine{NDF\_XPT0x( VALUE, INDF, XNAME, CMPT, STATUS )}
            {Write a scalar value to a component within a named NDF extension}
\noteroutine{NDF\_XSTAT( INDF, XNAME, THERE, STATUS )}
            {Determine if a named NDF extension exists}
\normalsize

\newpage
\section{CLASSIFIED LIST OF ROUTINES}

\subsection{Access to Existing NDFs}

\small
\noteroutine{NDF\_ASSOC( PARAM, MODE, INDF, STATUS )}
            {Associate an existing NDF with an ADAM parameter}
\noteroutine{NDF\_EXIST( PARAM, MODE, INDF, STATUS )}
            {See if an existing NDF is associated with an ADAM parameter.}
\noteroutine{NDF\_FIND( LOC, NAME, INDF, STATUS )}
            {Find an NDF in an HDS structure and import it into the NDF\_ system}
\noteroutine{NDF\_IMPRT( LOC, INDF, STATUS )}
            {Import an NDF into the NDF\_ system from HDS}
\normalsize

\subsection{Enquiring NDF Attributes}

\small
\noteroutine{NDF\_BOUND( INDF, NDIMX, LBND, UBND, NDIM, STATUS )}
            {Enquire the pixel-index bounds of an NDF}
\noteroutine{NDF\_DIM( INDF, NDIMX, DIM, NDIM, STATUS )}
            {Enquire the dimension sizes of an NDF}
\noteroutine{NDF\_ISACC( INDF, ACCESS, ISACC, STATUS )}
            {Determine whether a specified type of NDF access is available}
\noteroutine{NDF\_ISBAS( INDF, ISBAS, STATUS )}
            {Enquire if an NDF is a base NDF}
\noteroutine{NDF\_ISTMP( INDF, ISTMP, STATUS )}
            {Determine if an NDF is temporary}
\noteroutine{NDF\_NBLOC( INDF, NDIM, MXDIM, NBLOCK, STATUS )}
            {Determine the number of blocks of adjacent pixels in an NDF}
\noteroutine{NDF\_NCHNK( INDF, MXPIX, NCHUNK, STATUS )}
            {Determine the number of chunks of contiguous pixels in an NDF}
\noteroutine{NDF\_SAME( INDF1, INDF2, SAME, ISECT, STATUS )}
            {Enquire if two NDFs are part of the same base NDF}
\noteroutine{NDF\_SIZE( INDF, NPIX, STATUS )}
            {Determine the size of an NDF}
\noteroutine{NDF\_VALID( INDF, VALID, STATUS )}
            {Determine whether an NDF identifier is valid}
\normalsize

\subsection{Enquiring Component Attributes}

\small
\noteroutine{NDF\_BAD( INDF, COMP, CHECK, BAD, STATUS )}
            {Determine if an NDF array component may contain bad pixels}
\noteroutine{NDF\_BB( INDF, BADBIT, STATUS )}
            {Obtain the bad-bits mask value for the quality component of an NDF}
\noteroutine{NDF\_CLEN( INDF, COMP, LENGTH, STATUS )}
            {Determine the length of an NDF character component}
\noteroutine{NDF\_CMPLX( INDF, COMP, CMPLX, STATUS )}
            {Determine whether an NDF array component holds complex values}
\noteroutine{NDF\_FORM( INDF, COMP, FORM, STATUS )}
            {Obtain the storage form of an NDF array component}
\noteroutine{NDF\_FTYPE( INDF, COMP, FTYPE, STATUS )}
            {Obtain the full data type of an NDF array component}
\noteroutine{NDF\_QMF( INDF, QMF, STATUS )}
            {Obtain the value of an NDF's quality masking flag}
\noteroutine{NDF\_STATE( INDF, COMP, STATE, STATUS )}
            {Determine the state of an NDF component (defined or undefined)}
\noteroutine{NDF\_TYPE( INDF, COMP, TYPE, STATUS )}
            {Obtain the numeric data type of an NDF array component}
\normalsize

\subsection{Creating and Deleting NDFs}

\small
\noteroutine{NDF\_CREAT( PARAM, FTYPE, NDIM, LBND, UBND, INDF, STATUS )}
            {Create a new simple NDF via the ADAM parameter system}
\noteroutine{NDF\_CREP( PARAM, FTYPE, NDIM, UBND, INDF, STATUS )}
            {Create a new primitive NDF via the ADAM parameter system}
\noteroutine{NDF\_DELET( INDF, STATUS )}
            {Delete an NDF}
\noteroutine{NDF\_NEW( FTYPE, NDIM, LBND, UBND, PLACE, INDF, STATUS )}
            {Create a new simple NDF}
\noteroutine{NDF\_NEWP( FTYPE, NDIM, UBND, PLACE, INDF, STATUS )}
            {Create a new primitive NDF}
\noteroutine{NDF\_PROP( INDF1, CLIST, PARAM, INDF2, STATUS )}
            {Propagate NDF information to create a new NDF via the ADAM parameter system}
\normalsize

\subsection{Setting NDF Attributes}

\small
\noteroutine{NDF\_NOACC( ACCESS, INDF, STATUS )}
            {Disable a specified type of access to an NDF}
\noteroutine{NDF\_SBND( NDIM, LBND, UBND, INDF, STATUS )}
            {Set new pixel-index bounds for an NDF}
\noteroutine{NDF\_SHIFT( NSHIFT, SHIFT, INDF, STATUS )}
            {Apply pixel-index shifts to an NDF}
\normalsize

\subsection{Setting Component Attributes}

\small
\noteroutine{NDF\_RESET( INDF, COMP, STATUS )}
            {Reset an NDF component to an undefined state}
\noteroutine{NDF\_SBAD( BAD, INDF, COMP, STATUS )}
            {Set the bad-pixel flag for an NDF array component}
\noteroutine{NDF\_SBB( BADBIT, INDF, STATUS )}
            {Set a bad-bits mask value for the quality component of an NDF}
\noteroutine{NDF\_SQMF( QMF, INDF, STATUS )}
            {Set a new logical value for an NDF's quality masking flag}
\noteroutine{NDF\_STYPE( FTYPE, INDF, COMP, STATUS )}
            {Set a new type for an NDF array component}
\normalsize

\subsection{Access to Component Values}

\small
\noteroutine{NDF\_CGET( INDF, COMP, VALUE, STATUS )}
            {Obtain the value of an NDF character component}
\noteroutine{NDF\_CPUT( VALUE, INDF, COMP, STATUS )}
            {Assign a value to an NDF character component}
\noteroutine{NDF\_MAP( INDF, COMP, TYPE, MMOD, PNTR, EL, STATUS )}
            {Obtain mapped access to an array component of an NDF}
\noteroutine{NDF\_MAPQL( INDF, PNTR, EL, BAD, STATUS )}
            {Map the quality component of an NDF as an array of logical values}
\noteroutine{NDF\_MAPZ( INDF, COMP, TYPE, MMOD, RPNTR, IPNTR, EL, STATUS )}
            {Obtain complex mapped access to an array component of an NDF}
\noteroutine{NDF\_QMASK( QUAL, BADBIT )}
            {Combine an NDF quality value with a bad-bits mask to give a logical result}
\noteroutine{NDF\_UNMAP( INDF, COMP, STATUS )}
            {Unmap an NDF or a mapped NDF array}
\normalsize

\subsection{Enquiring and Setting Axis Attributes}

\small
\noteroutine{NDF\_ACLEN( INDF, COMP, IAXIS, LENGTH, STATUS )}
            {Determine the length of an NDF axis character component}
\noteroutine{NDF\_ACRE( INDF, STATUS )}
            {Ensure that an axis coordinate system exists for an NDF}
\noteroutine{NDF\_AFORM( INDF, COMP, IAXIS, FORM, STATUS )}
            {Obtain the storage form of an NDF axis array}
\noteroutine{NDF\_ANORM( INDF, IAXIS, NORM, STATUS )}
            {Obtain the logical value of an NDF axis normalisation flag}
\noteroutine{NDF\_AREST( INDF, COMP, IAXIS, STATUS )}
            {Reset an NDF axis component to an undefined state}
\noteroutine{NDF\_ASNRM( NORM, INDF, IAXIS, STATUS )}
            {Set a new value for an NDF axis normalisation flag}
\noteroutine{NDF\_ASTAT( INDF, COMP, IAXIS, STATE, STATUS )}
            {Determine the state of an NDF axis component (defined or undefined)}
\noteroutine{NDF\_ASTYP( TYPE, INDF, COMP, IAXIS, STATUS )}
            {Set a new numeric type for an NDF axis array}
\noteroutine{NDF\_ATYPE( INDF, COMP, IAXIS, TYPE, STATUS )}
            {Obtain the numeric type of an NDF axis array}
\normalsize

\subsection{Access to Axis Values}

\small
\noteroutine{NDF\_ACGET( INDF, COMP, IAXIS, VALUE, STATUS )}
            {Obtain the value of an NDF axis character component}
\noteroutine{NDF\_ACMSG( TOKEN, INDF, COMP, IAXIS, STATUS )}
            {Assign the value of an NDF axis character component to a message token}
\noteroutine{NDF\_ACPUT( VALUE, INDF, COMP, IAXIS, STATUS )}
            {Assign a value to an NDF axis character component}
\noteroutine{NDF\_AMAP( INDF, COMP, IAXIS, TYPE, MMOD, PNTR, EL, STATUS )}
            {Obtain mapped access to an NDF axis array}
\noteroutine{NDF\_AUNMP( INDF, COMP, IAXIS, STATUS )}
            {Unmap an NDF axis array component}
\normalsize

\subsection{Creation and Control of Identifiers}

\small
\noteroutine{NDF\_ANNUL( INDF, STATUS )}
            {Annul an NDF identifier}
\noteroutine{NDF\_BASE( INDF1, INDF2, STATUS )}
            {Obtain an identifier for a base NDF}
\noteroutine{NDF\_BEGIN}
            {Begin a new NDF context}
\noteroutine{NDF\_CLONE( INDF1, INDF2, STATUS )}
            {Clone an NDF identifier}
\noteroutine{NDF\_END( STATUS )}
            {End the current NDF context}
\noteroutine{NDF\_VALID( INDF, VALID, STATUS )}
            {Determine whether an NDF identifier is valid}
\normalsize

\subsection{Handling NDF (and Array) Sections}

\small
\noteroutine{NDF\_BASE( INDF1, INDF2, STATUS )}
            {Obtain an identifier for a base NDF}
\noteroutine{NDF\_BLOCK( INDF1, NDIM, MXDIM, IBLOCK, INDF2, STATUS )}
            {Obtain an NDF section containing a block of adjacent pixels}
\noteroutine{NDF\_CHUNK( INDF1, MXPIX, ICHUNK, INDF2, STATUS )}
            {Obtain an NDF section containing a chunk of contiguous pixels}
\noteroutine{NDF\_NBLOC( INDF, NDIM, MXDIM, NBLOCK, STATUS )}
            {Determine the number of blocks of adjacent pixels in an NDF}
\noteroutine{NDF\_NCHNK( INDF, MXPIX, NCHUNK, STATUS )}
            {Determine the number of chunks of contiguous pixels in an NDF}
\noteroutine{NDF\_SECT( INDF1, NDIM, LBND, UBND, INDF2, STATUS )}
            {Create an NDF section}
\noteroutine{NDF\_SSARY( IARY1, INDF, IARY2, STATUS )}
            {Create an array section, using an NDF section as a template}
\noteroutine{NDF\_XIARY( INDF, XNAME, CMPT, MODE, IARY, STATUS )}
            {Obtain access to an array stored in an NDF extension}
\normalsize

\subsection{Matching and Merging Attributes}

\small
\noteroutine{NDF\_MBAD( BADOK, INDF1, INDF2, COMP, CHECK, BAD, STATUS )}
            {Merge the bad-pixel flags of the array components of a pair of NDFs}
\noteroutine{NDF\_MBADN( BADOK, N, NDFS, COMP, CHECK, BAD, STATUS )}
            {Merge the bad-pixel flags of the array components of a number of NDFs}
\noteroutine{NDF\_MBND( OPTION, INDF1, INDF2, STATUS )}
            {Match the pixel-index bounds of a pair of NDFs}
\noteroutine{NDF\_MBNDN( OPTION, N, NDFS, STATUS )}
            {Match the pixel-index bounds of a number of NDFs}
\noteroutine{NDF\_MTYPE( TYPLST, INDF1, INDF2, COMP, ITYPE, DTYPE, STATUS )}
            {Match the types of the array components of a pair of NDFs}
\noteroutine{NDF\_MTYPN( TYPLST, N, NDFS, COMP, ITYPE, DTYPE, STATUS )}
            {Match the types of the array components of a number of NDFs}
\normalsize

\subsection{ADAM Parameter System Routines}
\label{ss:adamroutinelist}

\small
\noteroutine{NDF\_ASSOC( PARAM, MODE, INDF, STATUS )}
            {Associate an existing NDF with an ADAM parameter}
\noteroutine{NDF\_CINP( PARAM, INDF, COMP, STATUS )}
            {Obtain an NDF character component value via the ADAM parameter system}
\noteroutine{NDF\_CREAT( PARAM, FTYPE, NDIM, LBND, UBND, INDF, STATUS )}
            {Create a new simple NDF via the ADAM parameter system}
\noteroutine{NDF\_CREP( PARAM, FTYPE, NDIM, UBND, INDF, STATUS )}
            {Create a new primitive NDF via the ADAM parameter system}
\noteroutine{NDF\_EXIST( PARAM, MODE, INDF, STATUS )}
            {See if an existing NDF is associated with an ADAM parameter.}
\noteroutine{NDF\_PROP( INDF1, CLIST, PARAM, INDF2, STATUS )}
            {Propagate NDF information to create a new NDF via the ADAM parameter system}
\normalsize

\subsection{Message System Routines}

\small
\noteroutine{NDF\_CMSG( TOKEN, INDF, COMP, STATUS )}
            {Assign the value of an NDF character component to a message token}
\noteroutine{NDF\_MSG( TOKEN, INDF )}
            {Assign the name of an NDF to a message token}
\normalsize

\subsection{Creating Placeholders}

\small
\noteroutine{NDF\_PLACE( LOC, NAME, PLACE, STATUS )}
            {Obtain an NDF placeholder}
\noteroutine{NDF\_TEMP( PLACE, STATUS )}
            {Obtain a placeholder for a temporary NDF}
\normalsize

\subsection{Copying NDFs}

\small
\noteroutine{NDF\_COPY( INDF1, PLACE, INDF2, STATUS )}
            {Copy an NDF to a new location}
\noteroutine{NDF\_PROP( INDF1, CLIST, PARAM, INDF2, STATUS )}
            {Propagate NDF information to create a new NDF via the ADAM parameter system}
\normalsize

\subsection{Handling Extensions}

\small
\noteroutine{NDF\_XDEL( INDF, XNAME, STATUS )}
            {Delete a specified NDF extension}
\noteroutine{NDF\_XGT0x( INDF, XNAME, CMPT, VALUE, STATUS )}
            {Read a scalar value from a component within a named NDF extension}
\noteroutine{NDF\_XIARY( INDF, XNAME, CMPT, MODE, IARY, STATUS )}
            {Obtain access to an array stored in an NDF extension}
\noteroutine{NDF\_XLOC( INDF, XNAME, MODE, LOC, STATUS )}
            {Obtain access to a named NDF extension via an HDS locator}
\noteroutine{NDF\_XNAME( INDF, N, XNAME, STATUS )}
            {Obtain the name of the N'th extension in an NDF}
\noteroutine{NDF\_XNEW( INDF, XNAME, TYPE, NDIM, DIM, LOC, STATUS )}
            {Create a new extension in an NDF}
\noteroutine{NDF\_XNUMB( INDF, NEXTN, STATUS )}
            {Determine the number of extensions in an NDF}
\noteroutine{NDF\_XPT0x( VALUE, INDF, XNAME, CMPT, STATUS )}
            {Write a scalar value to a component within a named NDF extension}
\noteroutine{NDF\_XSTAT( INDF, XNAME, THERE, STATUS )}
            {Determine if a named NDF extension exists}
\normalsize

\subsection{Tuning the NDF\_ system}

\small
\noteroutine{NDF\_GTUNE( TPAR, VALUE, STATUS )}
            {Obtain the value of an NDF\_ system tuning parameter}
\noteroutine{NDF\_TRACE( NEWFLG, OLDFLG )}
            {Set the internal NDF\_ system error-tracing flag}
\noteroutine{NDF\_TUNE( VALUE, TPAR, STATUS )}
            {Set an NDF\_ system tuning parameter}
\normalsize


\newpage
\section{ROUTINE DESCRIPTIONS}
\label{ss:routinedescriptions}

%+
%  Name:
%     LAYOUT.TEX

%  Purpose:
%     Define Latex commands for laying out documentation produced by PROLAT.

%  Language:
%     Latex

%  Type of Module:
%     Data file for use by the PROLAT application.

%  Description:
%     This file defines Latex commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by Latex. The
%     contents of this file should be included in the source presented to
%     Latex in front of any output from PROLAT. By default, this is done
%     automatically by PROLAT.

%  Notes:
%     The definitions in this file should be included explicitly in any file
%     which requires them. The \include directive should not be used, as it
%     may not then be possible to process the resulting document with Latex
%     at a later date if changes to this definitions file become necessary.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}

%  Define a \tt font of the required size.
\font\ssttt=cmtt10 scaled 1095

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.45pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{\item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[1]{\item[{\ssttt #1}] \mbox{} \\}

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  End of LAYOUT.TEX layout definitions.
%.

% Routine descriptions:
% =====================
\small
\sstroutine{
   NDF\_ACGET
}{
   Obtain the value of an NDF axis character component
}{
   \sstdescription{
      The routine obtains the value of the specified axis character
      component of an NDF (i.e. the value of the LABEL or UNITS
      component for an NDF axis).
   }
   \sstinvocation{
      CALL NDF\_ACGET( INDF, COMP, IAXIS, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the axis character component whose value is required:
         {\tt '}LABEL{\tt '} or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the axis for which a value is required.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The component{\tt '}s value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the requested axis component is in an undefined state and
         VALUE is set to a blank string on entry, then an appropriate
         default value will be returned. If VALUE is not blank on entry,
         then it will be returned unchanged.

         \sstitem
         If the length of the VALUE argument is too short to
         accommodate the returned result without losing significant
         (non-blank) trailing characters, then this will be indicated by
         an appended ellipsis, i.e. {\tt '}...{\tt '}. No error will result.
      }
   }
}
\sstroutine{
   NDF\_ACLEN
}{
   Determine the length of an NDF axis character component
}{
   \sstdescription{
      The routine returns the length of the specified axis character
      component of an NDF (i.e. the number of characters in the LABEL
      or UNITS component of an NDF axis).
   }
   \sstinvocation{
      CALL NDF\_ACLEN( INDF, COMP, IAXIS, LENGTH, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the axis character component whose length is required:
         {\tt '}LABEL{\tt '} or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the NDF axis.
      }
      \sstsubsection{
         LENGTH = INTEGER (Returned)
      }{
         The component{\tt '}s length in characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The length of an NDF axis character component is normally
         determined by the length of the VALUE string assigned to it by a
         previous call to NDF\_ACPUT (note that this could include trailing
         blanks).

         \sstitem
         If the requested axis component is in an undefined state, then
         the length returned will be the number of characters in the
         default value which would be returned by the NDF\_ACGET routine.

         \sstitem
         A value of zero may be supplied for the IAXIS argument, in
         which case the routine will return the maximum component length
         for all the NDF axes.
      }
   }
}
\sstroutine{
   NDF\_ACMSG
}{
   Assign the value of an NDF axis character component to a message
   token
}{
   \sstdescription{
      The routine assigns the value of the specified axis character
      component of an NDF to a message token, for use in constructing
      messages using the MSG\_ or ERR\_ routines (see SUN/104).
   }
   \sstinvocation{
      CALL NDF\_ACMSG( TOKEN, INDF, COMP, IAXIS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the message token.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the axis character component whose value is to be used:
         {\tt '}LABEL{\tt '} or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the NDF axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the requested axis component is in an undefined state, then
         an appropriate default value will be assigned to the token.
      }
   }
}
\sstroutine{
   NDF\_ACPUT
}{
   Assign a value to an NDF axis character component
}{
   \sstdescription{
      The routine assigns a value to the specified axis character
      component of an NDF (i.e. to the LABEL or UNITS component of an
      NDF axis).
   }
   \sstinvocation{
      CALL NDF\_ACPUT( VALUE, INDF, COMP, IAXIS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The value to be assigned.
      }
      \sstsubsection{
         INTEGER = INDF (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the axis character component whose value is to be
         assigned: {\tt '}LABEL{\tt '} or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the axis to receive the new value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The entire VALUE string (including trailing blanks if present)
         is assigned to the specified axis component, whose length is
         adjusted to accommodate it.

         \sstitem
         A value of zero may be given for the IAXIS argument, in which
         case the routine will assign the same value to all the NDF axes.

         \sstitem
         This routine may only be used to assign values to the axes of
         a base NDF. If an NDF section is supplied, then it it will return
         without action. No error will result.
      }
   }
}
\sstroutine{
   NDF\_ACRE
}{
   Ensure that an axis coordinate system exists for an NDF
}{
   \sstdescription{
      The routine ensures that an axis coordinate system exists for an
      NDF. An axis component with default coordinate values is created
      if necessary.
   }
   \sstinvocation{
      CALL NDF\_ACRE( INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDF\_AFORM
}{
   Obtain the storage form of an NDF axis array
}{
   \sstdescription{
      The routine returns the storage form of a specified NDF axis
      array component as an upper case character string (e.g.
      {\tt '}PRIMITIVE{\tt '}).
   }
   \sstinvocation{
      CALL NDF\_AFORM( INDF, COMP, IAXIS, FORM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the axis array component whose storage form is
         required: {\tt '}CENTRE{\tt '}, {\tt '}VARIANCE{\tt '} or {\tt '}WIDTH{\tt '}.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the NDF axis for which information is required.
      }
      \sstsubsection{
         FORM = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Storage form of the axis array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The symbolic constant NDF\_\_SZFRM may be used for declaring the
         length of a character variable to hold the storage form of an NDF
         axis array. This constant is defined in the include file NDF\_PAR.

         \sstitem
         At present, the NDF\_ routines only support {\tt "}primitive{\tt "} and
         {\tt "}simple{\tt "} arrays, so only the values {\tt '}PRIMITIVE{\tt '} and {\tt '}SIMPLE{\tt '} can
         be returned.
      }
   }
}
\sstroutine{
   NDF\_AMAP
}{
   Obtain mapped access to an NDF axis array
}{
   \sstdescription{
      The routine obtains mapped access to an NDF axis array, returning
      a pointer to the mapped values and a count of the number of
      elements mapped.
   }
   \sstinvocation{
      CALL NDF\_AMAP( INDF, COMP, IAXIS, TYPE, MMOD, PNTR, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the axis array component to be mapped: {\tt '}CENTRE{\tt '},
         {\tt '}VARIANCE{\tt '} (or {\tt '}ERROR{\tt '}) or {\tt '}WIDTH{\tt '}.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the NDF axis whose array is to be mapped.
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Numeric type to be used for access (e.g. {\tt '}\_REAL{\tt '}).
      }
      \sstsubsection{
         MMOD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Mapping mode for access to the array: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or
         {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         PNTR( $*$ ) = INTEGER (Returned)
      }{
         Pointer(s) to the mapped values (see the Notes section).
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements mapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of axis array component names may also
         be given, in which case the routine will map all the requested
         axis arrays using the same numeric type and mapping mode.
         Pointers to the values of these mapped arrays will be returned
         (in the specified order) in the elements of the array PNTR, which
         must be of sufficient size to accommodate them.
      }
   }
}
\sstroutine{
   NDF\_ANNUL
}{
   Annul an NDF identifier
}{
   \sstdescription{
      The routine annuls the NDF identifier supplied so that it is no
      longer recognised as a valid identifier by the NDF\_ routines.
      Any resources associated with it are released and made available
      for re-use. If any NDF components are mapped for access, then
      they are automatically unmapped by this routine.
   }
   \sstinvocation{
      CALL NDF\_ANNUL( INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given and Returned)
      }{
         The NDF identifier to be annulled. A value of NDF\_\_NOID is
         returned (as defined in the include file NDF\_PAR).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set on
         entry, although no further error report will be made if it
         subsequently fails under these circumstances. In particular, it
         will fail if the identifier supplied is not initially valid, but
         this will only be reported if STATUS is set to SAI\_\_OK on entry.

         \sstitem
         An error will result if an attempt is made to annul the last
         remaining identifier associated with an NDF whose DATA component
         has not been defined (unless it is a temporary NDF, in which case
         it will be deleted at this point).
      }
   }
}
\sstroutine{
   NDF\_ANORM
}{
   Obtain the logical value of an NDF axis normalisation flag
}{
   \sstdescription{
      The routine returns a logical value for the normalisation flag
      associated with an NDF axis.
   }
   \sstinvocation{
      CALL NDF\_ANORM( INDF, IAXIS, NORM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the axis whose normalisation flag value is required.
      }
      \sstsubsection{
         NORM = LOGICAL (Returned)
      }{
         Normalisation flag value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A value of zero may be supplied for the IAXIS argument, in
         which case the routine will return the logical {\tt "}OR{\tt "} of the
         normalisation flag values for all the NDF{\tt '}s axes.
      }
   }
}
\sstroutine{
   NDF\_AREST
}{
   Reset an NDF axis component to an undefined state
}{
   \sstdescription{
      The routine resets an NDF axis component so that its value
      becomes undefined. It may be used to remove unwanted optional NDF
      axis components.
   }
   \sstinvocation{
      CALL NDF\_AREST( INDF, COMP, IAXIS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the axis component to be reset: {\tt '}LABEL{\tt '}, {\tt '}UNITS{\tt '},
         {\tt '}VARIANCE{\tt '} or {\tt '}WIDTH{\tt '}.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the NDF axis to be modified.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of axis component names may also be
         supplied, in which case each component will be reset in turn.

         \sstitem
         A value of zero may be supplied for the IAXIS argument, in
         which case the same component(s) will be reset on all the NDF{\tt '}s
         axes.

         \sstitem
         An axis component name of {\tt '}CENTRE{\tt '} may not be specified for
         this routine because the pixel centre information cannot be reset
         for each axis of an NDF individually. This information may only
         be removed from an NDF by resetting the entire axis component.
         This can be done by calling the routine NDF\_RESET and specifying
         a component name of {\tt '}AXIS{\tt '}.

         \sstitem
         This routine may only be used to reset an axis component via a
         base NDF. If an NDF section is supplied, then it will return
         without action. No error will result.

         \sstitem
         An NDF axis array component cannot be reset while it is mapped
         for access, even if this is via another NDF identifier. This
         routine will fail, and set a STATUS value, if this is the case.
      }
   }
}
\sstroutine{
   NDF\_ASNRM
}{
   Set a new logical value for an NDF axis normalisation flag
}{
   \sstdescription{
      The routine sets a new logical value for the normalisation flag
      associated with an NDF axis.
   }
   \sstinvocation{
      CALL NDF\_ASNRM( NORM, INDF, IAXIS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NORM = LOGICAL (Given)
      }{
         Normalisation flag value to be set.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the NDF axis whose normalisation flag value is to be
         set.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A value of zero may be supplied for the IAXIS component, in
         which case the routine will set the same normalisation flag value
         for all the NDF{\tt '}s axes.

         \sstitem
         This routine may only be used to set an axis normalisation
         flag value for a base NDF. If an NDF section is supplied, then it
         will return without action. No error will result.
      }
   }
}
\sstroutine{
   NDF\_ASSOC
}{
   Associate an existing NDF with an ADAM parameter
}{
   \sstdescription{
      The routine obtains access to an existing NDF through the ADAM
      parameter system, associates it with the named parameter, and
      issues an NDF identifier for it.
   }
   \sstinvocation{
      CALL NDF\_ASSOC( PARAM, MODE, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of NDF access required: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If {\tt '}WRITE{\tt '} access is specified, then all the NDF{\tt '}s components
         will be reset to an undefined state ready to receive new values.
         If {\tt '}UPDATE{\tt '} access is specified, the NDF{\tt '}s components will retain
         their values, which may then be modified.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_ASTAT
}{
   Determine the state of an NDF axis component (defined or
   undefined)
}{
   \sstdescription{
      The routine returns a logical value indicating whether a
      specified NDF axis component has a defined value (or values).
   }
   \sstinvocation{
      CALL NDF\_ASTAT( INDF, COMP, IAXIS, STATE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the axis component: {\tt '}CENTRE{\tt '}, {\tt '}LABEL{\tt '}, {\tt '}UNITS{\tt '},
         {\tt '}VARIANCE{\tt '} or {\tt '}WIDTH{\tt '}.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the NDF axis for which information is required.
      }
      \sstsubsection{
         STATE = LOGICAL (Returned)
      }{
         Whether the specified component is defined.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
\newpage
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of axis component names may also be
         given, in which case the routine will return the logical {\tt "}AND{\tt "} of
         the states of the specified components (i.e. a .TRUE. result will
         be returned only if all the components have defined values).

         \sstitem
         A value of zero may be given for the IAXIS argument, in which
         case the routine will return the logical {\tt "}AND{\tt "} of the results for
         all the NDF{\tt '}s axes.
      }
   }
}
\sstroutine{
   NDF\_ASTYP
}{
   Set a new numeric type for an NDF axis array
}{
   \sstdescription{
      The routine sets a new numeric type for an NDF axis array,
      causing its data storage type to be changed. If the array{\tt '}s
      values are defined, they will be converted from from the old type
      to the new one. If they are undefined, then no conversion will be
      necessary. Subsequent enquiries will reflect the new numeric
      type. Conversion may be performed between any numeric types
      supported by the NDF\_ routines.
   }
   \sstinvocation{
      CALL NDF\_ASTYP( TYPE, INDF, COMP, IAXIS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         New numeric type for the axis array (e.g. {\tt '}\_DOUBLE{\tt '}).
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the axis array component whose numeric type is to be
         set: {\tt '}CENTRE{\tt '}, {\tt '}VARIANCE{\tt '} or {\tt '}WIDTH{\tt '}.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the NDF axis whose array is to be modified.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of axis array component names may also
         be supplied, in which case the numeric type of each array will be
         set to the same value in turn.

         \sstitem
         A value of zero may be supplied for the IAXIS argument, in
         which case the routine will set a new numeric type for the
         specified component(s) of all the NDF{\tt '}s axes.

         \sstitem
         This routine may only be used to change the numeric type of an
         axis array via a base NDF. If an NDF section is supplied, then it
         will return without action. No error will result.

         \sstitem
         The numeric type of an axis array component cannot be changed
         while it, or any part of it, is mapped for access (e.g. via
         another NDF identifier). This routine will fail, and set a STATUS
         value, if this is the case.

         \sstitem
         If the numeric type of an axis array component is to be
         changed without its values being retained, then a call to
         NDF\_AREST should be made beforehand.  This will avoid the cost of
         converting all the values.
      }
   }
}
\sstroutine{
   NDF\_ATYPE
}{
   Obtain the numeric type of an NDF axis array
}{
   \sstdescription{
      The routine returns the numeric type of an NDF axis array as an
      upper-case character string (e.g. {\tt '}\_REAL{\tt '}).
   }
   \sstinvocation{
      CALL NDF\_ATYPE( INDF, COMP, IAXIS, TYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the axis array component whose numeric type is
         required: {\tt '}CENTRE{\tt '}, {\tt '}VARIANCE{\tt '} or {\tt '}WIDTH{\tt '}.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the NDF axis for which information is required.
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Numeric type of the axis array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of axis array component names may also
         be supplied to this routine. In this case the result returned
         will be the lowest precision numeric type to which all the
         specified axis arrays can be converted without unnecessary loss
         of information.

         \sstitem
         A value of zero may be supplied for the IAXIS argument, in
         which case the routine will combine the results for all the NDF{\tt '}s
         axes in the same way as described above.

         \sstitem
         The symbolic constant NDF\_\_SZTYP may be used for declaring the
         length of a character variable which is to hold the numeric type
         of an NDF axis array. This constant is defined in the include
         file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_AUNMP
}{
   Unmap an NDF axis array
}{
   \sstdescription{
      The routine unmaps an NDF axis array which has previously been
      mapped for READ, UPDATE or WRITE access.
   }
   \sstinvocation{
      CALL NDF\_AUNMP( INDF, COMP, IAXIS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the axis array component to be unmapped: {\tt '}CENTRE{\tt '},
         {\tt '}VARIANCE{\tt '}, {\tt '}WIDTH{\tt '} or {\tt '}$*${\tt '}. The last value acts as a wild
         card, causing all mapped axis components to be unmapped.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         Number of the NDF axis whose array is to be unmapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set on
         entry, although no further error report will be made if it
         subsequently fails under these circumstances.

         \sstitem
         A comma-separated list of axis component names may also be
         given, in which case each component will be unmapped in turn.

         \sstitem
         A value of zero may be supplied for the IAXIS argument, in
         which case the routine will unmap the specified component(s) for
         all the NDF{\tt '}s axes.

         \sstitem
         An error will be reported if a component has not previously
         been mapped for access, except in cases where a wild card
         unmapping operation is specified (either with a component name of
         {\tt '}$*${\tt '} or an axis number of zero).
      }
   }
}
\sstroutine{
   NDF\_BAD
}{
   Determine if an NDF array component may contain bad pixels
}{
   \sstdescription{
      The routine returns a logical value indicating whether an array
      component of an NDF may contain bad pixels for which checks must
      be made when the array{\tt '}s values are processed. Only if the
      returned value is .FALSE. can such checks be omitted. If the
      CHECK argument to this routine is set .TRUE., then it will also
      perform an explicit check (if necessary) to see whether bad
      pixels are actually present.
   }
   \sstinvocation{
      CALL NDF\_BAD( INDF, COMP, CHECK, BAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component: {\tt '}DATA{\tt '}, {\tt '}QUALITY{\tt '} or
         {\tt '}VARIANCE{\tt '}.
      }
      \sstsubsection{
         CHECK = LOGICAL (Given)
      }{
         Whether to perform an explicit check to see whether bad pixels
         are actually present.
      }
      \sstsubsection{
         BAD = LOGICAL (Returned)
      }{
         Whether it is necessary to check for bad pixels when
         processing the array{\tt '}s values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of component names may also be
         supplied, in which case the routine returns the logical {\tt "}OR{\tt "} of
         the results for each component.

         \sstitem
         If CHECK is set .FALSE., then the returned value of BAD will
         indicate whether bad pixels might be present and should therefore
         be checked for during subsequent processing. However, even if BAD
         is returned .TRUE. in such circumstances, it is still possible
         that there may not actually be any bad pixels present (for
         instance, in an NDF section, the accessible region of an array
         component might happen to avoid all the bad pixels).

         \sstitem
         If CHECK is set .TRUE., then an explicit check will be made,
         if necessary, to ensure that BAD is only returned .TRUE. if bad
         pixels are actually present.

         \sstitem
         If a component is mapped for access through the identifier
         supplied, then the value of BAD will refer to the actual mapped
         values. It may differ from its original (unmapped) value if
         conversion errors occurred during the mapping process, if an
         initialisation option of {\tt '}/ZERO{\tt '} was specified for a component
         whose value was initially undefined, or if the mapped values have
         subsequently been modified.

         \sstitem
         A BAD=.TRUE. result will be returned for any components which
         are in an undefined state, except in the case of the QUALITY
         component for which a .FALSE. result is always returned under
         these circumstances.
      }
   }
}
\sstroutine{
   NDF\_BASE
}{
   Obtain an identifier for a base NDF
}{
   \sstdescription{
      The routine returns an identifier for the base NDF with which an
      NDF section is associated.
   }
   \sstinvocation{
      CALL NDF\_BASE( INDF1, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF section (the routine will also
         work if this is already a base NDF).
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the base NDF with which the section is
         associated.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_BB
}{
   Obtain the bad-bits mask value for the quality component of an
   NDF
}{
   \sstdescription{
      The routine returns an unsigned byte value representing the
      bad-bits mask associated with the quality component of an NDF.
   }
   \sstinvocation{
      CALL NDF\_BB( INDF, BADBIT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         BADBIT = BYTE (Returned)
      }{
         The unsigned byte bad-bits mask.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDF\_BEGIN
}{
   Begin a new NDF context
}{
   \sstdescription{
      The routine begins a new NDF context. A subsequent call to
      NDF\_END may then be used to annul all the NDF identifiers (and
      placeholders) issued since the call to NDF\_BEGIN was made.
   }
   \sstinvocation{
      CALL NDF\_BEGIN
   }
   \sstnotes{
      Matching pairs of calls to NDF\_BEGIN and NDF\_END may be nested.
   }
}
\sstroutine{
   NDF\_BLOCK
}{
   Obtain an NDF section containing a block of adjacent pixels
}{
   \sstdescription{
      The routine returns an identifier for an NDF section describing a
      {\tt "}block{\tt "} of adjacent pixels selected from an initial NDF. The
      routine divides the original NDF logically into a series of such
      blocks, each of which does not exceed a specified maximum number
      of pixels in each dimension. The routine{\tt '}s IBLOCK argument
      allows one of these blocks to be selected; an NDF section for it
      is then returned.
   }
   \sstinvocation{
      CALL NDF\_BLOCK( INDF1, NDIM, MXDIM, IBLOCK, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for the initial NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of maximum dimension sizes.
      }
      \sstsubsection{
         MXDIM( NDIM ) = INTEGER (Given)
      }{
         Array specifying the maximum size of a block in pixels along
         each dimension.
      }
      \sstsubsection{
         IBLOCK = INTEGER (Given)
      }{
         Number of the block required (the first block is numbered 1).
      }
      \sstsubsection{
         INTEGER = INDF2 (Returned)
      }{
         Identifier for an NDF section describing the block.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine is intended to allow NDFs to be processed in
         smaller pieces by selecting successive blocks, each of which may
         then be processed individually. Note that in general not all the
         blocks selected from an NDF will have the same shape or size,
         although none will exceed the specified maximum number of pixels
         in each dimension.

         \sstitem
         Corresponding blocks selected from different NDFs (or NDF
         sections) with identical shapes will themselves have identical
         shapes and will contain the same number of pixels.

         \sstitem
         All NDF sections obtained via this routine have the same
         number of dimensions as the input NDF. If the number of maximum
         dimension sizes supplied (NDIM) is less than this number, then a
         value of 1 will be used for the extra dimension sizes. If the
         value of NDIM is larger than this number, then the excess
         dimension sizes will be ignored.

         \sstitem
         If the number of the requested block (IBLOCK) exceeds the
         number of blocks available in the NDF, then a value of NDF\_\_NOID
         will be returned for the INDF2 argument (but no error will
         result). This condition may be used to terminate a loop when all
         available blocks have been processed. The NDF\_NBLOC routine may
         also be used to determine the number of blocks available.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason.

         \sstitem
         The NDF\_\_NOID constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_BOUND
}{
   Enquire the pixel-index bounds of an NDF
}{
   \sstdescription{
      The routine returns the lower and upper pixel-index bounds of
      each dimension of an NDF, together with the total number of
      dimensions.
   }
   \sstinvocation{
      CALL NDF\_BOUND( INDF, NDIMX, LBND, UBND, NDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NDIMX = INTEGER (Given)
      }{
         Maximum number of pixel-index bounds to return (i.e. the
         declared size of the LBND and UBND arguments).
      }
      \sstsubsection{
         LBND( NDIMX ) = INTEGER (Returned)
      }{
         Lower pixel-index bounds for each dimension.
      }
      \sstsubsection{
         UBND( NDIMX ) = INTEGER (Returned)
      }{
         Upper pixel-index bounds for each dimension.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         Total number of NDF dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the NDF has fewer than NDIMX dimensions, then any remaining
         elements of the LBND and UBND arguments will be filled with 1{\tt '}s.

         \sstitem
         If the NDF has more than NDIMX dimensions, then the NDIM
         argument will return the actual number of dimensions. In this
         case only the first NDIMX sets of bounds will be returned, and an
         error will result if the size of any of the remaining dimensions
         exceeds 1.

         \sstitem
         If this routine is called with STATUS set, then a value of 1
         will be returned for all elements of the LBND and UBND arrays and
         for the NDIM argument, although no further processing will occur.
         The same values will also be returned if the routine should fail
         for any reason.

         \sstitem
         The symbolic constant NDF\_\_MXDIM may be used to declare the
         size of the LBND and UBND arguments so that they will be able to
         hold the maximum number of NDF bounds that this routine can
         return. This constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_CGET
}{
   Obtain the value of an NDF character component
}{
   \sstdescription{
      The routine obtains the value of the specified character
      component of an NDF (i.e. the value of the LABEL, TITLE or UNITS
      component).
   }
   \sstinvocation{
      CALL NDF\_CGET( INDF, COMP, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the character component whose value is required:
         {\tt '}LABEL{\tt '}, {\tt '}TITLE{\tt '} or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The component{\tt '}s value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the requested component is in an undefined state, then the
         VALUE argument will be returned unchanged. A suitable default
         should therefore be established before calling this routine.

         \sstitem
         If the length of the VALUE argument is too short to
         accommodate the returned result without losing significant
         (non-blank) trailing characters, then this will be indicated by
         an appended ellipsis, i.e. {\tt '}...{\tt '}. No error will result.
      }
   }
}
\sstroutine{
   NDF\_CHUNK
}{
   Obtain an NDF section containing a chunk of contiguous pixels
}{
   \sstdescription{
      The routine returns an identifier for an NDF section describing a
      {\tt "}chunk{\tt "} of contiguous pixels selected from an initial NDF.  The
      routine divides the initial NDF logically into a series of such
      chunks, each of which follows immediately on from the previous
      chunk, and each of which contains no more than a specified
      maximum number (MXPIX) of contiguous pixels. The routine{\tt '}s ICHUNK
      argument allows one of these chunks to be selected; an NDF
      section for it is then returned.
   }
   \sstinvocation{
      CALL NDF\_CHUNK( INDF1, MXPIX, ICHUNK, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for the initial NDF.
      }
      \sstsubsection{
         MXPIX = INTEGER (Given)
      }{
         Maximum number of contiguous pixels required in each chunk.
      }
      \sstsubsection{
         ICHUNK = INTEGER (Given)
      }{
         Number of the chunk required (the first chunk is numbered 1).
      }
      \sstsubsection{
         INDF2 = INTEGER (Given)
      }{
         Identifier for an NDF section describing the chunk.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine is intended to allow large NDFs to be processed
         in smaller pieces by selecting successive chunks, each of which
         may then be processed individually. Note that in general not all
         the chunks selected from an NDF will have the same size, although
         none will contain more than the specified maximum number of
         pixels.

         \sstitem
         Corresponding chunks selected from different NDFs (or NDF
         sections) with identical shapes will themselves have identical
         shapes and will contain the same number of pixels.

         \sstitem
         All NDF sections obtained via this routine have the same number
         of dimensions as the input NDF.

         \sstitem
         If the number of the requested chunk (ICHUNK) exceeds the
         number of chunks available in the NDF, then a value of NDF\_\_NOID
         will be returned for the INDF2 argument (but no error will
         result). This condition may be used to terminate a loop when all
         available chunks have been processed. The NDF\_NCHNK routine may
         also be used to determine the number of chunks available.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason.

         \sstitem
         The NDF\_\_NOID constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_CINP
}{
   Obtain an NDF character component value via the ADAM parameter
   system
}{
   \sstdescription{
      The routine obtains a new value for a character component of an
      NDF via the ADAM parameter system and uses it to replace any
      pre-existing value of that component in the NDF.
   }
   \sstinvocation{
      CALL NDF\_CINP( PARAM, INDF, COMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the character component for which a value is to be
         obtained: {\tt '}LABEL{\tt '}, {\tt '}TITLE{\tt '} or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A {\tt "}null{\tt "} parameter value is interpreted as indicating that no
         new value should be set for the character component. In this
         event, the routine will return without action (and without
         setting a STATUS value). A suitable default value for the
         character component should therefore be established before this
         routine is called.
      }
   }
}
\sstroutine{
   NDF\_CLEN
}{
   Determine the length of an NDF character component
}{
   \sstdescription{
      The routine returns the length of the specified character
      component of an NDF (i.e. the number of characters in the LABEL,
      TITLE or UNITS component).
   }
   \sstinvocation{
      CALL NDF\_CLEN( INDF, COMP, LENGTH, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the character component whose length is required:
         {\tt '}LABEL{\tt '}, {\tt '}TITLE{\tt '} or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         LENGTH = INTEGER (Returned)
      }{
         Length of the component in characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The length of an NDF character component is determined by the
         length of the VALUE string assigned to it by a previous call to
         NDF\_CPUT (note that this could include trailing blanks).

         \sstitem
         If the specified component is in an undefined state, then a
         length of zero will be returned.
      }
   }
}
\sstroutine{
   NDF\_CLONE
}{
   Clone an NDF identifier
}{
   \sstdescription{
      The routine produces a {\tt "}cloned{\tt "} copy of an NDF identifier (i.e.
      it produces a new identifier describing an NDF with identical
      attributes to the original).
   }
   \sstinvocation{
      CALL NDF\_CLONE( INDF1, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         NDF identifier to be cloned.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Cloned identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_CMPLX
}{
   Determine whether an NDF array component holds complex values
}{
   \sstdescription{
      The routine returns a logical value indicating whether the
      specified array component of an NDF holds complex values.
   }
   \sstinvocation{
      CALL NDF\_CMPLX( INDF, COMP, CMPLX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component: {\tt '}DATA{\tt '}, {\tt '}QUALITY{\tt '} or
         {\tt '}VARIANCE{\tt '}.
      }
      \sstsubsection{
         CMPLX = LOGICAL (Returned)
      }{
         Whether the component holds complex values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
\newpage
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of components may also be specified, in
         which case the logical {\tt "}OR{\tt "} of the results for each component
         will be returned.

         \sstitem
         The value returned for the QUALITY component is always
         .FALSE..
      }
   }
}
\sstroutine{
   NDF\_CMSG
}{
   Assign the value of an NDF character component to a message token
}{
   \sstdescription{
      The routine assigns the value of the specified character
      component of an NDF to a message token, for use in constructing
      messages using the MSG\_ or ERR\_ routines (see SUN/104).
   }
   \sstinvocation{
      CALL NDF\_CMSG( TOKEN, INDF, COMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the message token.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the character component whose value is to be used:
         {\tt '}LABEL{\tt '}, {\tt '}TITLE{\tt '} or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the specified NDF component does not have a defined value,
         then the string {\tt '}$<$undefined$>${\tt '} is assigned to the token instead.
      }
   }
}
\sstroutine{
   NDF\_COPY
}{
   Copy an NDF to a new location
}{
   \sstdescription{
      The routine copies an NDF to a new location and returns an
      identifier for the resulting new base NDF.
   }
   \sstinvocation{
      CALL NDF\_COPY( INDF1, PLACE, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for the NDF (or NDF section) to be copied.
      }
      \sstsubsection{
         PLACE = INTEGER (Given and Returned)
      }{
         An NDF placeholder (e.g. generated by the NDF\_PLACE routine)
         which indicates the position in the data system where the new
         NDF will reside. The placeholder is annulled by this routine,
         and a value of NDF\_\_NOPL will be returned (as defined in the
         include file NDF\_PAR).
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason.  In either
         event the placeholder will still be annulled.  The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_CPUT
}{
   Assign a value to an NDF character component
}{
   \sstdescription{
      The routine assigns a value to the specified character component
      of an NDF (i.e. to the LABEL, TITLE or UNITS component). Any
      previous value is over-written.
   }
   \sstinvocation{
      CALL NDF\_CPUT( VALUE, INDF, COMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The value to be assigned.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the character component whose value is to be assigned:
         {\tt '}LABEL{\tt '}, {\tt '}TITLE{\tt '} or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The entire VALUE string (including trailing blanks if present)
         is assigned to the specified component, whose length is adjusted
         to accommodate it.
      }
   }
}
\sstroutine{
   NDF\_CREAT
}{
   Create a new simple NDF via the ADAM parameter system
}{
   \sstdescription{
      The routine creates a new simple NDF via the ADAM parameter
      system, associates it with a parameter, and returns an NDF
      identifier for it.
   }
   \sstinvocation{
      CALL NDF\_CREAT( PARAM, FTYPE, NDIM, LBND, UBND, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_DOUBLE{\tt '} or
         {\tt '}COMPLEX\_REAL{\tt '}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine creates a {\tt "}simple{\tt "} NDF, i.e. one whose array
         components will be stored in {\tt "}simple{\tt "} form by default (see
         SGP/38).

         \sstitem
         The full data type of the DATA component is specified via the
         FTYPE argument and the data type of the VARIANCE component
         defaults to the same value. These data types may be set
         individually with the NDF\_STYPE routine if required.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_CREP
}{
   Create a new primitive NDF via the ADAM parameter system
}{
   \sstdescription{
      The routine creates a new primitive NDF via the ADAM parameter
      system, associates it with a parameter, and returns an NDF
      identifier for it.
   }
   \sstinvocation{
      CALL NDF\_CREP( PARAM, FTYPE, NDIM, UBND, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_REAL{\tt '}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine creates a {\tt "}primitive{\tt "} NDF, i.e. one whose array
         components will be stored in {\tt "}primitive{\tt "} form by default (see
         SGP/38).

         \sstitem
         The data type of the DATA component is specified via the FTYPE
         argument and the data type of the VARIANCE component defaults to
         the same value. These data types may be set individually with the
         NDF\_STYPE routine if required.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_DELET
}{
   Delete an NDF
}{
   \sstdescription{
      The routine deletes the specified NDF. If this is a base NDF,
      then the associated data object is erased and all NDF identifiers
      which refer to it (or to sections derived from it) become
      invalid. If any NDF components are mapped for access, then they
      are first unmapped. If an NDF section is specified, then this
      routine is equivalent to calling NDF\_ANNUL, and no other
      identifiers are affected.
   }
   \sstinvocation{
      CALL NDF\_DELET( INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given and Returned)
      }{
         Identifier for the NDF to be deleted. A value of NDF\_\_NOID is
         returned (as defined in the include file NDF\_PAR).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set on
         entry, although no further error report will be made if it
         subsequently fails under these circumstances.
      }
   }
}
\sstroutine{
   NDF\_DIM
}{
   Enquire the dimension sizes of an NDF
}{
   \sstdescription{
      The routine returns the size in pixels of each dimension of an
      NDF, together with the total number of dimensions (the size of a
      dimension is the difference between that dimension{\tt '}s upper and
      lower pixel-index bounds $+$ 1).
   }
   \sstinvocation{
      CALL NDF\_DIM( INDF, NDIMX, DIM, NDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NDIMX = INTEGER (Given)
      }{
         Maximum number of dimension sizes to return (i.e. the declared
         size of the DIM argument).
      }
      \sstsubsection{
         DIM( NDIMX ) = INTEGER (Returned)
      }{
         Size of each dimension in pixels.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         Total number of NDF dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the NDF has fewer than NDIMX dimensions, then any remaining
         elements of the DIM argument will be filled with 1{\tt '}s.

         \sstitem
         If the NDF has more than NDIMX dimensions, then the NDIM
         argument will return the actual number of dimensions. In this
         case only the first NDIMX dimension sizes will be returned, and
         an error will result if the size of any of the excluded
         dimensions exceeds 1.

         \sstitem
         If this routine is called with STATUS set, then a value of 1
         will be returned for all elements of the DIM array and for the
         NDIM argument, although no further processing will occur.  The
         same values will also be returned if the routine should fail for
         any reason.

         \sstitem
         The symbolic constant NDF\_\_MXDIM may be used to declare the
         size of the DIM argument so that it will be able to hold the
         maximum number of NDF dimension sizes that this routine can
         return. This constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_END
}{
   End the current NDF context
}{
   \sstdescription{
      The routine ends the current NDF context, causing all NDF
      identifiers and placeholders created within that context (i.e.
      since a matching call to NDF\_BEGIN) to be annulled. Any mapped
      values associated with these identifiers are unmapped, and any
      temporary NDFs which no longer have identifiers associated with
      them are deleted.
   }
   \sstinvocation{
      CALL NDF\_END( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Matching pairs of calls to NDF\_BEGIN and NDF\_END may be
         nested. An error will be reported if NDF\_END is called without a
         corresponding call to NDF\_BEGIN.

         \sstitem
         This routine attempts to execute even if STATUS is set on
         entry, although no further error report will be made if it
         subsequently fails under these circumstances.
      }
   }
}
\sstroutine{
   NDF\_EXIST
}{
   See if an existing NDF is associated with an ADAM parameter
}{
   \sstdescription{
      The routine determines if an existing (and accessible) NDF is
      associated with an ADAM parameter. If it is, then an identifier
      is returned for it. If not, then the routine returns with an
      identifier value of NDF\_\_NOID; this then allows the NDF structure
      to be created (e.g. using NDF\_CREAT) if required.
   }
   \sstinvocation{
      CALL NDF\_EXIST( PARAM, MODE, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of NDF access required: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If {\tt '}WRITE{\tt '} access is specified, then all the NDF{\tt '}s components
         will be reset to an undefined state ready to receive new values.
         If {\tt '}UPDATE{\tt '} access is specified, the NDF{\tt '}s components will retain
         their values, which may then be modified.

         \sstitem
         The behaviour of this routine is the same as NDF\_ASSOC, except
         that in the event of the NDF structure not existing (or being
         inaccessible), control is returned to the application with an
         identifier value of NDF\_\_NOID, rather than re-prompting the user.

         \sstitem
         Note that unlike the DAT\_EXIST routine, on which it is
         modelled, this routine does not set a STATUS value if the data
         structure does not exist.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason.  The
         NDF\_\_NOID constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_FIND
}{
   Find an NDF in an HDS structure and import it into the NDF\_
   system
}{
   \sstdescription{
      The routine finds an NDF within an HDS structure, imports it into
      the NDF\_ system and issues an identifier for it. The imported NDF
      may then be manipulated by the NDF\_ routines.
   }
   \sstinvocation{
      CALL NDF\_FIND( LOC, NAME, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Locator to the enclosing HDS structure.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the HDS structure component to be imported.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The value given for the NAME argument may be an HDS path name,
         consisting of several fields separated by {\tt '}.{\tt '}, so that an NDF can
         be found in a sub-component (or a sub-sub-component...) of the
         structure identified by the locator LOC.  Array subscripts may
         also be used in this component name.  Thus a string such as
         {\tt '}MYSTRUC.ZONE(2).IMAGE{\tt '} could be used as a valid NAME value.

         \sstitem
         If a blank value is given for the NAME argument, then the NDF
         to be imported will be the object identified directly by the
         locator LOC.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF argument, although no
         further processing will occur.  The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_FORM
}{
   Obtain the storage form of an NDF array component
}{
   \sstdescription{
      The routine returns the storage form of an NDF array component as
      an upper case character string (e.g. {\tt '}SIMPLE{\tt '}).
   }
   \sstinvocation{
      CALL NDF\_FORM( INDF, COMP, FORM, STATUS )
   }
\newpage
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component whose storage form is required:
         {\tt '}DATA{\tt '}, {\tt '}QUALITY{\tt '} or {\tt '}VARIANCE{\tt '}.
      }
      \sstsubsection{
         FORM = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Storage form of the component.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The symbolic constant NDF\_\_SZFRM may be used for declaring the
         length of a character variable to hold the storage form of an NDF
         array component. This constant is defined in the include file
         NDF\_PAR.

         \sstitem
         At present, the NDF\_ routines only support {\tt "}primitive{\tt "} and
         {\tt "}simple{\tt "} arrays, so only the values {\tt '}PRIMITIVE{\tt '} and {\tt '}SIMPLE{\tt '} can
         be returned.
      }
   }
}
\sstroutine{
   NDF\_FTYPE
}{
   Obtain the full data type of an NDF array component
}{
   \sstdescription{
      The routine returns the full data type of one of the array
      components of an NDF as an upper-case character string (e.g.
      {\tt '}\_REAL{\tt '} or {\tt '}COMPLEX\_BYTE{\tt '}).
   }
   \sstinvocation{
      CALL NDF\_FTYPE( INDF, COMP, FTYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component whose type is required: {\tt '}DATA{\tt '},
         {\tt '}QUALITY{\tt '} or {\tt '}VARIANCE{\tt '}.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Full data type of the component.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of component names may also be supplied
         to this routine. In this case the result returned will be the
         lowest precision full data type to which the values held in all
         the specified components can be converted without unnecessary
         loss of information.

         \sstitem
         The value returned for the QUALITY component is always
         {\tt '}\_UBYTE{\tt '}.

         \sstitem
         The symbolic constant NDF\_\_SZFTP may be used for declaring the
         length of a character variable to hold the full data type of an
         NDF array component. This constant is defined in the include file
         NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_GTUNE
}{
   Obtain the value of an NDF\_ system tuning parameter
}{
   \sstdescription{
      The routine returns the current value of an NDF\_ system internal
      tuning parameter.
   }
   \sstinvocation{
      CALL NDF\_GTUNE( TPAR, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TPAR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the tuning parameter whose value is required (case
         insensitive).  This name may be abbreviated to no less than 3
         characters.
      }
      \sstsubsection{
         VALUE = INTEGER (Returned)
      }{
         Value of the parameter.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      See the NDF\_TUNE routine for a list of the tuning parameters
      currently available.
   }
}
\sstroutine{
   NDF\_IMPRT
}{
   Import an NDF into the NDF\_ system from HDS
}{
   \sstdescription{
      The routine imports an NDF into the NDF\_ system from HDS and
      issues an identifier for it. The NDF may then be manipulated by
      the NDF\_ routines.
   }
   \sstinvocation{
      CALL NDF\_IMPRT( LOC, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         HDS locator to an NDF structure.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The locator supplied as input to this routine may later be
         annulled without affecting the subsequent behaviour of the NDF\_
         system.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_ISACC
}{
   Determine whether a specified type of NDF access is available
}{
   \sstdescription{
      The routine determines whether a specified type of access to an
      NDF is available, or whether it has been disabled. If access is
      not available, then any attempt to access the NDF in this way
      will fail.
   }
   \sstinvocation{
      CALL NDF\_ISACC( INDF, ACCESS, ISACC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         ACCESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The type of NDF access required: {\tt '}BOUNDS{\tt '}, {\tt '}DELETE{\tt '}, {\tt '}SHIFT{\tt '},
         {\tt '}TYPE{\tt '} or {\tt '}WRITE{\tt '} (see the Notes section for details).
      }
      \sstsubsection{
         ISACC = LOGICAL (Returned)
      }{
         Whether the specified type of access is available.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The valid access types control the following operations on the
      NDF:
      \sstitemlist{

         \sstitem
         {\tt '}BOUNDS{\tt '} permits the pixel-index bounds of a base NDF to be
         altered.

         \sstitem
         {\tt '}DELETE{\tt '} permits deletion of the NDF.

         \sstitem
         {\tt '}SHIFT{\tt '} permits pixel-index shifts to be applied to a base
         NDF.

         \sstitem
         {\tt '}TYPE{\tt '} permits the data types of an NDF{\tt '}s components to be
         altered.

         \sstitem
         {\tt '}WRITE{\tt '} permits new values to be written to the NDF, and the
         state of any of its components to be reset.
      }
   }
}
\sstroutine{
   NDF\_ISBAS
}{
   Enquire if an NDF is a base NDF
}{
   \sstdescription{
      The routine returns a logical value indicating whether the NDF
      whose identifier is supplied is a base NDF (as opposed to an NDF
      section).
   }
   \sstinvocation{
      CALL NDF\_ISBAS( INDF, ISBAS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         ISBAS = LOGICAL (Returned)
      }{
         Whether the NDF is a base NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDF\_ISTMP
}{
   Enquire if an NDF is temporary
}{
   \sstdescription{
      The routine returns a logical value indicating whether the
      specified NDF is temporary. Temporary NDFs are deleted once the
      last identifier which refers to them is annulled.
   }
   \sstinvocation{
      CALL NDF\_ISTMP( INDF, ISTMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         ISTMP = LOGICAL (Returned)
      }{
         Whether the NDF is temporary.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDF\_LOC
}{
   Obtain an HDS locator for an NDF
}{
   \sstdescription{
      The routine returns an HDS locator for an NDF whose identifier is
      supplied.
   }
   \sstinvocation{
      CALL NDF\_LOC( INDF, MODE, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Mode of access required to the NDF: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or
         {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         HDS locator to the NDF data structure.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If an identifier for an NDF section is supplied to this
         routine, then the returned locator will refer to the associated
         base NDF.

         \sstitem
         It is the caller{\tt '}s responsibility to annul the locator
         returned by this routine (by calling the HDS routine DAT\_ANNUL)
         when it is no longer required. The NDF\_ system will not perform
         this task itself.

         \sstitem
         If this routine is called with STATUS set, then an invalid
         locator will be returned for the LOC argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason.

         \sstitem
         Although this routine will check the access mode value
         supplied against the available access to the NDF, HDS does not
         allow the returned locator to be protected against write access
         in the case where WRITE access to an NDF is available, but only
         READ access was requested. In this case it is the responsibility
         of the caller to respect the locator access restriction.

         \sstitem
         The locator returned by this routine should not be used to
         make alterations to any part of a data structure which is
         simultaneously being used by the NDF\_ system, otherwise there is
         the possibility of serious internal errors and data corruption.
      }
   }
}
\sstroutine{
   NDF\_MAP
}{
   Obtain mapped access to an array component of an NDF
}{
   \sstdescription{
      The routine obtains mapped access to an array component of an
      NDF, returning a pointer to the mapped values and a count of the
      number of elements mapped.
   }
   \sstinvocation{
      CALL NDF\_MAP( INDF, COMP, TYPE, MMOD, PNTR, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component to be mapped: {\tt '}DATA{\tt '},
         {\tt '}QUALITY{\tt '} or {\tt '}VARIANCE{\tt '} (or {\tt '}ERROR{\tt '}).
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Numeric type to be used for access (e.g. {\tt '}\_REAL{\tt '}).
      }
      \sstsubsection{
         MMOD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Mapping mode for access to the array: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or
         {\tt '}WRITE{\tt '}, with an optional initialisation mode {\tt '}/BAD{\tt '} or
         {\tt '}/ZERO{\tt '} appended.
      }
      \sstsubsection{
         PNTR( $*$ ) = INTEGER (Returned)
      }{
         Pointer(s) to the mapped values (see the Notes section).
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements mapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of component names may also be given,
         in which case the routine will map all the requested components
         using the same data type and mapping mode. Pointers to the values
         of these mapped components will be returned (in the specified
         order) in the elements of the array PNTR, which must be of
         sufficient size to accommodate them.

         \sstitem
         The result of mapping the QUALITY component with a data type
         other than {\tt '}\_UBYTE{\tt '} is not defined and should not be used.

         \sstitem
         If this routine is called with STATUS set, then a value of 1
         will be returned for the EL argument, although no further
         processing will occur.  The same value will also be returned if
         the routine should fail for any reason.
      }
   }
}
\sstroutine{
   NDF\_MAPQL
}{
   Map the quality component of an NDF as an array of logical
   values
}{
   \sstdescription{
      The routine maps the quality component of an NDF for read access,
      returning a pointer to an array of logical values. Elements of
      this array are set to .TRUE. if the bit-wise {\tt "}AND{\tt "} of the
      corresponding quality value and its effective bad-bits mask gives
      a zero result, indicating that the corresponding NDF pixel may be
      used in subsequent processing. Other array elements are set to
      .FALSE., indicating that corresponding NDF pixels should be
      excluded from subsequent processing.
   }
   \sstinvocation{
      CALL NDF\_MAPQL( INDF, PNTR, EL, BAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         PNTR = INTEGER (Returned)
      }{
         Pointer to the mapped array of logical values.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of values mapped.
      }
      \sstsubsection{
         BAD = LOGICAL (Returned)
      }{
         This argument is set to .TRUE. if any of the mapped values is
         set to .FALSE. (i.e. if any NDF pixels are to be excluded as a
         consequence of the associated quality values). Otherwise it is
         set to .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the quality component{\tt '}s values are undefined, then this
         routine will return a pointer to an array of .TRUE. values.

         \sstitem
         Note that this routine only obtains read access to the quality
         component; changes made to the mapped values will not be
         reflected in changes to the NDF{\tt '}s quality values.

         \sstitem
         This routine disables automatic quality masking, so that
         subsequent access to other NDF array components via the same
         identifier will take no account of the possible presence of
         associated quality values.

         \sstitem
         If this routine is called with STATUS set, then a value of 1
         will be returned for the EL argument, although no further
         processing will occur.  The same value will also be returned if
         the routine should fail for any reason.
      }
   }
}
\sstroutine{
   NDF\_MAPZ
}{
   Obtain complex mapped access to an array component of an NDF
}{
   \sstdescription{
      The routine obtains complex mapped access to an array component
      of an NDF, returning pointers to the mapped real and imaginary
      values and a count of the number of elements mapped.
   }
   \sstinvocation{
      CALL NDF\_MAPZ( INDF, COMP, TYPE, MMOD, RPNTR, IPNTR, EL,
      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component to be mapped: {\tt '}DATA{\tt '} or
         {\tt '}VARIANCE{\tt '} (or {\tt '}ERROR{\tt '}).
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Numeric type to be used for access (e.g.  {\tt '}\_REAL{\tt '}).
      }
      \sstsubsection{
         MMOD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Mapping mode for access to the array: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or
         {\tt '}WRITE{\tt '}, with an optional initialisation mode {\tt '}/ZERO{\tt '} or
         {\tt '}/BAD{\tt '} appended.
      }
      \sstsubsection{
         RPNTR( $*$ ) = INTEGER (Returned)
      }{
         Pointer(s) to the mapped real (i.e. non-imaginary) values (see
         the Notes section).
      }
      \sstsubsection{
         IPNTR( $*$ ) = INTEGER (Returned)
      }{
         Pointer(s) to the mapped imaginary values (see the Notes
         section).
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements mapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of component names may also be given,
         in which case the routine will map all the requested components
         using the same data type and mapping mode. Pointers to the values
         of these mapped components will be returned (in the specified
         order) in the elements of the arrays RPNTR and IPNTR, which must
         be of sufficient size to accommodate them.

         \sstitem
         Access to an NDF{\tt '}s QUALITY component is not available using
         this routine.

         \sstitem
         If this routine is called with STATUS set, then a value of 1
         will be returned for the EL argument, although no further
         processing will occur.  The same value will also be returned if
         the routine should fail for any reason.
      }
   }
}
\sstroutine{
   NDF\_MBAD
}{
   Merge the bad-pixel flags of the array components of a pair of
   NDFs
}{
   \sstdescription{
      The routine merges the bad-pixel flag values of an array
      component (or components) for a pair of NDFs, returning the
      logical {\tt "}OR{\tt "} of the separate values for each NDF. In addition, if
      bad pixels are found to be present in either NDF but the
      application indicates that it cannot correctly handle such
      values, then an error to this effect is reported and a STATUS
      value is set.
   }
   \sstinvocation{
      CALL NDF\_MBAD( BADOK, INDF1, INDF2, COMP, CHECK, BAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BADOK = LOGICAL (Given)
      }{
         Whether the application can correctly handle NDF array
         components containing bad pixel values.
      }
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for the first NDF whose bad-pixel flag value is to
         be merged.
      }
      \sstsubsection{
         INDF2 = INTEGER (Given)
      }{
         Identifier for the second NDF.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component: {\tt '}DATA{\tt '}, {\tt '}QUALITY{\tt '} or
         {\tt '}VARIANCE{\tt '}.
      }
      \sstsubsection{
         CHECK = LOGICAL (Given)
      }{
         Whether to perform explicit checks to see whether bad pixels
         are actually present. (This argument performs the same
         function as in the routine NDF\_BAD.)
      }
      \sstsubsection{
         BAD = LOGICAL (Returned)
      }{
         The combined bad-pixel flag value (the logical {\tt "}OR{\tt "} of the
         values obtained for each NDF).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of component names may also be
         supplied, in which case the routine will take the logical {\tt "}OR{\tt "} of
         all the specified components when calculating the combined
         bad-pixel flag value.

         \sstitem
         The effective value of the bad-pixel flag for each NDF array
         component which this routine uses is the same as would be returned
         by a call to the routine NDF\_BAD.

         \sstitem
         If this routine detects the presence of bad pixels which the
         application cannot support (as indicated by a .FALSE. value for
         the BADOK argument), then an error will be reported to this
         effect and a STATUS value of NDF\_\_BADNS (bad pixels not
         supported) will be returned.  The value of the BAD argument will
         be set to .TRUE. under these circumstances. The NDF\_\_BADNS
         constant is defined in the include file NDF\_ERR.
      }
   }
}
\sstroutine{
   NDF\_MBADN
}{
   Merge the bad-pixel flags of the array components of a number of
   NDFs
}{
   \sstdescription{
      The routine merges the bad-pixel flag values of an array
      component (or components) for a number of NDFs, returning the
      logical {\tt "}OR{\tt "} of the separate values for each NDF. In addition, if
      bad pixels are found to be present in any NDF but the application
      indicates that it cannot correctly handle such values, then an
      error to this effect is reported and a STATUS value is set.
   }
   \sstinvocation{
      CALL NDF\_MBADN( BADOK, N, NDFS, COMP, CHECK, BAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BADOK = LOGICAL (Given)
      }{
         Whether the application can correctly handle NDF array
         components containing bad pixel values.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of NDFs whose bad-pixel flags are to be merged.
      }
      \sstsubsection{
         NDFS( N ) = INTEGER (Given)
      }{
         Array of identifiers for the NDFs to be merged.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component: {\tt '}DATA{\tt '}, {\tt '}QUALITY{\tt '} or
         {\tt '}VARIANCE{\tt '}.
      }
      \sstsubsection{
         CHECK = LOGICAL (Given)
      }{
         Whether to perform explicit checks to see whether bad pixels
         are actually present. (This argument performs the same
         function as in the routine NDF\_BAD.)
      }
      \sstsubsection{
         BAD = LOGICAL (Returned)
      }{
         The combined bad-pixel flag value (the logical {\tt "}OR{\tt "} of the
         values obtained for each NDF).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of component names may also be
         supplied, in which case the routine will take the logical {\tt "}OR{\tt "} of
         all the specified components when calculating the combined
         bad-pixel flag value.

         \sstitem
         The effective value of the bad-pixel flag for each NDF array
         component which this routine uses is the same as would be returned
         by a call to the routine NDF\_BAD.

         \sstitem
         If this routine detects the presence of bad pixels which the
         application cannot support (as indicated by a .FALSE. value for
         the BADOK argument), then an error will be reported to this
         effect and a STATUS value of NDF\_\_BADNS (bad pixels not
         supported) will be returned.  The value of the BAD argument will
         be set to .TRUE. under these circumstances. The NDF\_\_BADNS
         constant is defined in the include file NDF\_ERR.
      }
   }
}
\sstroutine{
   NDF\_MBND
}{
   Match the pixel-index bounds of a pair of NDFs
}{
   \sstdescription{
      The routine matches the pixel-index bounds of a pair of NDFs so
      that their array components may be compared pixel-for-pixel
      during subsequent processing. Matching is performed by selecting
      an appropriate section from each NDF, the method used to define
      this section being determined by the value given for the OPTION
      argument.
   }
   \sstinvocation{
      CALL NDF\_MBND( OPTION, INDF1, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         OPTION = CHARACTER $*$ ( $*$ ) (Given)
      }{
         This argument determines how the section to be selected from
         each NDF is defined: {\tt '}PAD{\tt '} or {\tt '}TRIM{\tt '} (see the Notes section
         for details). Its value may be abbreviated to 3 characters.
      }
      \sstsubsection{
         INDF1 = INTEGER (Given and Returned)
      }{
         Identifier for the first NDF whose pixel-index bounds are to
         be matched.
      }
      \sstsubsection{
         INDF2 = INTEGER (Given and Returned)
      }{
         Identifier for the second NDF to be matched.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If OPTION={\tt '}PAD{\tt '} is specified, then the NDF bounds will be
         matched by {\tt "}padding{\tt "}; i.e. each NDF will be extended by selecting
         the smallest section from it which encompasses all the pixels in
         both NDFs. In effect, the pixel-index bounds of the two NDFs are
         {\tt "}maximised{\tt "} and the {\tt "}union{\tt "} of the two sets of pixels is
         selected.  Any new pixels introduced into either NDF will be
         padded with the {\tt "}bad{\tt "} value.  If the NDFs have different numbers
         of dimensions, then the dimensionality of both the returned
         sections will match the NDF with the higher dimensionality.

         \sstitem
         If OPTION={\tt '}TRIM{\tt '} is specified, then the NDF bounds will be
         matched by {\tt "}trimming{\tt "}; i.e. each NDF will be restricted in extent
         by selecting a section from it which encompasses only those
         pixels which are present in both NDFs. In effect, the pixel-index
         bounds of the two NDFs are {\tt "}minimised{\tt "} and the {\tt "}intersection{\tt "} of
         the two sets of pixels is selected. An error will result if the
         two NDFs have no pixels in common. If the NDFs have different
         numbers of dimensions, then the dimensionality of both the
         returned sections will match the NDF with the lower
         dimensionality.

         \sstitem
         Note that the initial NDF identifier values will be annulled
         by this routine and replaced with identifiers describing
         appropriate new sections from the original NDFs. If access to the
         original data is still required, then the initial identifiers may
         be cloned with the routine NDF\_CLONE before calling this routine.
      }
   }
}
\sstroutine{
   NDF\_MBNDN
}{
   Match the pixel-index bounds of a number of NDFs
}{
   \sstdescription{
      The routine matches the pixel-index bounds of a number of NDFs so
      that their array components may be compared pixel-for-pixel
      during subsequent processing. Matching is performed by selecting
      an appropriate section from each NDF, the method used to define
      this section being determined by the value given for the OPTION
      argument.
   }
   \sstinvocation{
      CALL NDF\_MBNDN( OPTION, N, NDFS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         OPTION = CHARACTER $*$ ( $*$ ) (Given)
      }{
         This argument determines how the section to be selected from
         each NDF is defined: {\tt '}PAD{\tt '} or {\tt '}TRIM{\tt '} (see the Notes section
         for details). Its value may be abbreviated to 3 characters.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of NDFs whose pixel-index bounds are to be matched.
      }
      \sstsubsection{
         NDFS( N ) = INTEGER (Given and Returned)
      }{
         Array of identifiers for the NDFs to be matched.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If OPTION={\tt '}PAD{\tt '} is specified, then the NDF bounds will be
         matched by {\tt "}padding{\tt "}; i.e. each NDF will be extended by selecting
         the smallest section from it which encompasses all the pixels in
         all the NDFs. In effect, the pixel-index bounds of the NDFs are
         {\tt "}maximised{\tt "} and the {\tt "}union{\tt "} of all N sets of pixels is selected.
         Any new pixels introduced into an NDF will be padded with the
         {\tt "}bad{\tt "} value.  If the NDFs have different numbers of dimensions,
         then the dimensionality of all the returned sections will match
         the NDF with the highest dimensionality.

         \sstitem
         If OPTION={\tt '}TRIM{\tt '} is specified, then the NDF bounds will be
         matched by {\tt "}trimming{\tt "}; i.e. each NDF will be restricted in extent
         by selecting a section from it which encompasses only those
         pixels which are present in all the NDFs. In effect, the
         pixel-index bounds of the NDFs are {\tt "}minimised{\tt "} and the
         {\tt "}intersection{\tt "} of all N sets of pixels is selected. An error will
         result if the NDFs have no pixels in common. If the NDFs have
         different numbers of dimensions, then the dimensionality of all
         the returned sections will match the NDF with the lowest
         dimensionality.

         \sstitem
         Note that the initial NDF identifier values will be annulled
         by this routine and replaced with identifiers describing
         appropriate new sections from the original NDFs. If access to the
         original data is still required, then the initial identifiers may
         be cloned with the routine NDF\_CLONE before calling this routine.
      }
   }
}
\sstroutine{
   NDF\_MSG
}{
   Assign the name of an NDF to a message token
}{
   \sstdescription{
      The routine assigns the name of an NDF to a message token (in a
      form which a user will understand) for use in constructing
      messages with the ERR\_ and MSG\_ routines (see SUN/104).
   }
   \sstinvocation{
      CALL NDF\_MSG( TOKEN, INDF )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the message token.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine has no STATUS argument and performs no error
         checking. If it should fail, then no assignment to the message
         token will be made and this will be apparent in the final message.
      }
   }
}
\sstroutine{
   NDF\_MTYPE
}{
   Match the types of the array components of a pair of NDFs
}{
   \sstdescription{
      The routine matches the types of the array components of a pair
      of NDFs, selecting a numeric type which an application may use to
      process these components. It also returns the type which should
      be used for storing the result of this processing.
   }
   \sstinvocation{
      CALL NDF\_MTYPE( TYPLST, INDF1, INDF2, COMP, ITYPE, DTYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TYPLST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the numeric types which the
         application can process explicitly; e.g. {\tt '}\_INTEGER,\_REAL{\tt '}. The
         first type which has sufficient precision will be selected
         from this list, so they should normally be given in order of
         increasing computational cost.
      }
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for the first NDF whose type is to be matched.
      }
      \sstsubsection{
         INDF2 = INTEGER (Given)
      }{
         Identifier for the second NDF.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component whose type is to be
         considered.
      }
      \sstsubsection{
         ITYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Numeric type which the application should use to process the
         NDF components. This value is returned as an upper case
         character string of maximum length NDF\_\_SZTYP. Its value is
         the first entry in the TYPLST list to which the NDF array
         components may be converted without unnecessary loss of
         information.
      }
      \sstsubsection{
         DTYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Data type required to hold the result of processing the NDF
         array components. This result is returned as an upper case
         character string of maximum length NDF\_\_SZFTP. It is intended
         to be used as input to the NDF\_STYPE routine to set the type
         of the output NDF component into which the result will be
         written.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of component names may also be
         supplied, in which case the results returned by this routine will
         take account of the types of all the specified components in both
         NDFs.

         \sstitem
         Matching of the type of a single NDF to an application may be
         performed by supplying the same identifier value for both the
         INDF1 and INDF2 arguments. There is no extra cost in doing this.

         \sstitem
         If the TYPLST argument does not specify any type to which the
         NDF components may be converted without loss of information, then
         the routine will return the highest precision type which is
         available. An error will be reported, however, and STATUS will be
         set to NDF\_\_TYPNI (type not implemented).

         \sstitem
         The constants NDF\_\_SZTYP and NDF\_\_SZFTP are defined in the
         include file NDF\_PAR. The error code NDF\_\_TYPNI is defined in the
         include file NDF\_ERR.
      }
   }
}
\sstroutine{
   NDF\_MTYPN
}{
   Match the types of the array components of a number of NDFs
}{
   \sstdescription{
      The routine matches the types of the array components of a number
      of NDFs, selecting a type which an application may use to process
      these components. It also returns the numeric type which should
      be used for storing the result of this processing.
   }
   \sstinvocation{
      CALL NDF\_MTYPN( TYPLST, N, NDFS, COMP, ITYPE, DTYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TYPLST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the numeric types which the
         application can process explicitly; e.g. {\tt '}\_INTEGER,\_REAL{\tt '}. The
         first type which has sufficient precision will be selected
         from this list, so they should normally be given in order of
         increasing computational cost.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of NDFs whose types are to be matched.
      }
      \sstsubsection{
         NDFS( N ) = INTEGER (Given)
      }{
         Array of identifiers for the NDFs to be matched.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component whose type is to be
         considered.
      }
      \sstsubsection{
         ITYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Numeric type which the application should use to process the
         NDF components. This value is returned as an upper case
         character string of maximum length NDF\_\_SZTYP. Its value is
         the first entry in the TYPLST list to which the NDF array
         components may be converted without unnecessary loss of
         information.
      }
      \sstsubsection{
         DTYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Data type required to hold the result of processing the NDF
         array components. This result is returned as an upper case
         character string of maximum length NDF\_\_SZFTP. It is intended
         to be used as input to the NDF\_STYPE routine to set the type
         of the output NDF component into which the result will be
         written.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of component names may also be
         supplied, in which case the results returned by this routine will
         take account of the types of all the specified components in all
         the NDFs.

         \sstitem
         If the TYPLST argument does not specify any type to which the
         NDF components may be converted without loss of information, then
         the routine will return the highest precision type which is
         available. An error will be reported, however, and STATUS will be
         set to NDF\_\_TYPNI (type not implemented).

         \sstitem
         The constants NDF\_\_SZTYP and NDF\_\_SZFTP are defined in the
         include file NDF\_PAR. The error code NDF\_\_TYPNI is defined in the
         include file NDF\_ERR.
      }
   }
}
\sstroutine{
   NDF\_NBLOC
}{
   Determine the number of blocks of adjacent pixels in an NDF
}{
   \sstdescription{
      The routine determines the number of {\tt "}blocks{\tt "} (i.e. sections) of
      adjacent pixels that can be obtained from an NDF, subject to the
      constraint that no block should exceed a specified maximum number
      of pixels in any dimension. More specifically, given the maximum
      size in pixels of a block in each dimension (MXDIM), this routine
      returns the maximum value which can be supplied for the IBLOCK
      argument of the routine NDF\_BLOCK if a valid NDF identifier for a
      block of adjacent pixels is to be returned.
   }
   \sstinvocation{
      CALL NDF\_NBLOC( INDF, NDIM, MXDIM, NBLOCK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of maximum dimension sizes.
      }
      \sstsubsection{
         MXDIM( NDIM ) = INTEGER (Given)
      }{
         Array specifying the maximum size of a block in pixels along
         each dimension.
      }
      \sstsubsection{
         NBLOCK = INTEGER (Returned)
      }{
         Number of blocks which can be obtained from the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine is provided to calculate an upper bound on the
         number of blocks for DO-loops which process NDFs by dividing them
         into separate blocks by means of calls to the routine NDF\_BLOCK.

         \sstitem
         If the number of maximum dimension sizes supplied (NDIM) is
         less than the number of NDF dimensions, then a value of 1 will be
         used for the extra dimension sizes. If the value of NDIM is
         larger than this number, then the excess dimension sizes will be
         ignored.

         \sstitem
         A value of zero will be returned for the NBLOCK argument if
         this routine is called with STATUS set. The same value will also
         be returned if the routine should fail for any reason.
      }
   }
}
\sstroutine{
   NDF\_NCHNK
}{
   Determine the number of chunks of contiguous pixels in an NDF
}{
   \sstdescription{
      The routine determines the number of {\tt "}chunks{\tt "} (i.e. sections) of
      contiguous pixels that can be obtained from an NDF, subject to
      the constraint that no chunk should contain more than a specified
      maximum number of pixels. More specifically, given the maximum
      number of pixels in a chunk (MXPIX), this routine returns the
      maximum value which can be supplied for the ICHUNK argument of
      the routine NDF\_CHUNK if a valid NDF identifier for a chunk of
      contiguous pixels is to be returned.
   }
   \sstinvocation{
      CALL NDF\_NCHNK( INDF, MXPIX, NCHUNK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         MXPIX = INTEGER (Given)
      }{
         Maximum number of contiguous pixels required in each chunk.
      }
      \sstsubsection{
         NCHUNK = INTEGER (Returned)
      }{
         Number of chunks which can be obtained from the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine is provided to calculate an upper bound on the
         number of chunks for DO-loops which process NDFs by dividing them
         into separate chunks by means of calls to the routine NDF\_CHUNK.

         \sstitem
         A value of zero will be returned for the NCHUNK argument if
         this routine is called with STATUS set. The same value will also
         be returned if the routine should fail for any reason.
      }
   }
}
\sstroutine{
   NDF\_NEW
}{
   Create a new simple NDF
}{
   \sstdescription{
      The routine creates a new simple NDF and returns an identifier
      for it. The NDF may subsequently be manipulated with the NDF\_
      routines.
   }
   \sstinvocation{
      CALL NDF\_NEW( FTYPE, NDIM, LBND, UBND, PLACE, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_REAL{\tt '} or
         {\tt '}COMPLEX\_INTEGER{\tt '}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         PLACE = INTEGER (Given and Returned)
      }{
         An NDF placeholder (e.g. generated by the NDF\_PLACE routine)
         which indicates the position in the data system where the new
         NDF will reside. The placeholder is annulled by this routine,
         and a value of NDF\_\_NOPL will be returned (as defined in the
         include file NDF\_PAR).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine creates a {\tt "}simple{\tt "} NDF, i.e. one whose array
         components will be stored in {\tt "}simple{\tt "} form by default (see
         SGP/38).

         \sstitem
         The full data type of the DATA component is specified via the
         FTYPE argument and the data type of the VARIANCE component
         defaults to the same value. These data types may be set
         individually with the NDF\_STYPE routine if required.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. In either
         event, the placeholder will still be annulled. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_NEWP
}{
   Create a new primitive NDF
}{
   \sstdescription{
      The routine creates a new primitive NDF and returns an identifier
      for it. The NDF may subsequently be manipulated with the NDF\_
      routines.
   }
   \sstinvocation{
      CALL NDF\_NEWP( FTYPE, NDIM, UBND, PLACE, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Data type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_REAL{\tt '}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         PLACE = INTEGER (Given and Returned)
      }{
         An NDF placeholder (e.g. generated by the NDF\_PLACE routine)
         which indicates the position in the data system where the new
         NDF will reside. The placeholder is annulled by this routine,
         and a value of NDF\_\_NOPL will be returned (as defined in the
         include file NDF\_PAR).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine creates a {\tt "}primitive{\tt "} NDF, i.e. one whose array
         components are stored in {\tt "}primitive{\tt "} form by default (see
         SGP/38).

         \sstitem
         The full type of the DATA component is specified via the FTYPE
         argument and the type of the VARIANCE component defaults to the
         same value. These types may be set individually with the
         NDF\_STYPE routine if required.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. In either
         event, the placeholder will still be annulled. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_NOACC
}{
   Disable a specified type of access to an NDF
}{
   \sstdescription{
      The routine disables the specified type of access to an NDF, so
      that any subsequent attempt to access it in that way will fail.
      Access restrictions imposed on an NDF identifier by this routine
      will be propagated to any new identifiers derived from it, and
      cannot be revoked.
   }
   \sstinvocation{
      CALL NDF\_NOACC( ACCESS, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ACCESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The type of access to be disabled: {\tt '}BOUNDS{\tt '}, {\tt '}DELETE{\tt '},
         {\tt '}MODIFY{\tt '}, {\tt '}SHIFT{\tt '}, {\tt '}TYPE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      Disabling each type of access imposes the following restrictions
      on an NDF:
      \sstitemlist{

         \sstitem
         {\tt '}BOUNDS{\tt '} prevents the pixel-index bounds of a base NDF from
         being altered.

         \sstitem
         {\tt '}DELETE{\tt '} prevents an NDF from being deleted.

         \sstitem
         {\tt '}MODIFY{\tt '} prevents any form of modification to the NDF (i.e. it
         disables all the other access types).

         \sstitem
         {\tt '}SHIFT{\tt '} prevents pixel-index shifts from being applied to a
         base NDF.

         \sstitem
         {\tt '}TYPE{\tt '} prevents the data type of any NDF components from being
         altered.

         \sstitem
         {\tt '}WRITE{\tt '} prevents new values from being written to the NDF, or
         the state of any of its components from being reset.
      }
   }
}
\sstroutine{
   NDF\_PLACE
}{
   Obtain an NDF placeholder
}{
   \sstdescription{
      The routine returns an NDF placeholder. A placeholder is used
      to identify a position in the underlying data system (HDS) and
      may be passed to other routines (e.g. NDF\_NEW) to indicate where
      a newly created NDF should be positioned.
   }
   \sstinvocation{
      CALL NDF\_PLACE( LOC, NAME, PLACE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         HDS locator to the structure to contain the new NDF.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the new structure component (i.e. the NDF).
      }
      \sstsubsection{
         PLACE = INTEGER (Returned)
      }{
         NDF placeholder identifying the nominated position in the
         data system.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Placeholders are intended only for local use within an
         application and only a limited number of them are available
         simultaneously. They are always annulled as soon as they are
         passed to another routine to create a new NDF, where they are
         effectively exchanged for an NDF identifier.

         \sstitem
         The value given for the NAME argument may be an HDS path name,
         consisting of several fields separated by {\tt '}.{\tt '}, so that an NDF can
         be created in a sub-component (or a sub-sub-component...) of the
         structure identified by the locator LOC.  Array subscripts may
         also be used in this component name.  Thus a string such as
         {\tt '}MYSTRUC.ZONE(2).IMAGE{\tt '} could be used as a valid NAME value. All
         structures lying above the actual object to be created must
         already exist.

         \sstitem
         Normally, this routine will be used as the basis for creating
         a completely new NDF data structure. However, if the LOC and NAME
         arguments refer to a pre-existing object, then this structure
         will be used as the basis for the new NDF.  An object which is to
         be used in this way must be an empty scalar structure with an HDS
         type of {\tt '}NDF{\tt '}.

         \sstitem
         If a blank value is given for the NAME argument, then the new
         NDF will be the object identified directly by the locator LOC.
         This must be an empty scalar structure of type {\tt '}NDF{\tt '}.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOPL will be returned for the PLACE argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOPL
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_PROP
}{
   Propagate NDF information to create a new NDF via the ADAM
   parameter system
}{
   \sstdescription{
      The routine creates a new NDF data structure through the ADAM
      parameter system, associates it with a parameter and returns an
      identifier for it. The shape, data type, etc. of this new NDF are
      based on a existing {\tt "}template{\tt "} NDF, and the values of components
      of this template may be selectively propagated to initialise the
      new data structure.
   }
   \sstinvocation{
      CALL NDF\_PROP( INDF1, CLIST, PARAM, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the NDF components which are to be
         propagated to the new data structure. By default, the HISTORY,
         LABEL and TITLE components and all extensions are propagated.
         See below for further details.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter for the new NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
   \sstdiytopic{
      Component Propagation
   }{
      \sstitemlist{

         \sstitem
         The template components whose values are to be propagated to
         initialise the new data structure are specified via the CLIST
         argument. Thus CLIST={\tt '}DATA,QUALITY{\tt '} would cause the new NDF to
         inherit its DATA and QUALITY values (if available) from the
         template structure, in addition to those propagated by default.
         Component propagation may be suppressed by supplying a component
         name with the prefix {\tt '}NO{\tt '}. Thus CLIST={\tt '}DATA,NOHISTORY{\tt '} would
         propagate the DATA component, but suppress propagation of
         HISTORY. If component names appear more than once in the CLIST
         value, then the last occurrence takes precedence.

         \sstitem
         Propagation of specific NDF extensions may be suppressed by
         using {\tt '}NOEXTENSION(){\tt '} as one of the items in the CLIST argument;
         a list of the extensions to be suppressed should appear between
         the parentheses. Thus CLIST={\tt '}AXIS,NOEXTENSION(IRAS,ASTERIX){\tt '}
         would propagate the AXIS component, but suppress propagation of
         the IRAS and ASTERIX extensions (if present). Propagation of
         suppressed extensions may be re-enabled by specifying
         {\tt '}EXTENSION(){\tt '} in a similar manner at a later point in the CLIST
         value.

         \sstitem
         Component names in the CLIST argument may be abbreviated to 3
         characters, but extension names must appear in full.
      }
   }
}
\sstroutine{
   NDF\_QMASK
}{
   Combine an NDF quality value with a bad-bits mask to give a
   logical result
}{
   \sstdescription{
      This function may be used to combine an NDF quality array value
      with the associated bad-bits mask value to derive a logical
      result indicating whether an NDF pixel should be included or
      excluded from processing by general-purpose software.
   }
   \sstinvocation{
      RESULT = NDF\_QMASK( QUAL, BADBIT )
   }
   \sstarguments{
      \sstsubsection{
         QUAL = BYTE (Given)
      }{
         The unsigned byte quality value.
      }
      \sstsubsection{
         BADBIT = BYTE (Given)
      }{
         The unsigned byte bad-bits mask value.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         NDF\_QMASK = LOGICAL
      }{
         If the function returns a .TRUE. result, then the pixel with
         quality value QUAL should be included in processing by
         general-purpose software. If it returns a .FALSE. result, then
         the pixel should be regarded as {\tt "}bad{\tt "} and excluded from
         processing.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This function is implemented as a Fortran statement function
         and should be defined in each program unit from which it is
         invoked by means of the include file NDF\_FUNC. This file should
         normally be included immediately after any local variable
         declarations.

         \sstitem
         The result of this function is computed by forming the
         bit-wise {\tt "}AND{\tt "} between the QUAL and BADBIT values and testing the
         result for equality with zero. Its actual implementation is
         machine-dependent.
      }
   }
}
\sstroutine{
   NDF\_QMF
}{
   Obtain the logical value of an NDF{\tt '}s quality masking flag
}{
   \sstdescription{
      The routine returns the current value of an NDF{\tt '}s logical quality
      masking flag. This flag determines whether the NDF{\tt '}s quality
      component (if present) will be used to generate {\tt "}bad{\tt "} pixel
      values for automatic insertion into the data and variance arrays
      when these are accessed in READ or UPDATE mode. Normally, this
      automatic quality masking is used to convert quality information
      into {\tt "}bad{\tt "} pixels so that an application need not consider the
      quality information explicitly.  If the quality masking flag is
      set to .FALSE., then automatic masking will not occur so that the
      application can process the quality component by accessing it
      directly.
   }
   \sstinvocation{
      CALL NDF\_QMF( INDF, QMF, STATUS )
   }
\newpage
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         QMF = LOGICAL (Returned)
      }{
         The value of the quality masking flag.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A quality masking flag is associated with each NDF identifier
         and is initially set to .TRUE..  Its value changes to .FALSE.
         whenever the quality component is accessed directly (e.g. using
         NDF\_MAP or NDF\_MAPQL) and reverts to .TRUE. when access is
         relinquished (e.g. using NDF\_UNMAP). This default behaviour may
         also be over-ridden by calling NDF\_SQMF to set its value
         explicitly.  NDF\_QMF allows the current value to be determined.
      }
   }
}
\sstroutine{
   NDF\_RESET
}{
   Reset an NDF component to an undefined state
}{
   \sstdescription{
      The routine resets a component of an NDF so that its value
      becomes undefined. It may be used to remove unwanted optional NDF
      components. Its use is also advisable before making format
      changes to an NDF if retention of the existing values is not
      required (e.g. before changing the data type of an array
      component with the NDF\_STYPE routine); this will avoid the cost
      of converting the existing values.
   }
   \sstinvocation{
      CALL NDF\_RESET( INDF, COMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF component to be reset; any NDF component name
         is valid. No error will result if the component is already
         undefined.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of component names may also be supplied
         in which case each component will be reset in turn.

         \sstitem
         Specifying a component name of {\tt '}$*${\tt '} will cause all components,
         except for HISTORY and extensions, to be reset. The former may be
         reset by specifying its name explicitly, while all extensions may
         be removed by specifying a component name of {\tt '}EXTENSION{\tt '}.

         \sstitem
         Individual extensions may be removed from an NDF with the
         NDF\_XDEL routine.

         \sstitem
         This routine may only be used to reset components of a base
         NDF. If an NDF section is supplied, then it will return without
         action. No error will result.

         \sstitem
         An array component of an NDF cannot be reset while it is
         mapped for access. Neither can an NDF{\tt '}s axis component be reset
         while any axis array is mapped for access. This routine will fail
         if either of these conditions occurs.
      }
   }
}
\sstroutine{
   NDF\_SAME
}{
   Enquire if two NDFs are part of the same base NDF
}{
   \sstdescription{
      The routine determines whether two NDF identifiers refer to parts
      of the same base NDF. If so, it also determines whether their
      transfer windows intersect.
   }
   \sstinvocation{
      CALL NDF\_SAME( INDF1, INDF2, SAME, ISECT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for the first NDF (or NDF section).
      }
      \sstsubsection{
         INDF2 = INTEGER (Given)
      }{
         Identifier for the second NDF (or NDF section).
      }
      \sstsubsection{
         SAME = LOGICAL (Returned)
      }{
         Whether the identifiers refer to parts of the same base NDF.
      }
      \sstsubsection{
         ISECT = LOGICAL (Returned)
      }{
         Whether their transfer windows intersect.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the transfer windows of the two NDFs (or NDF sections)
         intersect, then (i) they both refer to the same base NDF, and
         (ii) altering values in an array component of one of the NDFs can
         result in the values in the corresponding component of the other
         NDF changing in consequence. Thus, the array components of the
         two NDFs are not mutually independent.
      }
   }
}
\sstroutine{
   NDF\_SBAD
}{
   Set the bad-pixel flag for an NDF array component
}{
   \sstdescription{
      The routine sets the value of the bad-pixel flag for an NDF array
      component. A call to this routine with BAD set to .TRUE. declares
      that the specified component may contain bad pixel values for
      which checks must be made by algorithms which subsequently
      process its values. A call with BAD set to .FALSE. declares that
      there are definitely no bad values present and that subsequent
      checks for such values may be omitted.
   }
   \sstinvocation{
      CALL NDF\_SBAD( BAD, INDF, COMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Bad-pixel flag value to be set.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component; {\tt '}DATA{\tt '} or {\tt '}VARIANCE{\tt '}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
\newpage
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of component names may also be
         supplied, in which case the bad-pixel flag will be set to the
         same value for each component in turn.

         \sstitem
         If a component is mapped for access when this routine is
         called, then the bad-pixel flag will be associated with the
         mapped values. This information will only be transferred to the
         actual data object when the component is unmapped (but only if it
         was mapped for UPDATE or WRITE access). The value transferred may
         be modified if conversion errors occur during the unmapping
         process.

         \sstitem
         This routine has no effect on components which are in an
         undefined state; the bad-pixel flag for such components always
         remains set to .TRUE. (or .FALSE. in the case of the QUALITY
         component).
      }
   }
}
\sstroutine{
   NDF\_SBB
}{
   Set a bad-bits mask value for the quality component of an NDF
}{
   \sstdescription{
      The routine assigns a new unsigned byte bad-bits mask value to
      the quality component of an NDF.
   }
   \sstinvocation{
      CALL NDF\_SBB( BADBIT, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BADBIT = BYTE (Given)
      }{
         The unsigned byte bad-bits mask value.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If WRITE access to the NDF is not available, or if an NDF
         section is supplied (as opposed to a base NDF), then no permanent
         change to the data object will be made. In this case, the new
         bad-bits value will be associated with the NDF identifier and
         will subsequently be used by other NDF\_ routines which access the
         NDF through this identifier. The new value will also be
         propagated to any new identifiers derived from it.
      }
   }
}
\sstroutine{
   NDF\_SBND
}{
   Set new pixel-index bounds for an NDF
}{
   \sstdescription{
      The routine sets new pixel-index bounds for an NDF (or NDF
      section). The number of NDF dimensions may also be changed. If a
      base NDF is specified, then a permanent change is made to the
      actual data object and this will be apparent through any other
      NDF identifiers which refer to it. However, if an identifier for
      an NDF section is specified, then its bounds are altered without
      affecting other identifiers.
   }
   \sstinvocation{
      CALL NDF\_SBND( NDIM, LBND, UBND, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         New number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         New lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         New upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The bounds of an NDF section cannot be altered while any of
         its array components (or any of its axis arrays) is mapped for
         access through the identifier supplied to this routine.

         \sstitem
         The bounds of a base NDF cannot be altered while any part of
         any of its array components (or any of its axis arrays) is mapped
         for access, even through another identifier.

         \sstitem
         The pixel values of any defined NDF array component will be
         retained if those pixels lie within both the old and new bounds.
         Any pixels lying outside the new bounds will be lost and cannot
         later be recovered by further changes to the NDF{\tt '}s bounds. Any
         new pixels introduced where the new bounds extend beyond the old
         ones will be assigned the {\tt "}bad{\tt "} value, and subsequent enquiries
         about the presence of bad pixels will reflect this.

         \sstitem
         If the new NDF bounds extend beyond the bounds of the
         associated base NDF and any of the NDF{\tt '}s axis arrays have defined
         values, then these values will be extrapolated as necessary.

         \sstitem
         If the bounds of a base NDF are to be altered and retention of
         the pixel values of any of its components is not required, then a
         call to NDF\_RESET should be made before calling this routine.
         This will eliminate any unnecessary processing which might be
         needed to retain the existing values. This step is not necessary
         with an NDF section, as no processing of pixel values takes place
         in this case.
      }
   }
}
\sstroutine{
   NDF\_SECT
}{
   Create an NDF section
}{
   \sstdescription{
      The routine creates a new NDF section which refers to a selected
      region of an existing NDF (or NDF section). The region may be
      larger or smaller in extent than the initial NDF.
   }
   \sstinvocation{
      CALL NDF\_SECT( INDF1, NDIM, LBND, UBND, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         Identifier for the initial NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions for the new section.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the section.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the section.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new section.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
\newpage
   \sstnotes{
      \sstitemlist{

         \sstitem
         The number of section dimensions need not match the number of
         dimensions in the initial NDF. Pixel-index bounds will be padded
         with 1{\tt '}s as necessary to identify the pixels to which the new
         section should refer.

         \sstitem
         The array components of sections which extend beyond the
         pixel-index bounds of the initial NDF will be padded with bad
         pixels.

         \sstitem
         If the section bounds extend beyond the bounds of the
         associated base NDF and any of the NDF{\tt '}s axis arrays have defined
         values, then these values will be extrapolated as necessary.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_SHIFT
}{
   Apply pixel-index shifts to an NDF
}{
   \sstdescription{
      The routine applies pixel-index shifts to an NDF. An integer
      shift is applied to each dimension so that its pixel-index
      bounds, and the indices of each pixel, change by the amount of
      shift applied to the corresponding dimension. The NDF{\tt '}s pixels
      retain their values and none are lost.
   }
   \sstinvocation{
      CALL NDF\_SHIFT( NSHIFT, SHIFT, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSHIFT = INTEGER (Given)
      }{
         Number of dimensions to which shifts are to be applied. This
         must not exceed the number of NDF dimensions. If fewer shifts
         are applied than there are NDF dimensions, then the extra
         dimensions will not be shifted.
      }
      \sstsubsection{
         SHIFT( NSHIFT ) = INTEGER (Given)
      }{
         The pixel-index shifts to be applied to each dimension.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Pixel-index shifts applied to a base NDF will affect the
         appearance of that NDF as seen by all base-NDF identifiers
         associated with it. However, NDF sections derived from that base
         NDF will remain unchanged (as regards both pixel-indices and
         array values).

         \sstitem
         Pixel-index shifts applied to an NDF section only affect that
         section itself, and have no effect on other NDF identifiers.

         \sstitem
         Pixel-index shifts cannot be applied to a base NDF while any
         of its components (or any of its axis arrays) is mapped for
         access, even through another identifier.

         \sstitem
         Pixel-index shifts cannot be applied to an NDF section while
         any of its components (or any of its axis arrays) is mapped for
         access through the identifier supplied to this routine.
      }
   }
}
\sstroutine{
   NDF\_SIZE
}{
   Determine the size of an NDF
}{
   \sstdescription{
      The routine returns the number of pixels in the NDF whose
      identifier is supplied (i.e. the product of its dimensions).
   }
   \sstinvocation{
      CALL NDF\_SIZE( INDF, NPIX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NPIX = INTEGER (Returned)
      }{
         Number of pixels in the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of 1
         will be returned for the NPIX argument, although no further
         processing will occur.  The same value will also be returned if
         the routine should fail for any reason.
      }
   }
}
\sstroutine{
   NDF\_SQMF
}{
   Set a new logical value for an NDF{\tt '}s quality masking flag
}{
   \sstdescription{
      The routine sets a new logical value for an NDF{\tt '}s quality masking
      flag.  This flag determines whether the NDF{\tt '}s quality component
      (if present) will be used to generate {\tt "}bad{\tt "} pixel values for
      automatic insertion into the data and variance arrays when these
      are accessed in READ or UPDATE mode. If this flag is set to
      .TRUE., then masking will occur, so that an application need not
      consider the quality information explicitly.  If the flag is set
      to .FALSE., then automatic masking will not occur, so that the
      application can process the quality component by accessing it
      directly.
   }
   \sstinvocation{
      CALL NDF\_SQMF( QMF, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOGICAL = QMF (Given)
      }{
         The logical value to be set for the quality masking flag.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A quality masking flag is associated with each NDF identifier
         and is initially set to .TRUE..  Its value changes to .FALSE.
         whenever the quality component is accessed directly (e.g. using
         NDF\_MAP or NDF\_MAPQL) and reverts to .TRUE. when access is
         relinquished (e.g. using NDF\_UNMAP). This default behaviour may
         also be over-ridden by calling NDF\_SQMF to set its value
         explicitly. The routine NDF\_QMF allows the current value to be
         determined.

         \sstitem
         The value of the quality masking flag is not propagated to new
         identifiers.
      }
   }
}
\sstroutine{
   NDF\_SSARY
}{
   Create an array section, using an NDF section as a template
}{
   \sstdescription{
      The routine creates a {\tt "}similar section{\tt "} from an array (whose ARY\_
      system identifier is supplied) using an existing NDF section as a
      template.  An identifier for the array section is returned and
      this may subsequently be manipulated using the ARY\_ system
      routines (SUN/11).  The new array section will bear the same
      relationship to its base array as the NDF template does to its
      own base NDF.  Allowance is made for any pixel-index shifts which
      may have been applied, so that the pixel-index system of the new
      array section matches that of the NDF template.

      This routine is intended for use when an array which must match
      pixel-for-pixel with an NDF is stored in an NDF extension; if an
      NDF section is obtained, then this routine may be used to obtain
      a pixel-by-pixel matching section from the array.
   }
   \sstinvocation{
      CALL NDF\_SSARY( IARY1, INDF, IARY2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY1 = INTEGER (Given)
      }{
         The ARY\_ system identifier for the array, or array section,
         from which the new section is to be drawn.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF\_ system identifier for the template NDF section (may also
         be a base NDF).
      }
      \sstsubsection{
         IARY2 = INTEGER (Returned)
      }{
         ARY\_ system identifier for the new array section.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine will normally generate an array section. However,
         if the input array is a base array and the input NDF is a base
         NDF with the same pixel-index bounds, then there is no need to
         generate a section in order to access the required part of the
         array. In this case, a base array identifier will be returned
         instead.

         \sstitem
         It is the caller{\tt '}s responsibility to annul the ARY\_ system
         identifier issued by this routine (e.g. by calling ARY\_ANNUL)
         when it is no longer required. The NDF\_ system will not perform
         this task itself.

         \sstitem
         The new array generated by this routine will have the same
         number of dimensions as the array from which it is derived. If
         the template NDF has fewer dimensions, then the pixel-index
         bounds of the extra array dimensions are preserved unchanged. If
         the NDF has more dimensions, then the extra ones are ignored.

         \sstitem
         This routine takes account of the transfer windows of the
         array and NDF supplied and will restrict the transfer window of
         the new array section so as not to grant access to regions of the
         base array which were not previously accessible through both the
         input array and the NDF section.

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The ARY\_\_NOID
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   NDF\_STATE
}{
   Determine the state of an NDF component (defined or undefined)
}{
   \sstdescription{
      The routine returns a logical value indicating whether an NDF
      component has a defined value (or values).
   }
   \sstinvocation{
      CALL NDF\_STATE( INDF, COMP, STATE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the component; any NDF component name is valid.
      }
      \sstsubsection{
         STATE = LOGICAL (Returned)
      }{
         Whether the specified component is defined.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a component name of {\tt '}EXTENSION{\tt '} is given, then a .TRUE.
         result will be returned if one or more extensions are present in
         the NDF.

         \sstitem
         A comma-separated list of component names may also be given,
         in which case the routine will return the logical {\tt "}AND{\tt "} of the
         states of the specified components (i.e. a .TRUE. result will be
         returned only if all the components have defined values).
      }
   }
}
\sstroutine{
   NDF\_STYPE
}{
   Set a new type for an NDF array component
}{
   \sstdescription{
      The routine sets a new full type for an NDF array component,
      causing its storage type to be changed. If the component{\tt '}s values
      are defined, they will be converted from from the old type to the
      new one. If they are undefined, then no conversion will be
      necessary. Subsequent enquiries will reflect the new type.
      Conversion may be performed between any types supported by the
      NDF\_ routines, including from a non-complex type to a complex
      type (and vice versa).
   }
   \sstinvocation{
      CALL NDF\_STYPE( FTYPE, INDF, COMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The new full type specification for the NDF component (e.g.
         {\tt '}\_REAL{\tt '} or {\tt '}COMPLEX\_INTEGER{\tt '}).
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the array component whose type is to be set: {\tt '}DATA{\tt '}
         or {\tt '}VARIANCE{\tt '}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
\newpage
   \sstnotes{
      \sstitemlist{

         \sstitem
         The routine may only be used to change the type of a component
         of a base NDF. If it is called for an NDF which is not a base
         NDF, then it will return without action. No error will result.

         \sstitem
         A comma-separated list of component names may also be supplied,
         in which case the type of each component will be set to the same
         value in turn.

         \sstitem
         An error will result if a component being modified, or any
         part of it, is currently mapped for access (e.g. through another
         identifier).

         \sstitem
         If the type of a component is to be changed without its values
         being retained, then a call to NDF\_RESET should be made
         beforehand. This will avoid the cost of converting all the
         values.
      }
   }
}
\sstroutine{
   NDF\_TEMP
}{
   Obtain a placeholder for a temporary NDF
}{
   \sstdescription{
      The routine returns an NDF placeholder which may be used to
      create a temporary NDF (i.e. one which will be deleted
      automatically once the last identifier associated with it is
      annulled). The placeholder returned by this routine may be passed
      to other routines (e.g. NDF\_NEW or NDF\_COPY) to produce a
      temporary NDF in the same way as a new permanent NDF would be
      created.
   }
   \sstinvocation{
      CALL NDF\_TEMP( PLACE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PLACE = INTEGER (Returned)
      }{
         Placeholder for a temporary NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Placeholders are intended only for local use within an
         application and only a limited number of them are available
         simultaneously. They are always annulled as soon as they are
         passed to another routine to create a new NDF, where they are
         effectively exchanged for an NDF identifier.

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOPL will be returned for the PLACE argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOPL
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_TRACE
}{
   Set the internal NDF\_ system error-tracing flag
}{
   \sstdescription{
      The routine sets an internal flag in the NDF\_ system which
      enables or disables error-tracing messages. If this flag is set
      to .TRUE., then any error occurring within the NDF\_ system will
      be accompanied by error messages indicating which internal
      routines have exited prematurely as a result. If the flag is set
      to .FALSE., this internal diagnostic information will not appear
      and only standard error messages will be produced.
   }
   \sstinvocation{
      CALL NDF\_TRACE( NEWFLG, OLDFLG )
   }
   \sstarguments{
      \sstsubsection{
         NEWFLG = LOGICAL (Given)
      }{
         The new value to be set for the error-tracing flag.
      }
      \sstsubsection{
         OLDFLG = LOGICAL (Returned)
      }{
         The previous value of the flag.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         By default, the error-tracing flag is set to .FALSE., so no
         internal diagnostic information will be produced.
      }
   }
}
\sstroutine{
   NDF\_TUNE
}{
   Set an NDF\_ system tuning parameter
}{
   \sstdescription{
      The routine sets a new value for an NDF\_ system internal tuning
      parameter.
   }
   \sstinvocation{
      CALL NDF\_TUNE( VALUE, TPAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = INTEGER (Given)
      }{
         New value for the tuning parameter.
      }
      \sstsubsection{
         TPAR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter to be set (case insensitive).  This name
         may be abbreviated to no less than 3 characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The following tuning parameters are currently available:
      \sstitemlist{

         \sstitem
         {\tt '}WARN{\tt '}: Controls the issuing of warning messages when certain
         non-fatal errors in the structure of NDF data objects are
         detected. If WARN is set to 1 (the default), then a warning
         message is issued. If WARN is set to 0, then no message is
         issued.  In both cases normal execution continues and no STATUS
         value is set.
      }
   }
}
\sstroutine{
   NDF\_TYPE
}{
   Obtain the numeric type of an NDF array component
}{
   \sstdescription{
      The routine returns the numeric type of one of the array
      components of an NDF as an upper-case character string (e.g.
      {\tt '}\_REAL{\tt '}).
   }
   \sstinvocation{
      CALL NDF\_TYPE( INDF, COMP, TYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component whose type is required:
         {\tt '}DATA{\tt '}, {\tt '}QUALITY{\tt '} or {\tt '}VARIANCE{\tt '}.
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Numeric type of the component.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A comma-separated list of component names may also be supplied
         to this routine. In this case the result returned will be the
         lowest precision numeric type to which all the specified
         components can be converted without unnecessary loss of
         information.

         \sstitem
         The value returned for the QUALITY component is always
         {\tt '}\_UBYTE{\tt '}.

         \sstitem
         The symbolic constant NDF\_\_SZTYP may be used for declaring the
         length of a character variable which is to hold the numeric type
         of an NDF array component. This constant is defined in the
         include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_UNMAP
}{
   Unmap an NDF or a mapped NDF array
}{
   \sstdescription{
      The routine unmaps an NDF, or a individual NDF array which has
      previously been mapped for READ, UPDATE or WRITE access.
   }
   \sstinvocation{
      CALL NDF\_UNMAP( INDF, COMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ )
      }{
         Name of the NDF component to be unmapped: {\tt '}AXIS{\tt '}, {\tt '}DATA{\tt '},
         {\tt '}QUALITY{\tt '}, {\tt '}VARIANCE{\tt '} or {\tt '}$*${\tt '}. The last value acts as a wild
         card, causing all mapped arrays to be unmapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set on
         entry, although no further error report will be made if it
         subsequently fails under these circumstances.

         \sstitem
         A component name of {\tt '}AXIS{\tt '} will act as a partial wild card,
         unmapping any axis arrays which are mapped, but leaving other
         components unchanged. The routine NDF\_AUNMP may be used to unmap
         individual axis arrays.

         \sstitem
         A comma-separated list of component names may also be given, in
         which case each component will be unmapped in turn.

         \sstitem
         An error will be reported if a component has not previously
         been mapped for access, except in the case where a value of {\tt '}$*${\tt '}
         is given for COMP, or where {\tt '}AXIS{\tt '} is used to unmap axis arrays.
      }
   }
}
\sstroutine{
   NDF\_VALID
}{
   Determine whether an NDF identifier is valid
}{
   \sstdescription{
      The routine determines whether an NDF identifier is valid (i.e.
      associated with an NDF).
   }
   \sstinvocation{
      CALL NDF\_VALID( INDF, VALID, STATUS )
   }
\newpage
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         Identifier to be tested.
      }
      \sstsubsection{
         VALID = LOGICAL (Returned)
      }{
         Whether the identifier is valid.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDF\_XDEL
}{
   Delete a specified NDF extension
}{
   \sstdescription{
      The routine deletes a named extension in an NDF together with its
      contents, if any. No error results if the specified extension
      does not exist.
   }
   \sstinvocation{
      CALL NDF\_XDEL( INDF, XNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the extension to be deleted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDF\_XIARY
}{
   Obtain access to an array stored in an NDF extension
}{
   \sstdescription{
      The routine locates an array stored in an NDF extension and
      imports it into the ARY\_ system, returning an array identifier
      for it. If necessary, a section of the array will be selected so
      that it matches pixel-for-pixel with the main data array of the
      NDF (or NDF section) supplied.  The returned array identifier may
      be used to manipulate the array using the ARY\_ routines (see
      SUN/11).
   }
   \sstinvocation{
      CALL NDF\_XIARY( INDF, XNAME, CMPT, MODE, IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the extension.
      }
      \sstsubsection{
         CMPT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the array component within the extension.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Mode of access required: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         IARY = INTEGER (Returned)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
\newpage
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine will normally generate an array section. However,
         if the input NDF is a base NDF and the requested array has the
         same pixel-index bounds, then there is no need to generate a
         section in order to access the required part of the array. In
         this case, a base array identifier will be issued instead.

         \sstitem
         It is the caller{\tt '}s responsibility to annul the ARY\_ system
         identifier returned by this routine (e.g. by calling ARY\_ANNUL)
         when it is no longer required. The NDF\_ system will not perform
         this task itself.

         \sstitem
         The array associated with the returned identifier will have
         the same number of dimensions as the base array from which it is
         derived. If the input NDF has fewer dimensions than this, then
         the pixel-index bounds of the extra array dimensions are
         preserved unchanged. If the NDF has more dimensions, then the
         extra ones are ignored.

         \sstitem
         This routine takes account of the transfer window of the NDF
         supplied and will restrict the transfer window of the new array
         section so as not to grant access to regions of the base array
         which are not accessible in the input NDF.

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason.

         \sstitem
         The ARY\_\_NOID constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   NDF\_XGT0x
}{
   Read a scalar value from a component within a named NDF extension
}{
   \sstdescription{
      The routine reads a scalar value from a component within a named
      NDF extension. The extension must be a scalar HDS structure and
      must already exist, although the component within the extension
      need not exist (a default value, established beforehand, will be
      returned if necessary).
   }
   \sstinvocation{
      CALL NDF\_XGT0x( INDF, XNAME, CMPT, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF extension.
      }
      \sstsubsection{
         CMPT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the component within the extension whose value is to be
         obtained.
      }
      \sstsubsection{
         VALUE = ? (Given and Returned)
      }{
         The value obtained from the extension component. Its type is
         determined by the name of the routine called (see the Notes
         section).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for reading values with each of the
         standard Fortran data types: integer, real, double precision,
         logical and character.  Replace the (lower case) {\tt "}x{\tt "} in the
         routine name by I, R, D, L or C as appropriate.

         \sstitem
         If the requested component in the extension does not exist,
         then the VALUE argument will be returned unchanged.  A suitable
         default should therefore be established before this routine is
         called.

         \sstitem
         If the length of the character VALUE argument passed to the
         NDF\_XGT0C routine is too short to accommodate the returned result
         without losing significant (non-blank) trailing characters, then
         this will be indicated by an appended ellipsis, i.e. {\tt '}...{\tt '}. No
         error will result.
      }
   }
}
\sstroutine{
   NDF\_XLOC
}{
   Obtain access to a named NDF extension via an HDS locator
}{
   \sstdescription{
      The routine returns an HDS locator to a named extension (if
      present) in an NDF. An error results if the specified extension
      is not present.
   }
   \sstinvocation{
      CALL NDF\_XLOC( INDF, XNAME, MODE, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the required extension.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Mode of access required to the extension: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or
         {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Extension locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If WRITE access is specified, then any existing extension
         contents or values will be erased or reset, so that the extension
         is ready to receive new values. If UPDATE access is specified,
         then existing values will be retained so that they may be
         modified.

         \sstitem
         It is the caller{\tt '}s responsibility to annul the HDS locator
         issued by this routine (e.g. by calling DAT\_ANNUL) when it is no
         longer required. The NDF\_ system will not perform this task
         itself.

         \sstitem
         Although this routine will check the access mode value
         supplied against the available access to the NDF, HDS does not
         allow the returned locator to be protected against write access
         in the case where WRITE access to the NDF is available, but only
         READ access was requested.  In this case it is the responsibility
         of the caller to respect the locator access restriction.

         \sstitem
         If this routine is called with STATUS set, then an invalid
         locator will be returned for the LOC argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason.
      }
   }
}
\sstroutine{
   NDF\_XNAME
}{
   Obtain the name of the N{\tt '}th extension in an NDF
}{
   \sstdescription{
      The routine returns the name of the N{\tt '}th extension in an NDF. If
      the requested extension does not exist, then the name is returned
      blank. The routine may therefore be used to obtain the names of
      all the extensions present by setting N to 1,2... etc.  until a
      blank name is returned. Note that the order in which these names
      are obtained is not defined.
   }
   \sstinvocation{
      CALL NDF\_XNAME( INDF, N, XNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of the extension whose name is required.
      }
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The extension name (in upper case).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The symbolic constant NDF\_\_SZXNM is provided to define the
         length of character variables which are to hold an NDF extension
         name. This constant is defined in the include file NDF\_PAR.
      }
   }
}
\sstroutine{
   NDF\_XNEW
}{
   Create a new extension in an NDF
}{
   \sstdescription{
      The routine creates a new named extension of specified type and
      shape in an NDF structure, and returns an HDS locator to it.
   }
   \sstinvocation{
      CALL NDF\_XNEW( INDF, XNAME, TYPE, NDIM, DIM, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Extension name.
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         HDS data type of the extension.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of extension dimensions.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         Extension dimension sizes.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Locator to the newly created extension.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then an invalid
         locator will be returned for the LOC argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason.
      }
   }
}
\sstroutine{
   NDF\_XNUMB
}{
   Determine the number of extensions in an NDF
}{
   \sstdescription{
      The routine returns the number of extensions present in the NDF
      whose identifier is supplied.
   }
   \sstinvocation{
      CALL NDF\_XNUMB( INDF, XNUMB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         XNUMB = INTEGER (Returned)
      }{
         Number of extensions present.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDF\_XPT0x
}{
   Write a scalar value to a component within a named NDF extension
}{
   \sstdescription{
      The routine writes a scalar value to a component within a named
      NDF extension. The extension must be a scalar HDS structure and
      must already exist, although the component within the extension
      need not exist and will be created if necessary. If a component
      of the same name already exists within the extension, then it
      will be deleted and a new component will be created with an HDS
      primitive type matching the value assigned.
   }
   \sstinvocation{
      CALL NDF\_XPT0x( VALUE, INDF, XNAME, CMPT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         The value to be written to the extension component. Its type
         is determined by the name of the routine called (see the Notes
         section).
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF extension.
      }
      \sstsubsection{
         CMPT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the component within the extension whose value is to be
         assigned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for writing values with each of the
         standard Fortran data types: integer, real, double precision,
         logical and character.  Replace the (lower case) {\tt "}x{\tt "} in the
         routine name by I, R, D, L or C as appropriate.
      }
   }
}
\sstroutine{
   NDF\_XSTAT
}{
   Determine if a named NDF extension exists
}{
   \sstdescription{
      The routine returns a logical value indicating whether a named
      extension is present in an NDF.
   }
   \sstinvocation{
      CALL NDF\_XSTAT( INDF, XNAME, THERE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the extension.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         Whether the extension is present in the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\normalsize

\newpage
\section{CHANGES AND NEW FEATURES IN V1.2}
\label{ss:changes}

The following describes the most significant changes which have occurred in
the NDF\_ system since the previous version (V1.1): 

\begin{enumerate}

\item A new facility has been added to allow users of NDF applications to select
sections (both subsets and super-sets) when giving the names of NDFs to be
processed. The required sections may be specified in a variety of ways, using
both pixel indices and {\em axis\/} coordinates (see \S\ref{ss:usersections}).

\item A new routine NDF\_LOC has been introduced to return an HDS locator for a
data structure whose NDF identifier is supplied (see
\S\ref{ss:gettingalocator}).

\item A new routine NDF\_XIARY has been introduced to simplify access to array
information stored in NDF extensions (see \S\ref{ss:extnarrays}).

\item Four new routines (NDF\_NCHNK, NDF\_CHUNK, NDF\_NBLOC \& NDF\_BLOCK) have
been introduced to provide facilities for partitioning NDFs in order to reduce
memory requirements when large datasets are being processed. These facilities
may also have applications to parallel processing (see \S\ref{ss:partitioning}
onwards).

\item Two new routines, NDF\_TUNE and NDF\_GTUNE, have been introduced to allow
certain aspects of the NDF\_ system's behaviour to be {\em tuned\/} to
individual needs. An associated {\em tuning parameter\/} `WARN' has been
introduced to control the issuing of warning messages when certain non-fatal
errors are detected in NDF data structures (see \S\ref{ss:tuning}).

\item A number of new example applications have been added to
Appendix~\ref{ss:exampleapplications}.

\item The documentation has been revised and brought up to date.

\end{enumerate}

No changes to existing applications should be required, neither should any 
re-compilation or re-linking be necessary.

\end{document}
