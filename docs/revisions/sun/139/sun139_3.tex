\documentstyle[11pt]{article} 
\pagestyle{myheadings}

%------------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocnumber}    {139.3}
\newcommand{\stardocauthors}   {Peter W. Draper}
\newcommand{\stardocdate}      {6th December 1993}
\newcommand{\stardoctitle}     {CCDPACK --- CCD data reduction package}
%------------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\renewcommand{\_}{{\tt\char'137}}     % re-centres the underscore
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

%------------------------------------------------------------------------------
% Add any \newcommand or \newenvironment commands here
%
% Number with circle
\newcommand{\numcir}[1]
{\mbox{\hspace{4ex}{\normalsize$\bigcirc$}\hspace{-1.9ex}{\small #1}}}
%
% Environment for indenting and using a small font.
\newenvironment{myquote}{\begin{quote}\begin{small}}{\end{small}\end{quote}}
%
% in-line verbatims
\newcommand{\myverb}[1]{{\small \verb+#1+}}
%
% quick routine descriptions
\newcommand{\quickdes}[3]{ 
                         \parbox{1.1in}{\bf #1} 
                         \parbox{4.4in}{\raggedright #2 \dotfill}
                         \parbox{0.6in}{\pageref{#3}}
                         \vspace*{0.2in}}
%------------------------------------------------------------------------------

\begin{document}
\thispagestyle{empty}
SCIENCE \& ENGINEERING RESEARCH COUNCIL \hfill \stardocname\\
RUTHERFORD APPLETON LABORATORY\\
{\large\bf Starlink Project\\}
{\large\bf \stardoccategory\ \stardocnumber}
\begin{flushright}
\stardocauthors\\
\stardocdate
\end{flushright}
\vspace{-4mm}
\rule{\textwidth}{0.5mm}
\vspace{5mm}
\begin{center}
{\Large\bf \stardoctitle}
\end{center}
\vspace{5mm}

%------------------------------------------------------------------------------
%  Add this part if you want a table of contents
\setlength{\parskip}{0mm}
\tableofcontents
\setlength{\parskip}{\medskipamount}
\markright{\stardocname}
%------------------------------------------------------------------------------

\newpage
\section{Introduction}

CCDPACK is a package for performing the {\em preparative} stages of CCD
reduction. These initial stages being those taken {\em before} analyses
which make measurements of astronomical relevance. CCDPACK contains
applications for removing the CCD instrumental signature and for
registering, resampling, normalising and combining imaging data.

A major aim of CCDPACK is to help in processing large amounts of data.
Consequently {\em all} CCDPACK routines process {\em lists} of data and
record information using an internal log system (data in the context of
CCDPACK means NDFs and also lists of coordinates).

Applications for instrumental correction cover, bias subtraction, defect
removal, dark or pre-flash correction and flatfielding. Bias correction
is via the subtraction of bias frames (usually bias frames are combined
into a `master' to reduce noise levels) which may be offset to the
level of the bias strips (over-scan regions), or by interpolation using
the bias strips.

Registration usually involves the determination of inter-dataset {\em
linear} transformations (offsets, scalings, rotation and shear),
although more general transformations can be accommodated (defined by
you). If the transformations between the datasets are linear then an
interactive procedure for displaying and selecting image features may be
used, this provides a standard methodology and reduces the amount of
image-feature identification required to a sensible minimum.

If the datasets to be registered are related by simple offsets then
registration may be performed using a {\em non-interactive} series of
commands which locate the objects in a dataset, determine the
object-object correspondence across all datasets and then derive the
transforms between all the datasets. Alternatively a graphical
application is provided which allows you to select the objects to be
used, this needs an absolute minimum of preparation.

The data resampling application uses the registration information 
stored with the datasets --- there is no need for you to record
registration information, this is all passed invisibly between the
applications. General transformations may also be given which allow
`rubber-sheeting' of the datasets.

Data normalisation and combination is provided in a single {\em
comprehensive} application, which is designed to deal with very large
datasets. This uses robust methods for determining the scale and zero
point corrections.

Other features of some import are the ability to define defective areas
of CCDs using {\em keyword } descriptions in ordinary text files, 
support for many data-combination techniques (mean, median, trimmed mean
etc.), and the ability to take full account of statistical uncertainty
during all stages using variance production and propagation ({\em even}
during the data-combination stages). CCDPACK also has facilities for
helping you perform batch and background  processing with ease.

\section{Starting up CCDPACK}

The CCDPACK package is available on all Starlink supported operating
systems (VMS and various flavours of UNIX). The VMS variant is available
as an ICL monolith and as a series of DCL applications. The UNIX version
of CCDPACK is only available from the C shell.

For simplicity most examples in this document use the VMS DCL version 
of CCDPACK although many examples of how to use CCDPACK in UNIX are 
also shown. These are displayed beneath the DCL commands in square 
braces `\myverb{[ ]}'.

To run CCDPACK from ICL issue the commands

\begin{myquote}
\begin{verbatim}
$ ADAMSTART
$ ADAM CCDPACK
ICL>
\end{verbatim}
\end{myquote}

or alternatively enter ICL and issue the command CCDPACK in response to
the prompt.

The DCL version of CCDPACK is simply initialised by using the CCDPACK
command.
\begin{myquote}
\begin{verbatim}
$ ADAMSTART
$ CCDPACK
\end{verbatim}
\end{myquote}

To make CCDPACK commands available from the C shell (after performing
the required Starlink startup sequence -- SUN/118) use.
\begin{myquote}
\begin{verbatim}
% ccdpack
\end{verbatim}
\end{myquote}

The arrangement for starting CCDPACK in batch or within a background
process is essentially the same (but see \S\ref{sec:batch} for the 
details).

\subsection{Getting Help}

Help can be obtained on VMS at any time by typing
\begin{myquote}
\begin{verbatim}
$ HELP CCDPACK, or
$ CCDHELP, or
$ HELP `taskname'
\end{verbatim}
\end{myquote}
from DCL - after issuing the CCDPACK command.

From ICL help can be obtained by typing
\begin{myquote}
\begin{verbatim}
ICL> HELP CCDPACK, or
ICL> HELP `taskname'
\end{verbatim}
\end{myquote}

On UNIX machines CCDPACK help is obtained by the 

\begin{myquote}
\begin{verbatim}
% ccdhelp
\end{verbatim}
\end{myquote}

command.

Help can also be accessed at any prompt by returning a `?'.

\section{Basic principles of CCD data reduction}

The aim in all initial data reduction (or preparation if you prefer) is
to remove the instrumental signature from the data, so that measurements
(by analysis packages) can be taken which do not require knowledge of
the device with which the data was taken. Before CCD data can be said to
be free of these effects various corrections have to be made to it. The
most basic of these corrections is the `bias level' subtraction. The
bias level is an artificially induced electronic offset which ensures
that the Analogue-to-Digital Converter (ADC) always receives a positive
signal. All CCD data has such an offset which must be removed.

The bias level intrinsic noise is known as the `readout noise'. This is
one of the features which limits the usefulness of CCDs at very low
light levels. Usually the bias level is removed by the subtraction of
specifically taken `bias-frames', or by the subtraction of bias level
values which are specially recorded around the main data in regions
known as the bias strips (or over-scan regions).

After bias subtraction the CCD data is in a form which is directly
related to the number of photons which were detected in the device light
sensitive `pixels'. The relation between the units of the data and the
actual number of detected photons is known as the gain and is
multiplicative. In this document the gain factor is referred to as the
ADC factor (Analogue-to-Digital Conversion factor), CCD data units
before being multiplied by the ADC factor are known as ADUs
(Analogue-to-Digital Units) --- these are the values directly output by
the ADC.

Other `additive' corrections which are occasionally made to CCD data are
dark count subtraction and pre-flash subtraction. These corrections are
only usual in older CCD data (but for IR array data the dark current
correction is essential). Dark correction is the subtraction of the
electron count which accumulates in each CCD pixel due to thermal noise.
Modern CCDs usually have dark counts of less than a few ADUs per pixel
per hour, so this correction can generally be ignored. Pre-flashing of
CCDs has been used to stop loss of signal in CCDs with poor across-chip
charge transfer characteristics, the rational being that if signal is
entered in a pixel before the main exposure, then subsequent losses are
less likely to effect the data --- note however that this also means
that a higher signal to noise level is required for detection.


The final stage in the correction of CCD data for instrument signature
is `flatfielding'. The sensitivity of CCDs varies from point to point
(i.e.\ the recorded signal per unit of incident flux -- photons -- is not
uniform), so if the data is to be relatively flux calibrated (so that
comparison from point to point can be made) this sensitivity variation
must be removed. To achieve this correction exposures of a
photometrically flat source (i.e.\ a source with uniform brightness)
must be taken, these are known as flatfields. The basic idea of
flatfield correction is then to divide the data by this `sensitivity
map', although in real life noise considerations, together with others
(see Appendix \ref{app:glos}), mean that particular care needs to be
taken at this stage. After all these corrections have been made your
data is usually \footnote{ Usually because another correction may also
be necessary -- the removal of fringing see Appendix \ref{app:glos}.}
ready for analysis. 

Other processes which are frequently undertaken before analysis are
registration, alignment, normalisation and combination. Registration is
the process of determining the transformations which map the same
positions on different datasets. This is essential if measurements, say
with different filters, are to be made. In this case registration may be
informal and just consists of identifying the same objects on different
datasets. However, very accurate measures are often also required;
certainly this is the case when data combination is to be performed.
`Data combination' is just when aligned datasets are combined by a
process of taking the mean or some other estimator at each pixel, this
is also frequently referred to as `mosaicing'. Aligning datasets 
means achieving pixel-to-pixel correspondence (in real data it is
unlikely that this state is true, even if it was intended). Alignment 
uses the registering transforms to `resample' the data onto the new
coordinate system pixel grid. If the exposure times, atmospheric
transparency or sky brightness have varied, then data must be
`normalised' before combination. Normalisation is the  determination
of the zero points and scale factors which correct for these changes. 

\section{The initial stages of reduction}

The main initial reduction facilities of CCDPACK are the applications:
\begin{itemize}
\item MAKEBIAS - combines bias frames into a `master' bias calibration
NDF.
\item DEBIAS   - de-biases lists of NDFs either by master bias
subtraction or by interpolation, applies bad data masks, extracts a 
subset of the data area, produces variances and applies saturation
values.
\item MAKECAL  - combines pre-flash or dark count frames into a `master'
calibration NDF.
\item CALCOR   - performs dark or flash count corrections on a list of
NDFs.
\item MAKEFLAT - combines flat fields into a `master' calibration 
                 flatfield.
\item FLATCOR  - performs the flatfield correction on a list of NDFs.
\end{itemize}

\subsection{Step 1 - Setting up}
\label{CCDSETUP}

The first recommended step in starting a CCDPACK reduction sequence is
to setup the device characteristics using the routine
\begin{itemize}
\item CCDSETUP.
\end{itemize}
This sets the values of a sequence of global parameters. The
values of these parameters, when set, will override those of any others,
except values entered on the command line or in response to a prompt.
Starting with this routine serves as a useful reminder of what values
etc.\ will be required to perform the reduction. Note, however, that
none of the parameters are compulsory (indeed CCDSETUP itself is not
compulsory) and may be returned as  \myverb{`!'} (the ADAM parameter
system null-value symbol).  CCDSETUP asks for the following values
(together with some others which are  best accepted until more
experience with the package is gained). 

\begin{itemize}
\item The ADC (Analogue-to-Digital Conversion) factor which converts the
ADUs of the input data frames into detected electrons (used as part of
the variance estimation).
\item The bias strip placements (used for offsetting the bias frame or for
bias interpolation).
\item The readout direction (defines bias strip placements and the direction 
bias interpolation is valid).
\item The typical readout-noise (used as part of the variance
estimation).
\item The useful CCD area.
\end{itemize}
The routine also initialises the CCDPACK logging system (see
\S\ref{logsystem}).

A typical CCD geometry is shown in Figure \ref{CCDPICCY}; note how the
bias strips and useful CCD areas are defined. The coordinate values for
these regions are always defined in pixel indices (i.e.\ row or column
numbers, starting at 1,1 for the lower left-hand corner of the data array
--- unless the NDF has been sectioned in which case the pixel indices of
the lower left-hand corner are given by the ORIGIN values stored in the
NDF DATA\_ARRAY component).

A typical setup command is
\begin{myquote}
\begin{verbatim}
$ CCDSETUP ADC=1.5 BOUNDS=[2,10,400,416] RNOISE=10 EXTENT=[11,399,1,576] \

[% ccdsetup adc=1.5 bounds='[2,10,400,416]' rnoise=10 \
            extent='[11,399,1,576]' accept ]

\end{verbatim}
\end{myquote}
The `{\small \verb+\+}' means `accept' and forces the task to accept
defaults for all the other parameters. In the UNIX example this
conflicts with the C shell continuation character and must be protected,
similarly the single quotes around the vector statements protect
\myverb{[ ]}. These methods must be used to protect other symbols with
special meaning to the shell. 

\begin{figure}
\begin{center}
\setlength{\unitlength}{0.012500in}%
%
\begingroup\makeatletter
% extract first six characters in \fmtname
\def\x#1#2#3#4#5#6#7\relax{\def\x{#1#2#3#4#5#6}}%
\expandafter\x\fmtname xxxxxx\relax \def\y{splain}%
\ifx\x\y   % LaTeX or SliTeX?
\gdef\SetFigFont#1#2#3{%
  \ifnum #1<17\tiny\else \ifnum #1<20\small\else
  \ifnum #1<24\normalsize\else \ifnum #1<29\large\else
  \ifnum #1<34\Large\else \ifnum #1<41\LARGE\else
     \huge\fi\fi\fi\fi\fi\fi
  \csname #3\endcsname}%
\else
\gdef\SetFigFont#1#2#3{\begingroup
  \count@#1\relax \ifnum 25<\count@\count@25\fi
  \def\x{\endgroup\@setsize\SetFigFont{#2pt}}%
  \expandafter\x
    \csname \romannumeral\the\count@ pt\expandafter\endcsname
    \csname @\romannumeral\the\count@ pt\endcsname
  \csname #3\endcsname}%
\fi
\endgroup
\begin{picture}(280,206)(38,626)
\thicklines
\put( 80,660){\framebox(152,100){}}
\put( 80,816){\vector( 0,-1){ 23}}
\put(232,816){\vector( 0,-1){ 23}}
\put( 53,631){\vector( 1, 0){ 23}}
\put( 53,659){\vector( 1, 0){ 23}}
\put( 53,760){\vector( 1, 0){ 23}}
\put( 53,788){\vector( 1, 0){ 23}}
\put(246,660){\vector( 0, 1){100}}
\put( 80,631){\dashbox{4}(152,29){}}
\put( 80,761){\dashbox{4}(152,28){}}
\put(153,642){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}Over-scan Region}}}
\put(153,771){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}Over-scan Region}}}
\put(156,704){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{it}Data Collection Area}}}
\put( 80,823){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}M}}}
\put(232,823){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}N}}}
\put( 43,626){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}I}}}
\put( 44,654){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}J}}}
\put( 43,756){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}K}}}
\put( 44,783){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}L}}}
\put(283,725){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}Readout/}}}
\put(286,707){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}Interpolation}}}
\put(285,690){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}Direction}}}
\end{picture}

\caption{\label{CCDPICCY} Typical CCD geometry. The readout direction is
`Y', the bias strips (over-scan regions) are located with bounds I,J,K,L.
The useful CCD area is M,N,J,K.}
\end{center}
\end{figure}

CCDSETUP also allows you to define which parts of the CCD are
corrupted or unreliable (due to hot spots, bad columns etc.); see
\S\ref{datamasks}, if you need to do this.

\subsection{Step 2 - Making a bias calibration frame} If you intend
to debias your CCD data using specifically recorded bias frames, then
the next move is to combine all these into a `best bet' frame; a `master
bias'. There are probably only two ways in which you'd like to do this:

\begin{itemize}
\item combine all your bias frames preserving the bias level
\item combine all your bias frames zeroing the mean level first and
leaving  it zeroed, after combination.
\end{itemize}

The second option may seem strange (if you're not used to it), but it
has a good rationale behind it and is the default method. Using this
method relies on data having an `over-scan' region in which the bias
level at readout time is recorded. This monitors the (true) bias level
and the master bias is offset to this so that any small variations in
the zero point are tracked.

The way to actually make a master bias is to run the routine 

\begin{itemize}
\item MAKEBIAS.
\end{itemize}

If you want to make a master bias using the first method, then type
something like

\begin{myquote}
\begin{verbatim}
$ MAKEBIAS IN=[.BIAS]* OUT=MASTER_BIAS RNOISE=10 ZERO=FALSE \

[% makebias in='bias/*' out=master_bias rnoise=10 zero=false accept]
\end{verbatim}
\end{myquote}

for the second method use

\begin{myquote}
\begin{verbatim}
$ MAKEBIAS IN=[.BIAS]* OUT=MASTER_BIAS RNOISE=10 \

[% makebias in='bias/*' out=master_bias rnoise=10 accept]
\end{verbatim}
\end{myquote}

The \myverb{IN} specification  \myverb{[.BIAS]*} \myverb{(bias/*)} means
get all the NDFs in the subdirectory \myverb{[.BIAS]} \myverb{(bias/)}.
The \myverb{RNOISE} parameter specifies the readout-noise (in ADUs) of
the CCD you're using (if you've set up a global value for this  using
CCDSETUP then this need not be supplied). MAKEBIAS shows an estimate of
the readout-noise which it derives from the data, use this to check your
value, or use this value if none other exists. The nominal readout-noise
value can usually be found in the technical descriptions issued by the
observatories. CCDPACK uses the readout noise value to generate variance
estimates, you may specify \myverb{GENVAR=FALSE} to disable  this option
if your destination analysis package does not support the  use of
variance, or if disk space is tight (the addition of a variance
component to your data will approximately double the disk space
requirement per NDF).

\subsection{Step 3 - Debiassing}

The next stage (or the first stage, if you're not using a master bias
calibration frame) is to debias all your data frames. This includes the
flatfields, flash frames, dark frames, as well as the target frames
themselves. Debiassing, within CCDPACK, occurs in two basic forms
(actually three are supported but the last method, subtraction of a
constant, is well worth avoiding unless there's nothing else for it) ---
with and without a bias frame. Let's tackle these methods one at a time.

\subsubsection{With a bias frame}

If you have made a master bias frame using MAKEBIAS then the form of
debiassing used depends on how you made it. If your master bias
has been combined to give a mean of zero then it will
require offsetting to the `zero' level in the bias strips. DEBIAS will
require the values of the rows or columns that the strip(s) are found
within, you tell DEBIAS whether the values are rows or columns by
specifying a readout direction `X' or `Y' (see Figure \ref{CCDPICCY}).
The bias strip extents must be supplied in pairs; the column or row
number on which it starts and the column or row number on which it ends
(there is usually one strip on each side of the data, so 4 values are
typical). To subtract a zeroed master bias frame type something like

\begin{myquote}
\begin{verbatim}
$ DEBIAS IN="[.RDATA]*,[.FFR]*" OUT=*_DEBIAS BOUNDS=[2,10,400,416] -
         RNOISE=10 ADC=1 BIAS=MASTER_BIAS \

[% debias in='"rdata/*,ffr/*"' out='*_debias' bounds='[2,10,400,416]' \
         rnoise=10 adc=1 bias=master_bias accept]
\end{verbatim}
\end{myquote}

or conversely let DEBIAS prompt you. If you meet any questions which you
do not understand hit return to accept the default, or respond with a
`?' to get some help. If things are really bad then `!!' (abort) will
aways terminate the application immediately. (Note that \myverb{ADC},
\myverb{BOUNDS} and \myverb{RNOISE} need not be supplied if you've used
CCDSETUP to define them.)

If your master bias frame has a non zero mean (if you've selected
the \myverb{ZERO=FALSE} option in MAKEBIAS) you just want to subtract 
it so use

\begin{myquote}
\begin{verbatim}
$ DEBIAS IN="[.RDATA]*,[.FFR]*" OUT=*_DEBIAS RNOISE=10 ADC=1 -
         BIAS=MASTER_BIAS OFFSET=FALSE \
\end{verbatim}
\end{myquote}

It is probably useful, at this point, to say a quick word about the
parameters. The \myverb{IN} specifier  \myverb{"[.RDATA]*,[.FFR]*"} 
means process all the NDFs in these subdirectories (note the quotes ---
they are important). \myverb{OUT=*\_DEBIAS} means call all the output
NDFs the same as the input  NDFs (and place them in the same
directories), but add the string  \myverb{`\_DEBIAS'} to their names.
The \myverb{ADC}  -- analogue-to-digital conversion --  factor is 
required to generate variances from the number of ADUs recorded in 
each pixel, as is the \myverb{RNOISE} value. To not generate 
variances just use \myverb{GENVAR=FALSE} and leave out the 
\myverb{ADC} and \myverb{RNOISE} parameters.

\subsubsection{Without a bias frame}

Debiassing of CCD data can be performed reasonably well by the
subtraction of values stored in the bias strips (over-scan regions) 
around the actual data. The subtraction is performed by DEBIAS using
`interpolations' of various kinds. If the data has two bias strips then
a true interpolation using a line fit or a constant for each line of
data can be performed, or alternatively a plane can be fitted to the
whole of the bias strip data (using again a linear or constant fit). If
only one bias strip is present then the interpolation option is really
an extrapolation across the whole of the data. This extrapolation is
limited to constant values, either one per line or a single global
value.

To subtract the bias using interpolation type something like.

\begin{myquote}
\begin{verbatim}
$ DEBIAS IN="[.RDATA]*,[.FFR]*" OUT=*_TMP BOUNDS=[2,10,400,416] -
         RNOISE=10 ADC=2 \
\end{verbatim}
\end{myquote}

This will interpolate between each pair of lines in the bias strips
using a  constant. Before the interpolation occurs the bias strips are
smoothed using a box filter.

\subsubsection{ Other DEBIAS functions}
DEBIAS is the most complex of the initial reduction applications 
and performs much more than just debiassing, although that, of course,
is its main task. The other functions which DEBIAS performs are

\begin{itemize}
\item variance production/propagation.
\item defect removal using a flagged NDF or ASCII regions definition
file.
\item gain correction (i.e.\ expansion from ADUs to electrons)
\item deferred charge correction
\item saturated value detection (saturated values can be flagged by
using BAD values, NDF quality or by being set to a given constant).
\item data subsetting (i.e.\ extraction of the useful CCD area).
\end{itemize}

For details about these functions see \S\ref{descriptions}.

\subsection{Step 4 - Flash or dark calibration}

If your CCD data has been pre-flashed or has a significant dark level
(see the device technical description) and you have taken some
calibration frames, then this contribution to the data will require
removal before flat fielding.

The most simple case (and probably the most usual) is when the
calibration data are exposed for exactly the correct time to do the
correction. Thus the calibration data just require combining to reduce
the noise level. When making a calibration frame the routine

\begin{itemize}
\item MAKECAL
\end{itemize}

is used. This combines a list of NDFs together using an associated list
of (relative) exposure times. A typical invocation of MAKECAL in which
the data has been collected with the same exposure time is

\begin{myquote}
\begin{verbatim}
$ MAKECAL IN=[.DARKS]* EXPOSE=1 OUT=MASTER_DARK \
\end{verbatim}
\end{myquote}

This uses all the NDFs in the \myverb{[.DARKS]} directory to make a 
master dark frame. The exposure times given are 1 as the dark frames
have exactly the same exposure time as the data. Note that if the input
data do not have exactly the same exposure times an exact number of
values must be returned, in the same order as the input NDF names.

Correcting the data for the dark counts, or pre-flash, is performed by
the routine

\begin{itemize}
\item CALCOR
\end{itemize}

which just subtracts a suitably scaled master calibration NDF from a
list of NDFs.

\begin{myquote}
\begin{verbatim}
$ CALCOR IN="[.RDATA]*_DEBIAS,[.FFR]*_DEBIAS" OUT=*_DARK -
         CAL=MASTER_DARK EXPOSE=1 \
\end{verbatim}
\end{myquote}

Performing pre-flash subtraction is just as straight-forward if the
pre-flash calibration frames are exposed for the same time as the
pre-flash on the data.

If the calibration data have different exposure times then an explicit
list of NDF names is required, together with their associated times (all
entered in the correct order). So you might use
\begin{myquote}
\begin{verbatim}
$ MAKECAL IN=^DARK_FRAMES.LIS OUT=MASTER_DARK -
          EXPOSE=^DARK_CALIBRATION_EXPOSURES.LIS \
$ CALCOR IN=^LIST_OF_FRAMES.LIS OUT=*_DARK CAL=MASTER_DARK -
         EXPOSE=^LIST_OF_FRAME_DARK_EXPOSURES.LIS \
\end{verbatim}
\end{myquote}
The contents of the text files \myverb{DARK\_FRAMES.LIS} and 
\myverb{LIST\_OF\_FRAMES.LIS} are the names of all the NDFs to be
processed. The contents of the files 
\myverb{DARK\_CALIBRATION\_EXPOSURES.LIS} and
\myverb{LIST\_OF\_FRAME\_DARK\_EXPOSURES.LIS}  are the exposure times
(in seconds?) of the calibration data entered in the same order as the
NDF names. Of course these names and values could be supplied on the
command line, or in response to a prompt  --- terminating a line with a
`\myverb{-}' forces reprompting for another line of values.

\subsection{Step 5 - Flatfielding}

The next stage in the instrumental correction of your data is to make a 
`flatfield'. A flatfield is probably best made from exposures of the
twilight sky or from long-exposures of dark sky. Either way it is quite
possible that the data have some corrupted parts (such as stars) which
should be removed before combination and normalisation. MAKEFLAT
`cleans' the input data by comparing it with a locally smoothed mean,
rejecting any deviant values outside of a number of standard deviations,
then trying again for a given number of iterations. After this has been
done you can then combine the data using a method, such as median
stacking (see  \S\ref{combinations}), which rejects even more bad data
(in fact any method except the mean will reject some spurious data). To
use MAKEFLAT just type something like

\begin{myquote}
\begin{verbatim}
$ MAKEFLAT IN=[.FFR]* OUT=MASTER_FLATR \
\end{verbatim}
\end{myquote}

and it's done (well actually it might take some time; see
\S\ref{sec:batch} about batch and background processing ). One master
flatfield should be made for each filter used.  If your data frames are
spectroscopic then you'll have to provide a suitable flatfield to 
CCDPACK.

The final process in correcting your CCD data is to divide by a
normalised flatfield. The flatfield corrects for such things as
vignetting (the optical response) and the pixel-to-pixel variations in
the CCD response (these can be up to 10 percent). To perform
flatfielding make a normalised --- mean of one --- flatfield (using
MAKEFLAT) and then use FLATCOR. Type something like:

\begin{myquote}
\begin{verbatim}
$ FLATCOR IN=[.RDATA]*_DEBIAS_DARKC OUT=*|DEBIAS_DARKC|PROCESSED| -
          FLAT=MASTER_FLATR \

[% flatcor in='rdata/*_debias_darkc' out='*|debias_darkc|processed|' \
          flat=master_flatr accept]
\end{verbatim}
\end{myquote}

and it's done. The specification \myverb{OUT=*|DEBIAS\_DARKC|PROCESSED|}
is one we have not seen before, its meaning is; call all the output NDFs
the same as the input NDFs except remove the string
\myverb{`DEBIAS\_DARKC'} from the names and replace it with
\myverb{`PROCESSED'}.

\subsection{Schematic reduction sequence}
The reduction sequences outlined above are shown in a schematic format
in figure \ref{red:seq}. 

\begin{figure}
\begin{center}

\setlength{\unitlength}{0.012500in}%
%
\begingroup\makeatletter
% extract first six characters in \fmtname
\def\x#1#2#3#4#5#6#7\relax{\def\x{#1#2#3#4#5#6}}%
\expandafter\x\fmtname xxxxxx\relax \def\y{splain}%
\ifx\x\y   % LaTeX or SliTeX?
\gdef\SetFigFont#1#2#3{%
  \ifnum #1<17\tiny\else \ifnum #1<20\small\else
  \ifnum #1<24\normalsize\else \ifnum #1<29\large\else
  \ifnum #1<34\Large\else \ifnum #1<41\LARGE\else
     \huge\fi\fi\fi\fi\fi\fi
  \csname #3\endcsname}%
\else
\gdef\SetFigFont#1#2#3{\begingroup
  \count@#1\relax \ifnum 25<\count@\count@25\fi
  \def\x{\endgroup\@setsize\SetFigFont{#2pt}}%
  \expandafter\x
    \csname \romannumeral\the\count@ pt\expandafter\endcsname
    \csname @\romannumeral\the\count@ pt\endcsname
  \csname #3\endcsname}%
\fi
\endgroup
\begin{picture}(387,577)(13,247)
\thicklines
\put(243,272){\dashbox{4}(128,39){}}
\put(281,297){\makebox(0,0)[lb]{\smash{\SetFigFont{10}{12.0}{rm}Optional/}}}
\put(264,280){\makebox(0,0)[lb]{\smash{\SetFigFont{10}{12.0}{rm}not always required}}}
\put( 73,647){\framebox(120,40){}}
\put( 73,327){\framebox(120,40){}}
\put( 73,247){\framebox(120,40){}}
\put( 73,727){\framebox(120,40){}}
\put( 13,707){\dashbox{4}(240,80){}}
\put( 13,627){\dashbox{4}(240,80){}}
\put(128,727){\vector( 0,-1){ 40}}
\put(128,647){\vector( 0,-1){ 40}}
\put(128,327){\vector( 0,-1){ 40}}
\put(170,397){\dashbox{4}(230,140){}}
\put(280,485){\vector( 0,-1){ 38}}
\put(225,407){\framebox(120,40){}}
\put(280,406){\vector(-3,-2){ 86.769}}
\put(127,565){\vector( 0,-1){199}}
\put( 73,565){\framebox(120,40){}}
\put(225,485){\framebox(120,40){}}
\put(193,589){\vector( 3,-2){ 89.538}}
\put(131,741){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}CCDSETUP}}}
\put(130,662){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}MAKEBIAS}}}
\put(129,581){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}DEBIAS}}}
\put(131,342){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}MAKEFLAT}}}
\put(129,261){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}FLATCOR}}}
\put(228,815){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}STANDARD REDUCTION ROUTES}}}
\put(282,422){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}CALCOR}}}
\put(283,501){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}MAKECAL}}}
\end{picture}

\end{center}
\caption{\label{red:seq} A schematic outline of the order in which
CCDPACK reduction routines should be used. Dashed boxes indicate that
this part is optional or not required. The MAKECAL/CALCOR section may
need repeating more than once (e.g. if flash and dark frames are to be
processed)}
\end{figure}

%  Make sure that this schematic gets printed out now.
\clearpage

\section{Registration and mosaicing}

Multiple observations form the backbone of many astronomical programmes.
Determining the registration (inter-dataset transformations) of the
observations is a necessary step when preparing to inter-compare or
combine the data. Inter-comparison is used when performing multiple
waveband observations; combination when measurements beyond the
capabilities of the detector are required. Helping astronomers to
determine the registration of imaging data and subsequently to transform
positions or resample and combine the data is the purpose of this part
of CCDPACK.

At present the registration techniques provided by CCDPACK are almost
exclusively reliant on the presence of image features (objects which are
centroidable). So registration is simply determining the correspondence
of the image features between all the datasets and from that the
transformations which map image feature to image feature. If it is the
intention to combine datasets into one (to increase signal to noise
levels, or to increase the effective area or dynamic range of the 
detector) the registering transforms may be used to resample the
datasets so they are aligned (i.e.\ have pixel-to-pixel correspondence).
If atmospheric transparency, sky brightness or exposure times have 
varied between the datasets, they need to go though a process of
`normalisation', in which global zero points and scale factors are
determined. After these stages the data may be combined to produce
a mosaic. Data combination usually makes use of a robust estimator to
protect against spurious values, cosmic rays etc.

In CCDPACK four methods for determining image feature correspondence
are provided. Two methods are reliant on the transformations being `well
modelled' by simple offsets. These methods have the advantage of
automated (completely hands-off) and semi-automated processing. The
third method relies on considerable interaction but can
deal with transformations of scale, magnification and shear as well as
offsets (so called linear transformations). The fourth method is
undefined -- do-it-yourself -- and consists of making any use of the
basic tools provided. Using the CCDPACK applications it is possible to
determine transformations between datasets using completely general 
functions.
\subsection{Registration}

The routine which determines the transformations between labelled
position lists is called
\begin{itemize}
\item REGISTER.
\end{itemize}
Labelled position lists are those in which the same objects (image
features) have the same identification number. So for instance if a
star say no.\ 100 is present on several datasets it should be labelled
no.\ 100 (or any other unique value) in all the datasets in which it
appears {\em regardless of its coordinates}. In many ways getting
labelled position lists may be considered as most of the process of
registration, the rest being essentially straight-forward. 

The main transform used by REGISTER is the linear transform
\begin{myquote}
\begin{verbatim}
XX = PA + PB * X + PC * Y
YY = PD + PE * X + PF * Y 
\end{verbatim}
\end{myquote}
where the \myverb{PA-PF} are the coefficients which are to be
determined, \myverb{X} and \myverb{Y} the current coordinates and
\myverb{XX} and \myverb{YY} the new coordinates. REGISTER supports
various types of linear transformations namely;
\begin{itemize}
\item a shift of origin
\item a shift of origin and rotation
\item a shift of origin and magnification
\item a shift of origin, rotation and magnification (solid body)
\item or a full six parameter fit
\end{itemize}

When using a linear fit you can register a {\em whole} list of datasets
in one go. So for instance if you have a set of position lists in which
corresponding objects have been identified, you may pick any list as the
reference set (the first is chosen by default) and all the transforms to
(and from) the reference set from the other datasets will be
derived. If the position lists are `associated' with NDFs then the
NDFs will have the transformation information to map to and from the
reference set entered into their CCDPACK extensions (see
\S\ref{using_lists_of_positions} and \S\ref{handling_transforms}), this
information can be used by other CCDPACK applications.

A general transformation between {\em two} datasets can also be
determined. These are entered using suitably parameterised algebraic
expressions. A general least squares fitting algorithm is used to find
a solution which gives satisfactory values for the parameters (see
\S\ref{general_transforms}).

\subsection{Registering offset datasets}

If your datasets are just offset from each other (i.e.\ translated in X
and Y), or more precisely are sufficiently `well modelled' by simple
offsetting (with distorting terms small enough that the error in
positioning is in general a larger effect) and have image features in
common it may be possible to register them with a minimum of effort and
preparation.

\subsubsection{Automated registration}
Automated registration is performed by the applications:
\begin{itemize}
\item FINDOBJ
\item FINDOFF
\item REGISTER
\end{itemize}
used in that order.

FINDOBJ locates and centroids image features. FINDOFF determines the
correspondence of the image-features and REGISTER produces the
transformations from this information. This sequence is used in the
CCDEXERCISE script. To see it in action set to a empty directory and
issue the command CCDEXERCISE ([ccdexercise]).

FINDOBJ works by looking for pixels above a threshold value, objects are
then identified as groups of `connected' pixels. The groups of connected
pixels are then centroided to give an accurate position.

FINDOFF is the crucial application in this sequence, it performs
pattern-matching between all the object positions. It assesses the
degree of match found between each pair of frames and assigns it a
weight. The best matches are then used to identify corresponding objects
on each frame.  The inter-comparison process which provides the
pattern-matching facilities uses two algorithms, one which matches  
{\em all} the point pair-offsets between any two input lists, counting
all the other points which are then paired (within an error box).  The
match with the most positions paired is then chosen. The second  uses a
statistical algorithm based on histograms of the differences in the
offsets (where the peak in a histogram is assumed to be the most likely
difference). In each case an estimate of the positional error must be
given as it is used when deciding which positions match or as the bin 
size when forming histograms.

Which algorithm you should use depends of the number of points your
positions lists contain and the expected number of objects in the 
overlaps. Obviously it is much easier to detect a match between  two
lists which have most of their positions in common. With small overlaps
a serious concern is the likelyhood of finding a `false' match. False
matches are more likely the larger the datasets and the smaller the
overlaps.

The first algorithm (named SLOW) is the most careful and is capable of
pairing positions in data with small overlaps (although a level of false
detections will always be present) but the process is inherently slow
scaling as $N^{3}\ln_{2}N$. The second algorithm (named FAST) is an
$N^2$ process so is much quicker, but requires better overlap
statistics. The {\em maximum} time taken for determining the
correspondence of two position lists for the SLOW algorithm are shown in
table \ref{table1}. If you intend to process large lists then take heed.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
$N$ & $5$ & $10$ & $25$ & $50$ & $100$ & $250$ & $500$ \\
\hline
Time (seconds) & 
     $0.03$ & $0.043$ & $0.12$ & $0.85$ & $7.3$ & $187$ & $1876$ \\
\hline
\end{tabular}
\caption{ \label{table1} 
Maximum time taken to process two lists of $N$ points. The tests were
run on a DECstation 5000/25 ($\approx 19$ SPECmark).}
\end{center}
\end{table}

Because the FAST process takes so little CPU time it is better to try
this first (without the SLOW process as a backup, 
\myverb{FAILSAFE=FALSE}), only
use the SLOW algorithm when you have small datasets or do not have large
overlaps.

Having obtained estimates of the offsets between each dataset pair and
the number of positions in common, the next stage is to determine a {\em
global} solution to the registration of all the datasets. A major
consideration is the possible presence of false matches. 

The global registration process works by forming a graph with each
position list at a node and with connecting edges of weight the number
of matched  position-pairs. The edge weights may be modified by a
completeness factor which attempts to assess the quality of the match
(this is based on the ratio of the expected number of matches in the
overlap region to the actual number, random matches shouldn't return
good statistics when compared with genuine ones). This still leaves a
possibility of false matches disrupting any attempt to register the
datasets so a single `spanning tree' is chosen (this is a graph which
just visits each node the minimum number of times required to get
complete connectivity, no loops allowed) which has the highest possible
number of matched positions (rejecting edges with few matched
positions/low completenesses where possible). This gives a most likely
solution to the offsets between the position lists, rather than the 
{\em best} solution which could well include false matches; compare this
with a median as opposed to a mean. This registration is then used to
identify objects in all datasets, resulting in {\em labelled} position
lists which are output for use by REGISTER.

The above scheme also works with datasets whose transformations really
need fully linear transforms provided that distorting terms are so small
that the error box used when comparing objects will include
corresponding positions. One can also envision its use when all terms
(say plate distortions) except the offset are known. Then the known
transformations could be applied to the data (using TRANLIST) and the
offsets determined. The new position lists could then be transformed
back into the original coordinates.

Invoking FINDOBJ, FINDOFF and REGISTER is trivial
\begin{myquote}
\begin{verbatim}
$ FINDOBJ IN=* OUTLIST=*.FIND \
$ FINDOFF INLIST=* OUTLIST=*.OFF ERROR=1 \
$ REGISTER INLIST=* FITTYPE=1 \
\end{verbatim}
\end{myquote}

This locates the objects on all the NDFs in the current directory,
performs pattern-matching and finally registers them, writing the
transformations into the NDFs. See \S\ref{using_lists_of_positions} if
using `\myverb{*}' for both the  \myverb{IN} and \myverb{INLIST}
parameters seems mysterious. How the transformation information is
stored is described in \S\ref{handling_transforms}.

FINDOFF's other parameters are detailed in \S\ref{des:findoff} and some
of its internals are explained in, P.W. Draper, {\bf 1993}, `Preparing
multiple CCD frames for the photometry of extended fields', Proceedings
of the 5th ESO/ST-ECF Data Analysis Workshop.

\subsubsection{Semi-automated registration}

Semi-automated registration uses the applications:
\begin{itemize}
\item PAIRNDF
\item REGISTER
\end{itemize}

PAIRNDF displays the NDFs to be registered and allows the direct
selection of image features which are common between image pairs.  This
works by displaying all the NDFs in a pallette region down the
right-hand side of an IDI image display. The mouse buttons may then be
used to select two of the images which are re-displayed in the larger
`scratch' region. After selection these two images may be manipulated by
setting a reference position (which may be on either image), then
showing  where this corresponds on the other image. The two are then
displayed overlaid with an average value in the overlap region. If the
overlap is correct then the positions of the image-features in it may be
identified. Zoom and pan are available if the device allows this (X
displays), so that images may be closely inspected and positioned very
accurately. As with all graphically based interfaces it is difficult to
describe the advantages and ease of use, it's best to try them out.

When enough of the datasets have been selected this way, and
successfully paired, the global correspondence of the image features is
determined. Using this method avoids the need to identify each image
feature in a particular sequence, they are just selected as being in
`common' between any pair, PAIRNDF works out the rest using the same
methods as FINDOFF, except a single spanning tree is not chosen since
in this case all pairings are assumed to be correct.

\subsection{Using linear transforms}

Aligning datasets which require linear transformations is helped by
using the
\begin{itemize}
\item CCDALIGN
\end{itemize}
procedure. This accepts either a sequence of NDFs or related NDFs
(datasets which are already approximately aligned, at least within the
capabilities of centroiding $\approx$ few pixels) and displays them one
by one (or the first member of each group). You then have to simply
identify the image features to use, but in the correct order. Only
enough image features to identify the approximate image position are
required as the  procedure then centroids the image features, works out
an approximate registration which it then uses to extrapolate the
positions of a reference set on each dataset. This new extended set of
positions are now centroided picking up any missed objects. The
reference set of positions are either selected from a designated NDF or
from the first NDF. The reference set can be extended by identifying
objects after all the current reference set have been identified
(possibly by selecting positions off the image if they are not actually
present). The complete registration is performed using all these
positions.

\subsection{General transformations}
\label{general_transforms}
CCDPACK can also fit and use general transformations. The fitting of
general transformations is restricted to {\em two} datasets. General
transformations are `algebraic-like' expressions supplied by you. An
example of such a transformation is the Sanson-Flamstead sinusoidal.
\begin{myquote}
\begin{verbatim}
XX = X * COS(Y)
YY = Y
X  = XX / COS(YY)
Y  = YY
\end{verbatim}
\end{myquote}
where \myverb{X} and \myverb{Y} are the present coordinates and
\myverb{XX} and \myverb{YY} are the new coordinates.

This is the `Fortran-like' form understood by the package TRANSFORM
(SUN/61). TRANSFORM is used for passing all transformation information 
between CCDPACK applications. When fitting such a transform it is
necessary to parameterise the formulation, the object of the exercise
being to determine good values for the parameters. An obvious way to use
this ability is to test the hypothesis that a linear transformation is
not sufficient to accurately register datasets. To do this you might use
the forward transform expression.
\begin{myquote}
\begin{verbatim}
XX = PA + PB * X + PC * Y + PD * X * X + PE * Y * Y
YY = PF + PG * X + PH * Y + PI * X * X + PJ * Y * Y
\end{verbatim}
\end{myquote}
The best values of the \myverb{PA-PJ} parameters can then be determined.
General expressions are always given in this form with coordinates
\myverb{(X,Y)} and \myverb{(XX,YY)}, parameters \myverb{PA-PZ}.
Sub-expressions are also supported using the tokens \myverb{FA-FZ}, these
should be used when complex repeated strings (which may include
\myverb{PA-PZ} references) occur e.g.
\begin{myquote}
\begin{verbatim}
XX = PA * ASIND( FA / PA ) * X / FA
YY = PA * ASIND( FA / PA ) * Y / FA
X  = PA * SIND( FB / PA ) * XX / FB
Y  = PA * SIND( FB / PA ) * YY / FB
FA = SQRT( X * X + Y * Y )
FB = SQRT( XX * XX + YY * YY )
\end{verbatim}
\end{myquote}
which is a form of perspective projection.

Transformations which are already known (as must be the case if no
objects are present in the data) may be entered directly into the NDFs
(by-passing REGISTER) using the CCDEDIT command
(see its entry in appendix \ref{app:description}).

\subsection{Transforming positions}
Transforms may be applied to position lists using the routine
\begin{itemize}
\item TRANLIST
\end{itemize}
TRANLIST can use transformations expressed in three different forms
\begin{itemize}
\item transform structures
\item linear transform coefficients
\item and general algebraic expressions.
\end{itemize}
The first method is the usual one used for passing transformation
information between CCDPACK applications (\S\ref{handling_transforms}).
The second uses the coefficients of the linear transform and the third
allows you to transform a list using the algebraic expressions which are
understood by the TRANSFORM package (SUN/61).

Transforming positions using transform structures is usually
straight-forward, provided you've registered your data and finally
entered this information into the NDFs using REGISTER. The choice then
becomes one of whether you want the forward or inverse transform.

Transforming positions selected from one dataset (say using the IDICURS
application) to a reference coordinate system or indeed vice-versa, is
fairly straight-forward given registered datasets. It is also possible
to transform to the coordinates of another dataset. The sequence of
commands for this operation goes like:

\begin{myquote}
\verb+$ DISPLAY  NDF                              + \numcir{1} \\
\verb+$ IDICURS  IN=NDF OUTLIST=NDF.APPROX        + \numcir{2} \\
\verb+$ FINDCENT INLIST=NDF OUTLIST=NDF.ACC       + \numcir{3} \\
\verb+$ TRANLIST TRTYPE=STRUCT INLIST=NDF FORWARD + \\
\verb+           OUTLIST=NDF.REF                  + \numcir{4} \\  
\verb+$ TRANLIST INLIST=NDF INEXT=FALSE           + \\
\verb+           OUTLIST=NDF.LOOK                 + \\
\verb+           TRANSFORM=NEWNDF.MORE.CCDPACK.TRANSFORM + \\
\verb+           FORWARD=FALSE                    + \numcir{5} 
\end{myquote}

Notes:
\begin{enumerate}
\item The KAPPA (SUN/95) routine DISPLAY is used to display an NDF's 
data component.
\item IDICURS is used to select positions which are written into a
position list \myverb{NDF.APPROX} and associated with the NDF.
\item FINDCENT centroids the positions. The new position list is
\myverb{NDF.ACC} which is now associated with the NDF.
\item TRANLIST transforms the new positions to the reference 
coordinates, using the forward transformation stored in the NDF.
\item TRANLIST now transforms the positions from the reference
coordinate system to coordinate system of \myverb{NEWNDF}, using the
inverse transform stored in \myverb{NEWNDF}.
\end{enumerate}

The final command is complex as the transform to be used is not
associated with the NDF with which the position list to be transformed
is associated, so it is necessary to give the full name of the 
transform structure. This exemplifies why using NDFs to store the
transformations is such a good idea. Managing the names of objects such
as these in a complex situation could be fraught.

Using linear coefficients is a quick way of applying offsets, scales and
rotations to data. The linear transform form is 
\begin{myquote}
\begin{verbatim}
XX = PA + PB * X + PC * Y 
YY = PD + PE * X + PF * Y 
\end{verbatim}
\end{myquote}
The \myverb{PA-PZ} correspond to the coefficients you give to TRANLIST.
The identity transformation is \myverb{[0,1,0,0,0,1]} which corresponds
to the coefficients \myverb{[PA,PB,PC,PD,PE,PF]}. So an offset in X and
Y would be \myverb{[PA,1,0,PD,0,1]}. Scaling uses the \myverb{PB,PC,PE
and PF} coefficients, obviously in this case \myverb{PB,PE} and
\myverb{PC,PF} would be identical. Rotation uses the coefficients
\begin{eqnarray*}
\left(
        \begin{array}{ll} 
           \myverb{PB} = cos(\theta), & \myverb{PC} = -sin(\theta) \\
           \myverb{PE} = sin(\theta), & \myverb{PF} = cos(\theta) \\
        \end{array}
\right)
\end{eqnarray*}
where $\theta$ is the angle to rotate (counter-clockwise). So a rotation
of 45 degrees counter-clockwise about \myverb{(0,0)} is
\myverb{[0,0.7071,-0.7071,0,0.7071,0.7071]}.

General transformations are expressed in a `Fortran-like' form and may
use the functions \myverb{SIN}, \myverb{TAN}, \myverb{COS}, 
\myverb{ASIN}, 
\myverb{ACOS}, \myverb{LOG}, \myverb{LOG10} and many others  which are
listed in SUN/61 appendix A. An example of using this capability is to
transform positions by a parameterised pin-cushion distortion.
\begin{myquote}
\begin{verbatim}
$ TRANLIST  XFOR = ( FX * ( 1 + PA * ( FX*FX + FY*FY ) ) ) * PS + PX
            YFOR = ( FY * ( 1 + PA * ( FX*FX + FY*FY ) ) ) * PS + PY
            FX = ( X - PX ) / PS  FY = ( Y - PY ) / PS
            PA = 21.4 PX = 100D0 PY = 200D0 PS=11.5
\end{verbatim}
\end{myquote}
This also shows how to use sub-expressions to reduce complex formulae to
more manageable levels (\myverb{X} and \myverb{Y} are offset and scaled
to some arbitrary level and now masquerade as \myverb{FX} and
\myverb{FY}). This also allows quick modifications since only the values
of the parameters need to be changed on re-runs.

\subsection{Handling transformation information}
\label{handling_transforms}
The transformations determined by the REGISTER application are stored in
HDS (SUN/92) objects known as `transform structures'. These objects are
produced by the TRANSFORM (SUN/65) package and contain a full
description (in an algebraic form which may be examined using the TRACE
(SUN/102) utility) of the transformation. Usually transform structures
are written into the CCDPACK part of the extension of the NDF to which
they apply (under the item TRANSFORM) and can be accessed without any
further action.

An example trace of a transform structure is shown next.

\begin{myquote}
\begin{verbatim}
NDF.MORE.CCDPACK.TRANSFORM  <TRN_TRANSFORM>
  TRN_VERSION    <_REAL>   0.9
  FORWARD        <_CHAR*9>   'DEFINED'
  INVERSE        <_CHAR*9>   'DEFINED'
  MODULE_ARRAY(1)  <TRN_MODULE>   {structure}
    NVAR_IN        <_INTEGER>   2
    NVAR_OUT       <_INTEGER>   2
    COMMENT        <_CHAR*44>   'name of data file'
    PRECISION      <_CHAR*7>   '_DOUBLE'
    FORWARD_FUNC(2)  <_CHAR*37>  'XX=37.981916884451D0+1D0*X+0.D00*Y,'
                                 'YY=8.79311726090132D-02+0.D00*X+1D0*Y'
    INVERSE_FUNC(2)  <_CHAR*41>  'X=(-37.981916884451D0)+1D0*XX+0.D00*YY',
                                 'Y=(-8.79311726090132D-02)+0.D00*XX+1D0*YY'
    
    CLASSIFICATION  <TRN_CLASS>   {structure}
      LINEAR         <_LOGICAL>   TRUE
      INDEPENDENT    <_LOGICAL>   TRUE
      ISOTROPIC      <_LOGICAL>   TRUE
      POSITIVE_DET   <_LOGICAL>   TRUE
      CONSTANT_DET   <_LOGICAL>   TRUE
      UNIT_DET       <_LOGICAL>   TRUE

End of Trace.
\end{verbatim}
\end{myquote}

Note that a full transform is defined with a forward and an inverse
mapping (these are produced automatically by CCDPACK when using linear
transforms). All transformations (and positions) are stored in double
precision. The number of variables is two for the forward and inverse
functions (\myverb{X},\myverb{Y} and \myverb{XX},\myverb{YY}). Finally
the transformation is classified so that future applications know its
properties and may take action to speed up or stop processing if a
required property is not apparent (CCDPACK produces classifications for
linear transformations).

\subsection{Using lists of positions}
\label{using_lists_of_positions}
In CCDPACK the positions of identified/detected image features are
stored in ordinary text files which are referred to as `position lists'.
The format of these lists is flexible. Usually position lists have three
columns:
\begin{myquote}
\begin{verbatim}
Identifier    X-position    Y-position
\end{verbatim}
\end{myquote}
these may be separated by commas or blanks. The identifier is an
integer value which is used to identify positions which are the related
(i.e.\ are of the same object) in different lists.

If more than three columns exist then only the first three are used.
If only two columns exist it is assumed that they are:
\begin{myquote}
\begin{verbatim}
X-position   Y-position
\end{verbatim}
\end{myquote}
such lists may be produced by KAPPA applications. In this case 
applications which rely on a knowledge of the identifiers  assume they
are monotonically increasing from one.

Whole and in-line and comments are allowed in position lists using the
character `\#'.

Usually position lists are `associated' with NDFs. What is means is
that when a position list is created a record of its name is kept in the
extension of the NDF. It is then usual to refer to the NDF instead of
the position list when the position list is to be accessed. Applications
which create new position lists associate the new position lists with
the appropriate NDF. Using this method avoids any confusion about the
relationship of position lists and NDFs, which is vital when determining
the registration of many NDFs at one go. It also allows the use of the
wildcarding properties of NDF names to access position lists.

Position lists may be associated with NDFs using the CCDEDIT routine. To
disable associations set the NDFNAMES global parameter (CCDSETUP) to
false. In this case, position lists must be specified explicitly as a
comma separated list of names or gotten from a text file using
indirection, this is exactly the same as for naming NDFs (see
\S\ref{ndflists}) except that wildcards are {\em not} allowed. Output
list names may be formed from the modification of these names when
NDFNAMES is false, otherwise the input NDF names are {\em always} used.

\subsection{Data resampling}
Data resampling is performed by the application:
\begin{itemize}
\item TRANNDF
\end{itemize}
This uses the transformation information produced by the REGISTER or
CCDEDIT routines and resamples a list of NDFs. TRANNDF will use any
transform structure and hence has the capability of `rubber-sheeting'
NDFs. A major restriction (for the present) is that both the forward and
the inverse transformations must be available. This will only cause
problems when using general transformations; a tractable inverse doesn't
often exist.

TRANNDF resamples using two different techniques, linear interpolation
and nearest neighbour. Linear interpolation uses two pixels to estimate
the new pixel value, nearest neighbour just uses the nearest pixel. Flux
conservation is available but is only supported for linear 
transformations. Variances are resampled in the same way as ordinary
data.

The size of the output NDFs can be estimated from the transformation of
selected boundary positions, this is very useful when transforming whole
lists of NDFs as the output NDFs are made only as big as necessary,
without any interaction. Note, however, that this method will fail for
complex transformations.

To use TRANNDF type something like
\begin{myquote}
\begin{verbatim}
$ TRANNDF IN=* OUT=*-TRN 
\end{verbatim}
\end{myquote}
This resamples all the NDFs in the current directory naming the output
NDFs the same as the inputs except that the string `\myverb{-TRN}' is
appended to each output name. By default TRANNDF will guess a size for
the output NDF interpolate using nearest neighbour and conserve flux.

TRANNDF is based on the KAPPA application TRANSFORMER, look at
TRANSFORMER if TRANNDF does not supply the capabilities you require.

\subsection{Controlling NDF extensions}
The contents of an NDF's CCDPACK extension may be examined at any time
using the TRACE utility (SUN/102). The CCDPACK extension is always
stored in 
\begin{myquote}
\begin{verbatim}
NDF_NAME.MORE.CCDPACK
\end{verbatim}
\end{myquote}
CCDPACK `items' are stored under this object using fixed names i.e.\
transform structures are always stored as `TRANSFORM'. An example trace
of a transform structure is shown in \S\ref{handling_transforms}.
Another useful item is `CURRENT\_LIST', which stores the name of the
position list currently associated with an NDF.

Controlling the contents of NDF CCDPACK extensions is performed by the
\begin{itemize}
\item CCDEDIT
\end{itemize}
application. This allows the deletion of CCDPACK items, the association
of position lists, the entry of general transforms and the inversion of
the sense of transforms, of a list of NDFs.

\subsection{Mosaicing and normalisation}

The tasks of mosaicing and (optional) normalisation are performed by 
the 
\begin{itemize}
\item MAKEMOS
\end{itemize}
command. MAKEMOS is a comprehensive application and has many
capabilities. In its default mode MAKEMOS just combines NDFs using a
selected data combination method (MAKEMOS supports the methods -- mean,
median, trimmed mean etc.\ \S\ref{combinations}). In this it is similar
to the MAKECAL routine, but, MAKEMOS makes much more efficient use of
memory (it is designed to deal with datasets which may not have much
overlap and which might have a very large output extent, unlike with CCD
calibration data where the overlap will usually be complete).

The other capabilities of MAKEMOS are concerned with data normalisation.
Normalisation is determined as two components, a scaling factor and a
zero point factor. These may be controlled independently by the
parameters \myverb{SCALE} and \myverb{ZERO}. So 
\begin{myquote}
\begin{verbatim}
$ MAKEMOS IN=* OUT=MOSAIC SCALE
$ MAKEMOS IN=* OUT=MOSAIC ZERO
$ MAKEMOS IN=* OUT=MOSAIC SCALE ZERO
\end{verbatim}
\end{myquote}
would determine just scale factors, just zero points or both scale
factors and zero points respectively. The option also exists to modify
the data values of the input datasets so that their values are
normalised (this may be combined with producing a mosaic or not using
the \myverb{OUT} parameter). A full description of MAKEMOS is given in
\S\ref{des:makemos}, some of the philosophy of its algorithms are
explained in, R.F. Warren-Smith, {\bf 1993}, `The Calibration of
Large-Field Mosaics', Proceedings of the 5th ESO/ST-ECF Data Analysis
Workshop.

\subsection{Schematic registration sequences}
The order in which the various application should be used are shown
in schematic form in figure \ref{registration}. 

\begin{figure}
\begin{center}
\setlength{\unitlength}{0.012500in}%
%
\begingroup\makeatletter
% extract first six characters in \fmtname
\def\x#1#2#3#4#5#6#7\relax{\def\x{#1#2#3#4#5#6}}%
\expandafter\x\fmtname xxxxxx\relax \def\y{splain}%
\ifx\x\y   % LaTeX or SliTeX?
\gdef\SetFigFont#1#2#3{%
  \ifnum #1<17\tiny\else \ifnum #1<20\small\else
  \ifnum #1<24\normalsize\else \ifnum #1<29\large\else
  \ifnum #1<34\Large\else \ifnum #1<41\LARGE\else
     \huge\fi\fi\fi\fi\fi\fi
  \csname #3\endcsname}%
\else
\gdef\SetFigFont#1#2#3{\begingroup
  \count@#1\relax \ifnum 25<\count@\count@25\fi
  \def\x{\endgroup\@setsize\SetFigFont{#2pt}}%
  \expandafter\x
    \csname \romannumeral\the\count@ pt\expandafter\endcsname
    \csname @\romannumeral\the\count@ pt\endcsname
  \csname #3\endcsname}%
\fi
\endgroup
\begin{picture}(445,457)(5,360)
\thicklines
\put( 60,720){\vector( 1,-2){119}}
\put(225,719){\vector( 0,-1){ 37}}
\put(225,790){\line( 0, 1){ 10}}
\put(225,800){\line( 1, 0){160}}
\put(385,800){\line( 0,-1){ 10}}
\put(  5,720){\framebox(125,40){}}
\put(165,720){\framebox(125,40){}}
\put(325,720){\framebox(125,40){}}
\put(165,640){\framebox(125,40){}}
\put(225,520){\vector( 0,-1){ 37}}
\put(225,440){\vector( 0,-1){ 37}}
\put(165,360){\framebox(125,40){}}
\put(165,440){\framebox(125,40){}}
\put(165,520){\framebox(125,40){}}
\put( 65,720){\vector( 1,-1){150}}
\put(385,720){\vector(-1,-1){150}}
\put(225,640){\vector( 0,-1){ 80}}
\put( 64,740){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}CCDALIGN}}}
\put(225,739){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}FINDOBJ}}}
\put(385,740){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}PAIRNDF}}}
\put(224,660){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}FINDOFF}}}
\put( 65,775){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}Generic}}}
\put(225,775){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}Automatic}}}
\put(385,775){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}Manual}}}
\put(305,805){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}Translation only}}}
\put(224,539){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}REGISTER}}}
\put(224,459){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}TRANNDF}}}
\put(224,380){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{bf}MAKEMOS}}}
\put( 22,580){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{rm}Linear transforms}}}
\end{picture}
\end{center}

\caption{\label{registration} A schematic of the standard sequences 
of commands used to perform registration, resampling and mosaicing.}
\end{figure}

%  Make sure that this picture get printed out now.
\clearpage

\section{Parameter behaviour and control}

CCDPACK has a number of `global' parameters which you can setup
`once and for all'. The usual time to do this is at the beginning of a
reduction sequence. These parameters are set in the
ADAM\_USER:GLOBAL.SDF (UNIX - \$HOME/adam/GLOBAL or if you have set 
the environment variable \$ADAM\_USER/GLOBAL)
file and are used (when set) to override all other values (typically the
current values of other applications or perhaps  dynamically generated
defaults). The global values may be overridden, at any time by values
entered on the command line, or given in response to a prompt. The task
which sets up the global parameters is 

\begin{itemize}
\item CCDSETUP
\end{itemize}

This routine was described in \S\ref{CCDSETUP}.

The current values of the global parameters can be viewed at any time by
using the routine 

\begin{itemize}
\item CCDSHOW.
\end{itemize}

The global values should always be cleared before analysing data from a
different instrument, this is achieved using 

\begin{itemize}
\item CCDCLEAR.
\end{itemize}

which can also clear individual parameters.

A second control strategy that CCDPACK routines use is that of leaving
parameters set at the last used value (this is known as the `current'
value). This means that once a parameter has a value assigned to it (by
a run of a task), this will be used again (unless it's one of those
with a global association, which if set will override this). This is
useful in that you do not have to remember the values on each occasion
of use. However, this does have a drawback of hiding some values. These
will typically appear in the log or be directly reported (if the log
system is setup to do so), so always take care to inspect the log, or
the terminal output, until you're sure of how things are setup. To get
rid of any unwanted parameter values (and restore the `intrinsic'
default behaviour of an application) just use the keyword 
\myverb{RESET}, on the
command line when activating the application. This resets all current
values but does not effect the global values.

If resetting the parameters seems not to work or you want to clear all
the CCDPACK task current values, then a brutal reset can be achieved by
deleting the appropriate files (application\_name.sdf) in the ADAM\_USER
(\$HOME/adam or \$ADAM\_USER on UNIX). If you're using the CCDPACK
monolith then all its current parameter values are kept in one file --
CCDPACK.SDF.

\section{Batch and background processing}
\label{sec:batch}

The easiest way to use the full benefits of CCDPACK in batch (VMS) or in
the background (UNIX), is to produce a file just containing the CCDPACK
commands you want performed. The content of such files is made much
simpler if use of CCDPACK's NDF list accessing facility is made. The
best way to do this is to get your data files organised. This
organisation can be performed in several different ways, I prefer the
first method\ldots

\begin{itemize}
\item Organise all your files into related subdirectories (as in most of
the previous examples), i.e.\ put all your bias frames into a
subdirectory, put all your flatfield and target data into colour related
directories etc.

\item Make up ASCII lists of all the names of the different file types
(i.e.\ use an editor to create say a list of the names of your bias
frames, a list of your R flatfields, R data etc.).

\item Use a naming scheme which allows differentiation between the data
types.

\item None of the above, just supply all the relevant names on the
command line, or in response to a prompt.
\end{itemize}

The command file which controls CCDPACK can be written as if responding
to DCL, ICL or to a C shell. Examples of such CCDPACK command files are
shown next.

\subsection{Example DCL command file}

\begin{myquote}
\begin{verbatim}
$!
$! DCL command file to run a CCDPACK reduction sequence from BATCH
$!
$! set up the global parameters.
$!
$CCDSETUP BOUNDS=[323,349] RNOISE=10 ADC=1 EXTENT=[4,318,3,510] -
          DIRECTION=X LOGTO=TERMINAL LOGFILE=CCDPACK.LOG PRESERVE=TRUE \
$!
$! Add some explanatory notes
$!
$CCDNOTE "Test run of CCDPACK atasks in batch-"
Reduction perform by AUSER on 20-JUN-1991.
$!
$! Make the master bias frame.
$!
$MAKEBIAS IN=[.BIAS]* OUT=[.BIAS]MASTER_BIAS \
$!
$! DEBIAS all the frames. Note using a master bias frame and normalising to
$! the bias strip.
$!
$DEBIAS IN="[.FLATR]*,[.FLATB]*,[.BDATA]*,[.RDATA]*" OUT=*_DEBIAS \
$!
$! Create the master flat fields for the R and B filters.
$!
$MAKEFLAT IN=[.FLATR]*_DEBIAS OUT=[.FLATR]MASTER_FLAT \
$MAKEFLAT IN=[.FLATB]*_DEBIAS OUT=[.FLATB]MASTER_FLAT \
$!
$! Flat field all the appropriate frames.
$!
$FLATCOR IN=[.RDATA]*_DEBIAS OUT=*|DEBIAS|FLATTENED| -
         FLAT=[.FLATR]MASTER_FLAT \
$FLATCOR IN=[.BDATA]*_DEBIAS OUT=*|DEBIAS|FLATTENED| -
         FLAT=[.FLATB]MASTER_FLAT \
$!
$! All done. Add note.
$!
$CCDNOTE "Test reduction finished"
$!
$exit
\end{verbatim}
\end{myquote}

\subsection{Example ICL command file}

ICL command files are very similar to DCL ones:

\begin{myquote}
\begin{verbatim}
{
{  ICL control file for testing CCDPACK batch reductions using the
{  monolith and ICL.
{
{ set up global parameters.
CCDSETUP BOUNDS=[323,349] RNOISE=10 ADC=1 EXTENT=[4,318,3,510] ~
         DIRECTION=X LOGFILE=CCDPACK.LOG PRESERVE=TRUE RESET \
{
{ Add some explanatory notes
{
CCDNOTE "Test run of CCDPACK monolith in batch-"
CCDNOTE "Reduction perform by AUSER on 8-JUN-1992."
{
{ Make the bias frames.
{
MAKEBIAS IN=[.BIAS]* OUT=[.BIAS]MASTER_BIAS RESET \
{
{ DEBIAS all the frames. Note using a bias frame and normalising to
{ the bias strip.
{
DEBIAS IN="[.FLATR]*,[.FLATB]*,[.BDATA]*,[.RDATA]*" ~
       OUT=*_DEBIAS MASK=[.MASK]MASK BIAS=[.BIAS]MASTER_BIAS RESET \
{
{ Create the flat fields
{
MAKEFLAT IN=[.FLATR]*_DEBIAS OUT=[.FLATR]MASTER_FLAT RESET \
MAKEFLAT IN=[.FLATB]*_DEBIAS OUT=[.FLATB]MASTER_FLAT RESET \
{
{ Flat field all the appropriate frames.
{
FLATCOR IN=[.RDATA]*_DEBIAS OUT=*|DEBIAS|FLATTENED| ~
        FLAT=[.FLATR]MASTER_FLAT RESET \
FLATCOR IN=[.BDATA]*_DEBIAS OUT=*|DEBIAS|FLATTENED| ~
        FLAT=[.FLATB]MASTER_FLAT RESET \
{
{ All done.
{
CCDNOTE "Test reduction finished"
{
\end{verbatim}
\end{myquote}

\subsection{Example C shell command file}

C shell command files are not too dissimilar from the DCL and ICL
versions, the only exceptions being the requirement to protect certain
symbols from being interpreted by the shell and the CCDNOTE entry. The
CCDNOTE entry uses the shell to read in lines of data (until the
occurrence of \myverb{FOO}, that's what \myverb{<<FOO} means -- read this
file until an occurrence of \myverb{FOO}).

\begin{myquote}
\begin{verbatim}
#
# command file to run a CCDPACK reduction sequence from a
# C shell background job.
#
# set up the global parameters.
#
ccdsetup bounds='[323,349]' rnoise=10 adc=1 extent='[4,318,3,510]' \
         direction=x logto=terminal logfile=ccdpack.log \
         preserve=true accept
#
# Add some explanatory notes
#
ccdnote <<FOO
Test run of CCDPACK atasks in background job -
Reduction perform by AUSER on 8-JUN-1992.
FOO
#
# Make the master bias frame.
#
makebias in='bias/*' out=bias/master_bias accept
#
# DEBIAS all the frames. Note using a master bias frame and normalising to
# the bias strip.
#
debias in='"flatr/*,flatb/*,bdata/*,rdata/*"' out='*_debias' accept
#
# Create the master flat fields for the R and B filters.
#
makeflat in='flatr/*_debias' out='flatr/master_flat' accept
makeflat in='flatb/*_debias' out='flatb/master_flat' accept
#
# Flat field all the appropriate frames.
#
flatcor in='rdata/*_debias' out='*|debias|flattened|' \
        flat=flatr/master_flat accept
flatcor in='bdata/*_debias' out='*|debias|flattened|' \
        flat=flatb/master_flat accept
#
# All done. Add note.
#
ccdnote '"Test reduction finished"'
#
\end{verbatim}
\end{myquote}

Copies of the appropriate files can be found in the CCDPACK\_DIR
directory (VMS) or the /star/bin/ccdpack directory (UNIX). They are
named CCDPACK\_BATCH.COM,\newline CCDPACK\_BATCH.ICL and ccdpack\_back
respectively. Note that the second example uses \myverb{RESET}, this stops any
previously set current values from being used accidentally, forcing the
use of all the non-globally defined defaults.

The next step after creating your command file is to run
\begin{itemize}
\item CCDBATCH (VMS)
\end{itemize}
or
\begin{itemize}
\item ccdfork (UNIX)
\end{itemize}

The actions of CCDBATCH and ccdfork are very similar, they both save the
current ADAM environment and write a procedure (script file) which (when
activated) restores the environment, ensures that CCDPACK is started
(sets the default directory -- VMS) and executes the commands in the
command file. The point in saving the current environment is that any
global or current values which you have set (by using CCDSETUP) are
restored to the job, without interference with any other processes.

CCDBATCH has two parameters, the name of your CCDPACK command file and
a name for the sub-directory of SYS\$SCRATCH in which it will save the
current ADAM environment (this last parameter is optional, if you do
not supply it then CCDBATCH will generate a unique name).
To use CCDBATCH type something like
\begin{myquote}
\begin{verbatim}
$ CCDBATCH CCDPACK_BATCH BATCH1
\end{verbatim}
\end{myquote}
This command will result in the creation of a DCL procedure file
\begin{itemize}
\item CCDPACKB.COM
\end{itemize}
which can be submitted to a batch queue. When submitted to batch
CCDPACKB  executes the procedure CCDPACK\_BATCH.COM (or .ICL if the .COM
form does not exist --- to override this action just supply the full
filename) using the environment stored in the subdirectory BATCH1 of
SYS\$SCRATCH.

The UNIX equivalent to CCDBATCH, {\em ccdfork} has three parameters, the
first is again the name of the input script, the second the name of the
output script (ccdpack\_fork by default) the final is the name of the
directory in which to save the current environment. If you do not supply
a name for the last option then a unique one will be generated as a
subdirectory of the parent of the directory that holds the environment
(\$ADAM\_USER or \$HOME/adam). Using this command results in a script file
which may be directly executed or forked (`nice'ly) into the background.

Since the ADAM execution environment of the current process is saved
when CCDBATCH or ccdfork are run any previous CCDPACK global and
current values, which are in force, will be restored to the batch
process. Thus one labour saving strategy would be to set the global
parameters for a CCD device using CCDSETUP {\em interactively}, this
command does not then need to be repeated in the batch/background job.
So the chances of making a mistake in this crucial stage are reduced. A
typical preparation sequence is:-

\begin{myquote}
\begin{verbatim}
$ CCDSETUP etc.
$ edit CCDPACK_BATCH.COM
  <make modifications to command file>
$ CCDBATCH CCDPACK_BATCH
$ SUBMIT/LOG_FILE=SYS$DISK:[]CCDPACKB.LOG/KEEP/NOPRINT CCDPACKB
\end{verbatim}
\end{myquote}
when using DCL, or 
\begin{myquote}
\begin{verbatim}
% ccdsetup etc.
% edit ccdpack_back
  <make modifications to command file>
% ccdfork ccdpack_back
% nice ccdpack_fork >&ccdpack_fork.log &
\end{verbatim}
\end{myquote}

In the above examples dark and flash counts calibration have not been
included, if you require these options then include the appropriate
commands between the debiassing and flatfielding (remember to be careful
specifying the NDF order if the exposure times vary).

\section{The CCDPACK logging system}
\label{logsystem}

One of the main features of the CCDPACK system is the incorporation of
an internal logging system in all of its applications. The logging
system is intended to provide you with a permanent record of the
actions, parameters (given and derived) and results of all your
reduction sequences. In addition to writing to the log file CCDPACK also
reports directly to the terminal.  Having the input and output of any
reduction sequence logged and/or reported to the terminal is an optional
feature, the level of reporting being controlled by a global parameter
LOGTO which is set by CCDSETUP. LOGTO is a character variable and can
take one of the following values.
\begin{quote}
\begin{description}
\item [Neither] - Perform no output.
\item [Terminal] - Perform output to the terminal only.
\item [Logfile] - Perform output to logfile only.
\item [Both] - Perform output to the logfile and the terminal [default].
\end{description}
\end{quote}
it is recommended that LOGTO is set so that some output occurs, this is
felt very necessary given the flexibility of the parameter system; it is
all too easy to be using values which you are not aware of, and you
should regularly inspect the log system output, especially if starting a
new sequence with a different setup. The alternative to this approach is
to make sure that every value is prompted for, this can be achieved by
issuing the ADAM command \myverb{PROMPT} when invoking the task, but of course
this forces the routines to be run interactively.

The basis of the CCDPACK logging system is different on VMS and UNIX
systems. At present the UNIX version of CCDPACK just uses a formatted
file system so its logfiles are just listed using cat. The basis of the
VMS log system is the same as that used by ICL. To inspect the
contents of an ICL log file it is necessary to use one of two utilities.
From within ICL the command 
\begin{itemize}
\item REPFILE 
\end{itemize}
will list the contents. From DCL and ICL
\begin{itemize}
\item LISTLOG 
\end{itemize}
will also list the contents, but has the added capability of writing to
a printable file. LISTLOG is detailed in Appendix \ref{app:description}.
The advantages of using the ICL log file system are that CCDPACK log
information can be written to the usual ICL logfile ADAM\_USER:ADAM.LOG
(if you use this facility), and that the date and time of the commands
are also stored and that records can be selected using these values.

\subsection{Writing your own comments to the log file}

It is possible to write comments about the reduction (say what object,
who was responsible for setting the reduction up etc.) directly into the
log file. To do this use the utility routine

\begin{itemize}
\item CCDNOTE
\end{itemize}

followed by the comments on the command line, or in response to the
prompt. To continue the comments on to other lines just terminate the
input string with the continuation character `\myverb{-}'.

\section{Using lists of NDFs etc.}
\label{ndflists}

Perhaps the most noticeable of CCDPACKs `features' is its ability to
accept, and process, lists of NDF names and other associated parameters,
such as exposure times and position list names (see 
\S\ref{using_lists_of_positions}). A list of `names' can be supplied in
response to one prompt, or can be supplied on successive lines using the
continuation character `\myverb{-}' to force a reprompt for more
specifications. A list of names consists of a series of character
strings separated by commas. Note that the list itself is really a
string not a vector and should be enclosed in quotes (\myverb{""} if
using DCL or C shell, \myverb{``} or \myverb{""} if using ICL) if given
on the command line, not square brackets as a vector quantity would. The
quotes are not necessary if the list consists of only one name, or if
given in response to a prompt.

\subsection{Input wildcards}
The names of NDFs given to CCDPACK routines may include wildcard
specifications. On VMS wildcards as given to the directory command may
be used e.g.:
\begin{myquote}
\begin{verbatim}
*,%, and [...]
\end{verbatim}
\end{myquote}
On UNIX wildcards as used by the `ls' command may be used, e.g.:
\begin{myquote}
\begin{verbatim}
      *,?,[a-z]
\end{verbatim}
\end{myquote}

all of which have usual meanings, i.e.\ any number of characters and a
single character, for \myverb{*,\%} and \myverb{*,?}. The simplest
return
would then be
\begin{myquote}
\begin{verbatim}
      IN > *
\end{verbatim}
\end{myquote}

and all the NDFs in the current directory would be accessed. Other
possibilities include specifications such as (UNIX examples shown in
\myverb{[ ]}):

\begin{myquote}
\verb+ IN > [.BIAS]*             + (all NDFs in the BIAS subdirectory)\\
\verb+[IN > bias/* ]             + \\
\verb+                           + \\
\verb+ IN > [.RDATA]*,[.BDATA]*  + (all NDFs in the RDATA and BDATA \\
\verb+[IN > rdata/*,bdata/* ]    +  subdirectories) \\
\verb+                           + \\
\verb+ IN > FFR*                 + (all NDFs whose names begin with FFR)\\
\verb+[IN > ffr* ]               + \\
\verb+                           + \\
\verb+ IN > NGC2261_%            + (all NDFs whose names begin with NGC2261\_,\\
\verb+[IN > NGC2261_? ]          +  followed by one extra character) 
\end{myquote}

\subsection{Indirection}
The names can also be supplied using ordinary text files containing
lists of allowed specifications. Indirection through a text file is
indicated by the character

\begin{description}
\item \hspace{13pt}{\bf$\wedge$}\hspace{3ex}(tophat).
\end{description}

The names may include wildcards (for NDFs) and other indirections (up to
7 deep). A typical response might be:
\begin{myquote}
\begin{verbatim}
IN > ^RFLATFIELDS.LIS
\end{verbatim}
\end{myquote}

the \myverb{RFLATFIELDS.LIS} file would contain something like:
\begin{myquote}
\begin{verbatim}
FFR1
FFR4
FFR10
[.RFLATS]*
\end{verbatim}
\end{myquote}

Indirection can be mixed with other specifications in response to a
prompt (or on the command line) i.e.
\begin{myquote}
\begin{verbatim}
IN > *,^otherframes,[.elsewhere]r*
\end{verbatim}
\end{myquote}
etc.

\subsection{Output names}

All output names may be created from wildcards and/or formed through 
indirection. However, this is not as flexible as the input scheme, 
and wildcards and indirection cannot be mixed. An example of an
output specification is
\begin{myquote}
\begin{verbatim}
OUT > *
\end{verbatim}
\end{myquote}

This means call all the output NDFs the same as the input NDFs and put
them in the same directory (a higher version .SDF file will be created
on VMS, an error will result on UNIX which has no version numbers).
Another possibility would be
\begin{myquote}
\begin{verbatim}
OUT > *_DEBIAS
\end{verbatim}
\end{myquote}

This means call all the output NDFs the same name as the associated
input NDFs, but append the string `\myverb{\_DEBIAS}' to the names. A
third option using wildcard methods is to replace the occurrences of a
particular string within the input names with a new string, e.g.
\begin{myquote}
\begin{verbatim}
OUT > *|DEBIAS|FLATTENED|
\end{verbatim}
\end{myquote}

This will end with the NDF names having the string `\myverb{DEBIAS}' 
replaced with `\myverb{FLATTENED}'. Note that substitution is case
sensitive on UNIX. Indirection files follow the usual rules --- but
if a wildcard is used in the file this must be the only
entry --- and of course explicit names can be always be given for the
output NDFs in response to a prompt or on the command line.

When NDF names are mixed with device names and directories, only the NDF
name itself may be modified. NDF names always exclude the `.SDF' file
type extension. Changing the directory of the output NDFs (which
otherwise will always be the same as the input NDFs) is achieved by
commands like
\begin{myquote}
\begin{verbatim}
IN > DISK$TEMP:[AUSER.RAW]*_CCD
OUT > DISK$USER:[AUSER.PRO]*|_CCD|-PR|

[ IN > /temp/auser/raw/*_ccd
  OUT > /home/auser/pro/*|_ccd|-pr| ]
\end{verbatim}
\end{myquote}

Which in this case will take all the NDFs `\myverb{*\_CCD}' from one
directory and create new NDFs in the second directory (which may be on
another device - VMS) replacing any occurrences of the string
`\myverb{\_CCD}' with `\myverb{-PR}'. {\bf Remember the
`\myverb{*}' in NDF output expressions represents only the names of
the input NDFs} not the directory or any other information, these are
only used if no `preferences' are shown in the output expression. To
keep NDFs from other directories in the current directory use commands
like
\begin{myquote}
\begin{verbatim}
IN > [.ELSEWHERE]*
OUT > []*

[ IN > elsewhere/*
  OUT > ./*         ]
\end{verbatim}
\end{myquote}

In general the same rules apply for non-NDF output names (such as when
position list access routines are not using NDFs to supply the name of
the appropriate file), the only real difference is that when dealing
with file names the {\em complete} name will be used (including the file
type and directory information) and any substitutions must take this
into account.

\subsection{Limitations of NDF access}
At present only one main limitation exists in the way CCDPACK can handle
NDFs.

\begin{itemize}
\item All NDFs must be stored one per container file.
\end{itemize}

This limitation is a direct consequence of the NDF list handling scheme.

\section{Bad data masks (ARD)}
\label{datamasks}
The CCDPACK routine DEBIAS allows regions to be defined as having poor
quality by two basic methods, by use of an NDF whose data component
values are set bad (either explicitly or by use of the quality component
and the badbits flag --- see SUN/33) or by interpreting bad-region
commands within an ordinary text file (an ASCII region definition file
--- ARD file)

A data-masking NDF can be produced within KAPPA (SUN/95) by use of the
routine ZAPLIN, or by the applications CURSOR and SEGMENT in
cooperation.

The capabilities of the ARD option (which uses considerably less disk
space than the NDF mask option and hence could form part of a `database'
of data masking information) are described below.

The shapes of regions which can be defined are specified by the
following KEYWORDS:
\begin{itemize}
\item PIXEL
\item LINE
\item ROW
\item COLUMN
\item BOX
\item POLYGON
\item CIRCLE
\item ELLIPSE
\end{itemize}

Regions are specified using the keywords suffixed by the following information.
\begin{quote}
\begin{description}
\item [PIXEL] - a list of the pixel indices ($X$ and $Y$) of the required
                pixels.
\item [LINE] - the coordinates (pixel coordinates or pixel indices) of the
               two end points of the line, all pixels through which the
               line passes will be used.
\item [ROW] - a list of row numbers (pixel indices).
\item [COLUMN] - a list of column numbers (pixel indices).
\item [BOX] - the coordinates of the centre of the box (pixel indices or
              pixel coordinates) followed by the lengths of the two sides
              in pixels (may be a fraction).
\item [POLYGON] - a list of coordinates (pixel indices or pixel coordinates) of 
                 the polygon vertices.
\item [CIRCLE] - the coordinates of the centre (pixel indices or pixel
                 coordinates) followed by the radius in pixels
                 (may be a fraction).
\item [ELLIPSE] - the coordinates of the centre (pixel indices or pixel 
                  coordinates) followed by the lengths of the semi-major and 
                  semi-minor axes in pixels (may be a fraction) and the position
                  angle of the semi-major axis (measured $+$X through $-$Y in 
                  degrees).
\end{description}
\end{quote}

Only one KEYWORD is allowed per line. Any amount of white space (blanks)
are allowed between keywords and numerics. Tabs are not allowed. Pixel
indices and pixel coordinates are differentiated by integer and floating
values (if any pixel coordinates are integer they should followed by a
period to indicate they are indeed pixel coordinates and not pixel
indices).

Comments are indicated by the characters `!' or `\#' and may be in-line
or whole line at any place within the file. The presence of a comment
terminates the current line immediately.

Any line within the file may be continued on to another by terminating
with the continuation character `\myverb{-}'.

Thus an ARD file might contain the following information:
\begin{myquote}
\begin{verbatim}
!
! ARD description file for bad regions of my CCD.
!
COLUMN   41 177  212         # Three bad columns
!
PIXEL    201 143  -
         153 167             # Two Bad pixels
!
BOX      188 313 5 5         # One Hot spot
!
ELLIPSE  99  120 21.2 5.4 45.0
!
! Polygons defining badly vignetted corners
!
POLYGON  2.2 96.4  12.1 81.5  26.9 63.7  47.7 41.9 -
        61.5 24.1  84.3  0.0   0.0  0.0
!
POLYGON  6.2 294.3 27.9 321.0 52.6 348.7 74.4 371.5 -
        80.0 384.0  0.0 384.0
!
!end
\end{verbatim}
\end{myquote}

There is no application for producing ARD files at present, you will
have to create your own by editing the output from IDICURS or the
KAPPA routine CURSOR.

The coordinates used by ARD are either pixel indices or pixel
coordinates (differentiated as described above). Both these coordinate
systems are  preserved between the output and input NDFs. This is
because the output NDF coordinate origins are modified hence the 
question ``which coordinates are ARD descriptions in --- the output or
input NDFs?'' is not relevant, they are the same.

\section{UNIX differences}

In the main there is little actual difference between the VMS and UNIX versions
of CCDPACK. The most noticeable exceptions are.

\begin{description}
   \item [Input wildcards] Any filename expansions as used by the ls 
         command ( \myverb{?} for single characters, \myverb{*} for 
         any number, \myverb{[a-z]} etc.) are allowed. NDF list 
         access is detailed in \S\ref{ndflists}.

   \item [Background processes] Are supported by using the routine
       `ccdfork'. This performs essentially the same functions as
       CCDBATCH, looking after the boring bits, all you do is write
       the appropriate CCDPACK commands into a file (as you would as if
       using the C shell directly), run CCDSETUP
       interactively then give the routine to ccdfork which produces a
       script which can be forked (nicely into the background) and
       forgotten (see \S\ref{sec:batch} and \ref{des:ccdfork}).
       An important point worth re-iterating is that the commands
       in the file will be interpreted by the C-shell, so special characters 
       should be suitably escaped or protected.

   \item [Log file] The ICL log file system is not yet available on UNIX
       so an ad-hoc formatted system has been implemented. Log files
       should now be listed using cat, lpr etc.
\end{description}

\section{Future developments}

CCDPACK now has a considerable fraction of the functionality which the
package is expected to encompass.

Hopefully the next stage of development of CCDPACK will be a release of
routines to use `header' information to drive the basic reduction
applications (MAKEBIAS, DEBIAS, MAKECAL, CALCOR, MAKEFLAT and FLATCOR).
Header driven means that the CCDPACK applications should be able to get
nearly all their inputs from information stored with the data, not by
prompting you. Note, however, that this does not mean the disappearance
of any of the applications released in this version, it is not the
intention to remove control from you, if you prefer to work in the
present manner. The header driven routines will eventually derive most
of their information from the FITS descriptions, provided with the data.
This ideal state is still some way off, as it depends on the
observatories supplying the necessary information, with CCD data. So
information will continue to be provided, in say instrument-dependent
definition files. It is hoped that the provision of such facilities will
remove a considerable fraction of the burden imposed by CCD data
preparation, freeing astronomers to concentrate on analysis.

\section{Acknowledgements}

Thanks to those who contributed their ideas and views about the 
development of CCDPACK. David Berry is thanked for supplying
the NDF list access software. Rodney Warren-Smith developed the
excellent MAKEMOS application. TRANNDF uses the internals of the KAPPA
application TRANSFORMER written by Malcolm Currie.

\newpage
\appendix
\section{Description of the CCDPACK routines}
\label{app:description}

In this Appendix a more exhaustive catalogue of the capabilities and parameters
of the CCDPACK routines are given. Do {\em not} read it if the previous
descriptions have met your present needs. Read it only if they don't. Remember
that help is available at any time by returning a `?' in response to a prompt,
or by entering the on-line help system after starting CCDPACK.

\subsection{General considerations}

Throughout the following descriptions various methodologies exist which are
worthy of discussion as topics. They cover such aspects of data processing as
the control of, saturation values, data types and data combination.

\subsubsection{Data saturation}

The CCDPACK routine DEBIAS allows you to flag data values above a given
limit as saturated. It performs this task using one of two methods,
either setting the pixels BAD (often referred to as invalidating or
setting to a magic value), in which case the future processing is
transparent if applications which can accommodate BAD values are used,
or alternatively by setting all such pixels to a defined value (this
option may be necessary if the destination analysis programs cannot
handle BAD values). In this latter case care is required because future
operations to the data can easily modify the values, so that
unintentional differentiation of the saturated data may occur. This will
only happen in such situations as flatfielding where the pixels are
modified singly, global operations such as subtraction, multiplication
etc.\ by a constant will preserve the saturated value dataset, although
modifying the actual saturation value. 

If you perform saturation using a specified value within CCDPACK then a
CCDPACK extension is created and the saturation value is written to it.
Future work within CCDPACK will then stop modification of these
saturated values (the routines CALCOR and FLATCOR perform this task for
instance). In general if you can safely use BAD values this is by far
the better option. If you are determined to saturate using a specific
value then is it recommended that calibration (dark, flash and flat)
frames are are processed using BAD values as the combination processes
do not support the preservation of saturated values. If the resultant
master calibration frames contain BAD values then replacement (by the
value 1 or by the mean) of these can be performed in KAPPA (SUN/95:
SETMAGIC).

\subsubsection{NDF data types and sizes}

The CCD data frames given to CCDPACK can be of any non-complex HDS
(SUN/92) numeric type (e.g. they could be of type \myverb{\_WORD} or 
\myverb{\_UWORD} - Fortran \myverb{INTEGER*2}, \myverb{\_REAL},
\myverb{\_INTEGER} or even  \myverb{\_DOUBLE}). CCDPACK usually processes
the data using this type. On occasion, however, frames, such as the
master flatfield, will not be returned in their original type. This is
because normalising to a mean of one precludes data storage of a
precision less than \myverb{\_REAL}. However, the flatfield correction routine
FLATCOR will return the data in your input type regardless of the
flatfield type so types are preserved in the longer term.

If your input frames are of a mixed data type CCDPACK will preserve the data
type of each individual frame. However, if you are combining mixed data types
into a calibration master of some kind, CCDPACK will choose the least precise
type which represents best all the input data types.

In the routines MAKEBIAS, MAKECAL and MAKEFLAT input NDFs which have
different physical sizes (because they have been previously sectioned,
for some reason) will be padded to a common size before processing. This
is so that no calibration data is lost. 

The corrective routines (CALCOR, DEBIAS and FLATCOR) trim the data down
to the size which contains the smallest dataset. The trimming processes
occur separately for each input NDF. The most efficient method of
processing is to keep the input data files of the same type and size, as
this avoids costly trimming, padding, and mapping/unmapping of the data
(CCDPACK always attempts to minimize the amount of re-mapping of
calibration frames when processing lists of NDFs).

The MAKEMOS application is specially designed to deal with datasets
which may have very small regions in common and which produce large 
output mosaics.

\subsubsection{Image combination techniques}
\label{combinations}

CCDPACK supports many different methods of data combination.

The main headings for the methods are:

\begin{itemize}
\item MEAN
\item MEDIAN
\item TRIMMED MEAN
\item MODE
\item SIGMA CLIPPED MEAN
\item THRESHOLD CLIPPED MEAN
\item MINIMUM AND MAXIMUM EXCLUSION MEAN
\item BROADENED MEDIAN
\end{itemize}

The aim is to provide you with a fairly exhaustive list of ways in which
you can combine your data. The methods include the most efficient 
(mean) and the most robust (median) estimators and a range of options 
in between these ideals. A description of the basis of the methods 
follows.

\begin{quote}
\begin{description}
\item[MEAN] a weighted mean.
\item[MEDIAN] a weighted median. The weighted average of the values nearest to
the half weight value. A more even handed estimator than the ordinary median
which takes no account of the errors in the individual measurements. 
\item[TRIMMED MEAN] Alpha trimmed mean. The final estimate is the mean of the
values excluding the alpha (a fraction between 0 and 0.5) upper and lower
values.
\item[MODE] a maximum likelyhood mean. This is essentially an iteratively sigma
(the standard deviation) clipped mean, where values outside of a given number of
sigmas of the mean value are rejected on each pass until convergence is
achieved.
\item[SIGMA CLIPPED MEAN]  the mean of the values left after rejecting those
outside of a given number of standard deviation of the initial mean.
\item[THRESHOLD CLIPPED MEAN] the mean of the values after rejecting
values above and below defined thresholds. Note this usually applies to
the output data range if some internal normalisation is preformed
(MAKEBIAS and
MAKEFLAT).
\item[MINIMUM AND MAXIMUM EXCLUSION MEAN] the mean after the \\ minimum and
maximum values are rejected. 
\item[BROADENED MEDIAN] the median if the number of input data values is
less than five. The mean of the central few values if the number of inputs is
larger.
\end{description}
\end{quote}

All of these methods support variance propagation, provided that the input data
has an approximately normal distribution.

In general if the input data comprise less than 5 datasets and spurious values
are expected to be present, it is very difficult to perform better than the
median, and this is the normal default.

\newpage
\subsection{Classified list of CCDPACK routines.}
%
% set up a mini table of contents for this section pointing into next section.
%
\quickdes{CALCOR}{Performs dark or flash count corrections.}{des:calcor}

\quickdes{CCDALIGN}{Determines general inter-NDF transformations.}
         {des:ccdalign}

\quickdes{CCDBATCH}
         {Prepares a VMS CCDPACK command file for submission to batch.}
         {des:ccdbatch}

\quickdes{CCDCLEAR}{Clears global parameters.}
         {des:ccdclear}

\quickdes{CCDEDIT}{Edits the CCDPACK extensions of NDFs.}
         {des:ccdedit}

\quickdes{ccdfork}{Prepares a UNIX CCDPACK command file for forking into a
                   background process.}{des:ccdfork}

\quickdes{CCDNDFAC}{Accesses a list of NDFs, writing their names to a file.}
         {des:ccdndfac}

\quickdes{CCDNOTE}{Adds a note to the log file.}{des:ccdnote}

\quickdes{CCDSETUP}{Sets up the CCDPACK global parameters.}{des:ccdsetup}

\quickdes{CCDSHOW}{Displays the current values of any CCDPACK global 
                   parameters.}{des:ccdshow}

\quickdes{DEBIAS}{Debiasses lists of NDFs either by bias NDF
                 subtraction or by interpolation --
                 applies bad data masks --
                 extracts a subset of the data area --
                 produces variances --
                 applies saturation values.}
                 {des:debias}

\quickdes{FINDCENT}{Centroids NDF image features.}
                   {des:findcent}

\quickdes{FINDOBJ}{Locates and centroids NDF image features.}
                  {des:findobj}

\quickdes{FINDOFF}{Performs pattern-matching between position lists 
                   related by simple offsets.}
                   {des:findoff}

\quickdes{FLATCOR}{Performs the flatfield correction on a list of NDFs.}
                  {des:flatcor}

\quickdes{IDICURS}{Reads co-ordinates from a graphics device (allows 
                   zooming and panning).}{des:idicurs}

\quickdes{LISTLOG}{Lists the contents of an ICL logfile.}{des:listlog}

\quickdes{MAKEBIAS}{Produces a bias calibration NDF.}{des:makebias}
\newpage

\quickdes{MAKECAL}{Produces calibration NDFs for flash or dark counts.}
                  {des:makecal}

\quickdes{MAKEFLAT}{Produces a flatfield NDF.}
                   {des:makeflat}

\quickdes{MAKEMOS}{Makes NDF mosaics by combining and (optionally) normalising.}
                  {des:makemos}

\quickdes{PAIRNDF}{Displays and manipulates NDF pairs to allow easy 
                   registration (offsets only).}
                  {des:pairndf}

\quickdes{PLOTLIST}{Draws position markers on a graphics display.}
                   {des:plotlist}

\quickdes{REGISTER}{Determines transformations between lists of positions.}
                   {des:register}

\quickdes{TRANLIST}{Transforms lists of positions.}
                   {des:tranlist}

\quickdes{TRANNDF}{Transforms (resamples) NDFs.}
                  {des:tranndf}

\subsection{Complete routine descriptions}
\label{descriptions}

The CCDPACK routine descriptions are contained in the following pages.

%+
%  Name:
%     LAYOUT.TEX

%  Purpose:
%     Define Latex commands for laying out documentation produced by PROLAT.

%  Language:
%     Latex

%  Type of Module:
%     Data file for use by the PROLAT application.

%  Description:
%     This file defines Latex commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by Latex. The
%     contents of this file should be included in the source presented to
%     Latex in front of any output from PROLAT. By default, this is done
%     automatically by PROLAT.

%  Notes:
%     The definitions in this file should be included explicitly in any file
%     which requires them. The \include directive should not be used, as it
%     may not then be possible to process the resulting document with Latex
%     at a later date if changes to this definitions file become necessary.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     10-DEC-1991 (RFWS):
%        Refer to font files in lower case for UNIX compatibility.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}

%  Define a \tt font of the required size.
\font\ssttt=cmtt10 scaled 1095

%  Set a useful width for example sections.
\newlength{\sstparboxlength}
\setlength{\sstparboxlength}{145mm}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} 
\\[1.3ex]\parbox{\sstparboxlength}{\raggedright \ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{\item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[3]{ \sloppy
\item[\ssttt #1] {\ssttt #2} \mbox{} \\ #3}

%\newcommand{\sstexamplesubsection}[3]{ \raggedright
%\item[\ssttt #1] {\ssttt #2} \mbox{} \\ #3}

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  End of LAYOUT.TEX layout definitions.
%.

\newpage
\label{des:calcor}
\sstroutine{
   CALCOR
}{
   Subtracts a scaled dark or flash calibration NDF from a series of
   NDFs
}{
   \sstdescription{
      CALCOR subtracts dark or flash calibration data from a series of
      bias-corrected NDFs. The calibration data are multiplied by a
      constant before subtraction, so that calibration data which have
      been normalised to counts per unit of time per pixel, can be
      scaled to the {\tt "}exposure{\tt "} times suitable for correcting the input
      data. If the calibration frame data levels are already correct
      to perform the necessary correction then the data should be
      scaled by a factor of one. In addition to subtracting the
      calibration data CALCOR also processes saturated values
      protecting them from modification. This protection is necessary
      if the saturated pixels are not to become differentiated.
   }
   \sstusage{
      CALCOR IN OUT CAL EXPOSE [PRESERVE] [TITLE]
   }
   \sstparameters{
      \sstsubsection{
         CAL = LITERAL (Read)
      }{
         Name of the NDF containing the calibration data, this would
         normally be the output from MAKECAL. The data should be
         normalised to one exposure unit. It is expected that the
         calibration NDF contains dark or flash exposure CCD data
         which have been bias corrected.

         The name of this file may be specified using indirection
         through a file.
         [Global calibration NDF]
      }
      \sstsubsection{
         EXPOSE = LITERAL (Read)
      }{
         A list of (comma separated) values specifying the numbers by
         which the calibration data need to be multiplied before
         subtraction from the input data. These are the {\tt "}exposure{\tt "}
         factors for the dark counts expected in the input data or the
         flash exposure times. If the calibration data have been
         normalised to reflect the number of counts per second of time,
         then this is the number of seconds of flash exposure or the
         number of seconds duration between readouts, if it is a dark
         counts NDF.  If the calibration NDF has been produced so
         that the correct levels are already present, then these values
         should be returned as one. A quick method of specifying that
         all the NDFs have the same {\tt "}exposure{\tt "} factors is to return a
         single value, this will then be used for all input NDFs.

         The given values must be in the same order as the
         input NDFs. Indirection through an ASCII file may be used.  If
         more than one line is required to enter the information then a
         continuation line may be requested by adding {\tt "}-{\tt "} to the end of
         the last value.
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         Names of the NDFs to be processed. The calibration data
         will be scaled and subtracted from these.
         The specification of the names of the NDFs follows the usual
         CCDPACK methods, namely:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines; {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "} etc.
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is {\tt "}$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection files using the
         character {\tt "}\#{\tt "}.

         NOTE the use of wildcards with this program is NOT recommended
         unless the input NDFs all have the same calibration exposure
         factors. The processing order of any wildcarded NDFs cannot
         be guaranteed.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         OUT = LITERAL (Read)
      }{
         Names of the output NDFs. These may be specified as list of
         comma separated names, using indirection if required, OR,
         as a single modification element (of the input names).
         The simplest modification element is the asterisk {\tt "}$*${\tt "} which
         means call each of the output NDFs the same name as the
         corresponding input NDFs. So,
         \begin{description}
            \item IN $>$ $*$
            \item OUT $>$ $*$
         \end{description}
         signifies that all the NDFs in the current directory should be
         used and the output NDFs should have the same names. On VMS
         systems this will result in the creation of a higher version
         number of the input NDFs. Other types of modification can also
         occur, such as,
         \begin{description}
            \item OUT $>$ TMP\_$*$
         \end{description}
         which means call the output NDFs the same as the input NDFs but
         put TMP\_ in front of the names. Replacement of a specified
         string with another in the output file names can also be used,
         \begin{description}
            \item OUT $>$ TMP\_$*$$|$DEBIAS$|$FLATTENED$|$
         \end{description}
         this replaces the string DEBIAS with FLATTENED in any of the
         output names TMP\_$*$.

         NOTE the use of wildcards with this program is not recommended
         unless the input NDFs all have the same calibration exposure
         factors. The order of processing of any wildcarded NDFs cannot
         be guaranteed.
      }
      \sstsubsection{
         PRESERVE = \_LOGICAL (Read)
      }{
         If the input data type is to be preserved and used for
         processing then this parameter should be set TRUE.
         If this parameter is set FALSE then the input data will be
         processed and returned in a suitable floating point
         representation. This option is useful if the output data will
         have a significant number of BAD values due to numeric errors
         (over or under flow), or if unacceptable loss of precision
         will occur if the data are processed in their initial data type
         (due to rounding errors).

         Note if a global value for this parameter has been set, using
         CCDSETUP, then this will be used.
         [TRUE]
      }
      \sstsubsection{
         SATURATION = \_DOUBLE (Read)
      }{
         The data saturation value, if it has been applied. See SETSAT.
         [1.0D6]
      }
      \sstsubsection{
         SETSAT = \_LOGICAL (Read)
      }{
         If the input data have had a saturation value applied then
         this parameter should be given as TRUE. If the input data
         have been processed within CCDPACK then the saturation value
         will have been stored within the CCDPACK extension, if this
         is so then this value will be used. Note that data with
         different saturation properties (i.e. values) which have not
         been set within CCDPACK will require separate processing
         (i.e. in groups with the same properties -- see notes).
         [FALSE]
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output NDFs.
         [Output from CALCOR].
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALCOR}{ FRAME1 FRAME2 CALIBRATION 250
      }{
This example runs CALCOR in its most basic mode. The input data in NDF
{\ssttt FRAME1} has the data in NDF {\ssttt CALIBRATION} subtracted,
after multiplying by {\ssttt 250}. The resultant data is written to NDF
{\ssttt FRAME2}. Note that if saturation values have been  applied to
the data in {\ssttt FRAME1} within CCDPACK, then this will be handled
automatically. The output data will be of the same type as the input
data.
      }
      \sstexamplesubsection{
         CALCOR}{ IN=$\wedge$FRAMES.DAT OUT=$*$\_DARKSUB CAL=DARK\_MASTER
             EXPOSE=$\wedge$DARK\_EXPOSURES
      }{
In this example a list of NDFs are sequentially processed. The list of
NDF names is stored in the file {\ssttt FRAMES.DAT}. The output NDFs are
named after the corresponding input NDF with the characters 
{\ssttt \_DARKSUB} appended. The dark times for each input frame are
read from the file {\ssttt DARK\_EXPOSURES}. This is the recommended
method for processing lists of input NDFs.
      }
      \sstexamplesubsection{
         CALCOR}{ L1551\_F11 L1551\_F11\_DS DARK\_MASTER 1.0 PRESERVE=FALSE
             LOGTO=BOTH LOGFILE=L1551\_DARKCOR.LOG
             TITLE=DARK\_CORRECTED\_DATA
      }{
This example follows a similar theme to the first example, except that
the output data type is now {\ssttt \_REAL} or {\ssttt \_DOUBLE},
depending on the precision required to process the data. The calibration
correction data are assumed to have the right exposure factor. The
output NDF is given the title {\ssttt "DARK\_CORRECTED\_DATA"}  and the
parameters used by CALCOR are stored in the logfile
{\ssttt L1551\_DARKCOR.LOG}.
      }
      \sstexamplesubsection{
         CALCOR}{ IN=NGC4151R\_F1 CAL=FLASH\_MASTER OUT=NGC4151R\_F1\_DC
             EXPOSE=310.0 SETSAT SATURATION=32767
      }{
In this example a saturation value external to CCDPACK has been applied
to the input NDF. This is indicated by setting {\ssttt SETSAT}
{\ssttt TRUE} and by supplying the saturation value. Values which are
greater than or equal to the saturation value are left unmodified by the
calibration frame subtraction. This may leave the saturated values {\tt
"}displaced{\tt "} from the local  values, causing a discontinuity in
the local isophotes, but is the only method by which the saturated
pixels may still be readily identified after the subtraction of the
calibration frame.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If any of the input data have had their saturation values set
           by applications not within CCDPACK, then this routine will
           require the saturation value which has been used if the values
           are to be propagated properly. If more than one saturation
           value has been used then the input frames will need to be
           processed singly. This is because CALCOR only uses one
           saturation value per input group. If the saturation values
           have been set within CCDPACK (by DEBIAS) these will be
           processed correctly and may be different.
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      Most parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.
      The exception to this rule is:
      \sstitemlist{

         \sstitem
            TITLE   -- always {\tt "}Output from CALCOR{\tt "}

      }
      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      on new datasets/different devices, or after a break of sometime.
      The intrinsic default behaviour of the application may be
      restored by using the RESET keyword on the command line.

      Certain parameters (LOGTO, LOGFILE, PRESERVE and CAL) have
      global values. These global values will always take precedence,
      except when an assignment is made on the command line.  In general
      global values may be set and reset using the CCDSETUP and
      CCDCLEAR commands, however, the CAL parameter may only be set by
      a run of the application MAKECAL.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Supports processing of all non-complex numeric types.
           BAD pixels are processed as are all NDF components.
      }
   }
}


\newpage
\label{des:ccdalign}
\sstroutine{
   CCDALIGN
}{
   Interactive procedure to aid the alignment of NDFs
}{
   \sstdescription{
      This procedure aids the registration of NDFs which cannot be
      registered using simple offsetting techniques (see FINDOFF and
      PAIRNDF). It also has the capability of dealing with groups of
      NDFs which are almost registered (frames which have not been
      moved on the sky) saving effort in re-identification of image
      features.

      The basic method used is to access groups of NDFs (or a series of
      single NDFs if all are moved sufficiently between exposures) and
      an optional reference NDF. The first NDF of the first group or
      the reference NDF is then displayed and a cursor application is
      used to record the positions of centroidable image features. The
      first NDFs of all the other groups are then displayed and you
      are invited to identify the image features in the order which
      corresponds to that used for the reference NDF. Missing image
      features are identified as off the currently displayed image (so
      the centroid routine will fail to find them). The reference set
      of image features may be extended by identification after the last
      reference feature has been marked.

      After centroiding you are then given the option to stop. If
      you decide to then you will have labelled position lists to use
      in the other CCDPACK routines (the labelled positions will be
      called NDF\_NAME.acc). If you chose the option to continue then
      a full registration of the NDFs will be attempted. This may only
      be performed for {\tt "}linear{\tt "} transformations.

      After choosing a transformation type the procedure will then go on
      to calculate a transformation set between all the NDFs, this is
      then used (with the extended reference set from REGISTER) to
      approximate the position of all possible image features, these are
      then located by centroiding and a final registration of all NDFs
      is performed. The resultant NDFs then have associated lists of
      labelled positions and TRANSFORM structures which may be used to
      transform other position lists or when resampling the data.
   }
   \sstparameters{
      \sstsubsection{
         NONE
      }{
      \mbox{}
      }
   }
}

\newpage
\label{des:ccdbatch}
\sstroutine{
   CCDBATCH
}{
   Prepares a CCDPACK command file for submission to batch
}{
   \sstdescription{
      This routine saves the current ADAM execution environment
      by taking a copy of the SDF files in the ADAM\_USER directory. It
      stores them in a directory which it creates as a subdirectory of
      SYS\$SCRATCH, or writes them to a subdirectory of SYS\$SCRATCH
      given as the parameter P2. It then writes a (DCL) command
      procedure CCDPACKB which contains commands for restoring the
      saved environment, executing the supplied command file
      (which can be written as if using DCL or ICL) and removing the 
      saved environment. CCDPACKB is suitable for direct submission 
      to batch.
   }
   \sstusage{
      CCDBATCH command\_procedure [subdirectory]
   }
   \sstparameters{
      \sstsubsection{
         P1 = STRING (Read)
      }{
         The name of the CCDPACK command file which is to be executed
         in batch. If no type is specified then .COM takes precedence
         over .ICL.
      }
      \sstsubsection{
         P2 = STRING (Read)
      }{
         The name of the subdirectory of SYS\$SCRATCH in which to place
         the copy of the current environment. If this value is not
         supplied then CCDSAVE generates a unique value and uses this.
         The created directory is assigned to the logical name
         NEW\_ADAM\_USER.
      }
      \sstsubsection{
         OUTPUT = CCDPACKB.COM (File - Write)
      }{
         Output command procedure which contains the commands necessary
         to execute the command procedure (P1) in batch.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CCDBATCH}{ CCDPACK\_BATCH
      }{
         In this example CCDBATCH saves the current ADAM parameter
         environment and writes commands which will enable the
         command file {\ssttt CCDPACK\_BATCH} to execute CCDPACK 
         commands in batch.
         The type (DCL or ICL) of the procedure file
         {\ssttt CCDPACK\_BATCH} is
         determined before submission so that suitable initialisation
         commands are written.
      }
      \sstexamplesubsection{
         CCDBATCH}{ CCDPACK\_BATCH.ICL  ADAM\_BATCH
      }{
         In this example the current ADAM context is written to the
         sub-directory {\ssttt ADAM\_BATCH} 
         of SYS\$SCRATCH. A command procedure
         {\ssttt CCDPACKB.COM} is produced suitable to execute the 
         ICL procedure
         {\ssttt CCDPACK\_BATCH.ICL}.
      }
   }
   \sstdiytopic{
      Notes
   }{
      \sstitemlist{

         \sstitem
         VMS specific.
      }
   }
}

\newpage
\label{des:ccdclear}
\sstroutine{
   CCDCLEAR
}{
   Clears CCDPACK global parameters
}{
   \sstdescription{
      CCDCLEAR removes CCDPACK specific parameters from the globals
      file. It has the capability of removing all the
      CCDPACK global parameters or just a named subset.
   }
   \sstusage{
      CCDCLEAR BYNAME
   }
   \sstparameters{
      \sstsubsection{
         BYNAME = \_LOGICAL (Read)
      }{
         This parameter controls how the parameters are cleared.
         If FALSE then all CCDPACK global parameters will be cleared.
         If TRUE then a list of the names of the global parameters to
         clear is requested (see parameter NAMES).
         [FALSE]
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         NAMES = LITERAL (Read)
      }{
         Only used when BYNAME is TRUE. The response to this parameter
         should be a comma separated list of the names of the CCDPACK
         parameters which are to be cleared. Valid names are:

         \sstitemlist{

            \sstitem
               ADC, BIAS, BOUNDS, CAL, DEFERRED, DIRECTION, EXTENT, FLAT, 
               GENVAR, MASK, NDFNAMES, PRESERVE, RNOISE

         }
         These correspond to the parameter names used in CCDSETUP (and
         in the other applications which access these parameters).

         The names may be abbreviated to unique values.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CCDCLEAR}{ ~~~~~~
      }{
         Invoking CCDCLEAR without any arguments will clear all the
         CCDPACK globals, unless the {\ssttt BYNAME=TRUE} option has 
         been used in a previous invocation.
      }
      \sstexamplesubsection{
         CCDCLEAR}{ FALSE
      }{
         Using this invocation will definitely clear all the CCDPACK
         global parameters.
      }
      \sstexamplesubsection{
         CCDCLEAR}{ BYNAME NAMES="ADC,RNOISE,DIREC"
      }{
         This example shows how to clear specific CCDPACK global
         parameters. The {\ssttt NAMES} need only be unique amongst 
         the
         possibilities so could have been abbreviated to 
         {\ssttt "A,R,DI"}.
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      All parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.

      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application. The intrinsic
      default behaviour of the application may be restored by using the
      RESET keyword on the command line.

      Certain parameters (LOGTO and LOGFILE ) have global values. These
      global values will always take precedence, except when an
      assignment is made on the command line.  Global values may be set
      using the CCDSETUP command.
   }
}

\newpage
\label{des:ccdedit}
\sstroutine{
   CCDEDIT
}{
   Edits CCDPACK NDF extensions
}{
   \sstdescription{
      This routine provides the ability to edit the contents the
      CCDPACK extensions of a list of NDFs. The following modes
      of operation are available:
      \sstitemlist{

         \sstitem
           associate position list(s)

         \sstitem
           erase extension items

         \sstitem
           add a transform structure

         \sstitem
           invert a transform structure.

      }
      The associate list facility allows the names of position lists to
      be added to NDF extensions, these lists are then accessed when the
      NDF names are given in response to an INLIST prompt (provided the
      application NDFNAMES parameter is TRUE). This option also allows a
      single position list to be associated with a range of NDFs.

      Erase extension items is a safe way of deleting primitives and
      structures from an NDF CCDPACK extension and removes the need to
      remember the exact object name and path.

      Add transform allows arbitrary transform structures to be added.
      The transform may be generated from linear transform
      coefficients, copied from a existing transform structure or may
      be specified as an expression. Forward and inverse transformations
      are required.

      Invert transform inverts the sense of the transformation.
   }
   \sstusage{
      CCDEDIT MODE IN
   }
   \sstparameters{
      \sstsubsection{
         CLASS( ) = LITERAL (Read)
      }{
         If CLASSIFY is TRUE then a list of classifications that
         describe the properties of the transformation (parameters
         XFOR, YFOR, XINV and YINV) should be given. This is
         optional, but the information can be used to make other
         applications run more efficiently.  Valid values are:
         \sstitemlist{

            \sstitem
               LINEAR        -- Linear and preserves straight lines.

            \sstitem
               INDEPENDENT   -- Preserves the independence of the axes.

            \sstitem
               DIAGONAL      -- Preserves the axes themselves.

            \sstitem
               ISOTROPIC     -- Preserves angles and shapes.

            \sstitem
               POSITIVE\_DET  -- A component of reflection is absent.

            \sstitem
               NEGATIVE\_DET  -- A component of reflection is present.

            \sstitem
               CONSTANT\_DET  -- The scale factor is constant.

            \sstitem
               UNIT\_DET      -- Areas (or volumes etc.) are preserved.

         }
         See SUN/61 Appendix B for more details of transformation
         classification and a table of the classifications of common
         mappings.
      }
      \sstsubsection{
         CLASSIFY = \_LOGICAL (Read)
      }{
         If TRTYPE={\tt "}EXPRES{\tt "} is chosen then this parameter decides
         whether or not a classification of the transformation
         using parameters XFOR, YFOR, XINV and YINV will be given.
         Classification is optional, but you should note that the
         information can be used to make other applications run more
         efficiently, and the lack of a classification may stop certain
         types of operation. See SUN/61 appendix B for details. Linear
         transformations are classified by this routine using the
         FITTYPE parameter.
         [FALSE]
      }
      \sstsubsection{
         FA-FZ = LITERAL (Read)
      }{
         These parameters supply the values of {\tt "}sub-expressions{\tt "} used in
         the expressions XFOR, YFOR, XINV and YINV. These parameters
         should be used when repeated expressions are present in complex
         transformations. Sub-expressions may contain references to
         other sub-expressions and constants (PA-PZ).
         An example of using sub-expressions is:
         \begin{description}
            \item XFOR $>$ {\tt '}XX=PA$*$ASIND(FA/PA)$*$X/FA{\tt '}
            \item YFOR $>$ {\tt '}YY=PA$*$ASIND(FA/PA)$*$Y/FA{\tt '}
            \item XINV $>$ {\tt '}X=PA$*$SIND(FB/PA)$*$XX/FB{\tt '}
            \item YINV $>$ {\tt '}Y=PA$*$SIND(FB/PA)$*$YY/FB{\tt '}
            \item FA $>$ SQRT(X$*$X$+$Y$*$Y)
            \item PA $>$ 100D0
            \item FB $>$ SQRT(XX$*$XX$+$YY$*$YY)
        \end{description}
      }
      \sstsubsection{
         FITTYPE = \_INTEGER (Read)
      }{
         The type of fit specified by coefficients supplied via the
         TR parameter. Appropriate values are.
         \sstitemlist{

            \sstitem
               1 -- shift of origin

            \sstitem
               2 -- shift of origin and rotation

            \sstitem
               3 -- shift of origin and magnification

            \sstitem
               4 -- shift of origin, rotation and magnification
                      (solid body)

            \sstitem
               5 -- a full six parameter fit

         }
         The value of this parameter is used to classify the
         transformation (see the CLASS parameter).
         [5]
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         A list specifying the names of the NDFs whose CCDPACK
         extensions are to be modified. The specification of the NDF
         names follows the usual CCDPACK methods, namely:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines; {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "} etc.
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is {\tt "}$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection files using the
         character {\tt "}\#{\tt "}.
      }
      \sstsubsection{
         INLIST = LITERAL (Read)
      }{
         A list specifying one or more position list names (only used
         if MODE = "ALIST"). If a single name is given then this 
         position list will be associated with all the input NDFs. If 
         a list of names is given then there should be as many names 
         as input NDFs. The order of the input NDF names is shown so 
         that the correct correspondence may be achieved.

         Position list names may NOT include wildcards. So a comma
         separated list of explicit names should be used and/or the
         names should be read from indirection files (the indirection
         indicator is {\tt "}$\wedge${\tt "}).
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The mode of operation. Can be one of
         \sstitemlist{

            \sstitem
               ALIST

            \sstitem
               ERASE

            \sstitem
               TRANSFORM

            \sstitem
               INVERT

         }
         The {\tt "}ALIST{\tt "} option {\tt "}associates{\tt "} a position list(s) with NDFs
         (this sets the {\tt "}CURRENT\_LIST{\tt "} item).  This is useful when
         importing position lists generated externally to CCDPACK.

         The {\tt "}ERASE{\tt "} option removes a named item from NDF
         extensions. Two possible items are {\tt "}CURRENT\_LIST{\tt "} and
         {\tt "}TRANSFORM{\tt "}.

         The {\tt "}TRANSFORM{\tt "} option allows the generation or import of
         transforms into NDF extensions. Transforms from other NDFs
         may be copied. Linear transforms may be generated from the (6)
         coefficients. General transforms may be specified by
         algebraic-like expressions containing the functions allowed by
         the TRANSFORM package (SUN/61). If you intend to do this, see
         the related parameters (XFOR, YFOR, XINV, YINV, FA-FZ, PA-PZ,
         CLASSIFY and CLASS) and the examples section.

         The {\tt "}INVERT{\tt "} option inverts the sense of
         transformations in the NDFs.
         [ALIST]
      }
      \sstsubsection{
         NAME = LITERAL (Read)
      }{
         If MODE = {\tt "}ERASE{\tt "} is chosen then the value of this parameter
         names the CCDPACK extension item of the input NDFs which is to
         be erased. Typical items are {\tt "}CURRENT\_LIST{\tt "} and {\tt "}TRANSFORM{\tt "}.
      }
      \sstsubsection{
         PA-PZ = \_DOUBLE (Read)
      }{
         These parameters supply the values of constants used in the
         expressions XFOR, YFOR, XINV and YINV. Using parameters allows
         the substitution of repeated constants (with extended
         precisions?) using one reference. It also allows easy
         modification of parameterised expressions (expressions say
         with an adjustable centre) provided the application has not
         been used in the interim. The parameter PI has a default
         value of 3.14159265359D0. An example of using parameters is:
         \begin{description}
            \item XFOR $>$ {\tt '}XX=SQRT(FX$*$FX$+$FY$*$FY){\tt '}
            \item YFOR $>$ {\tt '}YY=ATAN2D(-FY,FX){\tt '}
            \item XINV $>$ {\tt '}X=XX$*$SIND(YY)$+$PA{\tt '}
            \item YINV $>$ {\tt '}Y=-YY$*$COSD(XX)$+$PB{\tt '}
            \item FX $>$ X-PA
            \item FY $>$ Y-PB
            \item PA $>$ X-centre-value
            \item PB $>$ Y-centre-value
         \end{description}
         This maps (X,Y) to (R,THETA) about a specified centre.
      }
      \sstsubsection{
         TRTYPE = LITERAL (Read)
      }{
         If MODE = {\tt "}TRANSFORM{\tt "} is selected then this parameter specifies
         the type of transform which will be supplied. Valid returns are
         \sstitemlist{

            \sstitem
               COEFF

            \sstitem
               EXPRES

            \sstitem
               STRUCT

         }
         If {\tt "}COEFF{\tt "} is chosen then the transform will be generated from
         the 6 coefficients of the equations.
         \begin{description}
            \item X{\tt '} = PA $+$ PB$*$X $+$ PC$*$Y
            \item Y{\tt '} = PD $+$ PE$*$X $+$ PF$*$Y
         \end{description}
         supplied in the order PA,PB,PC,PD,PE,PF.

         If {\tt "}STRUCT{\tt "} is chosen then an existing 
         transformation structure
         will be copied into the extensions of the NDFs. Note that
         no checking of the transform{\tt '}s validity will be made.

         If {\tt "}EXPRES{\tt "} is chosen then the transformation will be specified
         using algebraic-like statements of the type.
         \begin{description}
            \item XFOR $>$ {\tt '}XX=PA$+$PC$*$X{\tt '}
            \item YFOR $>$ {\tt '}YY=PD$+$PE$*$Y{\tt '}
            \item XINV $>$ {\tt '}X=(XX-PA)/PC{\tt '}
            \item YINV $>$ {\tt '}Y=(YY-PD)/PE{\tt '}
         \end{description}

         The values of PA-PZ are accessed through the PA-PZ parameters.
         The PA-PZ{\tt '}s are reserved for constants (FA-FZ are also
         reserved for repeated expressions). This example allows
         independent offsets and scales in X and Y. The inverse
         transformation must be supplied.
         [COEFF]
      }
      \sstsubsection{
         TR( 6 ) = \_DOUBLE (Read)
      }{
         If TRTYPE={\tt "}COEFF{\tt "} is chosen then the values of this parameter
         are the 6 coefficients of a linear transformation of the
         type.
         \begin{description}
               \item X{\tt '} = PA $+$ PB$*$X $+$ PC$*$Y
               \item Y{\tt '} = PD $+$ PE$*$X $+$ PF$*$Y
         \end{description}
         The default is the identity transformation.
         [0,1,0,0,0,1] [PA,PB,PC,PD,PE,PF]
      }
      \sstsubsection{
         TRANSFORM = TRN (Read)
      }{
         If TRTYPE={\tt "}STRUCT{\tt "} is chosen then this parameter is used to
         access the HDS object which contains a transform structure
         to copy into the input NDFs. The standard place to store a
         transform structure (in CCDPACK) is
         \sstitemlist{

            \sstitem
                NDF\_NAME.MORE.CCDPACK.TRANSFORM
         }
      }
      \sstsubsection{
         XFOR = LITERAL (Read)
      }{
         If TRTYPE={\tt "}EXPRES{\tt "} is chosen then this parameter{\tt '}s value is
         the transformation that maps to the new X coordinate. The
         expression can contain constants, arithmetic operators
         ($+$,-,/,$*$,$*$$*$) and the functions described in SUN/61
         (SIN,COS,TAN, etc.).

         Constants may be specified using the special tokens PA-PZ.
         Prompts for the values for these tokens will then be made (this
         provides a mechanism for parameterising functions allowing
         trivial value changes). Sub-expressions which occur in many
         places may also be specified using the special tokens FA-FZ.
         These are prompted for and placed into the main expression.
         Sub-expressions may contain references to constants and other
         sub-expressions. An example expression is:
         \begin{description}
            \item XFOR $>$ {\tt '}XX=PA$*$ASIND(FA/PA)$*$X/FA{\tt '}
         \end{description}
         Note the single quotes. They are necessary to protect the
         equals sign.
      }
      \sstsubsection{
         XINV = LITERAL (Read)
      }{
         If TRTYPE={\tt "}EXPRES{\tt "} is chosen then this parameter{\tt '}s value is
         the transformation that maps to the old X coordinate - the
         inverse transformation of XFOR. The expression can contain
         constants, arithmetic operators ($+$,-,/,$*$,$*$$*$) and the
         functions described in SUN/61 (SIN,COS,TAN, etc.).

         Constants may be specified using the special tokens PA-PZ
         prompts for values for these tokens will then be made (this
         provides a mechanism for parameterising functions allowing
         trivial values changes). Sub-expressions which occur in many
         places may also be specified using the special tokens FA-FZ.
         These are prompted for and placed into the main expression.
         Sub-expressions may contain references to constants and other
         sub-expressions. An example expression is:
         \begin{description}
            \item XINV $>$ {\tt '}X=PA$*$SIND(FB/PA)$*$XX/FB{\tt '}
         \end{description}
         Note the single quotes. They are necessary to protect the
         equals sign.
      }
      \sstsubsection{
         YFOR = LITERAL (Read)
      }{
         If TRTYPE={\tt "}EXPRES{\tt "} is chosen then this parameter{\tt '}s value is
         the transformation that maps to the new Y coordinate. The
         expression can contain constants, arithmetic operators
         ($+$,-,/,$*$,$*$$*$) and the functions described in SUN/61
         (SIN,COS,TAN, etc.).

         Constants may be specified using the special tokens PA-PZ.
         Prompts for the values of these tokens will then be made (this
         provides a mechanism for parameterising functions allowing
         trivial value changes). Sub-expressions which occur in many
         places may also be specified using the special tokens FA-FZ.
         These are prompted for and placed into the main expression.
         Sub-expressions may contain references to constants and other
         sub-expressions. An example expression is:
         \begin{description}
            \item YFOR $>$ {\tt '}YY=PA$*$ASIND(FA/PA)$*$Y/FA{\tt '}
         \end{description}
         Note the single quotes. They are necessary to protect the
         equals sign.
      }
      \sstsubsection{
         YINV = LITERAL (Read)
      }{
         If TRTYPE={\tt "}EXPRES{\tt "} is chosen then this parameter{\tt '}s value is
         the transformation that maps to the old Y coordinate - the
         inverse transformation of YFOR. The expression can contain
         constants, arithmetic operators ($+$,-,/,$*$,$*$$*$) and the
         functions described in SUN/61 (SIN,COS,TAN, etc.).

         Constants may be specified using the special tokens PA-PZ.
         Prompts for the values of these tokens will then be made (this
         provides a mechanism for parameterising functions allowing
         trivial value changes). Sub-expressions which occur in many
         places may also be specified using the special tokens FA-FZ.
         These are prompted for and placed into the main expression.
         Sub-expressions may contain references to constants and other
         sub-expressions. An example expression is:
         \begin{description}
            \item YINV $>$ {\tt '}Y=PA$*$SIND(FB/PA)$*$YY/FB{\tt '}
         \end{description}
         Note the single quotes. They are necessary to protect the
         equals sign.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CCDEDIT }{MODE=ALIST IN=$*$ INLIST=REFERENCE\_SET
      }{
         This example shows how to {\tt "}associate{\tt "} a single position list
         called {\ssttt REFERENCE\_SET} with all the NDFs in the current
         directory.
      }
      \sstexamplesubsection{
         CCDEDIT}{ MODE=ALIST IN={\tt "}NDF1,NDF2,NDF3{\tt "}
              INLIST={\tt "}POS1.DAT,POS2.DAT,POS3.DAT{\tt "}
      }{
         In this example the NDF {\ssttt NDF1} is associated with 
         {\ssttt POS1.DAT}, the
         NDF {\ssttt NDF2} with {\ssttt POS2.DAT} and the NDF {\ssttt NDF3}
         with {\ssttt POS3.DAT}.
      }
      \sstexamplesubsection{
         CCDEDIT }{MODE=ERASE IN=NDF\_WITH\_BAD\_TRANSFORM NAME=TRANSFORM
      }{
         In this example the TRANSFORM structure in the CCDPACK
         extension of the NDF {\ssttt NDF\_WITH\_BAD\_TRANSFORM} 
         is removed.
      }
      \sstexamplesubsection{
         CCDEDIT}{ MODE=INVERT IN=$*$
      }{
         In this example all the NDFs in the current directory have
         their transforms inverted.
      }
      \sstexamplesubsection{
         CCDEDIT}{ MODE=TRANSFORM TRTYPE=COEFF IN=SHIFT\_THIS\_NDF
              TR=[10.25,1,0,-101.1,0,1] FITTYPE=1
      }{
         In this example the NDF {\ssttt SHIFT\_THIS\_NDF} 
         has a transform
         structure written into its CCDPACK extension which specifies a
         shift of {\ssttt 10.25} in {\ssttt X} and a negative shift of
         {\ssttt 101.1} in {\ssttt Y}.
         The shift is specified using the appropriate linear
         transformation coefficients {\ssttt [XSHIFT,1,0,YSHIFT,0,1]}
         and is
         correctly classified as a {\ssttt FITTYPE} of {\ssttt 1}.
      }
      \sstexamplesubsection{
         CCDEDIT}{ MODE=TRANSFORM TRTYPE=COEFF IN=ROTATE\_THIS\_NDF
              TR=[0,0.965926,-0.258819,0,0.258819,0.965926] FITTYPE=2
      }{
         In this example the NDF {\ssttt ROTATE\_THIS\_NDF} has a 
         transform
         structure written into its CCDPACK extension which specifies a
         rotation by {\ssttt 15} degrees about the {\ssttt [0,0]} 
         position. The rotation
         is specified using the appropriate linear transformation
         coefficients {\ssttt [0,COS,-SIN,0,SIN,COS]}.
      }
      \sstexamplesubsection{
         CCDEDIT}{ MODE=TRANSFORM TRTYPE=STRUCT IN=NEED\_TRANSFORM
              TRANSFORM=TRN.MORE.CCDPACK.TRANSFORM
      }{
         In this example the transformation structure
         {\ssttt TRN.\-MORE.\-CCDPACK.\-TRANSFORM} 
         is copied to the NDF {\ssttt NEED\_TRANSFORM}.
      }
      \sstexamplesubsection{
         CCDEDIT}{MODE=TRANSFORM TRTYPE=EXPRES IN=MAP2GLS
              XFOR={\tt "}XX=X$*$COSD(Y){\tt "} YFOR={\tt "}YY=Y{\tt "} XINV={\tt "}X=XX/COSD(YY){\tt "}
              YINV={\tt "}Y=YY{\tt "}
      }{
         In this example the transform structure to be added to NDF
         {\ssttt MAP2GLS} is defined as an algebraic expression. The 
         mapping used
         is a Sanson-Flamstead sinusoidal with {\ssttt X} and 
         {\ssttt Y} in degrees.
      }
      \sstexamplesubsection{
         CCDEDIT}{ MODE=TRANSFORM TRTYPE=EXPRESS IN=MAP2MERC
              XFOR={\tt "}X=XX{\tt "}
              YFOR={\tt "}Y=180/PI$*$LOG(TAND((90D0$+$MIN(PA,MAX(-PA,YY))/2D0))){\tt "}
              XINV={\tt "}XX=X{\tt "}
              YINV=2D0$*$(ATAND(EXP(Y$*$PI/180D0)))-90D0{\tt "}
              PA=89.9999D0 ACCEPT
      }{
         In this example a Mercator-like transform structure is added to
         the NDF {\ssttt MAP2MERC}. The arguments to {\ssttt TAND} 
         are limited to the
         range {\ssttt +/- 89.9999D} to stop blow-up. The parameter 
         {\ssttt PI} is
         defaulted to {\ssttt 3.14159265359D0}.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         NDF extension items.
            All NDF extension items dealt with by this routine are in the
            structure .MORE.CCDPACK.

         \sstitem
         When using the MODE=ALIST option the item CURRENT\_LIST in the
           CCDPACK extension of the input NDFs is set to the name of the
           input list(s). Such NDF items may be used by other CCDPACK
           position list processing routines to automatically access
           these lists.

         \sstitem
         When using the MODE=ERASE option the name of the item to be
           erase is the name of the structure or primitive after the
           NDF\_NAME.MORE.CCDPACK has been removed.

         \sstitem
         Transforms are stored in the item .MORE.CCDPACK.TRANSFORM .
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      All parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.

      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      after a break of sometime.  The intrinsic default behaviour of
      the application may be restored by using the RESET keyword on the
      command line.

      Certain parameters (LOGTO and LOGFILE) have global values. These
      global values will always take precedence, except when an
      assignment is made on the command line.  Global values may be set
      and reset using the CCDSETUP and CCDCLEAR commands.
   }
}

\newpage
\label{des:ccdfork}
\sstroutine{
   ccdfork
}{
   Produces a script file suitable for executing 
   a CCDPACK command file in the background
}{
   \sstdescription{
      This command saves the current ADAM execution environment
      and writes a script file which will execute a
      CCDPACK command file written for running in C shell.
      The output script is suitable for execution as a (nice{\tt '}d)
      background process, restoring the current environment
      (thus isolating it from the interactive or any other
      background processes) and re-initialising CCDPACK.
   }
   \sstusage{
      ccdfork user\_script [output\_script] [directory]
   }
   \sstparameters{
      \sstsubsection{
         \$1 = filename (read)
      }{
         The name of the script file which contains the
         CCDPACK commands which are to be run in
         the background.
      }
      \sstsubsection{
         \$2 = filename (write)
      }{
         The name of the output script which will re-establish
         the current ADAM context and execute your command
         file. [ccdpack\_fork]
      }
      \sstsubsection{
         \$3 = directory (write)
      }{
         The name of a directory in which to store the current
         ADAM context. If no value is given then a sub-directory
         of the current ADAM\_USER parent is created. \newline
         [adam\_unique\_string]
      }
   }
   \sstexamples{
      \sstexamplesubsection{ccdfork}{
      ccdred ;
      nice ccdpack\_fork \&
      }{
         In this example ccdfork saves the current ADAM parameter
         files and writes a script file named {\ssttt ccdpack\_fork}
         which
         will enable the ccdred script file to execute in the
         background. The output script {\ssttt ccdpack\_fork} 
         is then nice'd 
         into the background.
      }
      \sstexamplesubsection{ccdfork}{
        ccdred batch1 ;
         nice batch1 \&
      }{
         As above except that the output script is now called
         {\ssttt batch1}.
      }
      \sstexamplesubsection{
         ccdfork}{ccdred batch2 /scratch/user/batch2
      }{
         As above except the output script is now called {\ssttt batch2}
         and the ADAM parameter files are written to the directory
         {\ssttt /scratch/user/batch2}.
      }
   }
   \sstdiytopic{
      Note
   }{
      \sstitemlist{

         \sstitem
         C shell specific.
      }
   }
}

\newpage
\label{des:ccdndfac}
\sstroutine{
   CCDNDFAC
}{
   Accesses a list of NDFs and writes their names to a file
}{
   \sstdescription{
      This routine accesses a list of NDFs and writes their names to a
      text file. It is intended to be used as an aid to producing
      procedures which require the facilities of NDF list access used
      in CCDPACK. For this reason the usual application introductory
      message is suppressed. The names of the NDFs may be written
      out to the terminal as an aid to memory. If no NDFs are accessed
      then the output file will not be created, testing for the 
      existence of this file is a platform independent way of 
      determining if the invocation has been successful.
   }
   \sstusage{
      CCDNDFAC NAMELIST ECHO
   }
   \sstparameters{
      \sstsubsection{
         ECHO = \_LOGICAL (Read)
      }{
         If TRUE then the names of the NDFs will be written to the
         terminal unless there is only one input NDF.
         [TRUE]
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         A list of NDF names. The specification of the NDF names
         follows the usual CCDPACK methods, namely:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines; 
         {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "} etc.\
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is {\tt "}$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection files using the
         character {\tt "}\#{\tt "}.
         [!]
      }
      \sstsubsection{
         MAXNDF = \_INTEGER (Read)
      }{
         The maximum number of NDFs which should be accessed. If a null
         return {\tt "}!{\tt "} is given for this parameter then the normal CCDPACK
         limit will be applied.
         [!]
      }
      \sstsubsection{
         NAMELIST = LITERAL (Read)
      }{
         The name of the output file to contain the names of the
         accessed NDFs.
         [CCDNDFAC.LIS]
      }
   }
   \sstexamples{
      \sstexamplesubsection{CCDNDFAC}{
         NDF\_NAME\_LIST TRUE
      }{
         In this example the list of NDF names is written to
         {\ssttt NDF\_NAME\_LIST} and the NDF names are echoed to the 
         terminal.
         No constraint is placed on the number of NDFs accessed 
         (other than the normal CCDPACK limit).
      }
      \sstexamplesubsection{CCDNDFAC}{ 
         NDF\_NAME TRUE MAXNDF=1
      }{
         In this example only a single NDF name is accessed. The name is
         not echoed to the terminal (even though echo is set TRUE).
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      All parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.

      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application. The intrinsic
      default behaviour of the application may be restored by using the
      RESET keyword on the command line (you may well want to do this
      when using the application from a procedure).

      Certain parameters (LOGTO and LOGFILE) have global values. These
      global values will always take precedence, except when an
      assignment is made on the command line. Global values may be set
      and reset using the CCDSETUP and CCDCLEAR commands.
   }
}

\newpage
\label{des:ccdnote}
\sstroutine{
   CCDNOTE
}{
   Adds a note to the current CCDPACK log file
}{
   \sstdescription{
      This routine allows you to add a note to the CCDPACK log
      file. Notes are intended to cover such things as the object name,
      the person responsible for the data processing, etc. Notes can
      span more than one line if earlier lines are terminated by the
      continuation character {\tt "-"}.
   }
   \sstusage{
      CCDNOTE NOTE
   }
   \sstparameters{
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter, then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS system the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP,
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP,
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         NOTE = LITERAL (Read)
      }{
         The comment to enter into the CCDPACK logfile. This may be
         continued on to other lines by using the continuation
         character {\tt "-"}. Input can be terminated either by not ending a
         line with a continuation character, or by use of the ! null
         character at the beginning of the line.
      }
   }
   \sstexamples{
      \sstexamplesubsection{CCDNOTE}{
         {\tt "} Start of the NGC2261 CCD reduction{\tt "} 
      }{
         In this example a record of the object is entered
         into the current log file.
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      The NOTE parameter has no default and retains no information
      about any previous values.
   }
}

\newpage
\label{des:ccdsetup}
\sstroutine{
   CCDSETUP
}{
   Sets the CCDPACK global parameters
}{
   \sstdescription{
      CCDSETUP sets the values of a sequence of global parameters to be
      used within CCDPACK. The values of these parameters, when set,
      will override those of any others, except values entered on the
      command line. This routine should be used before starting a
      CCDPACK reduction sequence. The parameters are primarily
      concerned with values to do with the CCD device characteristics,
      items such as:
      \sstitemlist{

         \sstitem
           The ADC factor which converts the ADUs of the input data
             frames into detected electrons, for which Poissonian
             statistics are valid

         \sstitem
           The bias strip placements

         \sstitem
           The readout direction

         \sstitem
           The typical readout noise

         \sstitem
           The useful CCD area

         \sstitem
           The definition of the BAD areas of the chip

      }
      The routine also initialises the CCDPACK logging system.

      All parameters may be returned as ! (the parameter-system null
      value) this indicates that the current value is to be left
      unchanged if one exists (this will be shown as the default and
      can also be accepted by pressing return) or that a value is not
      to be assigned for this global parameter. If a value is not
      assigned it will be defaulted or prompted as appropriate when
      other CCDPACK applications are run.

      The removal of global parameters is performed by the CCDCLEAR
      application.
   }
   \sstusage{
      CCDSETUP LOGTO=? LOGFILE=? ADC=? BOUNDS=? RNOISE=? MASK=?
      DIRECTION=? DEFERRED=? EXTENT=? PRESERVE=? GENVAR=? NDFNAMES=?
   }
   \sstparameters{
      \sstsubsection{
         ADC = \_DOUBLE (Read and Write)
      }{
         The Analogue-to-Digital units Conversion factor (ADC). CCD
         readout values are usually given in Analogue-to-Digital Units
         (ADUs). The ADC factor is the value which converts ADUs back
         to the number of electrons which were present in each pixel in
         the CCD after the integration had finished. This value is
         required to allow proper estimates of the inherent noise
         associated with each readout value. CCDPACK makes these
         estimates and stores them in the variance component of the
         final NDFs. Not supplying a value for this parameter may be a
         valid response if variances are not to be generated by DEBIAS.
         [!]
      }
      \sstsubsection{
         BOUNDS( 2 or 4 ) = \_INTEGER (Read and Write)
      }{
         The bounds of the bias strips of the CCD. These should be in
         pixel indices (see notes) and be given in pairs up to a limit
         of 2. The sense of the bounds is along the readout direction.
         For example, 2,16,400,416 means that the bias strips are
         located between pixels 2 to 16 and 400 to 416 inclusive along
         the readout direction. The bias strips are used to either
         offset the bias frame or as an estimate of the bias which is to
         be interpolated across the frame in some way (see DEBIAS). Not
         supplying values for this parameter may be a valid response if
         the bias frame is to be directly subtracted from the data
         without offsetting.
         [!]
      }
      \sstsubsection{
         DEFERRED = \_DOUBLE (Read and Write)
      }{
         The deferred charge value. Often known as the {\tt "}fat{\tt "} or {\tt "}skinny{\tt "}
         zero (just for confusion). This is actually the charge which is
         not transferred from a CCD pixel when the device is read out.
         Usually this is zero or negligible and is only included for
         completeness and for processing very old data.
         [!]
      }
      \sstsubsection{
         DIRECTION = LITERAL (Read and Write)
      }{
         The readout direction of the CCD. This may take the values X
         or Y.  A value of X indicates that the readout direction is
         along the first (horizontal) direction, an Y indicates that
         the readout direction is along the direction perpendicular to
         the X axis. If this value is not supplied then it will be
         defaulted to X by DEBIAS.
         [!]
      }
      \sstsubsection{
         EXTENT( 4 ) = \_INTEGER (Read and Write)
      }{
         The extent of the useful CCD area in pixel indices (see notes).
         The extent is defined as a range in X values and a range in Y
         values (XMIN,XMAX,YMIN,YMAX). These define a section of an NDF
         (SUN/33). Any parts of the CCD outside of this area will not
         be present in the final output. This is useful for excluding
         bias strips, badly vignetted parts etc.
         [!]
      }
      \sstsubsection{
         GENVAR = \_LOGICAL (Read and Write)
      }{
         The value of this parameter controls whether or not variance
         estimates will be generated within CCDPACK. A value of TRUE
         indicates that the routines MAKEBIAS and DEBIAS should generate
         variances. A value of FALSE inhibits variance generation.
         Normally variances should be generated, even though disk and
         process-time savings can be made by their omission.
         [TRUE]
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read and Write)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read and Write)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all
            [BOTH]
         }
      }
      \sstsubsection{
         MASK = LITERAL (Read and Write)
      }{
         Either:
         The name of an NDF which is to be used to mask out known BAD
         lines, hot spots etc. of the supplied data. The NDF should
         have the areas which are to be flagged set BAD or have a
         suitable quality value set (see DEBIAS). This can be achieved
         by displaying a typical NDF using KAPPA, getting logs of the
         positions of an outline enclosing the BAD area and using the
         KAPPA application SEGMENT, or alternatively by using the
         ZAPLIN facility.

         Or:
         The name of a ordinary text file specifying the BAD regions of
         the CCD. Regions which may be specified are; PIXEL, LINE, ROW,
         COLUMN, BOX, POLYGON, CIRCLE and ELLIPSE. There is no
         application at present for interactively defining these
         regions, you are expected to create your own text files
         containing these descriptions. A more complete description of
         the method of defining regions in text files is given in the
         DEBIAS subtopic ASCII region definition files.

         To avoid using a MASKing file return an !.
         [!]
      }
      \sstsubsection{
         NDFNAMES = \_LOGICAL (Read and Write)
      }{
         The value of this parameter controls whether or not position
         list processing applications are expected to find the names of
         lists via association with NDFs or not.

         When position lists (which are just text files of positions
         with either an index, an X and a Y value, or or just X and Y
         values) are used the option exists to associate them with a
         particular NDF. This is achieved by entering the name of the
         position list file into an NDF{\tt '}s CCDPACK extension under the
         item {\tt "}CURRENT\_LIST{\tt "}. Associating position lists 
         with NDFs has
         the advantage of allowing wildcards to be used for the input
         names and makes sure that positions are always used in the
         correct context (this is particularly useful when determining
         inter-NDF transformations).
         [TRUE]
      }
      \sstsubsection{
         PRESERVE = \_LOGICAL (Read and Write)
      }{
         The value of this parameter controls whether or not processed
         NDF data arrays retain their input data types. If it is set
         TRUE then CCDPACK applications will return and process any
         data in the input type. If it is set FALSE then the
         applications will output an NDF whose type is determined by
         which data type was considered necessary to allow processing
         of the input data. This will usually mean an output type of
         \_REAL (all types not \_INTEGER or \_DOUBLE) or \_DOUBLE (when
         input types are \_INTEGER or \_DOUBLE). This option should be
         used when a unacceptable loss of accuracy may occur, or when
         the data range can no longer be represented in the range of
         the present data type. The latter effect may occur when
         expanding input ADU values into electrons in DEBIAS, if the
         ADC factor is large and the input data has a type of \_WORD.
         [TRUE]
      }
      \sstsubsection{
         RNOISE = \_DOUBLE (Read and Write)
      }{
         The nominal readout noise (in ADUs) for the current CCD.
         Estimates of the readout noise are made by the routines
         MAKEFLAT and DEBIAS. These can be used to estimate the
         validity of this value. Not supplying a value for this
         parameter may be a valid response if variances are not to be
         generated by MAKEBIAS and/or DEBIAS.
         [!]
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Pixel indices. The bounds supplied to DEBIAS should be given as
           pixel indices. These usually start at 1,1 for the pixel at the
           lower left-hand corner of the data array component (this may
           be not true if the NDFs have been sectioned, in which case the
           lower left hand pixel will have pixel indices equal to the data
           component origin values). Pixel indices are different from
           pixel coordinates in that they are non-continuous, i.e. can
           only have integer values, and start at 1,1 not 0,0. To change
           pixel coordinates to pixel indices add 0.5 and round to the
           nearest integer.
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      All parameters values are obtained by prompting. The suggested
      values (defaults) are either the current global values, if they
      exist, or the application current values (from the last time that
      the application was run). If the application has not been run
      then the {\tt "}intrinsic{\tt "} defaults are shown. The intrinsic defaults
      may be obtained at any time (in the absence of global values) by
      using the RESET keyword on the command line.
   }
}

\newpage
\label{des:ccdshow}
\sstroutine{
   CCDSHOW
}{
   Displays the value of the CCDPACK global parameters
}{
   \sstdescription{
      This routine shows the current value of any CCDPACK global
      parameters.
   }
   \sstusage{
      CCDSHOW
   }
   \sstparameters{
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter, then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS system the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP,
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP,
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      The parameters (LOGTO and LOGFILE ) have global values. These
      global values will always take precedence, except when an
      assignment is made on the command line.  Global values may be set
      using the CCDSETUP command.
   }
}

\newpage
\label{des:debias}
\sstroutine{
   DEBIAS
}{
   Performs the debiassing and initial preparation of CCD
   data
}{
   \sstdescription{
      This routine debiases CCD frames, masks defects, sets variances,
      corrects for CCD gain and deferred charge, sets saturated values
      and extracts the useful portion of the CCD data.

      The debiassing section operates in two basic modes -- with and
      without a bias frame. If a bias frame is supplied then it is
      subtracted from the data arrays of the input NDFs. The subtraction
      can either be direct, or by offsetting the values of the bias by
      the mean value in the bias-strip region(s). When determining
      the mean in the bias strips a function of the distance from the
      edges is used, this reduces the effect of any contamination. If
      you are offsetting to the bias strip mean then the bias frame
      should be averaged to zero (MAKEBIAS does this).

      The second debiassing method which DEBIAS supports is the
      subtraction of interpolated values. The interpolation is
      performed between the bias strips. If only one strip is given the
      interpolation is really an extrapolation and is limited to
      constant values either for each line or for the frame as a whole.
      Interpolation between bias strips can be as for a single strip or
      may be a straight line fit for each line, or a fit of a plane to
      the bias strips (see parameter SMODE). The interpolation uses
      weighting operations as for bias frame subtraction. Bad values
      can also be rejected from the strips by sigma clipping, or the
      noise can be reduced by smoothing the values.

      Additional DEBIAS functionality includes the (optional)
      production of variance estimates for the input CCD data. It does
      this by assuming Poissonian statistics for the bias-subtracted
      data, together with a contribution for the readout noise. The
      masking of bad data areas is achieved using the transfer of
      quality information from an NDF, or by using an ASCII description
      file. The expansion of the data values into counts and the
      extraction of the useful area of the CCD are also performed.
   }
   \sstusage{
      DEBIAS IN OUT BIAS [BOUNDS] RNOISE ADC [MASK]
   }
   \sstparameters{
      \sstsubsection{
         ADC = \_DOUBLE (Read)
      }{
         The Analogue-to-Digital Conversion factor. This number converts
         input ADUs to detected electrons. This value is used to
         estimate the Poissonian noise in the output (debiassed) data
         values. If variances are not being generated then this value
         will not be used.

         If a global value for this parameter has been set using
         CCDSETUP then this will be used.
         [1.0]
      }
      \sstsubsection{
         BADBITS = \_INTEGER (Read)
      }{
         If the first input NDF has no quality component, and you have
         specified the SETBAD = FALSE option, you will be requested to
         supply a value for BADBITS (SUN/33).  The default for this
         is 1. BADBITS is a byte value and hence can only be in the
         range 0-255.
         [1]
      }
      \sstsubsection{
         BIAS = LITERAL (Read)
      }{
         Name of the NDF which contains the bias calibration data. This
         parameter may be specified as ! in which case either a
         constant or values derived from the bias strip(s) are used.
         The name of this file may be specified using indirection
         through an ASCII file. The offered default is either the last
         used master bias name or (if one exists) the name of the NDF
         produced by the last run of MAKEBIAS.
         [Global master bias or !]
      }
      \sstsubsection{
         BOUNDS( 2 or 4 ) = \_INTEGER (Read)
      }{
         The pixel indices (see notes) of the upper and lower bounds of
         the bias strip(s). These bounds can run in either the
         horizontal or vertical directions. The direction is controlled
         by the DIRECTION parameter. The bounds must be supplied in
         pairs. Pixel indices are the actual number of pixels, starting
         at 1,1 at the lower left hand corner of the NDF data array,
         which includes any origin offsets within the input NDFs.

         If global values for these bounds have been set using
         CCDSETUP then those values will be used.
      }
      \sstsubsection{
         BOXSIZE( 2 ) = \_INTEGER (Read)
      }{
         The sizes of the sides of the box to be used when smoothing the
         bias strips. Only used when CMODE={\tt "}BOX{\tt "}.
         [15,15]
      }
      \sstsubsection{
         CMODE = LITERAL (Read)
      }{
         The {\tt "}clean-up{\tt "} mode for the bias strips. This parameter may
         take values of {\tt "}BOX{\tt "}, {\tt "}SIGMA{\tt "} or {\tt "}WEIGHT{\tt "}. If CMODE={\tt "}BOX{\tt "} then
         the bias strips are smoothed with a box filter before being
         processed. If CMODE={\tt "}SIGMA{\tt "} then the bias strips are sigma
         clipped before being processed. If CMODE={\tt "}WEIGHT{\tt "} then only
         the weighting as indicated by the WMODE parameter is used to
         attempt to decrease the effects of erroneous pixel values.
         [BOX]
      }
      \sstsubsection{
         DEFERRED = \_DOUBLE (Read)
      }{
         The deferred charge value. This is also often known as the
         {\tt "}fat{\tt "} or {\tt "}skinny{\tt "} zero. It represents the amount of charge
         left behind in a pixel on a readout transfer. This value is
         subtracted from the data.

         If a global value for this parameter has been set using
         CCDSETUP then this will be used.
         [0.0]
      }
      \sstsubsection{
         DIRECTION = LITERAL (Read)
      }{
         The readout direction of the CCD. This parameter can take
         values of {\tt "}X{\tt "} or {\tt "}Y{\tt "}. X indicates that the readout direction is
         horizontal , Y indicates that the readout direction is
         vertical. The BOUNDS parameter values are assumed to be values
         along the readout direction.

         If a global value for this parameter has been set using
         CCDSETUP then this will be used.
         [X]
      }
      \sstsubsection{
         EXPAND = \_LOGICAL (Read)
      }{
         This value controls whether or not the output data should be
         multiplied by the ADC factor to convert the input ADUs to
         counts (electrons). This option is disabled if no variances
         are generated. Care should be taken when using this option
         with a large ADC factor and data types of \_WORD,\_UWORD,\_BYTE
         or \_UBYTE as the output data range may exceed that allowed
         with these types. In this case the best option is to set
         the PRESERVE parameter FALSE.

         [Default is TRUE if input data is not an unsigned data type
         otherwise FALSE.]
      }
      \sstsubsection{
         EXTENT(4) = \_INTEGER (Read)
      }{
         The extent of the useful CCD area. This should be given in
         pixel index values (see notes). The extent is restricted to
         that of the CCD frame, so no padding of the data can occur. If
         values outside of those permissable are given then they are
         modified to lie within the CCD frame. The values should be
         given in the order XMIN,XMAX,YMIN,YMAX.

         Normally the extent should be set so that the bias strips
         are excluded from the output data, this is essential for
         flatfields whose normalisation could be adversely biased.

         If global values for these bounds have been set using
         CCDSETUP then those values will be used.
      }
      \sstsubsection{
         FMODE = LITERAL (Read)
      }{
         The fit mode which will be used when interpolating bias
       values.  May take values of {\tt "}LINE{\tt "} or {\tt "}PLANE{\tt "}.
       This is used together with the SMODE parameter to define the
       interpolation method, ie. FMODE = {\tt "}LINE{\tt "}, 
       SMODE = {\tt"}LINEAR{\tt "}, fits each row or column of the bias strips 
       by a straight line; FMODE = {\tt "}PLANE{\tt "}, 
       SMODE = {\tt "}CONSTANT{\tt "}
       derives a single constant for the bias value; 
       FMODE = {\tt "}PLANE{\tt"}, SMODE = {\tt "}LINEAR{\tt "} fits a plane 
       to the bias-strip data.
         [LINE]
      }
      \sstsubsection{
         GENVAR = \_LOGICAL (Read)
      }{
         If variances are to be generated then this value is set
         TRUE. If variances are not to be generated then this value
         should be set FALSE. Normally variances should be generated,
         even though disk and process time savings can be made by their
         omission.

         If a global value has been set up using CCDSETUP this value
         will be used.
         [TRUE]
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         A list of the names of the NDF which contain the raw CCD data.
         Note
         that at present the input data must have a common processing
         mode, i.e. use the same bias frame, have the same ADC factor,
         readout noise etc. These values are represented by the
         parameter values of the task.
         The specification of the names of the NDFs follows the usual
         CCDPACK methods, namely:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines; {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "} etc.
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is {\tt "}$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection files using the
         character {\tt "}\#{\tt "}.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP,
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MASK = LITERAL (Read)
      }{
         The name of an NDF or ASCII regions definition (ARD) file.

         If an NDF is given then any regions of BAD values (set through
         explicit BAD values or by BADBITS in the quality component)
         will be transferred to the output NDF.

         If an ARD file is given then regions will be interpreted and
         transferred to the output NDF. ARD is described in its own
         section.

         The regions whose quality is to be set are probably hot spots,
         line defects etc.  which contain little or no useful
         information. This parameters may be returned as ! indicating
         that no mask is to be applied.

         If a global value for this parameter has been set using
         CCDSETUP then this will be used.

         The name of this file may be specified using indirection
         through a file.
         [!]
      }
      \sstsubsection{
         NSIGMA = \_REAL (Read)
      }{
         The number of standard deviations to clip the bias strips at.
         This
         is only used if CMODE={\tt "}SIGMA{\tt "}. The actual clipping occurs at
         NSIGMA$*$RNOISE. If no variances are being generated then the
         RNOISE value is estimated from the data values in the strips.
         [4.0]
      }
      \sstsubsection{
         OUT = LITERAL (Write)
      }{
         Names of the output NDFs. These may be specified as list of
         comma separated names, using indirection if required, OR,
         as a single modification element (of the input names). The
         simplest modification element is the asterisk {\tt "}$*${\tt "} which means
         call each of the output NDFs the same name as the
         corresponding input NDFs. So,
         \begin{description}
            \item IN $>$ $*$
            \item OUT $>$ $*$
         \end{description}
         signifies that all the NDFs in the current directory should be
         used and the output NDFs should have the same names. Using VMS
         this will create a higher version of the input NDFs. Other
         types of modification can also occur, such as,
         \begin{description}
            \item OUT $>$ TMP\_$*$
         \end{description}
         which means call the output NDFs the same as the input NDFs but
         put TMP\_ in front of the names. Replacement of a specified
         string with another in the output file names can also be used,
         \begin{description}
            \item OUT $>$ TMP\_$*$$|$DEBIAS$|$FLATTENED$|$
         \end{description}
         this replaces the string DEBIAS with FLATTENED in any of the
         output names TMP\_$*$.
      }
      \sstsubsection{
         OFFSET = \_LOGICAL (Read)
      }{
         If TRUE then the input bias data array is offset
         by the mean value derived from the bias-strip areas. If FALSE
         then the bias data is directly subtracted. This parameter is
         disabled for unsigned data types as the bias data cannot have
         been previously zeroed.
         [TRUE]
      }
      \sstsubsection{
         PRESERVE = \_LOGICAL (Read)
      }{
         If TRUE then the data type of the input NDFs are used for
         processing and are preserved on exit from this routine. If
         FALSE then a suitable floating point type will be chosen for
         the output type and the processing will be performed using
         this choice.

         This option should be used when a unacceptable loss of
         accuracy may occur, or when the data range can no longer be
         represented in the range of the present data type. The latter
         effect may occur when expanding input ADU values into
         electrons, if the ADC factor is large and the input data have
         types of \_WORD,\_UWORD,\_BYTE or \_UBYTE.

         If a global value for this parameter has been set using
         CCDSETUP then this will be used.
         [TRUE]
      }
      \sstsubsection{
         RNOISE = \_DOUBLE (Read)
      }{
         The readout noise in input data units (ADUs). An estimate of
         the readout noise is shown for unweighted values in the bias
         strips, if the bias strips are used. If variances are not
         generated then this value is not used. If variances are
         generated then the readout noise is included in the variance
         estimates.

         If a global value has been set using CCDSETUP then this will
         be used.
         [Dynamic default or 1.0]
      }
      \sstsubsection{
         SATURATE = \_LOGICAL (Read)
      }{
         This flag controls whether the data are to be processed to
         detect saturated values or not.
         [FALSE]
      }
      \sstsubsection{
         SATURATION = \_DOUBLE (Read)
      }{
         The data saturation value. Only used if SATURATE is TRUE.
         [1.0D6]
      }
      \sstsubsection{
         SETBAD = \_LOGICAL (Read)
      }{
         If TRUE then the quality information will be transferred
         from the MASK NDF to the output NDFs in the form of BAD
         ({\tt "}flagged{\tt "}) values in the data component. This is the usual
         method of indicating the presence of pixels with no value. If
         FALSE then the quality information will be transferred into
         the quality component, all output quality pixels will have
         their BADBITS set. (Note that if the input NDF already has a
         quality component the BADBITS will be set by a logical OR of
         the current bits with the BADBITS value).
         [TRUE]
      }
      \sstsubsection{
         SETSAT = \_LOGICAL (Read)
      }{
         This parameter controls how saturated data will be flagged.
         If it is set TRUE then saturated values will be replaced by
         the value of the parameter SATURATION (which is also the value
         used to detect saturated data). If it is FALSE then saturated
         values will be set to BAD (also known as invalid).
         [FALSE]
      }
      \sstsubsection{
         SMODE = LITERAL (Read)
      }{
         The mode which will be used to perform any interpolation fit
         between the bias strips. Can take values of {\tt "}CONSTANT{\tt "} or
         {\tt "}LINEAR{\tt "}. If only one bias strip is given this may only take
         the value {\tt "}CONSTANT{\tt "}. This is used together with the FMODE
         parameter to define the interpolation method, i.e.
         FMODE={\tt "}LINE{\tt "}, SMODE={\tt "}LINEAR{\tt "}, fits each row or column of the
         bias strips by a straight line; FMODE={\tt "}PLANE{\tt "},
         SMODE={\tt "}CONSTANT{\tt "} derives a single constant for the bias value;
         FMODE={\tt "}PLANE{\tt "}, SMODE={\tt "}LINEAR{\tt "} fits a plane to the bias-strip
         data.
         [CONSTANT]
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output NDF.
         [Output from DEBIAS]
      }
      \sstsubsection{
         USECON = \_LOGICAL (Read)
      }{
         If TRUE then you can supply an estimate for the bias
         contribution (parameter ZERO). This value is then subtracted
         from the input NDF. Only use this option if you do not have
         any bias frames or bias strips and you have good reason to
         believe that the value you are supplying is accurate enough
         for your purposes.
         [FALSE]
      }
      \sstsubsection{
         WMODE = LITERAL (Read)
      }{
         The weighting method which is to be used when deriving means
         or performing the least squares interpolation fits using any
         bias strips. Can take the values {\tt "}LINEAR{\tt "}, {\tt "}EXP{\tt "}, or {\tt "}NONE{\tt "}.
         {\tt "}LINEAR{\tt "} and {\tt "}EXP{\tt "}-onential produce weights which are maximum
         in the centre of each bias strip and which fall off towards
         the edges. {\tt "}LINEAR{\tt "} weighting gives zero weighting for the
         edge lines and so is the more robust.
         [LINEAR]
      }
      \sstsubsection{
         ZERO = \_DOUBLE (Read)
      }{
         If USECON=TRUE then this value is subtracted from the input
         NDF.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DEBIAS}{ R1 R1B BIAS [2,10,400,415] ADC=1.1 RNOISE=8
      }{
         This example debiases the data array in NDF {\ssttt R1} 
         writing the
         result to NDF {\ssttt R1B}. It uses the data component of 
         NDF {\ssttt BIAS} as
         the bias estimator. The bias is offset by the mean value found
         within the ranges {\ssttt 2-10} and {\ssttt 400-415} 
         pixels along the {\ssttt X} axis.
         The data in the bias strips are smoothed by a box filter and
         weighted linearly from the edges inwards. The output variance
         is produced by a combination of the Poisson statistics (using
         an {\ssttt ADC} value of {\ssttt 1.1}) and readout noise 
         (value {\ssttt 8}), together
         with the variance of the bias NDF (if present).
      }
      \sstexamplesubsection{
         DEBIAS}{ IN=R1 OUT=R2 BOUNDS=[2,10,401,416] ADC=2.5 RNOISE=10
      }{
         This example debiases the NDF {\ssttt R1} data component 
         writing the
         result to the NDF {\ssttt R2}. The bias is estimated by an 
         interpolation
         of a constant for each data row. The constant is the result of
         a linearly weighted average of the bias strip data which has
         been box filtered.
      }
      \sstexamplesubsection{
         DEBIAS}{ IN=R1 OUT=R2 BOUNDS=[2,10,401,416] SMODE=LINEAR ADC=5
             FMODE=PLANE DIRECT=Y WMODE=EXP CMODE=SIGMA RNOISE=10
             NSIGMA=4
      }{
         This example debiases the NDF {\ssttt R1} data component 
         writing the
         result to the NDF {\ssttt R2}. The bias is estimated by the 
         fitting of a
         plane to the data in the bias strips. The bias-strip data are
         first sigma clipped at a level {\ssttt RNOISE$*$NSIGMA}. The 
         fit is
         performed with weighting based on a exponential fall off
         from the centre of the strips. The bias strips are defined by
         the bounds applied up the {\ssttt Y} axis.
      }
      \sstexamplesubsection{
         DEBIAS}{ IN=$*$ OUT=$*$\_DEBIAS BOUNDS=[3,16,912,940] ADC=1 RNOISE=4
             BIAS=[.BIAS]MASTER\_BIAS
      }{
         In this example all the NDFs in the current directory are
         debiassed. The names of the output NDFs are as those of the
         corresponding input NDFs, except that they are trailed by the
         {\ssttt "\_DEBIAS"} string.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the input NDFs have variance components and no variances
           are to be generated then they are processed.

         \sstitem
         Pixel indices. The bounds supplied to DEBIAS should be given as
           pixel indices. These usually start at 1,1 for the pixel at the
           lower left-hand corner of the data-array component (this may
           not be true if the NDFs have been sectioned, in which case the
           lower left hand pixel will have pixel indices equal to the data
           component origin values). Pixel indices are different from
           pixel coordinates in that they are non-continuous, i.e. can
           only have integer values, and start at 1,1 not 0,0. To change
           from pixel coordinates add 0.5 and round to the nearest integer.
      }
   }
   \sstdiytopic{
      ASCII\_region\_definition files
   }{
      DEBIAS allows regions which are to be defined as having poor
      quality (either by setting the appropriate pixels BAD or by
      setting part of the quality component) to be described within an
      ordinary (ARD) text file. The regions which can be defined are
      limited to the following KEYWORDS:
      \sstitemlist{

         \sstitem
            PIXEL

         \sstitem
            LINE

         \sstitem
            ROW

         \sstitem
            COLUMN

         \sstitem
            BOX

         \sstitem
            POLYGON

         \sstitem
            CIRCLE

         \sstitem
            ELLIPSE

         \sstitem
            NDF

      }
      Regions can be specified using the following conventions:
      \sstitemlist{

         \sstitem
            PIXEL   --- followed by a list of the pixel indices (X and
                          Y) of the required pixels.

         \sstitem
            LINE    --- coordinates (pixel coordinates or pixel indices)
                          of the two end points of the line, all pixels
                          through which the line passes will be used.

         \sstitem
            ROW     --- a list of the row numbers (pixel indices).

         \sstitem
            COLUMN  --- a list of column numbers (pixel indices).

         \sstitem
            BOX     --- coordinates of the centre of the box (pixel
                          indices or pixel coordinates) followed by the
                          lengths of the two sides in pixels (may be a
                          fraction).

         \sstitem
            POLYGON --- list of coordinates (pixel indices or pixel
                          coordinates) of the polygon vertices.

         \sstitem
            CIRCLE  --- coordinates of a centre (pixel indices or pixel
                          coordinates) followed by a radius in pixels
                          (may be a fraction).

         \sstitem
            ELLIPSE --- coordinates of the centre (pixel indices or
                          pixel coordinates) followed by the lengths of
                          the semi-major and semi-minor axes in pixels
                          (may be a fraction) and the position angle of
                          the semi-major axis (measured $+$X through -Y
                          in degrees).

      }
      Only one KEYWORD is allowed per line.

      Any amount of white space (blanks) are allowed between keywords
      and numerics. Tabs are not allowed.

      Comments are indicated by the characters {\tt "}!{\tt "} or {\tt "}\#{\tt "} and may be
      in-line or whole line at any place within the ARD file. The
      presence of a comment terminates the current line immediately.

      Any line within the file may be continued on to another by
      terminating with the continuation character {\tt "}-{\tt "}.
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      Most parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.
      The exception to this rule is:
      \sstitemlist{

         \sstitem
            TITLE   -- always {\tt "}Output from MAKEBIAS{\tt "}

      }
      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      on new datasets/different devices, or after a break of sometime.
      The intrinsic default behaviour of the application may be
      restored by using the RESET keyword on the command line.

      Certain parameters (LOGTO, LOGFILE, RNOISE, GENVAR, 
      ADC, BIAS, BOUNDS, MASK, PRESERVE, DIRECTION, DEFERRED, EXTENT )
      have global values. These global values will always take
      precedence, except when an assignment is made on the command line.
      In general global values may be set and reset using the CCDSETUP
      and CCDCLEAR commands, however, the BIAS parameter may only be set
      by a run of the application MAKEBIAS.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         This task supports all components of an NDF. If requested
           [default] a variance is produced from the bias subtracted
           values. The task processes BAD pixels. The UNITS of the output
           NDF are set to ADUs or electrons depending on whether data
           expansion has occurred or not. Processing is supported for all
           HDS (non-complex) numeric types.
      }
   }
}

\newpage
\label{des:findcent}
\sstroutine{
   FINDCENT
}{
   Centroids image features.
}{
   \sstdescription{
      This routine determines the centroids of image features located
      in the data components of a list of NDFs. It is useful for
      locating accurate values for the positions of stars given hand
      selected positions. It can also be used for centroiding any
      sufficiently peaked image features.

      The initial positions associated with each NDF are given in
      formatted files whose names are determined either using the
      CCDPACK NDF extension item CURRENT\_LIST (which is maintained by
      list processing CCDPACK applications) of from an explicit list of
      names.
   }
   \sstusage{
      FINDCENT IN OUTLIST
   }
   \sstparameters{
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         The names of the NDFs whose data components contain image
         features which are to be centroided. The specification of the
         NDF names follows the usual CCDPACK methods, namely:

         An explicit list of NDF names or indirection specifications
         separated by commas. NDF names may include the usual
         directory listing wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines;
         {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "} etc.\ on 
         UNIX machines.  Indirection may
         occur through ASCII files (these may be nested up to
         7 deep). The indirection character is {\tt "}$\wedge${\tt "}. If an extra prompt
         line is required then the continuation character {\tt "}-{\tt "} should
         be appended to end of the line.
      }
      \sstsubsection{
         INLIST = LITERAL (Read)
      }{
         If NDFNAMES is FALSE then this parameter will be used to
         access the names of the lists which contain the initial
         positions. The format of the data in the files is described in
         the notes section.

         The names of the input lists may use modifications of the
         input NDF names, so for instance if the position lists are
         stored in files with the same name as the input NDFs but with
         a file type of {\tt "}.DAT{\tt "} instead of {\tt "}.SDF{\tt "} then use

         \begin{description}
            \item INLIST $>$ $*$.DAT
         \end{description}

         (.SDF is always removed from NDF names). If the input list
         names are a modification of the NDF names say with a trailing
         type of {\tt "}\_INITIAL.POSITIONS{\tt "}. Then a response of

         \begin{description}
            \item INLIST $>$ $*$\_INITIAL.POSITIONS
         \end{description}

         will access the correct files. Names may also use substitution
         elements, say the NDF names are $*$\_DATA and the position lists
         are $*$\_POS.DAT, then a response like

         \begin{description}
             \item INLIST $>$ $*|$DATA$|$POS.DAT$|$
         \end{description}

         may be used. If a naming scheme has not been used then an
         explicit list of names should be returned (wildcards cannot be
         used to specify list names). These names should be given in
         the same order as the input NDF names and may use indirection
         elements as well as names separated by commas. A listing of
         the input NDF name order (after any wildcard expansions etc.\
         have been made) is shown to make sure that the order is
         correct.
      }
      \sstsubsection{
         ISIZE = \_INTEGER (Read)
      }{
         The size of a box side (in pixels) centered on current
         position which will be used to form the marginal profiles used
         to estimate the centroid.
         [9]
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter, then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS system the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP,
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP,
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MAXITER = \_INTEGER (Read)
      }{
         The maximum number of iterations which may be used in
         estimating the centroid. Only used if the tolerance criterion
         is not met in this number of iterations.
         [3]
      }
      \sstsubsection{
         MAXSHIFT = \_DOUBLE (Read)
      }{
         The maximum shift (in pixels) allowed from an initial position.
         [5.5]
      }
      \sstsubsection{
         NAMELIST = LITERAL (Read)
      }{
         Only used if NDFNAMES is FALSE. If this is the case then this
         specifies the name of a file to contain a listing of the names
         of the output lists. This file may then be used to pass the names
         onto another CCDPACK application using indirection.
         [FINDCENT.LIS]
      }
      \sstsubsection{
         NDFNAMES = \_LOGICAL (Read)
      }{
         If TRUE then the routine will assume that the names of the
         input position lists are stored in the CCDPACK extension item
         {\tt "}CURRENT\_LIST{\tt "} of the input NDFs. The names will
          be present in the extension if
         the positions were located using a CCDPACK application (such
         as IDICURS). Using this facility allows the transparent
         propagation of position lists through processing chains.

         If a global value for this parameter has been set using
         CCDSETUP then that value will be used.
         [TRUE]
      }
      \sstsubsection{
         POSITIVE = \_LOGICAL (Read)
      }{
         If TRUE then the image features have increasing values
         otherwise they are negative.
         [TRUE]
      }
      \sstsubsection{
         OUTLIST = FILENAME (Write)
      }{
         A list of names specifying the centroid result files. The
         names of the lists may use modifications of the input NDF
         names.  So if you want to call the output lists the same name
         as the input NDFs except to add a type use.

         \begin{description}
            \item OUTLIST $>$ $*$.CENT
         \end{description}

         Or alternatively you can use an explicit list of names.
         These may use indirection elements as well as names separated
         by commas.
         [$*$.cent]
      }
      \sstsubsection{
         TOLER = \_DOUBLE (Read)
      }{
         The required tolerance in the positional accuracy of the
         centroid. On each iteration the box of data from which the
         centroid is estimated is updated. If the new centroid does not
         differ from the previous value by more than this amount (in X
         and Y) then iteration stops. Failure to meet this
         level of accuracy does not result in the centroid being
         rejected, the centroiding process just stops after the 
         permitted number of iterations (MAXITER).
         [0.05]
      }
   }
   \sstexamples{
      \sstexamplesubsection{FINDCENT}{ IN=$*$ OUTLIST=$*$.CENT
      }{
         In this example all the NDFs in the current directory are
         processed. It is assumed that the NDFs are associated with
         positions lists of inaccurate positions (via the item
         {\ssttt CURRENT\_LIST} in the NDF CCDPACK extensions). These 
         position
         lists are accessed and centroided with the appropriate NDFs.
         On exit the new lists are named {\ssttt $*$.CENT} and are 
         associated with the NDFs (instead of the original 
         {\tt "}input{\tt "} lists).
      }
      \sstexamplesubsection{FINDCENT}
          { NDFNAMES=FALSE IN={\tt "}NDF1,NDF2,NDF3{\tt "}
               INLIST={\tt "}NDF1.POS,NDF2.POS,NDF3.POS{\tt "} OUTLIST=$*$.ACC
               NAMELIST=NEW\_POSITION\_LISTS
      }{
         In this example the position list names are not previously
         associated with the NDFs and must have their names given
         explicitly (and in the same order as the NDF names). The
         output lists are called the same names as the input NDFs except
         with the extension {\ssttt .ACC}. The names of the output 
         lists are
         written into the file {\ssttt NEW\_POSITION\_LISTS} which can
         be used to
         pass these names onto another application using indirection
         (in which case invoke the next application with 
         {\ssttt NDFNAMES = FALSE}
         {\ssttt INLIST = $\wedge$NEW\_POSITION\_LISTS}).
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem Position list formats. 
      }
        CCDPACK supports data in two formats.

        CCDPACK format - the first three columns are interpreted as the
        following.

      \sstitemlist{

         \sstitem
              Column 1: an integer identifier

         \sstitem
              Column 2: the X position

         \sstitem
              Column 3: the Y position

      }
        The column one value must be an integer and is used to identify
        positions which are the same but which have different locations
        on different images. Values in any other (trailing) columns are
        usually ignored.

        EXTERNAL format - positions are specified using just an X and
        a Y entry and no other entries.

      \sstitemlist{

         \sstitem
              Column 1: the X position

         \sstitem
              Column 2: the Y position

      }
        This format is used by KAPPA applications such as CURSOR.

        Comments may be included in a file using the characters {\tt "}\#{\tt "} and
        {\tt "}!{\tt "}. Columns may be separated by the use of commas or spaces.

         Data following the third column is copied without modification
           into the results files

      \sstitemlist{
         \sstitem NDF extension items. 
      }
       If NDFNAMES is TRUE then the item {\tt "}CURRENT\_LIST{\tt "} 
       of the 
       .MORE.CCDPACK structure of the input NDFs will be located 
       and assumed to contain the names of the lists whose positions 
       are to be centroided. On exit this item will be updated to 
       reference the name of the centroided list of positions.
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      All parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.

      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      on new datasets or after a break of sometime.  The intrinsic
      default behaviour of the application may be restored by using the
      RESET keyword on the command line.

      Certain parameters (LOGTO, LOGFILE and NDFNAMES) have global
      values. These global values will always take precedence, except
      when an assignment is made on the command line.  Global values may
      be set and reset using the CCDSETUP and CCDCLEAR commands.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         This routine correctly processes the DATA and QUALITY components
           of an NDF data structure. Bad pixels and all non-complex numeric
           data types can be handled.
      }
   }
}

\newpage
\label{des:findobj}
\sstroutine{
   FINDOBJ
}{
   Locates and centroids image features
}{
   \sstdescription{
      This routine processes a list of NDFs, locating and centroiding
      image features (such as stars) which have groups of connected
      pixels above threshold values.

      Connected groups of pixels are accepted as objects if they have
      more than a minimum number of pixels. Such groups may be rejected
      if they contact the edges of the data array.

      Threshold estimation is performed using either a percentage data
      point (i.e.\ the value for which this percentage of pixels have a
      lower value) or by using a standard deviation and background
      value determined by fitting a gaussian to the data histogram.
   }
   \sstusage{
      FINDOBJ IN MINPIX OUTLIST
   }
   \sstparameters{
      \sstsubsection{
         AUTOTHRESH = \_LOGICAL (Read)
      }{
         If this parameter is TRUE then a threshold determined by
         this routine for each of the NDFs will be used. If FALSE then
         you will be prompted for a threshold value for each NDF.
         [TRUE]
      }
      \sstsubsection{
         BINFRAC = \_DOUBLE (Read)
      }{
         The minimum fraction of the image area (expressed as a
         percentage) which is required in the peak bin when forming the
         histogram.  Ensuring that at least one bin contains this
         fraction of counts is intended to make sure that the image
         histogram is well sampled. This increases the robustness of
         mode estimates made from the histogram but decreases the
         accuracy.
         [2.5]
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         A list of NDF names which contain the data components to be
         scanned for image features. The specification of the names of
         the NDFs follows the usual CCDPACK methods, namely:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines; 
         {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "} etc.\
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is {\tt "}$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection files using the
         character {\tt "}\#{\tt "}.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MINPIX = \_INTEGER (Read)
      }{
         The minimum number of non-BAD pixels which must be present in
         a connected group for acceptance as an image feature.
         [6]
      }
      \sstsubsection{
         NAMELIST = LITERAL (Read)
      }{
         The name of a file to contain the names of the output
         position lists. The names written to this file are those
         generated using the expression given to the OUTLIST parameter.
         The file may be used in an indirection expression to input
         all the position lists output from this routine into another
         routine.
         [FINDOBJ.LIS]
      }
      \sstsubsection{
         NSIGMA = \_DOUBLE (Read)
      }{
         The number of standard deviations above the background that
         should be used as the threshold. This parameter is only
         accessed if the USEPER parameter is FALSE and a gaussian is
         being fitted to the background.
         [5]
      }
      \sstsubsection{
         OUTLIST = LITERAL (Read)
      }{
         The names of the output lists.

        These may be specified as list of comma separated names, 
        using indirection if required, OR, as a single modification 
        element (of the input NDF names).          
         The simplest modification
         element is the asterisk {\tt "}$*${\tt "} which means call each of the
         output lists the same name as the corresponding input NDFs (but
         without the {\tt "}.sdf{\tt "} extension).
         So,
         \begin{description}
            \item IN $>$ $*$
            \item OUTLIST $>$ $*$
         \end{description}
         signifies that all the NDFs in the current directory should be
         used and the output lists should have the same names. On VMS
         this will create position lists with the extension {\tt "}.dat{\tt "}. On
         UNIX a file of this name with no extension will be created.
         Other types of modification can also occur, such as,
         \begin{description}
            \item OUTLIST $>$ $*$\_OBJS.DAT
         \end{description}
         which means call the position lists the same as the input NDFs
         but put {\tt "}\_OBJS.DAT{\tt "} after the names. Replacement of a specified
         string with another in the output file names can also be used,
         \begin{description}
            \item OUTLIST $>$ $*|$\_DEBIAS$|$\_IMAGES.DAT$|$
         \end{description}
         this replaces the string {\tt "}\_DEBIAS{\tt "} with {\tt "}\_IMAGES.DAT{\tt "} in any
         of the output names.

         If wildcarded names for the input NDFs are used then is it
         recommended that wildcards are also used for the position list
         names (the order of input names is not guaranteed).

         The output files contain a integer index for each image
         feature followed by the X and Y centroid (formed using all the
         intensity information) and finally the mean intensity of
         pixels in the group.
         [$*$.DAT]
      }
      \sstsubsection{
         OVERSAMP = \_INTEGER (Read)
      }{
         An oversampling factor which is used when forming the initial
         histogram (greater than 1). The oversample is estimated by
         making the initial histogram mean count OVERSAMP times
         smaller than the mean count which would give BINFRAC in every
         bin. Increasing the oversample will increase the probability
         that only one bin will meet the BINFRAC criterion.
         [5]
      }
      \sstsubsection{
         PERCENTILE = \_DOUBLE (Read)
      }{
         The percentage point in the data histogram which is to be used
         as the threshold estimate.  For data which has a significant
         background count this value should always be much greater than
         50 (the median) and probably greater than the upper quantile
         (75). Only used if USEPER is TRUE.
         [96]
      }
      \sstsubsection{
         THRESH = \_DOUBLE (Read)
      }{
         The threshold which is to be used for detecting image
         features.  Connected pixel groups above this threshold form
         image features. This parameter is only used if the AUTOTHRESH
         parameter is set FALSE. In this case a value may be supplied
         for each NDF which is being processed.
         [Dynamic default]
      }
      \sstsubsection{
         TOUCH = \_LOGICAL (Read)
      }{
         If TRUE then pixel groups may contact the edges of the data
         array. Contact is defined as any pixel in the connected group
         of pixels being on the first or last column or row of the
         actual data array (not including any NDF origin information).
         Setting this FALSE decreases the probability of incomplete
         pixel groups being centroided which would result in inaccurate
         positions.
         [FALSE]
      }
      \sstsubsection{
         USEPER = \_LOGICAL (Read)
      }{
         If TRUE then a percentage point (of the total counts) in the
         histogram will be used to estimate the threshold. Otherwise a
         gaussian fit to the data histogram will be used to estimate the
         background value.
         [TRUE]
      }
   }
   \sstexamples{
      \sstexamplesubsection{FINDOBJ}{ IN=$*$ MINPIX=10 OUTLIST=$*$.FIND
      }{
         In this example FINDOBJ processes all the NDFs in the current
         directory locating objects with connected pixel groups which
         have more than {\ssttt 9} pixels above the threshold.
      }
      \sstexamplesubsection{FINDOBJ}
        { {\tt "}NDF1,NDF2,NDF10{\tt "} 6 {\tt "}OBJ1.DAT,OBJ2.DAT,OBJ3.DAT{\tt "}
              USEPER=FALSE NSIGMA=3
      }{
         In this example FINDOBJ estimates the threshold using the mode
         value in the histogram of data values as an estimate of the
         background and the fit of a gaussian to this to estimate the
         background standard deviation. The threshold used for each NDF
         is then {\ssttt 3} times the standard deviation above the estimated
         background.
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem Detection threshold
      }
            FINDOBJ is optimised to determine a reliable detection
           threshold and is not concerned with the accurate
           determination of the background value on a frame (as it
           performs no photometric measurements). For this reason the
           histogram which it uses to determine the background value is
           made in such a way that it is usually very well sampled
           (probably oversampled, for most other purposes). FINDOBJ
           should not be used in a manner for which it is not suited
           without understanding how if differs from other more
           specialized routines.

      \sstitemlist{
         \sstitem Histogram formation and gaussian fitting. 
      }
           The histogram used by
           FINDOBJ is formed by (if necessary) re-binning until the BINFRAC
           criterion is met, it is expected that this will always 
           result in a well sampled histogram. The background value is the
           mode of this histogram and is not refined during the gaussian
           fitting. The gaussian fitting just estimates the standard
           deviation of the background and uses a fixed peak value and
           position (the mode of the histogram) and iterates rejecting bins
           whose counts fall below 20 percent of the peak value, stopping
           when either 3 iterations have been performed or the standard
           deviation does not change by more than one bin width in data
           values.

      \sstitemlist{
         \sstitem NDF extension items. 
      }

       On exit the CURRENT\_LIST items in the CCDPACK extensions
       (.MORE.CCDPACK) of the input NDFs are set to the names of the 
       appropriate output lists. These items will be used by other
       CCDPACK position list processing routines to automatically 
       access the lists.
      \sstitemlist{
         \sstitem Output position list format.
      }
           CCDPACK format - Position lists in CCDPACK are formatted files
           whose first three columns are interpreted as the following.

      \sstitemlist{

         \sstitem
              Column 1: an integer identifier

         \sstitem
              Column 2: the X position

         \sstitem
              Column 3: the Y position

      }
        The column one value must be an integer and is used to identify
        positions which may have different locations but are to be
        considered as the same point. Comments may be included in the
        file using the characters \# and !. Columns may be separated by
        the use of commas or spaces.
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      Most parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.
      The exception to this rule is:
      \sstitemlist{

         \sstitem
            THRESH  -- dynamic value

      }
      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when re-using the
      application after a break of sometime. The intrinsic default
      behaviour of the application may be restored by using the RESET
      keyword on the command line.

      Certain parameters (LOGTO and LOGFILE) have global values. These
      global values will always take precedence, except when an
      assignment is made on the command line.  Global values may be set
      and reset using the CCDSETUP and CCDCLEAR commands.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         This routine correctly processes the DATA and QUALITY components
           of an NDF data structure. Bad pixels and all non-complex numeric
           data types can be handled.
      }
   }
}

\newpage
\label{des:findoff}
\sstroutine{
   FINDOFF
}{
   Performs pattern-matching between position lists related by
   simple offsets
}{
   \sstdescription{
      This routine is designed to determine which positions in many
      unaligned and unlabeled lists match, subject to the condition
      that the transformations between the lists are well modelled by
      simple translations.

      The results from this routine are labelled position lists (one
      for each input list) which may be used to complete image
      registration using the REGISTER routine. The estimated offsets are
      also reported.
   }
   \sstusage{
      FINDOFF INLIST ERROR OUTLIST
   }
   \sstparameters{
      \sstsubsection{
         COMPLETE = \_DOUBLE (Read)
      }{
         A completeness threshold for rejecting matched position
         list pairs. A completeness factor is estimated by counting the
         number of objects in the overlap region of two lists, taking
         the minimum of these two values (this adjusts for
         incompleteness due to a different object detection threshold)
         and comparing this with the number of objects actually
         matched. Ideally a completeness of 1 should be found, the lower
         this value the lower the quality of the match.
         [0.5]
      }
      \sstsubsection{
         ERROR = \_DOUBLE (Read)
      }{
         The error in the X and Y positions. This value is used to
         determine which positions match within an error box (SLOW) or as a
         bin size (FAST). An inaccurate value may result in excessive
         false or null matches.
         [1.0]
      }
      \sstsubsection{
         FAILSAFE = \_LOGICAL (Read)
      }{
         If FAST is TRUE then this parameter indicates whether the SLOW
         algorithm is to be used when FAST fails.
         [TRUE]
      }
      \sstsubsection{
         FAST = \_LOGICAL (Read)
      }{
         If TRUE then the FAST matching algorithm is used, otherwise
         just the SLOW algorithm is used.
         [TRUE]
      }
      \sstsubsection{
         INLIST = LITERAL (Read)
      }{
         This parameter is used to access the names of the lists
         which contain the positions and, if NDFNAMES is TRUE, the names
         of the associated NDFs. If NDFNAMES is TRUE the names of the
         position lists are assumed to be stored in the extension of the
         NDFs (in the CCDPACK extension item CURRENT\_LIST) and the names
         of the NDFs themselves should be given in response (and may
         include wildcards).

         If NDFNAMES is FALSE then the actual names of the position
         lists should be given. These may not use wildcards but may be
         specified using indirection (other CCDPACK position list
         processing routines will write the names of their results file
         into files suitable for use in this manner) the indirection
         character is {\tt "}$\wedge${\tt "}.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MINMATCH = \_INTEGER (Read)
      }{
         This parameter specifies the minimum number of positions
         which must be matched for a comparison of two lists to be 
         deemed successful.
         [3]
      }
      \sstsubsection{
         MINSEP = \_DOUBLE (Read)
      }{
         Positions which are very close may cause false matches by being
         within the error box of other positions. The value of this
         parameter controls how close objects may be before they are
         both rejected (this occurs before pattern-matching).
         [Dynamic -- 5.0$*$ERROR]
      }
      \sstsubsection{
         NAMELIST = LITERAL (Read)
      }{
         The name of a file to contain the names of the output
         position lists. The names written to this file are those
         generated using the expression given to the OUTLIST parameter.
         This file may be used in an indirection expression to input
         all the position lists output from this routine into another
         routine (say REGISTER), if the associating position lists with
         NDFs option is not being used.
         [FINDOFF.LIS]
      }
      \sstsubsection{
         NDFNAMES = \_LOGICAL (Read)
      }{
         If TRUE then the routine will assume that the names of the
         position lists are stored in the NDF CCDPACK extensions under
         the item {\tt "}CURRENT\_LIST{\tt "}. The names will be present in the
         extension if the positions were located using a CCDPACK
         application (such as FINDOBJ). Using this facility allows the
         transparent propagation of position lists through processing
         chains.

         If a global value for this parameter has been set using
         CCDSETUP then that value will be used.
         [TRUE]
      }
      \sstsubsection{
         OUTLIST = FILENAME (Write)
      }{
         A list of names specifying the result files. These contain
         labelled positions which can be used in registration.
         The names of the lists may use modifications of the
         input names (NDF names if available otherwise the names of the
         position lists). So if you want to call the output lists
         the same name as the input NDFs except to add a type use.
         \begin{description}
            \item OUTLIST $>$ $*$.FIND
         \end{description}
         If no NDF names are given (NDFNAMES is FALSE) then if you want
         to change the extension of the files (from {\tt "}.FIND{\tt "} to {\tt "}.OFF{\tt "}
         in this case) use
         \begin{description}
            \item OUTLIST $>$ $*$$|$FIND$|$OFF$|$
         \end{description}
         Or alternatively you can use an explicit list of names.
         These may use indirection elements as well as names separated
         by commas.
         [$*$]
      }
      \sstsubsection{
         USECOM = LOGICAL (Read)
      }{
         This parameter specifies whether the completeness value will
         be used to weight the number of matches between a pair, when
         determining the graph connecting all input datasets. Using
         a completeness weight increases the chance of selecting high
         quality matches, but may reduce the chance of selecting matches
         with the highest counts in favour of those with lower counts.
         [TRUE]
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         FINDOFF}{ INLIST=$*$ ERROR=1 OUTLIST=$*$.OFF
      }{
         In this example all the NDFs in the current directory are
         accessed and their associated position lists are used. The
         matched positions are named {\ssttt $*$.OFF}. The method 
         used is to try
         the FAST algorithm, switching to SLOW if FAST fails. The
         completeness measure is used when forming the spanning tree.
         Matches with completenesses less than {\ssttt 0.5} and with 
         less than three positions are rejected.
      }
      \sstexamplesubsection{
         FINDOFF}{ FAST NOFAILSAFE
      }{
         In this example the only the FAST algorithm is used.
      }
      \sstexamplesubsection{
         FINDOFF}{ USECOM=FALSE
      }{
         In this example the completeness factor is derived but not used
         to weight the edges of the spanning tree.
      }
      \sstexamplesubsection{
         FINDOFF}{ ERROR=0.002 MINSEP=0.008
      }{
         In this example very precise measurements (or small units)
         are being used. The intrinsic error in the measurements is
         around {\ssttt 0.002} and positions within a box 
         {\ssttt 0.008} of each other are rejected.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Position list formats.

      }
        CCDPACK supports data in two formats.

        CCDPACK format - the first three columns are interpreted as the
        following.

      \sstitemlist{

         \sstitem
              Column 1: an integer identifier

         \sstitem
              Column 2: the X position

         \sstitem
              Column 3: the Y position

      }
        The column one value must be an integer and is used to identify
        positions which are the same but which have different locations
        on different images. Values in any other (trailing) columns are
        usually ignored.

        EXTERNAL format - positions are specified using just an X
        and a Y entry and no other entries.

      \sstitemlist{

         \sstitem
              Column 1: the X position

         \sstitem
              Column 2: the Y position

      }
        This format is used by KAPPA applications such as CURSOR.

        Comments may be included in a file using the characters {\tt "}\#{\tt "} and
        {\tt "}!{\tt "}. Columns may be separated by the use of commas or spaces.

      \sstitemlist{

         \sstitem
         NDF extension items.

      }
        If NDFNAMEs is TRUE then the names of the input position lists
        will be gotten from the item {\tt "}CURRENT\_LIST{\tt "} of the CCDPACK
        extension of the input NDFs. On exit this item will be updated
        to contain the name of the appropriate output lists.
   }
   \sstdiytopic{
      Notes on Algorithms
   }{
      The pattern-matching process uses two algorithms, one which
      matches all the point pair-offsets between any two 
      input lists, looking for the matches with the most common
      positions, and one which uses a statistical method based on a
      histogram of the differences in the offsets (where the peak in
      the histogram is assumed the most likely difference). In each
      case an estimate of the positional error must be given as it is
      used when deciding which positions match (given an offset) or is
      used as the bin size when forming histograms.

      Which algorithm you should use depends on the number of points
      your positions lists contain and the expected size of the overlaps
      between the datasets. Obviously it is much easier to detect two
      lists with most of their positions in common. With small overlaps
      a serious concern is the likelyhood of finding a `false{\tt '} match.
      False matches must be more likely the larger the datasets and the
      smaller the overlaps.

      The first algorithm (referred to as SLOW) is more careful and is
      capable of selecting out positions when small overlaps in the
      data are present (although a level of false detections will
      always be present) but the process is inherently slow (scaling as
      $N^{3}\ln_{2}N$).  The second algorithm (referred to as FAST) is an
      $N^2$ process so is much quicker, but requires much better
      overlapping.

      Because the FAST process takes so little CPU time it is better to
      try this first (without the SLOW process as a backup), only use
      the SLOW algorithm when you have small datasets and do not
      expect large areas (numbers of positions) of overlap.

      The global registration process works by forming a graph with
      each position list at a node and with connecting edges of weight
      the number of matched position-pairs. The edge weights may be
      modified by a completeness factor which attempts to assess the
      quality of the match (this is based on the ratio of the expected
      number of matches in the overlap region to the actual number,
      random matches shouldn{\tt '}t return good statistics when compared
      with genuine ones). This still leaves a possibility of false
      matches disrupting any attempt to register the datasets so a
      single {\tt "}spanning tree{\tt "} is chosen (this is a graph which just
      visits each node the minimum number of times required to get
      complete connectivity, no loops allowed) which has the highest
      possible number of matched positions (rejecting edges with few
      matched positions/low completenesses where possible). This gives
      a most likely solution to the offsets between the position lists,
      rather than the {\tt "}best{\tt "} solution which could well include false
      matches; compare this solution with a median as opposed to a
      mean. The final registration is then used to identify all the
      objects which are the same in all datasets (using a relaxation
      method), resulting in labelled position lists which are output
      for use by REGISTER.
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      Most parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.

      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when re-using the
      application after a break of sometime. The intrinsic default
      behaviour of the application may be restored by using the RESET
      keyword on the command line.

      Certain parameters (LOGTO, LOGFILE and NDFNAMES) have global
      values. These global values will always take precedence, except
      when an assignment is made on the command line.  Global values may
      be set and reset using the CCDSETUP and CCDCLEAR commands.
   }
}

\newpage
\label{des:flatcor}
\sstroutine{
   FLATCOR
}{
   Divides a series of NDFs by a flatfield
}{
   \sstdescription{
   This routine applies a flat field correction to a series of NDFs.   
   If the input data have been saturated using a saturation value  
   (instead of using BAD pixel flagging) then the saturation values 
   may be protected from modification.
   }
   \sstusage{
      FLATCOR IN OUT FLAT
   }
   \sstparameters{
      \sstsubsection{
         FLAT = LITERAL (Read)
      }{
         Name of the NDF which contains the normalised (mean of one)
         flatfield data.
         This should have been produced by a program such as MAKEFLAT.
         The data should have a floating point HDS data type (\_REAL or
         \_DOUBLE).
         The name of this file may be specified using indirection
         through a file.
         [Global flatfield]
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         Names of the NDFs containing the data which are to have the
         flatfield correction applied.
         The specification of the names of the NDFs follows the usual
         CCDPACK methods, namely:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines; 
         {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]` etc.\
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is `$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection file using the
         character {\tt "}\#{\tt "}.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP,
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         OUT = LITERAL (Write)
      }{
        Names of the output NDFs. These may be specified as list of
        comma separated names, using indirection if required, OR,
        as a single modification element (of the input names).
         The simplest modification element is the asterisk {\tt "}$*${\tt "} which
         means each of the output NDFs the same name as the
         corresponding NDFs files. So,
         \begin{description}
            \item IN $>$ $*$
            \item OUT $>$ $*$
         \end{description}
         signifies that all the NDFs in the current directory should be
         used and the output NDFs should have the same names. On VMS
         systems this will result in the creation of a higher version
         number of the input NDFs. Other types of modification can also
         occur, such as,
         \begin{description}
            \item OUT $>$ TMP\_$*$
         \end{description}
         which means call the output NDFs the same as the input NDFs but
         put TMP\_ in front of the names. Replacement of a specified
         string with another in the output file names can also be used,
         \begin{description}
            \item OUT $>$ TMP\_$*|$DEBIAS$|$FLATTENED$|$
         \end{description}
         this replaces the string DEBIAS with FLATTENED in any of the
         output names TMP\_$*$.
      }
      \sstsubsection{
         SATURATION = \_DOUBLE (Read)
      }{
         The value at which the input data has been saturated. 
         This is only required if the saturation has been
         flagged using a non-BAD value.
         [1.0D6]
      }
      \sstsubsection{
         SETSAT = \_LOGICAL (Read)
      }{
         If the input data has had a saturation value applied then this
         value should be set to TRUE. However, if the saturation has
         been applied within CCDPACK then this will not be necessary as
         this information will have been stored in the CCDPACK
         extension.  Note that data with different saturation
         properties (i.e.\ saturation values) which have not been set
         within CCDPACK will require separate processing (see notes).
         [FALSE]
      }
      \sstsubsection{
         PRESERVE = \_LOGICAL (Read)
      }{
         If the input data types are to be preserved and used for
         processing then this parameter should be set TRUE [default].
         If this parameter is set FALSE then the input data will be
         processed and returned in a suitable floating point
         representation. This option is useful if the output data will
         have a significant number of BAD values due to numeric errors
         (over or under flow), or if unacceptable loss of precision
         will occur if the data are processed in the original data type
         (due to rounding errors).

         If a global value for this parameter has been set using
         CCDSETUP then this will be used.
         [TRUE]
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output NDFs.
         [Output from FLATCOR]
      }
   }
   \sstexamples{
      \sstexamplesubsection{FLATCOR}{ FRAME1 FRAME1\_F FLATR
      }{
         In this example the data in NDF {\ssttt FRAME1} are corrected for the
         flatfield response stored in NDF {\ssttt FLATR}. The result of 
         dividing
         {\ssttt FRAME1} by {\ssttt FLATR} is written to NDF 
         {\ssttt FRAME1\_F}. If a saturation
         value has been applied to the data in {\ssttt FRAME1} then this will 
         be automatically accommodated by FLATCOR providing the saturation
         has been applied within CCDPACK.
      }
      \sstexamplesubsection{FLATCOR}
        { N4151R1 N4151R1F FLATFIELD SETSAT=TRUE SATURATION=32767
      }{
         In this example the data have had a saturation value applied
         which has not been recorded within CCDPACK and the required 
         information has been supplied.
      }
      \sstexamplesubsection{FLATCOR}
         { IN=$*$ OUT=$*$\_FLATTENED FLAT=MASTER\_FLATR
      }{
         In this example all the NDFs in the current directory are
         processed. The resultant data are written to files with the
         same name as the corresponding input NDFs, but with the
         characters {\ssttt "\_FLATTENED"} appended to the filename.
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem If any of the input data have had their saturation values set by
           applications not within CCDPACK, then this routine will require
           this information if the values are to be propagated properly. If
           more than one saturation value has been used then the input
           frames will need to be processed singly. This is because FLATCOR
           only uses one saturation value per input group. If the
           saturation values have been set within CCDPACK (by DEBIAS)
           these will be processed correctly and may be different.
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      Most parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.
      The exception to this rule is:
      \sstitemlist{

         \sstitem
            TITLE   -- always {\tt "}Output from FLATCOR{\tt "}

      }
      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      on new datasets/different devices, or after a break of sometime.
      The intrinsic default behaviour of the application may be
      restored by using the RESET keyword on the command line.

      Certain parameters (LOGTO, LOGFILE, PRESERVE and FLAT) have
      global values. These global values will always take precedence,
      except when an assignment is made on the command line.  In general
      global values may be set and reset using the CCDSETUP and
      CCDCLEAR commands, however, the FLAT parameter may only be set by
      a run of the application MAKEFLAT.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Supports processing of all non-complex numeric types.
           BAD pixels are processed as are all NDF components.
      }
   }
}

\newpage
\label{des:idicurs}
\sstroutine{
   IDICURS
}{
   Reads coordinates from a graphics device
}{
   \sstdescription{
     This routine uses an interactive cursor to report and record 
     positions selected from an IDI graphics device. Before using this 
     routine an image must have been displayed using a routine such 
     as KAPPA DISPLAY (SUN/95). IDICURS allows displayed images and 
     graphics to be zoomed during the location operation, on X 
     display devices the memory may also be (optionally) scrolled.

     IDICURS uses the IDI package, hence the graphics device must
     an image display supported by IDI.
   }
   \sstusage{
      IDICURS OUTLIST DEVICE
   }
   \sstparameters{
      \sstsubsection{
         ARROWS = \_LOGICAL (Read)
      }{
         Only used if SCROLL is TRUE. This parameter defines whether or
         not the keyboard arrows are used to control the display scroll.
         Using the keyboard increases the accuracy of positioning but is
         slower. Pressing Shift-Arrow-Key increases the rate of scroll.
         [FALSE]
      }
      \sstsubsection{
         COLOUR = \_INTEGER (Read)
      }{
         The colour of the position marker. This may take any value in
         the range 0-4.
         [4]
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image display device.
         [Current-image display device]
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         The names of a list of NDFs which are to be {\tt "}associated{\tt "} with
         the output position list. Associating a list with an NDF means
         that the item {\tt "}CURRENT\_LIST{\tt "} in its CCDPACK extension will be
         set to the name of the list. In future applications the NDF
         name may then be used instead of the list name (any derived
         lists will then be associated with the NDF instead), this is
         the usual method in CCDPACK.

         The names of the NDFs may be given as {\tt "}!{\tt "} in which case none
         will be associated, otherwise the names may be specified using
         the usual methods i.e:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines; 
         {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "} etc.\
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is {\tt "}$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection file using the
         character {\tt "}\#{\tt "}.
         [!]
      }
      \sstsubsection{
         KEEPLUT = \_LOGICAL (Read)
      }{
         If TRUE then the Look-Up-Table of the current device will be
         used {\tt "}as is{\tt "}. Otherwise a greyscale will be loaded. The
         visibility of the cursor when using X windows and with
         scrolling enabled is often a problem. To help with this the
         primary colours are loaded into the first fews pens.
         [TRUE]
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MEMORY = \_INTEGER (Read)
      }{
         The memory of the device which is to be used. This can take
         the values 0 and 1. 0 means the base memory and 1 the overlay.
         [0]
      }
      \sstsubsection{
         MSIZE = \_REAL (Read)
      }{
        Determines the size of the position marker. This is set as a
        fraction of the X dimension of the display.
         [0.03]
      }
      \sstsubsection{
         OUTLIST = FILENAME (Write)
      }{
         The name of the file which is to contain the selected
         positions. The positions are written using the
         standard format in CCDPACK which is described in the notes
         section.
         [IDICURS.LIS]
      }
      \sstsubsection{
         SCROLL = \_LOGICAL (Read)
      }{
         If TRUE and the display device allows it, then scrolling of
         the image display is enabled. This may be very slow on devices
         with poor graphics facilities and/or slow processors so is
         normally disabled.
         [FALSE]
      }
      \sstsubsection{
         THICK = \_INTEGER (Read)
      }{
         The thickness of the position marker in device pixels.
         [1]
      }
   }
   \sstexamples{
      \sstexamplesubsection{IDICURS}{ STARS.POS
      }{
         In this example IDICURS writes the output positions to the
         formatted file 
         {\ssttt STARS.POS}.
      }
      \sstexamplesubsection{IDICURS}
        { DEVICE=XWINDOWS OUTLIST=OBJECTS.DAT MEMORY=1
      }{
         In this example the overlay plane of an {\ssttt XWINDOWS} display
         can be manipulated and coordinates are read. The overlay
         could contain a contour map as produced by KAPPA TURBOCONT.
      }
      \sstexamplesubsection{IDICURS}
          { OUTLIST=GROUP\_POSITIONS IN=$*$
      }{
         In this example an output position list {\ssttt GROUP\_POSITIONS} is
         associated with all the NDFs in the current directory. This
         method could be useful if all the NDFs are not moved
         significantly with respect to one another. This one list then
         supplies initial positions for objects in all these NDFs (using
         the centroid routine FINDCENT would then give each NDF an
         accurate position list from these initial positions).
      }
      \sstexamplesubsection{IDICURS}
          { SCROLL ARROWS
      }{
         In this example scrolling via the use of the keyboard arrows is
         enabled.
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem Output position list format.
      }
           CCDPACK format - Position lists in CCDPACK are formatted files
           whose first three columns are interpreted as the following.

      \sstitemlist{
         \sstitem
              Column 1: an integer identifier

         \sstitem
              Column 2: the X position

         \sstitem
              Column 3: the Y position

      }
        The column one value must be an integer and is used to identify
        positions which may have different locations but are to be
        considered as the same point. Comments may be included in the
        file using the characters \# and !. Columns may be separated by
        the use of commas or spaces.

      \sstitemlist{
         \sstitem X windows display. 
      }
 When the chosen device is an X windows display then several
 additional interactions beyond the standard ones are available.
 It is possible to scroll the memory using either the pointer or
 keyboard arrows (if the keyboard arrows are chosen then holding
 down the shift keys will accelerate the motion) parameters
 SCROLL and ARROWS control these options. The C key performs a
 quick re-centre, cancelling any zoom and scroll. The Q key
 is used to from the routine.
      \sstitemlist{
         \sstitem NDF extension items. 
      }
       On exit the CURRENT\_LIST items in the CCDPACK extensions
       (.MORE.CCDPACK) of the input NDFs are set to the name of the 
       output list. These items will be used by other
       CCDPACK position list processing routines to automatically 
       access the list.
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      All parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.

      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application.  The intrinsic
      default behaviour of the application may be restored by using the
      RESET keyword on the command line.

      Certain parameters (LOGTO and LOGFILE) have global values. These
      global values will always take precedence, except when an
      assignment is made on the command line.  Global values may be set
      and reset using the CCDSETUP and CCDCLEAR commands.

      The DEVICE parameter also has a global association. This is not
      controlled by the usual CCDPACK mechanisms, instead it works in
      co-operation with KAPPA (SUN/95) image display/control routines.
   }
}

\newpage
\label{des:listlog}
\sstroutine{
   LISTLOG
}{
   Lists an ADAM/ICL logfile
}{
   \sstdescription{
      LISTLOG lists the contents of a logfile created either by ICL or
      by an ADAM task using the ICL log file system (e.g. CCDPACK).
      The output can be directed into a printable file or to the
      terminal.
   }
   \sstusage{
      LISTLOG LOGFILENAME OUTPUT [SINCE] [DTNS] [NAMES] [LABELS]
   }
   \sstparameters{
      \sstsubsection{
         DTNS = LITERAL (Read)
      }{
         A single string whose elements indicate which parts of the
         logfile records (see notes) are to be listed. {\tt "}D{\tt "} stands 
         for Date, {\tt "}T{\tt "} stands for time, {\tt "}N{\tt "} 
         stands for taskName and {\tt "}S{\tt "}
         stands for String the actual entry. Thus the string 
         {\tt "}DTNS{\tt "}
         means that all the parts of each logfile record should be
         listed. The default value {\tt "}S{\tt "} lists only the 
         string entry part
         of the logfile record. Illegal characters (i.e.\ non 
         {\tt "}D{\tt "} {\tt "}T{\tt "}
         {\tt "}N{\tt "} {\tt "}S{\tt "} ones) will be ignored.
         [{\tt "}S{\tt "}]
      }
      \sstsubsection{
         LABELS( 1 to 5 ) = \_CHAR (Read)
      }{
         A list of up to five labels, separated by commas. Only records
         whose entry strings (see notes) start with these labels (case
         insensitive) are listed. This parameter defaults to 
         {\tt "}ALL{\tt "}
         which means list all entry strings irrespective of their
         initial content.
         [{\tt "}ALL{\tt "}]
      }
      \sstsubsection{
         LOGFILENAME = LITERAL (Read)
      }{
         The name of the log file which is to be read. This defaults to
         {\tt "}ADAM\_LOGFILE{\tt "} an ADAM system logical name 
         pointing the usual
         system logfile.
         [{\tt "}ADAM\_LOGFILE{\tt "}]
      }
      \sstsubsection{
         NAMES( 1 to 5 ) = \_CHAR (Read)
      }{
         A list of up to five tasknames (see notes), separated by
         commas. Only records with these tasknames (case insensitive)
         are listed. The default {\tt "}ALL{\tt "} means list all 
         records
         irrespective of taskname.  ICL interprets the taskname as the
         process name and uses this.  Other programs/packages which
         write to the log file may use other indicators (e.g. CCDPACK
         uses {\tt "}CCDPACK{\tt "} for this value so that its 
         records may be
         extracted by using this parameter, say if they are mixed with
         other log information).
         [{\tt "}ALL{\tt "}]
      }
      \sstsubsection{
         OUTPUT = LITERAL (Read)
      }{
         Where the output from LISTLOG is to be directed. This defaults
         to {\tt "}S{\tt "} which means list the output to the Screen 
         (the terminal). If the output is required in a printable 
         format then
         a file name should be returned.
         [{\tt "}S{\tt "}]
      }
      \sstsubsection{
         SINCE = LITERAL (Read)
      }{
         A date and time specified in the format:
         \begin{description}
            \item DD-MMM-YYYY HH:MM:SS.CC
         \end{description}
         e.g.
         \begin{description}
            \item 9-JAN-1991 10:30:22.5
         \end{description}

         Records whose time of entry into the log file are after this
         will be selected. The default {\tt "}S{\tt "} (for Start) 
         means use the
         time found at the beginning of the logfile (this time is shown
         immediately after the logfile is opened). If this return 
         ({\tt "}S{\tt "})
         is accepted then all records will be shown irrespective of
         their time of entry. A value a may be offset from the DATE
         (note that the TIME part is ignored) at the start of the
         logfile by using the format
         \sstitemlist{

            \sstitem
               -- HH:MM:SS.CC
            in this circumstance the {\tt "}-{\tt "} is replaced by the start date.
            [{\tt "}S{\tt "}]
         }
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LISTLOG}{ $\backslash$
      }{
         This example just lists the logfile. If LISTLOG has not been
         previously run then the logfile used is the system one
         (assigned to the logical name {\ssttt "ADAM\_LOGFILE"}) 
         and the output
         is listed to the terminal. If LISTLOG has been previously used
         then the current values (i.e.\ those entered on the last use)
         of {\ssttt LOGFILENAME} and {\ssttt OUTPUT} will be used.
      }
      \sstexamplesubsection{
         LISTLOG}{ CCDPACK.LOG CCDPACK.LIS
      }{
         Lists the contents of the logfile {\ssttt CCDPACK.LOG} to the printable
         file {\ssttt CCDPACK.LIS}.
      }
      \sstexamplesubsection{
         LISTLOG}{ MYREDUCE.LOG MYREDUCE.LIS SINCE={\tt "}1-JAN-1991 00{\tt "}
      }{
         This examples writes the contents of logfile {\ssttt MYREDUCE.LOG} to
         {\ssttt MYREDUCE.LIS}, selecting only the records whose dates are after
         the shown date.
      }
      \sstexamplesubsection{
         LISTLOG}{ DTNS=DS $\backslash$
      }{
         In this example the date and string parts of the current
         logfile are listed.
      }
      \sstexamplesubsection{
         LISTLOG}{ NAMES=[CCDPACK,AUSER] $\backslash$
      }{
         In this example only those logfile records whose tasknames are
         {\ssttt "CCDPACK"} or {\ssttt "AUSER"} are listed. The 
         comparison is case insensitive.
      }
      \sstexamplesubsection{
         LISTLOG}{ LABELS=[Mean,Average,Total] $\backslash$
      }{
         In this example only those logfile records whose entry strings
         start with the characters {\ssttt "Mean"}, 
         {\ssttt "Average"} or {\ssttt "Total"} are
         listed. The comparison is case insensitive.
      }
   }
   \sstnotes{
       The format of a record in a logfile is

         \begin{description}
            \item Date Time Taskname Entry
         \end{description}

        Date and Time are the time and date when the entry was made to
        the logfile.  Taskname is the name of the task which made the
        entry (usually the process or package name). Entry is the actual
        string which is to be recorded.

         Certain of the parameters are latched to use their current
           value. These are LOGFILENAME, OUTPUT, DTNS, NAMES and LABELS.
           LOGFILENAME and OUTPUT are prompted for and offer the current
           value as a default. DTNS, NAMES and LABELS do not prompt and
           hence always use the default or current value (if LISTLOG has
           been previously run then the current values are those entered at
           that time and may be inspected by using the utility TRACE on the
           file ADAM\_USER:LISTLOG) thus it is only necessary to enter your
           desired defaults for these values once. To override the current
           values use the keyword RESET on the command line or put the new
           values on the command line.
   }
}

\newpage
\label{des:makebias}
\sstroutine{
   MAKEBIAS
}{
   Produces a master from a set of bias frames
}{
   \sstdescription{
      This routine processes a series of bias frames (stored in NDFs),
      so as to produce a single {\tt "}master bias{\tt "} frame in which the noise
      levels are reduced. This master bias frame can then be used to
      de-bias other CCD frames (using DEBIAS). Using the given readout
      noise an, optional, variance component may be produced for the
      output data. The use of a variance component allows the effects
      of noise in bias subtraction to be properly monitored.

      MAKEBIAS also performs other functions during processing, such as
      estimating the readout noise (which it displays for comparison
      with the nominal value), estimating the data levels, zeroing the
      average value of the input data before combination (to more
      closely follow any drifts in the zero level) and also supports
      many different methods for performing the bias-frame data
      combination. The combination methods offer a mixture of very
      robust (median) to very efficient (mean) estimators.
   }
   \sstusage{
      MAKEBIAS IN OUT RNOISE METHOD
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                                      ALPHA=? \\
                                      SIGMAS=? NITER=? \\
                                      NITER=? \\
                                      MIN=? MAX=?
                  \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small method}
   }
   \sstparameters{
      \sstsubsection{
         ALPHA = \_REAL (Read)
      }{
         The fraction of extreme values to remove before combining
         the data at any pixel. This fraction is removed from each
         extreme so can only take a value in the range 0 to 0.5.
         Only used if METHOD={\tt "}TRIMMED{\tt "}
         [0.2]
      }
      \sstsubsection{
         GENVAR = \_LOGICAL (Read)
      }{
         If TRUE then a variance component representative of the
         readout noise will be generated. If FALSE then no variance
         component will be generated. If a variance component is not
         generated then any future estimates of variance made using the
         output NDF will be underestimates, however, disk space savings
         can be made using this option, if future error analyses are
         not important. If this parameter is set FALSE then a readout
         noise estimate will not be requested.

         If a global value has been set using CCDSETUP this value
         will be used, and will be shown as the default.
         [TRUE]
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         A list of NDF names which contain the raw bias frame data.
         The specification of the names of the NDF follows the usual
         CCDPACK methods, namely:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} 
         on VMS machines; {\tt "}$*${\tt "}, {\tt "}?{\tt "}, 
         {\tt "}[a-z]{\tt "} etc.
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is {\tt "}$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection files using the
         character {\tt "}\#{\tt "}.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MAX = \_REAL (Read)
      }{
         If METHOD = {\tt "}THRESH{\tt "} then this value defines the upper limit
         for values which can be used when combining data. Note that the
         value used for this parameter will not be corrected for zero
         pointing. Hence if the output NDF is to be zeroed then the
         maximum value should be a offset from zero (say some positive
         number 2 or 3 sigmas large). This could be used as a form of
         sigma clipping if no variances are to be generated.
      }
      \sstsubsection{
         METHOD = LITERAL (Read)
      }{
         The method to be used to combine the data components of
         the input NDFs. This may be set to any unique abbreviation of
         the following:
         \sstitemlist{

            \sstitem
               MEAN      -- Mean of the input data values

            \sstitem
               MEDIAN    -- Median of the input data values

            \sstitem
               TRIMMED   -- An {\tt "}alpha trimmed mean{\tt "} in which a fraction
                               alpha of the values are removed from
                               each extreme

            \sstitem
               MODE      -- An iteratively {\tt "}sigma clipped{\tt "} mean which
                               approximates to the modal value

            \sstitem
               SIGMA     -- A sigma clipped mean

            \sstitem
               THRESHOLD -- Mean with values above and below given
                               limits removed

            \sstitem
               MINMAX    -- Mean with the highest and lowest values
                               removed

            \sstitem
               BROADENED -- A broadened median (the mean of a small
                               number of central values)
            [MEDIAN]
         }
      }
      \sstsubsection{
         MIN = \_REAL (Read)
      }{
         If METHOD = {\tt "}THRESH{\tt "} then this value defines the lower limit
         for values which can be used when combining the data. Note that the
         value used for this parameter will not be corrected for zero
         pointing. Hence if the output NDF is to be zeroed then the
         minimum value should be a offset from zero (say some negative
         number 2 or 3 sigmas large). This could be used as a form of
         sigma clipping if no variances are to be generated.
      }
      \sstsubsection{
         MINPIX = \_INTEGER (Read)
      }{
         The minimum number of good (i.e. not BAD) pixels required 
         to contribute to the value of an output pixel. Output pixels
         not meeting this requirement are set BAD.
         [1]
      }
      \sstsubsection{
         NITER = \_INTEGER (Read)
      }{
         The number of refining iterations performed if METHOD = {\tt "}MODE{\tt "}.
         [7]
      }
      \sstsubsection{
         OUT = LITERAL (Read)
      }{
         Name of the output NDF. This has the master bias frame and
         the estimated variances. This name may be specified using
         indirection through a file.
      }
      \sstsubsection{
         PRESERVE = \_LOGICAL (Read)
      }{
         If TRUE then this indicates that the input data type is to be
         used for processing. If not then the output type will either
         be \_REAL or \_DOUBLE, the precision at which the combinations
         are performed.

         If a global value has been set using CCDSETUP then this will
         be used.
         [TRUE]
      }
      \sstsubsection{
         RNOISE = \_DOUBLE (Read)
      }{
         The readout-noise standard deviation. This should be in the
         input data units (ADUs). A value for this will be worked out
         for each frame and reported at the end of the task. The
         average of these values is reported immediately before this parameter
         is accessed and can be used if a better estimate is not known. Note 
         that the supplied estimate has some resilience to large-scale 
         structure in the input frames, but will be incorrect if the 
         input-frame backgrounds are severely sloped. If variances are not 
         generated then this value will not be accessed.

         If a global value has been set up using CCDSETUP this value
         will be used, and will be shown as the default.
         [Dynamically derived value]
      }
      \sstsubsection{
         SIGMAS = \_REAL (Read)
      }{
         Number of standard deviations to reject data at. Used for
         {\tt "}MODE{\tt "} and {\tt "}SIGMA{\tt "} methods. For METHOD = {\tt "}MODE{\tt "} the standard
         deviation is estimated from the population of values. For
         METHOD = {\tt "}SIGMA{\tt "} this value is the readout noise.
         [4]
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output NDF
         [Output from MAKEBIAS].
      }
      \sstsubsection{
         ZERO = \_LOGICAL (Read)
      }{
         Flag indicating whether the output master bias is to have a
         mean value of zero or not. If TRUE the input data components
         are zeroed before combination. Note that if
         this option is chosen then it will be necessary to offset the
         master bias to the data before subtraction. This option is
         not allowed for unsigned input data type (unless PRESERVE is
         FALSE) as zeroing will make around half the data values
         invalid.
         [TRUE]
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         MAKEBIAS}{ IN={\tt "}B1,B2,B3,B4,B5{\tt "} METHOD=MEDIAN OUT=MBIAS RNOISE=10
      }{ This forms a master bias from the data components of the NDFs 
{\ssttt B1-B5}. The combination mode chosen is the median. The output 
NDF is {\ssttt MBIAS} whose variance has values based on a readout 
noise of {\ssttt 10} data units. Note the quotes when entering a comma 
separated list on the command line.
      }
      \sstexamplesubsection{
         MAKEBIAS}{ IN=$\wedge$BIAS\_FRAMES.LIS OUT=MASTER\_BIAS
      }{
         In this example the list of NDFs is read from the file
         {\ssttt BIAS\_FRAMES}. This file may contain indirection to 
         other files up to a depth of 7.
      }
      \sstexamplesubsection{
         MAKEBIAS}{ IN=$*$ OUT=MASTER\_BIAS
      }{
         In this example all the NDFs in the directory are used.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a variance component is present it will not be propagated.
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      Most parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last 
      run of the application. If the application has not been run then 
      the {\tt "}intrinsic{\tt "} defaults, as shown in the parameter 
      help, apply. The exceptions to this rule are:
      \sstitemlist{

         \sstitem
            RNOISE  -- dynamic value (but see below)

         \sstitem
            TITLE   -- always {\tt "}Output from MAKEBIAS{\tt "}

      }
      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      on new datasets/different devices, or after a break of sometime.
      The intrinsic default behaviour of the application may be
      restored by using the RESET keyword on the command line.

      Certain parameters (LOGTO, LOGFILE, RNOISE, GENVAR, PRESERVE)
      have global values. These global values will always take
      precedence, except when an assignment is made on the command line.
      Global values may be set and reset using the CCDSETUP and
      CCDCLEAR commands.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The routine supports BAD pixels and all numeric data types
           except COMPLEX.  All combinational arithmetic is performed using
           floating values.  The UNITS, AXIS, TITLE and QUALITY components
           are correctly propagated. Any input variances are ignored.
      }
   }
}

\newpage
\label{des:makecal}
\sstroutine{
   MAKECAL
}{
   Produces a dark or pre-flash calibration NDF
}{
   \sstdescription{
     This routine performs the combination of a series of dark count
     or pre-flash exposure frames. The input NDFs should have been 
     bias subtracted. The input data are divided by the exposure 
     factors before combination into a calibration {\tt"}master{\tt"}, 
     giving an
     output NDF whose data represent one unit of the given exposure 
     time per pixel. Thus the calibration frame should be multiplied 
     by the appropriate factor before subtracting from other frames 
    (i.e. by the dark time or the flash-exposure time). This can be 
     performed by CALCOR and should be done prior to the production of
     a flatfield and flatfield correction. The data combination methods
     give a mixture of very robust (median) to very efficient (mean) 
    methods to suit the data.
   }
   \sstusage{
      MAKECAL IN EXPOSE OUT METHOD 
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                                      ALPHA=? \\
                                      SIGMAS=? NITER=? \\
                                      NITER=? \\
                                      MIN=? MAX=?
                  \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small method}
   }
   \sstparameters{
      \sstsubsection{
         ALPHA = \_REAL (Read)
      }{
         The fraction of extreme values to remove before combining
         the data at any pixel. This fraction is removed from each
         extreme so can only take a value in the range 0 to 0.5.
         Only used if METHOD={\tt "}TRIMMED{\tt "}
         [0.2]
      }
      \sstsubsection{
         EXPOSE = LITERAL (Read)
      }{
         Either:
         An exact number of exposure factors for the input NDFs. The
         values must be in the same order as the input NDFs.

         Or:
         A single value which applies to all the input NDFs.

         Indirection through an ASCII file may be used to specify these
         values. If more than one line is required at prompt time then
         a continuation line may be requested by adding {\tt "}-{\tt "} to the end
         of the line.
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         A list of NDF names which contain the calibration data.
         The specification of the names of the NDF follows the usual
         CCDPACK methods, namely:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines; {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "} etc.
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is {\tt "}$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection files using the
         character {\tt "}\#{\tt "}.

         NOTE the use of wildcards with this program is not recommended
         unless the input NDFs all have the same calibration exposure
         factors. The order of processing of any wildcarded NDFs cannot
         be guaranteed.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MAX = \_REAL (Read)
      }{
         If METHOD = {\tt "}THRESH{\tt "} then this value defines the 
         upper limit for values which can be used when combining the 
         data. This limit applies to the range of the output data 
         (i.e. the values after the exposure factors have been divided
         into the input data).

      }
      \sstsubsection{
         METHOD = LITERAL (Read)
      }{
         The method to be used to combine the data components of
         the input NDFs. This may be set to any unique abbreviation of
         the following:
         \sstitemlist{

            \sstitem
               MEAN      -- Mean of the input data values

            \sstitem
               MEDIAN    -- Median of the input data values

            \sstitem
               TRIMMED   -- An {\tt "}alpha trimmed mean{\tt "} in which a fraction
                               alpha/2 of the values are removed from
                               each extreme

            \sstitem
               MODE      -- An iteratively {\tt "}sigma clipped{\tt "} mean which
                               approximates to the modal value

            \sstitem
               SIGMA     -- A sigma clipped mean

            \sstitem
               THRESHOLD -- Mean with values above and below given
                               limits removed

            \sstitem
               MINMAX    -- Mean with the highest and lowest values
                               removed

            \sstitem
               BROADENED -- A broadened median (the mean of a small
                               number of central values)
            [MEDIAN]
         }
      }
      \sstsubsection{
         MIN = \_REAL (Read)
      }{
         If METHOD = {\tt "}THRESH{\tt "} then this value defines the lower limit
         for values which can be used when combining the data. This 
         limit applies to the range of the output data (i.e. the values
         after the exposure factors have been divided into the input 
         data).

      }
      \sstsubsection{
         MINPIX = \_INTEGER (Read)
      }{
         The minimum number of good (ie. not BAD) pixels required
         to contribute to the value of an output pixel. Output pixels
         not meeting this requirement are set BAD.
         [1]
      }
      \sstsubsection{
         NITER = \_INTEGER (Read)
      }{
         The number of refining iterations performed if METHOD = {\tt "}MODE{\tt "}.
         [7]
      }
      \sstsubsection{
         OUT = LITERAL (Write)
      }{
         Name of the output NDF to contain the calibration data.
         Note this NDF will have a type of at least \_REAL.
      }
      \sstsubsection{
         SIGMAS = \_REAL (Read)
      }{
         Number of standard deviations to reject data at. Used for
         {\tt "}MODE{\tt "} and {\tt "}SIGMA{\tt "} methods. For METHOD = {\tt "}MODE{\tt "} the standard
         deviation is estimated from the population of values, for
         METHOD = {\tt "}SIGMA{\tt "} the variances are used. If no variances
         exist then the inverse exposure factors are used.
         [4.0]
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output NDF.
         [Output from MAKECAL]
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         MAKECAL}{ IN={\tt "}F1,F2,F3,F4{\tt "} EXPOSE={\tt "}100,200,300,400{\tt "} METHOD=MEDIAN
              OUT=MASTER\_FLASH
      }{
         This example forms a flash calibration NDF from the data in
         NDFs {\ssttt F1,F2,F3} and {\ssttt F4}. The data are divided 
         by the relative
         exposure factors before combination. The combination method
         used is the (weighted) median, the resultant data are written
         to the NDF {\ssttt MASTER\_FLASH}.
      }
      \sstexamplesubsection{
         MAKECAL}{ {\tt "}D1,D2,D3,D4{\tt "} {\tt "}1{\tt "} MASTER\_DARK TRIMMED
              ALPHA=0.2
      }{
         This example produces a dark-count-calibration frame from the
         data in NDFs {\ssttt D1, D2, D3} and {\ssttt D4}. The exposure
         factors are given
         as {\ssttt 1} which probably indicates that the dark-exposure 
         times in
         these datasets are exactly right to correct any subsequent
         data frames. combination mode used is the trimmed mean with
         trimming fraction {\ssttt 0.2} and the output data are written to NDF
         {\ssttt MASTER\_DARK}.
      }
      \sstexamplesubsection{
         MAKECAL}{ $\wedge$FLASH\_FRAMES $\wedge$FLASH\_EXPOSURES FLASH\_MASTER
      }{
         In this example a list of frames to be processed is passed to
         the program by indirection through an ASCII file
         {\ssttt FLASH\_FRAMES.DAT}, the corresponding exposure times 
         are passed
         from the file {\ssttt FLASH\_EXPOSURES.DAT}. This is probably 
         the only
         safe method for entering NDFs to this routine other than as in
         the above examples. Using wildcards for the file
         specifications will mean that the exposures cannot be
         associated correctly. Thus wildcards should not be used except
         when the input NDFs have the same exposure times.
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      Most parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.
      The exception to this rule is:
      \sstitemlist{

         \sstitem
            TITLE  -- always {\tt "}Output from MAKECAL{\tt "}

      }
      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      on new datasets/different devices, or after a break of sometime.
      The intrinsic default behaviour of the application may be
      restored by using the RESET keyword on the command line.

      Certain parameters (LOGTO and LOGFILE) have global values. These
      global values will always take precedence, except when an
      assignment is made on the command line.  Global values may be set
      and reset using the CCDSETUP and CCDCLEAR commands.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The routine supports BAD pixels and all data types except
           COMPLEX. All combinational arithmetic is performed in floating
           point. The AXIS, TITLE and QUALITY components are correctly
           propagated. The variances are propagated through the combination
           processing, assuming that the input data have a normal
           distribution.
      }
   }
}

\newpage
\label{des:makeflat}
\sstroutine{
   MAKEFLAT
}{
   Produces a flatfield calibration NDF
}{
   \sstdescription{
      This routine combines a set of frames into a flatfield. The
      input data should be of a photometrically flat source, and
      should be corrected for any instrumental effects. The output
      calibration frame is normalised to have an average value of one.

      The input data are filtered in an attempt to remove any small
      blemishes etc. before combination.  This is achieved by smoothing
      using a boxfilter and then comparing with the original data. An
      estimate of the standard deviation of each pixel from its
      surroundings is made. Pixels deviating by more than GAMMA
      standard deviations are rejected. This procedure is then
      iterated ITER times. In this way, all image features with a
      scale size comparable with, or smaller than, the smoothing area
      size are rejected.
   }
   \sstusage{
      MAKEFLAT IN OUT METHOD
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                                      ALPHA=? \\
                                      SIGMAS=? NITER=? \\
                                      NITER=? \\
                                      MIN=? MAX=?
                  \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small method}
   }
   \sstparameters{
      \sstsubsection{
         ALPHA = \_REAL (Read)
      }{
         The fraction of extreme values to remove before combining
         the data at any pixel. This fraction is removed from each
         extreme so can only take a value in the range 0 to 0.5.
         Only used if METHOD={\tt "}TRIMMED{\tt "}
         [0.2]
      }
      \sstsubsection{
         BOXSIZE(2) = \_INTEGER (Read)
      }{
         The X and Y sizes (in pixels) of the rectangular box to be
         applied to smooth the input images. If only a single value is
         given, then it will be duplicated so that a square filter is
         used. The values given will be rounded up to positive odd
         integers if necessary. The values should be adjusted to be
         larger than the size of any expected defects.
         [15,15]
      }
      \sstsubsection{
         GAMMA = \_REAL (Read)
      }{
         The number of standard deviations by which a value has to
         deviate from the local mean (defined by the mean within a box
         of BOXSIZE(1) by BOXSIZE(2) pixels) before it is considered to
         be in error. Aberrant pixels are removed from the data before
         the next {\tt "}cleaning{\tt "} iteration is performed.
         [3.0]
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         A list NDF names. These contain the flatfield data. The
         specification of the names of the NDF follows the usual
         CCDPACK methods, namely:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines; {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "} etc.
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is {\tt "}$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection files using the
         character {\tt "}\#{\tt "}.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MAX = \_REAL (Read)
      }{
         If METHOD = {\tt "}THRESH{\tt "} then this value defines the upper limit
         for values which can be used when combining the data. This
         limit applies to the output data range.

      }
      \sstsubsection{
         METHOD = LITERAL (Read)
      }{
         The method to be used to combine the data components of
         the input NDFs. This may be set to any unique abbreviation of
         the following:
         \sstitemlist{

            \sstitem
               MEAN      -- Mean of the input data values

            \sstitem
               MEDIAN    -- Median of the input data values

            \sstitem
               TRIMMED   -- An {\tt "}alpha trimmed mean{\tt "} in which a fraction
                               alpha of the values are removed from
                               each extreme

            \sstitem
               MODE      -- An iteratively {\tt "}sigma clipped{\tt "} mean which
                               approximates to the modal value

            \sstitem
               SIGMA     -- A sigma clipped mean

            \sstitem
               THRESHOLD -- Mean with values above and below given
                               limits removed

            \sstitem
               MINMAX    -- Mean with the highest and lowest values
                               removed

            \sstitem
               BROADENED -- A broadened median (the mean of a small
                               number of central values)
            [MEDIAN]
         }
      }
      \sstsubsection{
         MIN = \_REAL (Read)
      }{
         If METHOD = {\tt "}THRESH{\tt "} then this value defines the lower limit
         for values which can be used when combining the data. This
         limit applies to the output data range.

      }
      \sstsubsection{
         MINPIX = \_INTEGER (Read)
      }{
         The minimum number of good (ie. not BAD) pixels required to 
         contribute to the value of an output pixel. Output pixels 
         not meeting this requirement are set BAD.
         [1]
      }
      \sstsubsection{
         NITER = \_INTEGER (Read)
      }{
         The number of refining iterations performed if METHOD = {\tt "}MODE{\tt "}.
         [7]
      }
      \sstsubsection{
         OUT = LITERAL (Write)
      }{
         Name of an NDF to contain the output flatfield data. Note this
         NDF will have a precision of at least \_REAL. This name
         may be specified using indirection through a file.
      }
      \sstsubsection{
         SIGMAS = \_REAL (Read)
      }{
         Number of standard deviations to reject data at. Used for
         {\tt "}MODE{\tt "} and {\tt "}SIGMA{\tt "} methods. For METHOD = {\tt "}MODE{\tt "} the standard
         deviation is estimated from the population of values.
         For METHOD = {\tt "}SIGMA{\tt "} this value is the pixel variance it one
         exists, otherwise it is the inverse of the mean data value.
         [4.0]
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output NDF.
         [Output from MAKEFLAT]
      }
      \sstsubsection{
         ITER = \_INTEGER (Read)
      }{
         The number of defect rejecting iterations.
         [3]
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         MAKEFLAT}{ IN={\tt "}F1,F2,F3,F4,F5{\tt "} METHOD=MEDIAN OUT=MFLAT
      }{
         This forms a master flat field from NDFs {\ssttt F1} to 
         {\ssttt F5}. The input
         data are first cleaned using the default values for the 
         {\ssttt GAMMA}
         and {\ssttt ITER} parameters. The combination mode chosen is 
         the
         median.  The output NDF is {\ssttt MFLAT}. Note the quotes when
         entering a comma separated list on the command line.
      }
      \sstexamplesubsection{
         MAKEFLAT}{ IN=$\wedge$FLAT\_FRAMES.LIS OUT=MASTER\_FLAT $\backslash$
      }{
         In this example the list of NDFs is read from the file
         {\ssttt FLAT\_FRAMES}. This file may contain indirection to other files
         up to a depth of 7.
      }
      \sstexamplesubsection{
         MAKEFLAT}{ IN=[.FLATR]$*$ OUT=[.FLATR]MASTER\_FLAT GAMMA=2.5 ITER=5 $\backslash$
      }{
         In this example all the NDFs in the subdirectory 
         {\ssttt [.BIAS]} are
         used. The input data are severely cleaned using a noise cut
         of {\ssttt 2.5} standard deviations (current) and {\ssttt 5} 
         iterations. Such
         severe cleaning is only recommended when many input frames
         are given, if this is not the case then BAD areas may be seen
         in the output NDF.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The data input into this routine should have bias strip
           regions and any badly vignetted parts removed.
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      Most parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.
      The exception to this rule is:
      \sstitemlist{

         \sstitem
            TITLE   -- always {\tt "}Output from MAKEFLAT{\tt "}

      }
      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      on new datasets/different devices, or after a break of sometime.
      The intrinsic default behaviour of the application may be
      restored by using the RESET keyword on the command line.

      Certain parameters (LOGTO and LOGFILE) have global values. These
      global values will always take precedence, except when an
      assignment is made on the command line.  Global values may be set
      and reset using the CCDSETUP and CCDCLEAR commands.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The routine supports BAD pixels and all data types except
           COMPLEX.  All combinational arithmetic is performed using
           floating point.  The AXIS, TITLE and QUALITY components are
           correctly propagated. The output is a ratio so the units are set
           to blank. The variances are propagated through the combination
           processing, assuming that the input data have a normal
           distribution.
      }
   }
}

\newpage
\label{des:makemos}
\sstroutine{
   MAKEMOS
}{
   Make a mosaic by combining and (optionally) normalising a set of
   NDFs
}{
   \sstdescription{
      This is a comprehensive application for combining a set of NDFs
      (normally representing overlapping coverage of an object) into a
      single mosaic. It addresses the problems of (a) combining a
      sequence of separate data sets into a single NDF and (b)
      optionally normalising each NDF so that they match each other in
      regions where they overlap. Mutual alignment of the separate NDFs
      is not performed by this application and must be addressed
      beforehand (although NDFs may be aligned to the nearest pixel
      simply by shifting their pixel origin).

      MAKEMOS registers the set of NDFs supplied by matching their
      pixel indices and then forms a mosaic by combining the separate
      input pixel values at each location using a nominated
      data-combination method (by default, it takes the median).  The
      resulting mosaic is of sufficient extent to accommodate all the
      input data, with any output data pixels which do not receive
      values from the input being set to the {\tt "}bad{\tt "} pixel value.
      Account is taken of variance information associated with the
      input NDFs, and all calculations are optimally weighted to
      minimize the output noise. Output variance estimates for the
      final mosaic may also be produced.

      Forming a mosaic in this way will normally be successful only so
      long as the input data are mutually consistent. Unfortunately,
      this is often not the case, since data frequently have differing
      effective exposure times and background levels which give
      discontinuities in the final mosaic. Thus, MAKEMOS also addresses
      the problem of normalising the input NDFs to make them mutually
      consistent. It does this by optionally applying optimised
      multiplicative and/or additive corrections (termed scale-factor
      and zero-point corrections) to each NDF before forming the
      mosaic.  These optimised corrections are determined by
      inter-comparing the input NDFs in pairs, using the regions where
      they overlap to determine the relative scale-factor and/or
      zero-point difference between each pair.  A self-consistent set
      of corrections is then found which, when applied to each input
      NDF, will best eliminate these observed differences and give a
      smooth mosaic.
   }
   \sstusage{
      MAKEMOS IN OUT
   }
   \sstparameters{
      \sstsubsection{
         ALPHA = \_REAL (Read)
      }{
   The fraction of extreme values to remove before combining
   input data if the {\tt "}trimmed mean{\tt "} data combination method is
   selected for producing the output mosaic (see the METHOD
   parameter). A fraction alpha (approximately) of the available
   values is removed from each extreme. This may take values in
   the range 0 to 0.5.
   [0.2]
      }
      \sstsubsection{
         CMPVAR = \_LOGICAL (Read)
      }{
         This parameter controls the use of statistical error
         (variance) information contained in the input NDFs when they
         are inter-compared in pairs to derive scale-factor or
         zero-point corrections. It is only used if either SCALE or
         ZERO is set to TRUE and if two or more of the input NDFs
         contain variance information (a {\tt "}reference NDF{\tt "} also counts,
         if supplied). In this case, if CMPVAR is set to TRUE, then
         variance information is used to correctly weight the input
         data whenever a pair of input NDFs are inter-compared and both
         have variance information available.

         The default behaviour is to use variance information during
         inter-comparisons. This may be suppressed by setting CMPVAR to
         FALSE, which sometimes gives faster execution without greatly
         affecting the result (also see the {\tt "}Algorithms Used{\tt "} section).
         However, if input data with similar values have widely
         differing variance values within the same input NDF, then use
         of input variance information is recommended (this could
         happen, for instance, if an input NDF is the result of a
         previous mosaic-ing process).
         [TRUE]
      }
      \sstsubsection{
         GENVAR = \_LOGICAL (Read)
      }{
         If GENVAR is set to TRUE and all the input NDFs supplied
         contain statistical error (variance) information, then
         variance information will also be calculated for the output
         mosaic NDF, provided that USEVAR is also TRUE. Otherwise,
         if GENVAR is set to FALSE (or if any input NDF does not
         contain variance information), then no output variance values
         will be generated.  This parameter is only used if all the
         input NDFs contain variance information.
         [TRUE]
      }
      \sstsubsection{
         IN = LITERAL (Read and [optionally] Write)
      }{
        A list of the names of the input NDFs which are to be combined
        into a mosaic. The method of specifying these names follows
        the usual CCDPACK conventions, namely: directly listing the
        names, wild-carding ({\tt "}$*${\tt "} and {\tt "}\%{\tt "} 
        are the wildcard characters 
        on VMS, {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "}
        etc. on UNIX) or indirection through
        a text file ({\tt "}$\wedge${\tt "} is the indirection 
        character).

         The input NDFs are normally accessed only for reading.
         However, if the MODIFY parameter is set to TRUE (and
         scale-factor or zero-point corrections are being calculated)
         then each of the {\tt "}input{\tt "} NDFs will be modified by applying the
         calculated corrections.
      }
      \sstsubsection{
         LISTIN = \_LOGICAL (Read)
      }{
         If a TRUE value is given for this parameter (the default),
         then the names of all the NDFs supplied as input will be
         listed (and will be recorded in the logfile if this is
         enabled).  Otherwise, this listing will be omitted.
         [TRUE]
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter, then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS system the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP,
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP,
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MAX = \_REAL (Read)
      }{
         Upper limit for input data values which may contribute to the
         output mosaic if the {\tt "}threshold{\tt "} data combination method is
         selected (see the METHOD parameter). [Maximum real value]
      }
      \sstsubsection{
         MAXIT = \_INTEGER (Read)
      }{
         This parameter specifies the maximum number of iterations to
         be used when inter-comparing pairs of input NDF data arrays to
         determine their relative scale-factor and/or zero-point. It is
         only used if (a) both the SCALE and ZERO parameters have been
         set to TRUE, or (b) SCALE has been set to TRUE and statistical
         error (variance) information obtained from the input NDFs is
         being used to weight the data during the inter-comparison. In
         other cases the inter-comparison operation is not iterative.

         If the specified number of iterations is exceeded without
         achieving the accuracy required by the settings of the TOLS
         and TOLZ parameters, then a warning message will be issued,
         but the results will still be used. The value given for MAXIT
         must be at least one.
         [20]
      }
      \sstsubsection{
         METHOD = LITERAL (Read)
      }{
         The method to be used to combine the input NDFs{\tt '} data values
         to form the output mosaic. This may be set to any unique
         abbreviation of the following:
         \sstitemlist{

            \sstitem
               MEAN      -- Mean of the input data values

            \sstitem
               MEDIAN    -- Median of the input data values

            \sstitem
               TRIMMED   -- An {\tt "}alpha trimmed mean{\tt "} in which a fraction
                               alpha of the values are removed from
                               each extreme

            \sstitem
               MODE      -- An iteratively {\tt "}sigma clipped{\tt "} mean which
                               approximates to the modal value

            \sstitem
               SIGMA     -- A sigma clipped mean

            \sstitem
               THRESHOLD -- Mean with values above and below given
                               limits removed

            \sstitem
               MINMAX    -- Mean with the highest and lowest values
                               removed

            \sstitem
               BROADENED -- A broadened median (the mean of a small
                               number of central values)
            [MEDIAN]
         }
      }
      \sstsubsection{
         MIN = \_REAL (Read)
      }{
         Lower limit for input data values which may contribute to the
         output mosaic if the {\tt "}threshold{\tt "} data combination method is
         selected (see the METHOD parameter).
         [Minimum real value]
      }
      \sstsubsection{
         MODIFY = \_LOGICAL (Read)
      }{
         By default, the NDFs supplied via the IN parameter are
         regarded as {\tt "}input{\tt "} NDFs and will not be modified. However, if
         scale-factor or zero-point corrections are being calculated
         (see the SCALE and ZERO parameters), then giving a TRUE value
         for MODIFY indicates that these NDFs are themselves to be
         modified by applying the calculated corrections before the
         output mosaic is formed.

         This facility provides a means of applying corrections to
         individual NDFs (e.g. to mutually normalise them) without
         necessarily also combining them into a mosaic. It may also be
         useful if several invocations of MAKEMOS are to be made with
         different parameter settings; by specifying MODIFY=TRUE for
         the first invocation, scale-factor or zero-point corrections
         may be applied to normalise the input data so that this need
         not be repeated on each invocation.

         WARNING: Caution should be exercised if setting MODIFY to
         TRUE, as information about the uncorrected data values of the
         {\tt "}input{\tt "} NDFs will not be retained.
         [FALSE]
      }
      \sstsubsection{
         NITER = \_REAL (Read)
      }{
         Maximum number of refining iterations used if the {\tt "}mode{\tt "} data
         combination method is selected (see the METHOD parameter).
         [7]
      }
      \sstsubsection{
         OPTOV = \_INTEGER (Read)
      }{
         This parameter specifies the {\tt "}optimum number of overlaps{\tt "}
         which an NDF should have with its neighbours and controls the
         number of inter-comparisons made between pairs of overlapping
         NDFs when determining scale-factor or zero-point corrections
         (see the SCALE and ZERO parameters).

         The need for this parameter arises because when multiple input
         NDFs are supplied there may be a large number of potential
         pair-wise overlaps between them.  To prevent them all being
         used, which may take far longer than is justified, this set of
         potential overlaps is reduced by elimination, starting with
         the smallest ones (as measured by the number of overlapping
         pixels) and continuing until no more overlaps can be removed
         without reducing the number of overlaps of any NDF below the
         value given for OPTOV.  In practice, this means that each NDF
         will end up with about (although not exactly) OPTOV overlaps
         with its neighbours, with the largest overlaps being
         preferred.

         Note that although this algorithm is effective in reducing the
         number of overlaps, it is not guaranteed always to result in a
         set of overlaps which allow the optimum set of corrections to
         be calculated. In practice, problems from this cause are
         unlikely unless unusual patterns of NDF overlap are involved,
         but they may be solved by increasing the value of OPTOV and/or
         constructing the required mosaic in pieces by running MAKEMOS
         several times on different sets of input NDFs.

         In some cases, reducing the value of OPTOV may reduce the
         number of inter-comparisons made, and hence reduce the
         execution time, however if too few inter-comparisons are made,
         there is a risk that the corrections obtained may not be the
         best possible.

         This parameter is only used if SCALE or ZERO is set to TRUE.
         [3]
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Name of the NDF to contain the output mosaic. This is normally
         mandatory. However, if the {\tt "}input{\tt "} NDFs are being modified (by
         setting the MODIFY parameter to TRUE), then it may optionally
         be omitted by supplying a null value (!). In this case, no
         output mosaic will be formed.
      }
      \sstsubsection{
         PRESERVE = \_LOGICAL (Read)
      }{
         If a TRUE value is given for this parameter (the default),
         then the data type of the output mosaic NDF will be derived
         from that of the input NDF with the highest precision, so that
         the input data type will be {\tt "}preserved{\tt "} in the output NDF.
         Alternatively, if a FALSE value is given, then the output NDF
         will be given an appropriate floating point data type.

         When using integer input data, the former option is useful for
         minimizing the storage space required for large mosaics, while
         the latter typically permits a wider output dynamic range when
         necessary. A wide dynamic range is particularly important if a
         large range of scale factor corrections are being applied (as
         when combining images with a wide range of exposure times).

         If a global value has been set up for this parameter using
         CCDSETUP, then that value will be used.
         [TRUE]
      }
      \sstsubsection{
         REF = NDF (Read)
      }{
         If scale-factor and/or zero-point corrections are being
         applied (see the SCALE and ZERO parameters) then, by default,
         these are normalised so that the median corrections are unity
         and zero respectively. However, if an NDF is given via the REF
         parameter (so as to over-ride its default null value), then
         scale-factor and zero-point corrections will instead be
         adjusted so that the corrected data are normalised to the
         {\tt "}reference NDF{\tt "} supplied.

         This provides a means of retaining the calibration of a set of
         data, even when corrections are being applied, by nominating a
         reference NDF which is to remain unchanged. It also allows the
         output mosaic to be normalised to any externally-calibrated
         NDF with which it overlaps, and hence allows a calibration to
         be transferred from one set of data to another.

         If the NDF supplied via the REF parameter is one of those
         supplied as input via the IN parameter, then this serves to
         identify which of the input NDFs should be used as a
         reference, to which the others will be adjusted. In this case,
         the scale-factor and/or zero-point corrections applied to the
         nominated input NDF will be set to one and zero, and the
         corrections for the others will be adjusted accordingly.

         Alternatively, if the reference NDF does not appear as one of
         the input NDFs, then it will be included as an additional set
         of data in the inter-comparisons made between overlapping NDFs
         and will be used to normalise the corrections obtained (so
         that the output mosaic is normalised to it). However, it will
         not itself contribute to the output mosaic in this case.
         [!]
      }
      \sstsubsection{
         SCALE = \_LOGICAL (Read)
      }{
         This parameter specifies whether MAKEMOS should attempt to
         adjust the input data values by applying scale-factor (i.e.\
         multiplicative) corrections before combining them into a
         mosaic. This would be appropriate, for instance, if a series
         of images had been obtained with differing exposure times; to
         combine them without correction would yield a mosaic with
         discontinuities at the image edges where the data values
         differ.

         If SCALE is set to TRUE, then MAKEMOS will inter-compare the
         NDFs supplied as input and will estimate the relative
         scale-factor between selected pairs of input data arrays where
         they overlap.  From this information, a global set of
         multiplicative corrections will be derived which make the
         input data as mutually consistent as possible. These
         corrections will be applied to the input data before combining
         them into a mosaic.

         Calculation of scale-factor corrections may also be combined
         with the use of zero-point corrections (see the ZERO
         parameter). By default, no scale-factor corrections are
         applied.
         [FALSE]
      }
      \sstsubsection{
         SIGMAS = \_REAL (Read)
      }{
         Number of standard deviations at which to reject values if the
         {\tt "}mode{\tt "} or {\tt "}sigma{\tt "} data combination methods are selected (see
         the METHOD parameter). This value must be positive. [4.0]
      }
      \sstsubsection{
         SKYSUP = \_REAL (Read)
      }{
         A positive {\tt "}sky noise suppression factor{\tt "} used to control the
         effects of sky noise when pairs of input NDFs are
         inter-compared to determine their relative scale-factor. It is
         intended to prevent the resulting scale-factor estimate being
         biased by the many similar values present in the {\tt "}sky
         background{\tt "} of typical astronomical data.  SKYSUP controls an
         algorithm which reduces the weight given to data where there
         is a high density of points with the same value, in order to
         suppress this effect. It is only used if a scale factor is
         being estimated (i.e.\ if SCALE is TRUE).

         A SKYSUP value of unity can often be effective, but a value
         set by the approximate ratio of sky pixels to useful object
         pixels (i.e.\ those containing non-sky signal) in a {\tt "}typical{\tt "}
         NDF overlap region will usually be better. The precise value
         is not critical. A value of zero disables the sky noise
         suppression algorithm completely. The default value for SKYSUP
         is 10$*$$*$(n/2.0), where n is the number of significant
         dimensions in the output mosaic. Hence, for a 2-dimensional
         image, it will default to 10 which is normally reasonable for
         CCD frames of extended objects such as galaxies (a larger
         value, say 100, may give slightly better results for star
         fields).
         [10$*$$*$(n/2.0)]
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output mosaic NDF. [Output from MAKEMOS]
      }
      \sstsubsection{
         TOLS = \_REAL (Read)
      }{
         This parameter defines the accuracy tolerance to be achieved
         when inter-comparing pairs of input NDF data arrays to
         determine their relative scale-factor. It is only used if the
         inter-comparison is to be performed iteratively, which will be
         the case if (a) both the SCALE and ZERO parameters have been
         set to TRUE, or (b) SCALE has been set to TRUE and statistical
         error (variance) information obtained from the input NDFs is
         being used to weight the data during the inter-comparison.

         The value given for TOLS specifies the tolerable fractional
         error in the estimation of the relative scale-factor between
         any pair of input NDFs. This value must be positive.
         [0.001]
      }
      \sstsubsection{
         TOLZ = \_REAL (Read)
      }{
         This parameter defines the accuracy tolerance to be achieved
         when inter-comparing pairs of input NDF data arrays to
         determine their relative zero-points. It is only used if the
         inter-comparison is to be performed iteratively, which will be
         the case if both the SCALE and ZERO parameters have been set
         to TRUE.

         The value given for TOLZ specifies the tolerable absolute
         error in the estimation of the relative zero-point between any
         pair of input NDFs whose relative scale-factor is unity. If
         the relative scale-factor is also being estimated, then the
         value used is multiplied by this relative scale-factor
         estimate (which reflects the fact that an NDF with a larger
         data range can tolerate a larger error in estimating its
         zero-point). The TOLS value supplied must be positive.
         [0.05]
      }
      \sstsubsection{
         USEVAR = \_LOGICAL (Read)
      }{
         The value of this parameter specifies whether statistical
         error (variance) information contained in the input NDFs
         should be used to weight the input data when they are combined
         to produce the output mosaic. This parameter is only used if
         all the input NDFs contain variance information, in which case
         the default behaviour is to use this information to correctly
         weight the data values being combined. If output variances are
         to be generated (specified by the GENVAR parameter) then this
         parameter (and GENVAR) should be set TRUE.

         If insufficient input variance information is available, or if
         USEVAR is set to FALSE, then weights are instead derived from
         the scale-factor corrections applied to each NDF (see the
         WEIGHTS parameter for details); unit weight is used if no
         scale-factor corrections are being applied. Alternatively,
         explicit weights may be given for each input NDF via the
         WEIGHTS parameter.
         [TRUE]
      }
      \sstsubsection{
         WEIGHTS( ) = \_REAL (Read)
      }{
         A set of positive weighting factors to be used to weight the
         input NDFs when they are combined. If this parameter is used,
         then one value should be given for each input NDF and the
         values should be supplied in the same order as the input NDFs.
         If a null (!) value is given (the default) then a set of
         weights will be generated internally - these will normally all
         be unity unless scale-factor corrections are being applied
         (see the SCALE parameter), in which case the reciprocal of the
         scale factor correction for each input NDF is used as its
         weight. This corresponds to the assumption that variance is
         proportional to data value in each input NDF.

         This parameter is only used if the USEVAR parameter is set to
         FALSE or if one or more of the input NDFs does not contain
         variance information. Otherwise, the input variance values are
         used to weight the input data when they are combined.
         [!]
      }
      \sstsubsection{
         ZERO = \_LOGICAL (Read)
      }{
         This parameter specifies whether MAKEMOS should attempt to
         adjust the input data values by applying zero-point (i.e.\
         additive) corrections before combining them into a mosaic.
         This would be appropriate, for instance, if a series of images
         had been obtained with differing background (sky) values; to
         combine them without correction would yield a mosaic with
         discontinuities at the image edges where the data values
         differ.

         If ZERO is set to TRUE, then MAKEMOS will inter-compare the
         NDFs supplied as input and will estimate the relative
         zero-point difference between selected pairs of input data
         arrays where they overlap.  From this information, a global
         set of additive corrections will be derived which make the
         input data as mutually consistent as possible. These
         corrections will be applied to the input data before they are
         combined into a mosaic.

         Calculation of zero-point corrections may also be combined
         with the use of scale-factor corrections (see the SCALE
         parameter). By default, no zero-point corrections are applied.
         [FALSE]
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         MAKEMOS}{ $*$ MYMOS
      }{
         Combines the set of NDFs matching the wild-card {\tt "}$*${\tt "} 
         into a
         single mosaic called {\ssttt MYMOS}. By default, no normalisation
         corrections are applied to the input data, which are combined
         by taking the median in regions where several input NDFs
         overlap.
      }
      \sstexamplesubsection{
         MAKEMOS}{ IN={\tt "}A,B,C,D{\tt "} OUT=COMBINED ZERO
      }{
         Combines the four overlapping input NDFs {\ssttt A}, {\ssttt B}, 
         {\ssttt C} and {\ssttt D} into a
         single mosaic called {\ssttt COMBINED}. Optimised zero-point
         corrections are derived and applied to the data before
         combining them so as to make them as mutually consistent as
         possible. This helps to eliminate unwanted discontinuities in
         the output mosaic.
      }
\newpage
      \sstexamplesubsection{
         MAKEMOS}{ {\tt "}A,B,C,D{\tt "} OUT=COMBINED SCALE
      }{
         Combines the four NDFs {\ssttt A}, {\ssttt B}, 
         {\ssttt C} and {\ssttt D} as above, but makes
         optimised corrections to the scale factor of each (i.e.\
         multiplies each by an appropriate constant) before they are
         combined. This would be appropriate if, for instance, the
         input data were CCD frames acquired using different exposure
         times and had subsequently had their sky background removed.
      }
      \sstexamplesubsection{
         MAKEMOS}{ IN=FRAME$*$ OUT=RESULT SCALE ZERO
      }{
         Combines the set of input NDFs matching the wild-card 
         {\ssttt "FRAME$*$"}
         into a single mosaic called {\ssttt RESULT}. Optimised scale factor 
         and
         zero point corrections are applied before combining the data.
         This would be appropriate if, for instance, the input data had
         been acquired using different exposure times and also had
         different levels of sky background.
      }
      \sstexamplesubsection{
         MAKEMOS}{ IN=FRAME$*$ OUT=RESULT SCALE ZERO MODIFY
      }{
         This is identical to the previous example, except that in
         addition to forming the output {\ssttt RESULT}, the {\ssttt MODIFY} 
         parameter
         causes all the input NDFs to be modified using the same
         optimised corrections as are applied when forming the mosaic,
         thus mutually normalising all the separate NDFs.  Note that
         this feature should be used with care, as information about
         the original normalisation of the input data will be lost.
         When {\ssttt MODIFY} is specified, a null value {\tt "}!{\tt "} 
         may be given for
         the {\ssttt OUT} parameter if an output mosaic is not actually
         required.
      }
      \sstexamplesubsection{
         MAKEMOS}{ {\tt "}A,B,C,D{\tt "} RESULT SCALE ZERO REF=B
      }{
         This example merges the four input NDFs {\ssttt A}, {\ssttt B}, 
         {\ssttt C} and {\ssttt D} into a
         mosaic called {\ssttt RESULT}. In calculating the optimised scale
         factor and zero point corrections to apply, {\ssttt B} is regarded 
         as a
         {\tt "}reference NDF{\tt "} and the other NDFs are normalised to it. 
         This
         means that if {\ssttt B} has previously been calibrated, then the
         output mosaic will inherit this calibration.
      }
      \sstexamplesubsection{
         MAKEMOS}{ {\tt "}A,B,C,D{\tt "} RESULT SCALE ZERO REF=E
      }{
         This example is identical to that above, except that the
         {\tt "}reference NDF{\tt "} {\ssttt E} is not one of the 
         input NDFs and will not
         form part of the output mosaic. Nevertheless, the scale factor
         and zero point corrections applied will be such that all the
         input NDFs are normalised to it (the reference NDF must
         overlap with at least one of the input NDFs). Thus, if {\ssttt E} has
         been calibrated, this calibration will be transferred to the
         output mosaic (note that if {\ssttt MODIFY} is specified, then the
         calibration could also be transferred to each of the input
         NDFs).
      }
      \sstexamplesubsection{
         MAKEMOS}{ FRAME$*$ MOSAIC NOPRESERVE NOGENVAR METHOD=MINMAX SKYSUP=0
      }{
         This example illustrates some of the less commonly used
         MAKEMOS options. {\ssttt NOPRESERVE} causes the output data type to be
         a floating point type rather than preserving the input data
         type, {\ssttt NOGENVAR} prevents generation of an output 
         variance array
         (possibly to save space with a large mosaic), {\ssttt METHOD = MINMAX}
         indicates that output pixels are to be calculated by taking
         the mean of input pixels after discarding the lowest and
         highest values, and {\ssttt SKYSUP = 0} is used to disable the 
         sky noise
         suppression algorithm (perhaps for data which contain few sky
         pixels).
      }
   }
   \sstdiytopic{
      Algorithms Used
   }{
      Some of the algorithms used by MAKEMOS require a little
      explanation.  The first of these is used to inter-compare
      overlapping regions of the input NDFs to determine their relative
      scale-factor and zero-point difference (in the most general
      case). In effect, this algorithm has to fit a straight line to a
      scatter plot representing the pixel values in the two overlapping
      NDFs.

      Rather than use a conventional least-squares fit for this
      purpose, which would be sensitive to spurious data, a fit based
      on minimization of the sum of the absolute values of the
      residuals is used instead. This is considerably more robust. It
      also allows the residuals to be defined by the perpendicular
      distance of each point from the fitted line, rather than the
      vertical distance used in conventional least squares. In turn,
      this removes the distinction between dependent and independent
      variables and allows the statistical uncertainty on both axes
      (described by an error ellipse) to be properly taken into account
      along with other weighting factors used to implement sky noise
      suppression.

      In general, this fitting algorithm is iterative and is controlled
      via the MAXIT, TOLS and TOLZ parameters which specify the
      convergence criteria. However, in some important cases the fit
      can be obtained in a single pass, with consequent savings in
      execution time. This occurs if:
      \sstitemlist{

         \sstitem
            Only zero-point corrections are being determined, or

         \sstitem
            Only scale-factor corrections are being determined and no
               input variance information is being used to weight the
               inter-comparison process (see the CMPVAR parameter).

      }
      The second stage of normalisation involves a global optimisation
      process which seeks to determine the best corrections to be
      applied to each input NDF. The algorithm which performs this task
      makes a guess at the best corrections to apply and then
      calculates the scale-factor and/or zero-point differences which
      would remain between each pair of overlapping NDFs if they were
      corrected in this way. These corrections are then adjusted until
      the weighted sum of squares of the remaining differences is
      minimized. The weights used in this process are derived from
      error estimates produced by the earlier (inter-comparison)
      algorithm. This allows information about the required corrections
      to be optimally combined from many overlaps, even in cases where
      individual overlaps may be small and contain inadequate
      information on their own.

      The algorithm used for combining the separate input NDFs into a
      mosaic requires no special explanation, except to note that it is
      designed to operate on large mosaics without making excessive
      demands on system resources such as memory. It does this by
      partitioning the mosaic into small regions for processing.
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      Most parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.
      The exceptions to this rule are:
      \sstitemlist{

         \sstitem
            SKYSUP  -- dynamically defaulted

         \sstitem
            SCALE   -- always FALSE

         \sstitem
            ZERO    -- always FALSE

         \sstitem
            MODIFY  -- always FALSE

         \sstitem
            TITLE   -- always {\tt "}Output from MAKEMOS{\tt "}

      }
      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      on new datasets/different devices, or after a break of sometime.
      The intrinsic default behaviour of the application may be
      restored by using the RESET keyword on the command line.

      Certain parameters (LOGTO, LOGFILE and PRESERVE) have global
      values. These global values will always take precedence, except
      when an assignment is made on the command line. Global values may
      be set and reset using the CCDSETUP and CCDCLEAR commands.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1992 Science \& Engineering Research Council
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         MAKEMOS supports {\tt "}bad{\tt "} pixel values and all non-complex data
           types, with arithmetic being performed using the appropriate
           floating point type. It can process NDFs with any number of
           dimensions. The DATA, TITLE and VARIANCE components of an NDF
           are directly supported, with the AXIS, HISTORY, LABEL, 
           QUALITY
           and UNITS components and all extensions being propagated from
           the first input NDF supplied (note that AXIS values, if
           present, will normally be extrapolated as a result of
           propagation to the output mosaic, which will typically have a
           larger extent than any of the input NDFs).
      }
   }
}



\newpage
\label{des:pairndf}
\sstroutine{
   PAIRNDF
}{
   Displays and manipulates image pairs to allow easy registration
}{
   \sstdescription{
      This routine accepts a list of NDFs which may be aligned using
      simple offsets. In a first interactive section pairs of images
      may be selected from a palette of images (which are drawn down
      the side of the display). Passing on to a second section the
      chosen pair of images may then be manipulated by selecting a
      reference position on one and then indicating where the
      corresponding position on the second is. The reference image is
      then moved and overlaid on the second. In any overlap regions the
      image display values are averaged. If the pair of images are
      overlaid (registering them) then a third section may be entered
      in which the cursor can be used to pick out the positions of
      image features in the overlap region. The image features are then
      centroided to get accurate positions.

      You are required to choose all the pairings required to
      completely register all frames (the routine will not exit
      until enough images have been paired to allow this, and a policy
      to ensure completeness is enforced by insisting that each pair,
      except for the first, contains one previously paired image).
      When this is complete a global merger of the all the positions
      for each NDF takes place. This results in the output of one list
      of uniquely labelled positions for each NDF. These position lists
      can then be used in a routine such as REGISTER to produce the
      actual transformation between the NDFs.
   }
   \sstusage{
      PAIRNDF IN OUTLIST DEVICE PERCENTILES
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image display device.
         [Current image display device]
      }
      \sstsubsection{
         FILLFRAC = \_DOUBLE (Read)
      }{
         The largest fraction of the display area which the images
         displayed in the scratch region (the part where they can be
         manipulated) may take. A value will always be in the
         range 0.05 to 0.95.
         [0.55]
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         A list of NDF names which contain the data components to be
         displayed. The specification of the names of the NDFs follows
         the usual CCDPACK methods, namely:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines; {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "} etc.
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is {\tt "}$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection files using the
         character {\tt "}\#{\tt "}.
      }
      \sstsubsection{
         KEEPLUT = \_LOGICAL (Read)
      }{
         Whether to retain the current device look-up-table. If FALSE
         then a greyscale look-up-table is loaded. PAIRNDF loads the
         primary colours into the first few pens regardless of the
         value of this parameter.
         [TRUE]
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MAKEBIG = \_LOGICAL (Read)
      }{
         If TRUE then images will be scaled to fit into the whole of
         the FILLFRAC area. If FALSE then scaling will never exceed
         one device pixel per NDF pixel. This latter option decreases
         the time needed to process images from the display palette
         into the scratch region.
         [TRUE]
      }
      \sstsubsection{
         MEMORY = \_INTEGER (Read)
      }{
         The memory of the device which is to be used. This can take
         the values 0 and 1. 0 means the base memory and 1 the overlay.
         [0]
      }
      \sstsubsection{
         MSIZE = \_REAL (Read)
      }{
         Determines the size of the position marker. This is set as a
         fraction of the X dimension of the display.
         [0.03]
      }
      \sstsubsection{
         NAMELIST = LITERAL (Read)
      }{
         The name of a file to contain the names of the output
         position lists. The names written to this file are those
         generated using the expression given to the OUTLIST parameter.
         This file may be used in an indirection expression to input
         all the position lists output from this routine into another
         routine, if the associating position lists with NDFs option is
         not being used.
         [PAIRNDF.LIS]
      }
      \sstsubsection{
         OUTLIST = LITERAL (Read)
      }{
         An expression which is either a list of names or expands to a
         list of names for the output position lists.

         These may be specified as list of comma separated names,
         using indirection if required, OR, as a single modification
         element (of the input names). The simplest modification
         element is the asterisk {\tt "}$*${\tt "} which means call each of the
         output lists the same name as the corresponding input NDFs (but
         without the {\tt "}.SDF{\tt "} extension).
         So,
         \begin{description}
            \item IN $>$ $*$
            \item OUTLIST $>$ $*$
         \end{description}
         signifies that all the NDFs in the current directory should be
         used and the output lists should have the same names. On VMS
         this will create position lists with the extension {\tt "}.dat{\tt "}. On
         UNIX a file of this name with no extension will be created.
         Other types of modification can also occur, such as,
         \begin{description}
            \item OUTLIST $>$ $*$\_OBJS.DAT
         \end{description}
         which means call the position lists the same as the input NDFs
         but put {\tt "}\_OBJS.DAT{\tt "} after the names. Replacement of a specified
         string with another in the output file names can also be used,
         \begin{description}
            \item OUTLIST $>$ $*$$|$\_DEBIAS$|$\_IMAGES.DAT$|$
         \end{description}
         this replaces the string {\tt "}\_DEBIAS{\tt "} with {\tt "}\_IMAGES.DAT{\tt "} in any
         of the output names.

         If wildcarded names for the input NDFs are used then is it
         recommended that wildcards are also used for the position list
         names as the correspondence between these may be confusing.
         [$*$.DAT]
      }
      \sstsubsection{
         PALFRAC = \_DOUBLE (Read)
      }{
         The fraction of display X-dimension which is reserved for the
         image palette. A value will always be in the range
         0.05 to 0.95.
         [0.25]
      }
      \sstsubsection{
         PERCENTILES( 2 ) = \_DOUBLE (Read)
      }{
         The percentile data range to use as limits when displaying the
         images. Must be in the range 0 to 100. Using percentiles as
         display limits automatically adjusts the data ranges of the
         images to show similar information levels. This helps when
         combining the data using a mean as a crude normalisation has
         been performed.
         [2,98]
      }
      \sstsubsection{
         THICK = \_INTEGER (Read)
      }{
         The thickness of the position marker in device pixels.
         [3]
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PAIRNDF}{ $*$  $*$.DAT XW [1,99]
      }{
         In this routine the positional nature of the parameters is
         shown. All the NDFs in the current directory are displayed.
         Their output positions lists have the same name as the NDFs
         except that they have a file type of {\ssttt .DAT}. An Xwindows (GWM)
         display is used and the images are displayed using the
         percentile limits {\ssttt 1,99} which shows bright detail well.
      }
      \sstexamplesubsection{
         PAIRNDF}{ IN=$*$\_DEBIAS OUTLIST=$*$.OBJECTS DEVICE=IKON MEMORY=1
      }{
         This example shows how to use the {\ssttt IKON} overlay device to
         display the images.
      }
      \sstexamplesubsection{
         PAIRNDF}{ MSIZE=0.1 THICK=7
      }{
         In this example the cross which is used to identify the
         image features is made very large and thick.
      }
      \sstexamplesubsection{
         PAIRNDF}{ FILLFRAC=0.75 KEEPLUT PALFRAC=0.15
      }{
         The parameters used in this example will make the images
         displayed in the scratch region larger than the default. This
         can be useful when the images have a long and a short side as
         a scale factor is chosen which maps one of the image sides to
         the scratch side exactly so images can be scaled and still be
         all visible. {\ssttt KEEPLUT} keeps the look-up-table loaded in the
         current device (say a colour one). Reducing {\ssttt PALFRAC} to
{\ssttt 0.15}
         makes the scratch display surface larger but has the
         disadvantage that the images in the palette are small (perhaps
         too small to identify image features, but this needn't be a
         problem as images may be drawn into the scratch region -- for
         inspection side-by-side -- during the pair selection phase).
      }
   }
\newpage
   \sstnotes{
      \sstitemlist{

         \sstitem
         Interactive sections.

      }

       There are three distinct sections in PAIRNDF. In the first
       section a pair of images should be chosen from the palette.
       Choosing an image is performed by simply placing the cursor on
       the image and pressing the left-hand button. to select an image
       for display on the left and the right button to display an
       image on the right. Two images must be chosen before a
       progression to the next section is allowed.  When an image is
       chosen it is rescaled and displayed in the scratch region.
       During the first pass any two images may be chosen,
       subsequently at least one image which has already been chosen
       (and successfully processed) must be used (you may of course
       select two processed images if you like). This ensures that
       the final registration is complete. Images which have been
       processed are probably outlined in green. You are not
       restricted to the first pair of images chosen - just keep
       pointing at images you want to expand into the scratch region
       until you have a pair with image features in common.

       After selecting the pair of images you want to register you
       must pass on to a second stage, this is entered by pressing the
       right-hand button, the title "Align the images" will then
       appear. These two images may now be moved. This is achieved by
       first selecting a reference point on one of the images (say a
       star which is clearly visible on both images) then moving the
       cursor onto it and pressing the left-hand button (accuracy is
       not critical as positions will be centroided later, but if
       you're using X-windows -- see the next section -- then zooming
       in on a feature allows very accurate placements). Next move the
       cursor to the corresponding image feature on the second image
       and press the centre button. The routine will now move the
       reference image onto the new position. In areas where the
       images overlap a mean is taken.

       The final interactive section is used to select the positions of
       image features in the overlap regions. These are selected by
       moving the cursor onto them and pressing the left-hand button.
       When you have selected as many image features as you require
       pressing the right-hand button exits this section. The features
       (on both images) are then centroided. If enough information has
       now been given to register all the frames then the routine 
       passes out of the interaction session and determines the 
       registration.
      \sstitemlist{

         \sstitem
         X windows display.

      }
        When the chosen device is an X windows
        display then several additional interactions beyond the standard
        ones are available. Using keyboard I and O keys it is possible
        to zoom-in and zoom-out. The arrow keys allow the memory to be
        scrolled, pressing the shift key at the same time increases the
        rate of scroll. The C key performs a quick re-centre, cancelling
        any zoom and scroll. The Q key aborts the routine.

      \sstitemlist{

         \sstitem
         NDF extension items.

      }
        On exit the CURRENT\_LIST items in the CCDPACK extensions
        (.MORE.CCDPACK) of the input NDFs are set to the names of the
        appropriate output lists. These items will be used by other
        CCDPACK position list processing routines to automatically
        access the lists.

      \sstitemlist{

         \sstitem
         Output position list format.

      }
        CCDPACK format - Position lists in CCDPACK are formatted files
        whose first three columns are interpreted as the following.

      \sstitemlist{

         \sstitem
              Column 1: an integer identifier

         \sstitem
              Column 2: the X position

         \sstitem
              Column 3: the Y position

      }
        The column one value must be an integer and is used to identify
        positions which may have different locations but are to be
        considered as the same point. Comments may be included in the
        file using the characters \# and !. Columns may be separated by
        the use of commas or spaces.
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      All parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.

      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application.  The intrinsic
      default behaviour of the application may be restored by using the
      RESET keyword on the command line.

      Certain parameters (LOGTO and LOGFILE) have global values. These
      global values will always take precedence, except when an
      assignment is made on the command line.  Global values may be set
      and reset using the CCDSETUP and CCDCLEAR commands.

      The DEVICE parameter also has a global association. This is not
      controlled by the usual CCDPACK mechanisms, instead it works in
      co-operation with KAPPA (SUN/95) image display/control routines.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Supports Bad pixel values and all non-complex data types.
      }
   }
}

\newpage
\label{des:plotlist}
\sstroutine{
   PLOTLIST
}{
   Draws position markers on a graphics display
}{
   \sstdescription{
      This routine draws a variety of markers (crosses, circles,
      squares etc.) at positions specified in series of position lists.
      Before this application can be run an image (or other graphical
      output such as a contour image) must have been displayed using a
      suitable routine such as KAPPA DISPLAY (SUN/95).
   }
   \sstusage{
      PLOTLIST INLIST [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         This parameter controls whether or not the display device
         is cleared before plotting the markers. Setting this TRUE could
         be useful if plotting in a device overlay.
         [FALSE]
      }
      \sstsubsection{
         DEVICE = DEVICE (Write)
      }{
         The name of the device on which to plot the markers.
         [Current display device]
      }
      \sstsubsection{
         INLIST = LITERAL (Read)
      }{
         This parameter is used to access the names of the lists which
         contain the positions and, if NDFNAMES is TRUE, the names of
         the associated NDFs. If NDFNAMES is TRUE the names of the
         position lists are assumed to be stored in the extension of
         the NDFs (in the CCDPACK extension item CURRENT\_LIST) and the
         names of the NDFs themselves should be given (and may include
         wildcards).

         If NDFNAMES is FALSE then the actual names of the position
         lists should be given. These may not use wildcards but may be
         specified using indirection (other CCDPACK position list
         processing routines will write the names of their results files
         into files suitable for use in this manner) the indirection
         character is {\tt "}$\wedge${\tt "}.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP,
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         MSIZE = \_REAL (Read)
      }{
         The size of the marker which will be drawn as a multiple of
         the default value. So for instance doubling the value of this
         parameter will increase the size of the markers by a factor of
         two. The default marker size is around 1/40 of the lesser of
         the width or height of the plot.
         [2.5]
      }
      \sstsubsection{
         MTYPE = \_INTEGER (Read)
      }{
         The type of marker to plot at the positions given in the input
         files. PGPLOT Graph Markers are drawn if the value lies in the
         range 0-31 (a value of 2 gives a cross, 7 a triangle, 24-27
         various circles etc.\ see the PGPLOT manual). If the value of
         this parameter is less than zero then the identifier values,
         which are in column one of the input file, will be written over
         the objects.
         [2]
      }
      \sstsubsection{
         NDFNAMES = \_LOGICAL (Read)
      }{
         If TRUE then the routine will assume that the names of the
         position lists are stored in the NDF CCDPACK extensions under
         the item {\tt "}CURRENT\_LIST{\tt "}.

         If a global value for this parameter has been set using
         CCDSETUP then that value will be used.
         [TRUE]
      }
      \sstsubsection{
         PALNUM = \_INTEGER (Read)
      }{
         The pen number to use when drawing the markers.  The colours
         associated with these pens are the default PGPLOT pens (see
         the PGPLOT manual for a complete description). These are:
         \sstitemlist{

            \sstitem
               0 -- background colour

            \sstitem
               1 -- foreground colour

            \sstitem
               2 -- red

            \sstitem
               3 -- green

            \sstitem
               4 -- blue

            \sstitem
               5 -- cyan

            \sstitem
               6 -- magenta

            \sstitem
               7 -- yellow

            \sstitem
               8 -- orange

         }
         and so on up to pen 16 (or up to the number available on the
         current graphics device). After PLOTLIST has been run these
         colours can be superseded by using the KAPPA palette
         facilities PALDEF and PALENTRY, but note that any subsequent
         runs of PLOTLIST will reinstate the PGPLOT default colours.
         The KAPPA palette pen numbers correspond to PALNUM values
         (hence the parameter name).
         [3]
      }
      \sstsubsection{
         THICK = \_INTEGER (Read)
      }{
         The thickness of the lines used to draw the markers. This may
         take any value in the range 1-21.
         [1]
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PLOTLIST}{ INLIST=$*$
      }{
         In this example all the NDFs in the current directory are
         accessed and their associated lists of positions are plotted
         onto the current display device.
      }
      \sstexamplesubsection{
         PLOTLIST}{ NDFNAMES=FALSE INLIST=ONE\_LIST.DAT
      }{
         In this example the position list {\ssttt ONE\_LIST.DAT} is opened and
         it's position are plotted on the current display device.
      }
      \sstexamplesubsection{
         PLOTLIST}{ IN=ALIGNED\_$*$ MTYPE=-1 PALNUM=4 MSIZE=1 THICK=3
      }{
         In this example the NDFs {\ssttt ALIGNED\_$*$} 
         have their associated
         position lists accessed and the positions are plotted on the
         current display device. The pen colour used is blue. The
         text is drawn at a relative size of {\ssttt 1} (the normal 
         default  is
         {\ssttt 2.5}) with a line thickness of {\ssttt 3}.
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem Position list formats. 
      }
        CCDPACK supports data in two formats.

        CCDPACK format - the first three columns are interpreted as the
        following.

      \sstitemlist{

         \sstitem
              Column 1: an integer identifier

         \sstitem
              Column 2: the X position

         \sstitem
              Column 3: the Y position

      }
        The column one value must be an integer and is used to identify
        positions which are the same but which have different locations
        on different images. Values in any other (trailing) columns are
        usually ignored.

        EXTERNAL format - positions are specified using just an X and
        a Y entry and no other entries.

      \sstitemlist{

         \sstitem
              Column 1: the X position

         \sstitem
              Column 2: the Y position

      }
        This format is used by KAPPA applications such as CURSOR.

        Comments may be included in a file using the characters {\tt "}\#{\tt "} and
        {\tt "}!{\tt "}. Columns may be separated by the use of commas or spaces.

      \sstitemlist{
         \sstitem NDF extension items. 
      }

       If NDFNAMES is TRUE then the item {\tt "}CURRENT\_LIST{\tt "} of the 
       .MORE.CCDPACK structure of the input NDFs will be located 
       and assumed to contain the names of the lists whose positions 
       are to be plotted. 
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      All parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.

      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application. The intrinsic
      default behaviour of the application may be restored by using the
      RESET keyword on the command line.

      Certain parameters (LOGTO, LOGFILE and NDFNAMES) have global
      values. These global values will always take precedence, except
      when an assignment is made on the command line. Global values may
      be set and reset using the CCDSETUP and CCDCLEAR commands.

      The DEVICE parameter also has a global association. This is not
      controlled by the usual CCDPACK mechanisms, instead it works in
      co-operation with KAPPA (SUN/95) image display/control routines.
   }
}



\newpage
\label{des:register}
\sstroutine{
   REGISTER
}{
   Determines transformations between lists of positions
}{
   \sstdescription{
      This routine determines the transformations between (labelled)
      position lists. Six different types of transformation are
      available. The first 5 are based on the linear transformation,
      the sixth being a function defined by you. The linear
      transformations are based on the mappings
      \begin{description}
         \item X{\tt '} = A $+$ B$*$X $+$ C$*$Y
         \item Y{\tt '} = D $+$ E$*$X $+$ F$*$Y
      \end{description}
      and allow:
      \sstitemlist{

         \sstitem
           shift of origin

         \sstitem
           shift of origin and rotation

         \sstitem
           shift of origin and magnification

         \sstitem
           shift of origin, rotation and magnification (solid body)

         \sstitem
           or a full six parameter fit

      }
      The self defined transform can be any mapping given as an
      algebraic expression (including functions) using the methods
      allowed by TRANSFORM (SUN/61).

      When determining linear transformations REGISTER allows many
      lists to be processed at once performing a simultaneous
      registration of all the lists. When using a self defined
      transform only two lists may be registered at any time.

      The results from REGISTER are reported via the logging system
      and then coded as TRANSFORM structures containing the final
      algebraic solutions for each input list. These structures are
      usually stored in the CCDPACK extensions of the associated NDFs
      and then used by the applications TRANLIST and TRANNDF
      which may be used to transform position lists and resample the
      actual datasets respectively. The transformation structures may
      also be stored within a named HDS container file if no associated
      NDFs exist.
   }
   \sstusage{
      REGISTER INLIST FITTYPE REFPOS
   }
   \sstparameters{
      \sstsubsection{
         CLASS( ) = LITERAL (Read)
      }{
         If CLASSIFY is TRUE then a list of classifications that
         describe the properties of the transformation (parameters
         XFOR, YFOR, XINV and YINV) should be given. This is
         optional, but the information can be used to make other
         applications run more efficiently.  Valid values are:
         \sstitemlist{

            \sstitem
               LINEAR        -- Linear and preserves straight lines.

            \sstitem
               INDEPENDENT   -- Preserves the independence of the axes.

            \sstitem
               DIAGONAL      -- Preserves the axes themselves.

            \sstitem
               ISOTROPIC     -- Preserves angles and shapes.

            \sstitem
               POSITIVE\_DET  -- A component of reflection is absent.

            \sstitem
               NEGATIVE\_DET  -- A component of reflection is present.

            \sstitem
               CONSTANT\_DET  -- The scale factor is constant.

            \sstitem
               UNIT\_DET      -- Areas (or volumes etc.) are preserved.

         }
         See SUN/61 Appendix B for details of transformation
         classification and a table of classifications of common
         mappings.
      }
      \sstsubsection{
         CLASSIFY = \_LOGICAL (Read)
      }{
         If TRUE then this indicates that you want to classify the
         transform. Classifying a transformation can help in later
         processing and allows applications to reject transformations
         that they cannot use. The topic of classification is discussed
         in SUN/61 which should be consulted before using this option.
         Linear transformations are classified by this routine directly
         and do not use this parameter.
         [FALSE]
      }
      \sstsubsection{
         FA-FZ = LITERAL (Read)
      }{
         These parameters supply the values of {\tt "}sub-expressions{\tt "} used in
         the expressions XFOR, YFOR, XINV and YINV. These parameters
         should be used when repeated expressions are present in complex
         transformations. Sub-expressions may contain references to
         other sub-expressions and the variables (PA-PZ).
         An example of using sub-expressions is:
         \begin{description}
            \item XFOR $>$ PA$*$ASIND(FA/PA)$*$X/FA
            \item YFOR $>$ PA$*$ASIND(FA/PA)$*$Y/FA
            \item XINV $>$ PA$*$SIND(FB/PA)$*$XX/FB
            \item YINV $>$ PA$*$SIND(FB/PA)$*$YY/FB
            \item FA $>$ SQRT(X$*$X$+$Y$*$Y)
            \item FB $>$ SQRT(XX$*$XX$+$YY$*$YY)
        \end{description}
      }
      \sstsubsection{
         FITTYPE = \_INTEGER (Read)
      }{
         The type of fit which should be used when determining the
         transformation between the input positions lists. This may take
         the values
         \sstitemlist{

            \sstitem
               1 -- shift of origin

            \sstitem
               2 -- shift of origin and rotation

            \sstitem
               3 -- shift of origin and magnification

            \sstitem
               4 -- shift of origin, rotation and magnification (solid
                      body)

            \sstitem
               5 -- a full six parameter fit

            \sstitem
               6 -- self defined function

         }
         [5]
      }
      \sstsubsection{
         FULL = \_LOGICAL (Read)
      }{
         If FITTYPE=6 is chosen then this is parameter value determines if a
         full transformation is to be performed or not. If FALSE then
         you will only be prompted for expressions for XFOR and
         YFOR and the inverse transformation will remain undefined.

         If TRUE then you will also be prompted for XINV and YINV in
         response to which the inverse mappings for X{\tt '} and Y{\tt '} are
         required. Not performing a full fit will affect the later
         uses of the transformation. At present not providing an inverse
         mapping means that image resampling (TRANNDF) may not be
         performed.
         [FALSE]
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         If NDFNAMES is FALSE and PLACEIN is {\tt "}NDF{\tt "} then a list of NDF
         names in which to store the transformation structures is
         required. This list of names must correspond exactly to the
         order of the associated input lists. A listing of the order
         of inputs is shown before this parameter is accessed.

         The NDF names may (although this is probably not advisable)
         be specified using wildcards, or may be specified using an
         indirection file (the indirection character is {\tt "}$\wedge${\tt "}).
      }
      \sstsubsection{
         INLIST = LITERAL (Read)
      }{
         This parameter is used to access the names of the lists
         which contain the positions and, if NDFNAMES is TRUE, the names
         of the associated NDFs. If NDFNAMES is TRUE the names of the
         position lists are assumed to be stored in the extension of the
         NDFs (in the CCDPACK extension item CURRENT\_LIST) and the names
         of the NDFs themselves should be given (and may include
         wildcards).

         If NDFNAMES is FALSE then the actual names of the position
         lists should be given. These may not use wildcards but may be
         specified using indirection (other CCDPACK position list
         processing routines will write the names of their results files
         into files suitable for use in this manner) the indirection
         character is {\tt "}$\wedge${\tt "}.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         NDFNAMES = \_LOGICAL (Read)
      }{
         This parameter specifies whether the names of the input
         positions lists are stored in the CCDPACK extensions of NDFs.
         If TRUE then the INLIST parameter accesses a list of NDFs
         which are used to get the associated positions lists. If FALSE
         then INLIST just accesses the position list names directly.

         If the names of the lists are stored in the CCDPACK NDF
         extension then the final transformation structure is also
         written to the NDF extension.

         If a global value for this parameter has been set using
         CCDSETUP then that value will be used.
         [TRUE]
      }
      \sstsubsection{
         PA-PZ = LITERAL (Read)
      }{
         When FITTYPE=6 these parameters are used for supplying initial
         guesses at the values of the fit parameters. Normally the
         values of these parameters are not critical, but occasionally
         the minimization routine fails due to numeric problems (these
         are usually caused by trig functions etc. which are given
         invalid values (outside $+$/-1 etc.)).
         [1.0D0]
      }
      \sstsubsection{
         PLACEIN = LITERAL (Read)
      }{
         If NDFNAMES is FALSE then this parameter specifies where
         you would like to store the final transformation structures.
         The options are:
         \sstitemlist{

            \sstitem
               NDF  -- store them in NDF extensions

            \sstitem
               FILE -- store them in a container file.
         }
         If the NDF option is chosen then you will have the option of
         supplying the NDF names via the parameter IN. If the FILE
         option is chosen then the name of an HDS container file should
         be given in response to the TRFILE parameter.
         [NDF]
      }
      \sstsubsection{
         REFPOS = \_INTEGER (Read)
      }{
         The position within the list of inputs which corresponds to
         the list to be used as the reference set.
         [1]
      }
      \sstsubsection{
         TOLER = \_DOUBLE (Read)
      }{
         The RMS tolerance in positions which is used to determine when
         a global fit between all possible positions has been achieved.
         Adjust this value only if the input positions are specified in
         coordinates with a higher accuracy or smaller units. Only used
         with fittypes 1-5.
         [0.001]
      }
      \sstsubsection{
         TRFILE = TRFILE (Read)
      }{
         If PLACEIN is given as {\tt "}FILE{\tt "} then the value of this parameter
         specifies the name of the container file to be used to store
         the resultant transformation structures.
      }
      \sstsubsection{
         XFOR = LITERAL (Read)
      }{
         If FITTYPE=6 then this parameter specifies the parameterised
         algebraic expression to be used as the forward X
         transformation. The expression may use all the functions
         specified in SUN/61 (TRANSFORM) as well as the usual
         mathematical operators ($+$,-,$*$,/,$*$$*$). Functions are
         parameterised by the strings PA,PB,PC...PZ which are the
         values which will be determined. The string must contain at
         least one reference to either X or Y.  So a possible return is
         \begin{description}
             \item PA$+$PB$*$X
         \end{description}
         which is the same as the linear X transformation which just
         applies an offset and a scale factor.
      }
      \sstsubsection{
         XINV = LITERAL (Read)
      }{
         If FITTYPE=6 and FULL=TRUE then this parameter specifies
         the inverse X transformation. The expression may use all the
         functions specified in SUN/61 (TRANSFORM) as well as the usual
         mathematical operations ($+$,-,$*$,/,$*$$*$). Functions are
         parameterised by the strings PA,PB,PC...PZ which are the
         values which will be determined.  This expression must contain
         a reference to either XX or YY. So a possible return is
         \begin{description}
             \item (XX-PA)/PB
         \end{description}
         which is the same as the inverse linear X transformation for an
         offset and scale.
      }
      \sstsubsection{
         YFOR = LITERAL (Read)
      }{
         If FITTYPE=6 then this parameter specifies the parameterised
         algebraic expression to be used as the forward Y
         transformation. The expression may use all the functions
         specified in SUN/61 (TRANSFORM) as well as the usual
         mathematical operators ($+$,-,$*$,/,$*$$*$). Functions are
         parameterised by the strings PA,PB,PC...PZ which are the
         values which will be determined.  The string must contain at
         least one reference to either X or Y.  So a possible return is
         \begin{description}
             \item PC$+$PD$*$Y
         \end{description}
         which is the same as the linear Y transformation which just
         applies an offset and a scale factor.
      }
      \sstsubsection{
         YINV = LITERAL (Read)
      }{
         If FITTYPE=6 and FULL=TRUE then this parameter specifies
         the inverse Y transformation. The expression may use all the
         functions specified in SUN/61 (TRANSFORM) as well as the usual
         mathematical operations ($+$,-,$*$,/,$*$$*$). Functions are
         parameterised by the strings PA,PB,PC...PZ which are the
         values which will be determined.  This expression must contain
         a reference to either XX or YY. So a possible return is
         \begin{description}
             \item (YY-PC)/PD
         \end{description}
         which is the same as the inverse linear Y transformation for an
         offset and scale.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         REGISTER}{ INLIST=$*$ FITTYPE=1
      }{
         In this example all the NDFs in the current directory are
         accessed and their associated position lists are opened.
         A global fit between all the datasets is then performed
         which results in estimates for the offsets from the first input
         NDF{\tt '}s position. The results are then coded as transform
         structures in the CCDPACK extensions of the NDFs (under the
         item TRANSFORM). The transform structures are arranged so that
         the forward transformation maps current positions into the
         reference coordinate system.
      }
      \sstexamplesubsection{
         REGISTER}{ INLIST=$*$ TRTYPE=5
      }{
         This example works as above but this time the global
         transformations are derived for a full 6-parameter linear fit
         (which allows offset, rotation, magnification and shear).
      }
      \sstexamplesubsection{
         REGISTER}{ INLIST={\tt "}MYNDF1,MYNDF2{\tt "} FITTYPE=4 REFPOS=2
      }{
         In this example a solid body fit is performed between the
         position lists associated with the NDFs {\ssttt MYNDF1} and 
         {\ssttt MYNDF2}.
         The reference positions are chosen to be those associated with
         {\ssttt MYNDF2}.
      }
      \sstexamplesubsection{
         REGISTER}{ INLIST={\tt "}ONE,TWO{\tt "} FITTYPE=6 
         XFOR=PA$+$PB$*$X YFOR=PA$+$PB$*$Y
      }{
         In this example the positions lists associated with the NDFs
         {\ssttt ONE} and {\ssttt TWO} are said to be related by the 
         algebraic
         expressions {\ssttt "PA$+$PB$*$X"} and {\ssttt "PA$+$PB$*$Y"},
         which indicates that a
         single offset applies in both directions and a single scale
         factor. A solution for the values {\ssttt PA} and {\ssttt PB}
         is found using a
         general least-squares minimization technique. Starting values
         for {\ssttt PA} and {\ssttt PB} can be given using the 
         parameters {\ssttt PA} and {\ssttt PB}.
      }
      \sstexamplesubsection{
         REGISTER}{ INLIST={\tt "}NDF1,NDF2{\tt "} FITTYPE=6 XFOR=PA$+$PB$*$X$+$PC$*$Y$+$PD$*$X$*$Y
               YFOR=PE$+$PF$*$X$+$PG$*$Y$+$PH$*$X$*$Y
      }{
         In this example an non-linear transformation is fit between the
         positions associated with the NDFs {\ssttt NDF1} and 
         {\ssttt NDF2}. This analysis
         may help in determining whether a 6-parameter fit is good
         enough, or if you just want to transform positions. A problem
         with proceeding with this transformation in a general fashion
         is deriving the inverse as this is required if you want to
         perform image resampling.
      }
      \sstexamplesubsection{
         REGISTER}{ NDFNAMES=FALSE INLIST={\tt "}LIST1.ACC,LIST2.ACC,LIST3.ACC{\tt "}
               FITTYPE=3 PLACEIN=NDF IN={\tt "}NDF1,NDF2,NDF3{\tt "}
      }{
         In this example the input position lists are not associated
         with NDFs ({\ssttt NDFNAMES = FALSE}) and have to be 
         specified by name
         (no wildcards allowed). Since the position lists are not
         associated with NDFs there is no natural home for the
         transform structures. In this example it has been decided to
         place the transforms in NDFs anyway. {\ssttt PLACEIN} could 
         also be
         given as {\ssttt "FILE"} in which case the transform 
         structures are
         written to a container file, under the items 
         {\ssttt TRN\_1, TRN\_2} \ldots
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Position list formats.

      }
        CCDPACK supports data in two formats.

        CCDPACK format - the first three columns are interpreted as the
        following.

      \sstitemlist{

         \sstitem
              Column 1: an integer identifier

         \sstitem
              Column 2: the X position

         \sstitem
              Column 3: the Y position

      }
        The column one value must be an integer and is used to identify
        positions which are the same but which have different locations
        on different images. Values in any other (trailing) columns are
        usually ignored.

        EXTERNAL format - positions are specified using just an X and
        a Y entry and no other entries.

      \sstitemlist{

         \sstitem
              Column 1: the X position

         \sstitem
              Column 2: the Y position

      }
        This format is used by KAPPA applications such as CURSOR.

        Comments may be included in a file using the characters {\tt "}\#{\tt "} and
        {\tt "}!{\tt "}. Columns may be separated by the use of commas or spaces.

        Files with EXTERNAL format may be used with this application but
        all positions have to be present in all lists, no missing
        positions are allowed.

      \sstitemlist{

         \sstitem
         NDF extension items.

      }
        If NDFNAMES is TRUE then the item {\tt "}CURRENT\_LIST{\tt "} of the
        .MORE.CCDPACK structure of the input NDFs will be located
        and assumed to contain the names of the lists whose positions
        are to be used for registration.

        On exit an item {\tt "}TRANSFORM{\tt "} will be added to any input NDFs.
        This contains the registration information as a TRANSFORM
        structure and may be inspected using the ADAM utility TRACE
        (SUN/102).
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      All parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.

      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      on new datasets or after a break of sometime.  The intrinsic
      default behaviour of the application may be restored by using the
      RESET keyword on the command line.

      Certain parameters (LOGTO, LOGFILE and NDFNAMES) have global
      values. These global values will always take precedence, except
      when an assignment is made on the command line.  Global values may
      be set and reset using the CCDSETUP and CCDCLEAR commands.
   }
}

\newpage
\label{des:tranlist}
\sstroutine{
   TRANLIST
}{
   Transform lists of positions
}{
   \sstdescription{
      This routine transforms positions stored in position lists.
      Transformations are defined either by a set of 6 coefficients
      for the linear transform, by an algebraic expression given by
      you, or by using a forward or inverse mapping from a TRANSFORM
      structure (as created by REGISTER).
   }
   \sstusage{
      TRANLIST INLIST OUTLIST TRTYPE
   }
   \sstparameters{
      \sstsubsection{
         FA-FZ = LITERAL (Read)
      }{
         These parameters supply the values of {\tt "}sub-expressions{\tt "} used in
         the expressions XFOR and YFOR. These parameters
         should be used when repeated expressions are present in complex
         transformations. Sub-expressions may contain references to
         other sub-expressions and constants (PA-PZ).
         An example of using sub-expressions is:
         \begin{description}
            \item XFOR $>$ PA$*$ASIND(FA/PA)$*$X/FA
            \item YFOR $>$ PA$*$ASIND(FA/PA)$*$Y/FA
            \item FA $>$ SQRT(X$*$X$+$Y$*$Y)
            \item PA $>$ 100D0
         \end{description}
      }
      \sstsubsection{
         FORWARD = \_LOGICAL (Read)
      }{
         If TRTYPE={\tt "}STRUCT{\tt "} is chosen then this parameter{\tt '}s value
         controls whether the forward or inverse mapping in the
         transform structure is used.
         [TRUE]
      }
      \sstsubsection{
         INEXT = \_LOGICAL (Read)
      }{
         If NDFNAMES is TRUE and the transformation is to be specified
         using a TRANSFORM structure (TRTYPE={\tt "}STRUCT{\tt "}) then this
         parameter controls whether or not the structure should be
         located in the CCDPACK extensions of the NDFs.

         If this option is chosen then the transform structure in EACH
         NDF will be applied to the associated position list. So for
         instance if you have a set of registered NDFs and positions
         these may be transformed all at once to and from the reference
         coordinate system.
         [TRUE]
      }
      \sstsubsection{
         INLIST = LITERAL (Read)
      }{
         This parameter is used to access the names of the lists which
         contain the positions and, if NDFNAMES is TRUE, the names of
         the associated NDFs. If NDFNAMES is TRUE the names of the
         position lists are assumed to be stored in the extension of
         the NDFs (in the CCDPACK extension item CURRENT\_LIST) and the
         names of the NDFs themselves should be given in response (and
         may include wildcards).

         If NDFNAMES is FALSE then the actual names of the position
         lists should be given. These may not use wildcards but may be
         specified using indirection (other CCDPACK position list
         processing routines will write the names of their results
         files into a file suitable for use in this manner) the
         indirection character is {\tt "}$\wedge${\tt "}.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         NAMELIST = \_FILENAME
      }{
         Only used if NDFNAME is FALSE. This specifies the name of a
         file to contain a listing of the names of the output lists.
         This file may then be used to pass the names onto another CCDPACK
         application using indirection.
         [TRANLIST.LIS]
      }
      \sstsubsection{
         NDFNAMES = \_LOGICAL (Read)
      }{
         If TRUE then the routine will assume that the names of the
         position lists are stored in the NDF CCDPACK extensions under
         the item {\tt "}CURRENT\_LIST{\tt "}. The names will be present in the
         extension if the positions were located using a CCDPACK
         application (such as FINDOBJ). Using this facility allows the
         transparent propagation of position lists through processing
         chains.

         If a global value for this parameter has been set using
         CCDSETUP then that value will be used.
         [TRUE]
      }
      \sstsubsection{
         OUTLIST = FILENAME (Write)
      }{
         A list of names specifying the result files. The names of the
         lists may use modifications of the input names (NDF names if
         available otherwise the names of the position lists). So if
         you want to call the output lists the same name as the input
         NDFs except to add a type use.
         \begin{description}
            \item OUTLIST $>$ $*$.FIND
         \end{description}
         If no NDF names are given (NDFNAMES is FALSE) then if you want
         to change the extension of the files (from {\tt "}.CENT{\tt "} to {\tt "}.TRAN{\tt "}
         in this case) use
         \begin{description}
            \item OUTLIST $>$ $*$$|$CENT$|$TRAN$|$
         \end{description}
         Or alternatively you can use an explicit list of names.
         These may use indirection elements as well as names separated
         by commas.
      }
      \sstsubsection{
         PA-PZ = \_DOUBLE (Read)
      }{
         These parameters supply the values of constants used in the
         expressions XFOR and YFOR. Using parameters allows
         the substitution of repeated constants (with extended
         precisions?) using one reference. It allows easy modification
         of parameterised expressions (expressions say with an
         adjustable centre) provided the application has not been used
         to apply a new transform using expressions. The parameter PI
         has a default value of 3.14159265359D0. An example of using
         parameters is:
         \begin{description}
            \item XFOR $>$ SQRT(FX$*$FX$+$FY$*$FY)
            \item YFOR $>$ ATAN2D(-FY,FX)
            \item FX $>$ X-PA
            \item FY $>$ Y-PB
            \item PA $>$ X-centre-value
            \item PB $>$ Y-centre-value
         \end{description}
         This maps (X,Y) to (R,THETA) about a specified centre.
      }
      \sstsubsection{
         TRTYPE = LITERAL (Read)
      }{
         The form of the transformation which is to be applied to the
         positions in the input lists. This can take the values

         \sstitemlist{

            \sstitem
               COEFF

            \sstitem
               EXPRES

            \sstitem
               STRUCT

         }
         or unique abbreviations of.

         COEFF means that a linear transformation of the form
         \begin{description}
               \item X{\tt '} = A $+$ B$*$X $+$ C$*$Y
               \item Y{\tt '} = D $+$ E$*$X $+$ F$*$Y
         \end{description}
         is to be applied to the data. In this case a prompt for the
         values of the coefficients A-F is made.

         EXPRES indicates that you want to supply algebraic-like
         expressions to transform the data. In this case the parameters
         XFOR and YFOR are used to obtain the expressions. Things like
         \begin{description}
             \item XFOR $>$ 2.5$*$COS(X)$+$LOG10(Y)
             \item YFOR $>$ 2.5$*$SIN(X)$+$EXP(Y)
         \end{description}
         are allowed. The expression functions must be in terms of X
         and Y. For a full set of possible functions see SUN/61
         (TRANSFORM).

         STRUCT signifies that a transform structure (probably created
         by REGISTER or CCDEDIT) is to be applied to the data. In this
         case the name of the object containing the structure should
         be supplied (this may be picked up automatically through the
         association of an NDF and a position list) and whether to use
         the forward or inverse mappings.
         [COEFF]
      }
      \sstsubsection{
         TR( 6 ) = \_DOUBLE (Read)
      }{
         If TRTYPE={\tt "}COEFF{\tt "} is chosen then the values of this parameter
         are the 6 coefficients of a linear transformation of the type.
         \begin{description}
               \item X{\tt '} = PA $+$ PB$*$X $+$ PC$*$Y
               \item Y{\tt '} = PD $+$ PE$*$X $+$ PF$*$Y
         \end{description}
         The default is the identity transformation.
         [0,1,0,0,0,1] [PA,PB,PC,PD,PE,PF]
      }
      \sstsubsection{
         TRANSFORM = TRN (Read)
      }{
         If TYPE={\tt "}STRUCT{\tt "} and INEXT=FALSE then this parameter is used to
         access the HDS object which contains the transform structure.
         The standard place to store a transform structure (in CCDPACK)
         is

         \sstitemlist{

            \sstitem
                NDF\_NAME.MORE.CCDPACK.TRANSFORM

         }
         Only one structure can be used at a time.
      }
      \sstsubsection{
         XFOR = LITERAL (Read)
      }{
         If TRTYPE={\tt "}EXPRES{\tt "} is chosen then this parameter specifies the
         transformation that maps to the new X coordinate. The
         expression can contain constants, arithmetic operators
         ($+$,-,/,$*$,$*$$*$) and the functions described in SUN/61
         (SIN,COS,TAN, etc.).

         As an inverse mapping is not required in this application
         there is no need to use the X{\tt '}=func(X,Y) form only func(X,Y)
         is required, however, the variables must be given as
         {\tt "}X{\tt "} and {\tt "}Y{\tt "}.
      }
      \sstsubsection{
         YFOR = LITERAL (Read)
      }{
         If TRTYPE={\tt "}EXPRES{\tt "} is chosen then this parameter specifies the
         transformation that maps to the new Y coordinate. The
         expression can contain constants, arithmetic operators
         ($+$,-,/,$*$,$*$$*$) and the functions described in SUN/61
         (SIN,COS,TAN, etc.).

         As an inverse mapping is not required in this application
         there is no need to use the Y{\tt '}=func(X,Y) form only func(X,Y)
         is required, however, the variables must be given as
         {\tt "}X{\tt "} and {\tt "}Y{\tt "}.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         TRANLIST}{ INLIST=$*$ OUTLIST=$*$.TRAN TRTYPE=STRUCT INEXT=TRUE
               FORWARD=FALSE
      }{
         In this example all the NDFs in the current directory are
         accessed and their associated position lists are opened.
         The transform structures in the NDFs are used to transform the
         associated positions using the inverse mappings. The output
         lists are called {\ssttt NDF\_NAME.TRAN} and are associated 
         with the NDFs.
      }
      \sstexamplesubsection{
         TRANLIST}{ INLIST=$*$\_REDUCED OUTLIST=$*$.OFF TRTYPE=COEFF
               TR=[10,1,0,20,0,1]
      }{
         In this example the position lists associated with the NDFs
         {\ssttt $*$\_REDUCED} are transformed using the linear fit 
         coefficients
         {\ssttt [10,1,0,20,0,1]} resulting in a shift of all the 
         positions in
         these lists of {\ssttt $+$10} in {\ssttt X} and {\ssttt $+$20}
         in {\ssttt Y}. The output lists are
         called {\ssttt NDF\_NAME.OFF} and are now associated with 
         the NDFs.
      }
      \sstexamplesubsection{
         TRANLIST}{ INLIST=$*$\_RESAM OUTLIST=$*$.ROT TRTYPE=COEFF
               TR=[0,0.707,-0.707,0,0.707,0.707]
      }{
         In this example a linear transformation is used to rotate the
         positions by {\ssttt 45} degrees about {\ssttt [0,0]}. The 
         linear coefficients
         for a rotation are specified as 
         {\ssttt [0, COS, -SIN, 0, SIN, COS]}.
      }
      \sstexamplesubsection{
         TRANLIST}{INLIST=HERE OUTLIST=REFLECT.DAT TRTYPE=EXPRESS
               XFOR=-X YFOR=-Y}
        {In this example a transformation expression is used to reflect
         the positions stored in the list associated with NDF 
         {\ssttt HERE}
         about the {\ssttt X} and {\ssttt Y} axes. A similar effect 
         could be achieved
         with {\ssttt TRTYPE = COEFF} and {\ssttt TR = [0,-1,0,0,0,-1]}.
      }
      \sstexamplesubsection{
         TRANLIST}{ INLIST=NDF\_WITH\_LIST OUTLIST=$*$.TRAN TRTYPE=EXPRESS
               XFOR=(FX$*$(1D0$+$PA$*$(FX$*$FX$+$FY$*$FY)))$*$PS$+$PX
               YFOR=(FY$*$(1D0$+$PA$*$(FX$*$FX$+$FY$*$FY)))$*$PS$+$PY
               FX=(X-PX)/PS FY=(Y-PY)/PS
               PA=pincushion\_distortion\_factor PX=X-centre-value
               PY=Y-centre-value PS=scale\_factor
      }{
         In this example a general transformation (which is of the type
         used when applying pin cushion distortions) is applied to the
         position list associated with the NDF 
          {\ssttt NDF\_WITH\_LIST}. The
         transformation is parameterised with an offset and scale
         (converts pixel coordinates to one projection radius units)
         applied to the input coordinates and a pincushion distortion
         parameter {\ssttt PA}.
      }
      \sstexamplesubsection{
         TRANLIST}{ NDFNAMES=FALSE INLIST={\tt "}LIST1,LIST2,LIST3{\tt "}
               OUTLIST={\tt "}OUTLIST1,OUTLIST2,OUTLIST3{\tt "} NAMELIST=NEWFILES
      }{
         In this example the input position lists are not associated
         with NDFs ({\ssttt NDFNAMES = FALSE}) and have to be 
         specified by name
         (no wildcards allowed). The output lists are also specified in
         this fashion, but, the same effect could have been achieved
         with {\ssttt OUTLIST = OUT$*$} as the input list 
         names are now used as as
         modifiers for the output list names (the NDF names are always
         used when they are available -- see previous examples). The
         names of the output lists are written to the file 
         {\ssttt NEWFILES},
         this could be used to specify the names of these files to
         another application using indirection (e.g 
         {\ssttt INLIST = $\wedge$NEWFILES},
         with {\ssttt NDFNAMES = FALSE} again).  The transformation 
         type is not
         specified in this example and will be obtained by prompting.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Position list formats.

      }
        CCDPACK supports data in two formats.

        CCDPACK format - the first three columns are interpreted as the
        following.

      \sstitemlist{

         \sstitem
              Column 1: an integer identifier

         \sstitem
              Column 2: the X position

         \sstitem
              Column 3: the Y position

      }
        The column one value must be an integer and is used to identify
        positions which are the same but which have different locations
        on different images. Values in any other (trailing) columns are
        usually ignored.

        EXTERNAL format - positions are specified using just an X and
        a Y entry and no other entries.

      \sstitemlist{

         \sstitem
             Column 1: the X position

         \sstitem
             Column 2: the Y position

      }
        This format is used by KAPPA applications such as CURSOR.

        Comments may be included in a file using the characters {\tt "}\#{\tt "} and
        {\tt "}!{\tt "}. Columns may be separated by the use of commas or spaces.

      \sstitemlist{

         \sstitem
         NDF extension items.

      }
        If NDFNAMES is TRUE then the item {\tt "}CURRENT\_LIST{\tt "} of the
        .MORE.CCDPACK structure of the input NDFs will be located
        and assumed to contain the names of the lists whose positions
        are to be transformed. On exit this item will be updated to
        reference the name of the transformed list of positions.

        This application may also access the item {\tt "}TRANSFORM{\tt "} from
        the NDF extensions if NDFNAMES and INEXT are TRUE and TRTYPE =
        {\tt "}STRUCT{\tt "}.

      \sstitemlist{

         \sstitem
         In this application data following the third column are copied
           without modification into the results files.
      }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      All parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.

      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      on new datasets or after a break of sometime.  The intrinsic
      default behaviour of the application may be restored by using the
      RESET keyword on the command line.

      Certain parameters (LOGTO, LOGFILE and NDFNAMES) have global
      values. These global values will always take precedence, except
      when an assignment is made on the command line.  Global values may
      be set and reset using the CCDSETUP and CCDCLEAR commands.
   }
}

\newpage
\label{des:tranndf}
\sstroutine{
   TRANNDF
}{
   Transforms a list of NDFs by resampling
}{
   \sstdescription{
      This application performs the arbitrary transformation of a list
      of NDFs using transform structures created by routines such as
      CCDPACK REGISTER and CCDEDIT. The output NDFs are calculated by 
      resampling
      the data of the input NDFs. Output array elements are set to the
      bad value if their inverse-transformed coordinates lie outside
      the corresponding input NDF{\tt '}s coordinate limits.

      NDFs processed within CCDPACK may be resampled using the
      appropriate transformation structures located within the NDF{\tt '}s
      extensions. Using these facilities allows many NDFs to be aligned
      with one invocation.
   }
   \sstusage{
      TRANNDF IN OUT [METHOD]
   }
   \sstparameters{
      \sstsubsection{
         CONSERVE = \_LOGICAL (Read)
      }{
         If CONSERVE is TRUE, the output values are normalised by the
         ratio of the output-to-input pixel areas.  In other words this
         conserves flux.  If CONSERVE is FALSE, there is no
         normalisation.  [TRUE]
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         A list of NDF names whose data are to be transformed. The
         specification of the NDF names follows the usual CCDPACK
         methods, namely:

         A list of NDF names or redirection specifications separated by
         commas. NDF names may include the usual directory listing
         wildcards; {\tt "}$*${\tt "} and {\tt "}\%{\tt "} on VMS machines; 
         {\tt "}$*${\tt "}, {\tt "}?{\tt "}, {\tt "}[a-z]{\tt "} etc.\
         on UNIX machines.  Indirection may occur through ASCII
         files (these may be nested up to 7 deep). The indirection
         character is {\tt "}$\wedge${\tt "}. If an extra prompt line is required then the
         continuation character {\tt "}-{\tt "} should be appended to end of the
         line. Comments may be added to indirection files using the
         character {\tt "}\#{\tt "}.
      }
      \sstsubsection{
         INEXT = \_LOGICAL (Read)
      }{
         If TRUE then the transformation which is to be applied to the
         NDF is stored in the NDF{\tt '}s CCDPACK extension
         (.MORE.CCDPACK.TRANSFORM). If FALSE then a transformation
         structure must be supplied via the parameter TRANSFORM. This
         transformation is then applied to the list of NDFs.  [TRUE]
      }
      \sstsubsection{
         LBOUND() = \_INTEGER (Read)
      }{
         If SHAPE is {\tt "}SPECIFY{\tt "} then this parameter specifies the lower
         pixel-index bounds of all the output NDFs. The number of
         values should equal the maximum number of dimensions of the
         input NDFs. The suggested defaults are the lower bounds
         generated by the SHAPE={\tt "}AUTO{\tt "} option for the first NDF. These
         bounds are probably small enough to ensure that all the
         transformed data (of the first NDF) will appear in the output
         NDF.
         [Dynamic default]
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         Name of the CCDPACK logfile.  If a null (!) value is given for
         this parameter then no logfile will be written, regardless of
         the value of the LOGTO parameter. On VMS systems the logfile
         should be read using one of the ICL utilities (LISTLOG,
         REPFILE), on UNIX systems the logfile is just an ordinary
         text file.

         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}CCDPACK.LOG{\tt "}.
         [CCDPACK.LOG]
      }
      \sstsubsection{
         LOGTO = LITERAL (Read)
      }{
         Every CCDPACK application has the ability to log its output
         for future reference as well as for display on the terminal.
         This parameter controls this process, and may be set to any
         unique abbreviation of the following:
         \sstitemlist{

            \sstitem
               TERMINAL  -- Send output to the terminal only

            \sstitem
               LOGFILE   -- Send output to the logfile only (see the
                               LOGFILE parameter)

            \sstitem
               BOTH      -- Send output to both the terminal and the
                               logfile

            \sstitem
               NEITHER   -- Produce no output at all

         }
         If the logging system has been initialised using CCDSETUP
         then the value specified there will be used. Otherwise, the
         default is {\tt "}BOTH{\tt "}.
         [BOTH]
      }
      \sstsubsection{
         METHOD = LITERAL (Read)
      }{
         The interpolation method used to resample the input NDF data
         arrays. Permitted values are {\tt "}NEAREST{\tt "} for nearest-neighbour,
         and {\tt "}LININT{\tt "} for linear interpolation.
         [NEAREST]
      }
      \sstsubsection{
         OUT = LITERAL (Write)
      }{
        Names of the output --transformed -- NDFs. These may be 
        specified as list of comma separated names, using indirection
        if required, OR, as a single modification element (of the 
        input names). The simplest modification element is the
         asterisk {\tt "}$*${\tt "} which means call each of the output NDFs the same
         name as the corresponding input NDFs. So,
         \begin{description}
            \item IN $>$ $*$
            \item OUT $>$ $*$
        \end{description}
        signifies that all the NDFs in the current directory should be
         used and the output NDFs should have the same names. On VMS
         systems this will result in the creation of a higher version
         number of the input NDFs. Other types of modification can also
         occur, such as,
         \begin{description}
            \item OUT $>$ $*$-TRN
        \end{description}
        which means call the output NDFs the same as the input NDFs
         but add -TRN to the end of the names. Replacement of a
         specified string with another in the output file names can
         also be used,
         \begin{description}
            \item OUT $>$ $*|$RAW$|$RES$|$
        \end{description}
        this replaces the string RAW with RES in any of the output
         names.
      }
      \sstsubsection{
         SHAPE = LITERAL (Read)
      }{
         The method to be used to determine the SHAPE of the output
         NDFs. Can take one of the values {\tt "}AUTO{\tt "}, {\tt "}SAME{\tt "}, {\tt "}SPECIFY{\tt "}.
         With the meanings.
         \sstitemlist{

            \sstitem
               AUTO    -- automatically determine the bounds of the
                            output NDFs such that all of the input data
                            appears. This is achieved by transforming test
                            points along the current bounds so assumes
                            that the transformation will behave reasonably.

            \sstitem
               SAME    -- set the output NDF bounds to those of the
                            corresponding input NDFs.

            \sstitem
               SPECIFY -- you will specify a single set of bounds for
                            all the output NDFs. (See the LBOUND and UBOUND
                            parameters.)
         }
         [AUTO]
      }
      \sstsubsection{
         TRANSFORM = TRN (Read)
      }{
         If INEXT is FALSE then this parameter specifies the
         transformation structure.  This includes the file name and the
         HDS object.  For example, DISTORT.MAPPING would use the
         TRANSFORM structure called MAPPING in the HDS file DISTORT.
         Normally the object name is TRANSFORM.  The structure must
         contain both the forward and inverse mappings. This transform
         if supplied acts on all the input NDFs.
      }
      \sstsubsection{
         UBOUND() = \_INTEGER (Read)
      }{
         If SHAPE is {\tt "}SPECIFY{\tt "} then this parameter specifies the upper
         pixel-index bounds of all the output NDFs. The number of
         values should equal the maximum number of dimensions of the
         input NDFs. The suggested defaults are the upper bounds
         generated by the SHAPE={\tt "}AUTO{\tt "} option for the first NDF. These
         bounds are probably large enough to ensure that all the
         transformed data (of the first NDF) will appear in the output
         NDF.
         [Dynamic default]
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         TRANNDF}{ $*$ $*$-TRN RESET
      }{
         This transforms all the NDFs in the current directory if
         they contain suitable transformation structures in their
         extensions. It uses nearest-neighbour resampling and conserves
         the flux levels. The output NDFs are of a size such that all
         the input pixels have contributed.
      }
      \sstexamplesubsection{
         TRANNDF}{ CURVED STRAIGHT LININT SHAPE=SAME
      }{
         As above, except linear interpolation is used, and 
         the {\ssttt STRAIGHT} array uses the bounds of {\ssttt CURVED}.
      }
      \sstexamplesubsection{
         TRANNDF}{ A119$*$ $*$S INEXT=FALSE TRANSFORM=PROJ.MERC SHAPE=BOUNDS
              LBOUND=[1,-20] UBOUND=[256,172]
      }{
         This transforms the NDFs called {\ssttt A119$*$}, using the 
         transformation
         {\ssttt MERC} in the HDS file called {\ssttt PROJ}, into 
         NDFs called {\ssttt A119$*$S}.
         It uses nearest-neighbour resampling.  All the output NDFs
         have size {\ssttt 256 x 192} pixels and origin 
         {\ssttt (1,-20)}.
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem This application is a restricted form of the KAPPA routine
           TRANSFORMER. If additional functionality is required then
           look at TRANSFORMER.
         }
   }
   \sstdiytopic{
      Behaviour of parameters
   }{
      Most parameters retain their current value as default. The
      {\tt "}current{\tt "} value is the value assigned on the last run of the
      application. If the application has not been run then the
      {\tt "}intrinsic{\tt "} defaults, as shown in the parameter help, apply.
      The exceptions to this rule are:
      \sstitemlist{

         \sstitem
            LBOUND  -- always uses a dynamic default

         \sstitem
            UBOUND  -- always uses a dynamic default

         \sstitem
            TITLE   -- always {\tt "}Output from TRANNDF{\tt "}

      }
      Retaining parameter values has the advantage of allowing you to
      define the default behaviour of the application but does mean
      that additional care needs to be taken when using the application
      after a break of sometime.
      The intrinsic default behaviour of the application may be
      restored by using the RESET keyword on the command line.

      Certain parameters (LOGTO and LOGFILE) have global values. These
      global values will always take precedence, except when an
      assignment is made on the command line.  Global values may be set
      and reset using the CCDSETUP and CCDCLEAR commands.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Flux conservation can only be applied to constant-determinant
           or linear transformations.

         \sstitem
         The NDF components are processed by this application as
           follows:

         \sstitem
            AXES, LABEL, UNITS, HISTORY, and extensions are merely
               propagated.

         \sstitem
            QUALITY is not derived from the input NDF for a linearly
               interpolated NDF. The DATA and VARIANCE arrays are
               resampled.

         \sstitem
         Bad pixels, including automatic quality masking, are supported.

         \sstitem
         All non-complex numeric data types are supported.

         \sstitem
         There can be an arbitrary number of NDF dimensions.
      }
   }
}

\newpage
\section{Processing quotas}

This appendix details some of the process/system quotas/limits which
are required to run CCDPACK.

The main VMS quota which will probably effect CCDPACK is the {\em page
file quota}, this is set on a per-process basis and can be modified
easily (by your system manager), to examine your quota use the {\em show
process/quota} command from DCL. A limit which may cause problems when
accessing very large datasets is the {\em virtual address size}
(VIRTUALPAGECNT) limit, this is a sysboot parameter and can only be
changed by a re-boot of your machine. Exceeding virtual page size is
indicated by the VASFULL identifier on system messages. Both of these
quotas are dependent on the size and quantity of the input data. Roughly
these are (in pages):
\begin{itemize}

\item for \_REAL data with size 590x400 pixels
   \begin{itemize}
      \item $\approx 38000$~~~VIRTUALPAGECNT
      \item $\approx 17000$~~~Page file size.
   \end{itemize}

\item for \_REAL data with size 1190x800 pixels
   \begin{itemize}
      \item $\approx 110000$~~~VIRTUALPAGECNT
      \item $\approx 31000 $~~~ Page file size.
   \end{itemize}

\end{itemize}

These figures are based on 5 fully activated NDFs (i.e.\ with their
variance components in use) running through MAKEFLAT.  Savings on these
figures can be easily be achieved by not using variances and reducing
calibration frame use (i.e.\ the mask and bias options in DEBIAS), even
by reducing the number of frames input (but only in this last case when
using MAKEFLAT - the other routines do not use extra memory when
processing lists of NDFs.) An even simpler method of saving on memory
related requirements is to use a reduced HDS precision, i.e.\ use the HDS
types \_WORD and \_UWORD when the data can be represented by these.

A value which has caused problems is the sysgen parameter
PROCSECTCNT, at present this value needs to be around 100. A failure
of this quota (which is related to the number of image sections in the
CCDPACK executables) should be indicated by the PSTFULL identifier. You
will require help from your system manager to overcome this problem.

The problems with quotas on UNIX machines are much less. Basically the
swap file size required for processing data is related to the size of
the data sets. Using DEBIAS for instance will require sufficient memory
to hold seven data\_array components (at worst, this has a bias and a
mask NDF accessed together with all the variance components).
The memory management performed within CCDPACK should, in general,
make this the worst case.

\section{A glossary of CCD terminology}
\label{app:glos}

In the following section various terms which are used when describing CCD
datasets are explained, a little of the rationale for the existence of the
various CCD data types is also given. A pixel in following context is one of the
CCDs light sensitive elements and should not be mistaken for a data pixel,
although there is a one to one correspondence between them.

\subsection{The bias level}

The bias level of a CCD frame is an artificially induced electronic offset
which ensures that the Analogue-to-Digital Converter (ADC) always receives a
positive signal. All CCD data has such an offset which must be removed if the
data values are to be truly representative of the counts recorded per pixel.

\subsection{Readout-noise}

The readout-noise is the noise which is seen in the bias level. This is produced
by the on-chip amplifier and other sources of noise in the data transmission
before the signal is converted into a digital representation by the ADC.
Typically this can be represented by one value which is an estimate of the
standard deviation of the bias level values.

\subsection{Bias strips}

In order that the bias level of the CCD system can be constantly monitored (it
may at times move due to thermal changes and very occasionally, discontinuous
steps) values (columns or rows) are read from the CCD {\em without} moving any
charge into the output registers. These extra readouts are usually found at the
sides of the real data and are often referred to as bias strips or over-scan
regions (see Figure \ref{CCDPICCY}).

\subsection{ADC factor}

The analogue to digital converter, samples the charge which is returned from
the CCD and returns a digital value (usually a 15 or 16 bit value). This value
does not equate to the actual number of electrons detected in the pixel in
question, but is proportional to it. Typically the proportionality constant is
determined by noise considerations --- the variance of the actual detected
electrons is poissonian, hence the variance in the output from the ADC should
equate to this (plus a few other terms such as the readout-noise), so the
constant ADC factor can be derived. The output from an ADC is measured in
analogue to digital units (ADUs). The ADC factor is multiplicative and converts
ADUs into detected electrons.

\subsection{Saturation}

The capability of pixels to hold charge (charge is entered into a pixel
every time a photon is detected) is not infinite and after a certain
limit is exceeded the pixel then stops accumulating charge. When the
charge in such a pixel is clocked along the CCD (on route to the output
registers, from where it is amplified and transferred to the ADC) the
excess from it `bleeds' along the readout columns and sometimes even
across them. Before saturation slight non-linearities in
intensity occur. Data values which exceed this non-linearity limit
should be removed from the final datasets and generally cause no further
problems. However, because of charge bleeding, contamination may occur
around the vicinity and care should be taken when using such data.

\subsection{Dark current}

All CCDs, at some level, exhibit the phenomenon of dark current. This is
basically charge which accumulates in the CCD pixels due to thermal
noise. The effect of dark current is to produce an additive quantity to
the electron count in each pixel. The reduction of dark current is the
main reason why all astronomical CCDs are cooled to liquid nitrogen
temperatures. Most modern CCDs only produce a few ADU (or less) counts
per pixel per hour and so this effect can generally be ignored. This,
however, is not the case for Infra-Red arrays.

\subsection{Pre-flashing}

The transfer of charge between pixels (and hence along columns) suffers
from inefficiencies. Usually this amounts to a charge loss which is
never read out from the CCD well - this level is often referred to as
the `fat' or `skinny' zero to confuse matters; I refer to it as the
deferred charge value. When observing objects with low sky backgrounds
(and/or low counts themselves) this loss of charge may be significant
(at least in some older CCDs). To overcome this CCDs can be pre-flashed.
This amounts simply to illuminating the CCD with a uniform light flux
just prior to the actual object exposure. The object counts are then
simply added to this pre-flash level of charge in the CCD wells. Note,
however, that this method is of no use for very low counts as the signal
to noise level which is required after pre-flashing is higher than
before (the noise from the pre-flash photons adding to the noise of the
object photons). Correction of data for pre-flashing is achieved by
subtracting the pre-flash ADU count from the final data (before
flatfielding).

\subsection{Flatfielding}

The sensitivity of a CCD to incident photon flux is not uniform across
the whole of its surface and before data can be said to be properly
relatively flux calibrated this needs to be corrected for. The
variations in CCD response can be on the large scale (one end of the CCD
to the other) and pixel-to-pixel. The relative flux levels on different
parts of the CCD are also vignetted by of the optics of the instrument
and telescope, this variation also needs correcting for and is performed
together with the CCD sensitivity corrections \footnote {An additional
effect of interest, which cannot be fully corrected, is the colour
sensitivity of the CCD pixels. Most pixels on a typical CCD frame are
exposed to the night sky which has a specific colour, this, however, may
not be the same colour as the object itself, so the best case response
is that the object and night sky colours mix to produce a response not
typical to the night sky dominated parts of the frame, if the object is
much brighter than the sky then its colour will dominate and ideally the
flatfield should be produced with a source mimicking this colour
response.}.

Flatfield calibration frames are usually taken of a photometrically flat
source using the same optical setup as that used to take the object
frames. In the past images of the interior of the telescope dome have
been used for this purpose, however, it now generally thought that
images of the twilight/dawn sky are more representative of a true
flatfield, having the same global illumination as the data and having a
good signal level (remember that calibration frames will be applied to
the object data at some stage and hence will introduce a noise
contribution to the final data values, it is therefore essential to get
a good set of calibration frames with lots of signal if this process is
to introduce the absolute minimum of noise, CCDPACK provides calibration
frame combination routines to produce `best bet' calibration frames with
very low noise levels), but these frames have a colour response which
may be not representative of the colour of the night time sky. If this
factor is important then specially taken night sky flatfields must be
produced. These can be taken of star free parts of the sky or produced
from many object frames whose (contaminating) objects are removed,
before median stacking to remove more spurious data values. Note in this
final case that the noise levels required to correct for small scale
variations are very time consuming to meet.

\subsection{Fringing}
Some CCD data show an effect known as `fringing'. This usually has the
appearance of a series of `ripples' in the sky regions. Fringing is
caused by the multiple reflection and interference of the night-sky
emission lines in the CCD substrate. The effect is considerably enhanced
in CCDs whose substrates have been machined thinned to increase the blue
sensitivity, the thickness of the substrate being comparable to that of
the incident radiation, hence any deviations from a planar geometry
cause these `Newton Ring' like effects.

The fringe pattern is an additive effect and must be subtracted. To
de-fringe data it is necessary to get special exposures of an object
clear part of the night sky, or, alternatively, remove all the
contaminations (objects) from data frames with large areas of night sky.
These frames should then be combined to give complete spatial coverage
and to reduce the noise contribution. This `fringe-frame' should then be
scaled to the fringes present on the data frame (after normalisation
--- MAKEMOS) and {\em subtracted}.


\section{Changes this release}

\begin{itemize}

\item CCDPACK is now at version 1.0 and has undergone a major 
      functionality enhancement. Support is now provided for the 
      registration and mosaicing of NDFs. The new applications are:

      \begin{description}
      \item[FINDCENT] centroids NDF image features

      \item[FINDOBJ] locates and centroids NDF image features

      \item[FINDOFF] Performs pattern-matching between unlabeled 
                     position lists related by simple offsets.

     \item[IDICURS] reads co-ordinates from a graphics device (allows 
                    zooming and panning)

    \item[MAKEMOS] makes NDF mosaics by combining and (optionally) 
                   normalising

     \item[PAIRNDF] displays and manipulates NDF pairs to allow easy
                    registration (offsets only)

    \item[PLOTLIST] draws position markers on a graphics display

    \item[REGISTER] determines transformations between many lists of 
                    positions

    \item[TRANLIST] transforms lists of positions

    \item[TRANNDF]  transforms (resamples) NDFs

    \item[CCDALIGN] helps determine general inter-NDF transformations

    \item[CCDEDIT] edits the CCDPACK extensions of NDFs

    \item[CCDNDFAC] accesses a list of NDFs, writing their names to a file

    \end{description}

 \item Highlights.
    \begin{description}
 
    \item Using a combination of these routines (FINDOBJ, FINDOFF, REGISTER,
     TRANNDF and MAKEMOS) it is possible to register, align, normalise
     and combine many datasets which are offset with respect to each
     without any graphical interaction -- i.e.\ automatically.

    \item Two applications are provided for interactive registration, 
     CCDALIGN and PAIRNDF. PAIRNDF is a specialist application
     which eases the selection of objects in (many) NDFs which are simply
     translated from each other (this removes the requirement to
     pre-select the labelling of the objects on every frame). CCDALIGN is
     a general purpose procedure for aligning single or multiple groups of
     NDFs.

   \item TRANNDF resamples NDFs. The transformations may be arbitrary if
    entered using the CCDEDIT facility. General transformations using
    algebraic expressions are supported by REGISTER, TRANLIST, CCDEDIT
    and TRANNDF.

   \item MAKEMOS is a comprehensive application for producing a mosaic from a
    list of aligned NDFs. It also provides very robust normalisation
    methods for data with varying exposures and/or sky transparencies.
   \end{description}

 \item Deprecated\_feature.
    \begin{quote}

    To allow the control of directories on UNIX it has been necessary
    to change the NDF names substitution character from `\myverb{/}'
    to 
    \begin{myquote}
    \begin{verbatim}
       "|"
    \end{verbatim}
    \end{myquote}

    The `\myverb{/}' form is {\em still} supported for the present
    so any existing command procedures will continue to work, but, this
    behaviour is not guaranteed in future releases. 

    Using the \myverb{"|"} form you can control the directory that
    output NDFs are placed. So for instance
    \begin{myquote}
    \begin{verbatim}
    IN > raw/rdata/*
    OUT > pro/rdata/*
    \end{verbatim}
    \end{myquote}

    will now access all the NDFs in the raw/rdata directory and when 
    they are processed the results will be in the pro/rdata directory,
    with the same name. Exactly the same effect has always been 
    possible on VMS i.e.
    \begin{myquote}
    \begin{verbatim}
    IN > [.raw.rdata]*
    OUT > [.pro.rdata]*
    \end{verbatim}
    \end{myquote}

    The new substitution element works exactly as the previous one.
    \begin{myquote}
    \begin{verbatim}
    IN > DISK$SCRATCH:[AUSER.CCD]*_CCD
    OUT > DISK$TEMP:[AUSER.PHT]*|CCD|PHT|

    [ IN > /home/auser/ccd/*_ccd
      OUT > /scratch/auser/pht/*|ccd|pht| ]
    \end{verbatim}
    \end{myquote}

    which also moves the output files onto different disks. An important
    point to remember is that the `*' in output names ONLY represents
    the names of the input NDFs (without the file extension `.SDF')
    and does not include any directory/disk information. These input 
    fields are only used when the output specification does not contain
    any `preferences' to override them. Hence substitution only works
    on the NDF names.

   \end{quote}

  \item Minor\_changes

   The routines
     \begin{itemize}
       \item CCDSETUP
       \item CCDCLEAR
       \item CCDSHOW
     \end{itemize}

   have had minor modifications made to them. CCDSETUP now controls
   the new global parameter NDFNAMES (this controls whether "position
   lists" are associated with NDFs or not). CCDCLEAR will now clear
   global parameters by name -- so you don't have to clear your whole
   setup if you want to get rid of an embarrassing MASK, a simple
    \begin{myquote}
    \begin{verbatim}
    $ CCDCLEAR BYNAME NAMES=MASK 
    \end{verbatim}
    \end{myquote}

   will do this.

   CCDSHOW now also writes out the name of the current logfile and 
   the LOGTO status.

\end{itemize}

\newpage
\mbox{This page is left blank intentionally.}

%
% set up a mini table of contents for the back pages of document.
%
\newpage

\quickdes{MAKECAL}{Produces calibration NDFs for flash or dark counts.}
                  {des:makecal}

\quickdes{MAKEFLAT}{Produces a flatfield NDF.}
                   {des:makeflat}

\quickdes{MAKEMOS}{Makes NDF mosaics by combining and (optionally) normalising.}
                  {des:makemos}

\quickdes{PAIRNDF}{Displays and manipulates NDF pairs to allow easy 
                   registration (offsets only).}
                  {des:pairndf}

\quickdes{PLOTLIST}{Draws position markers on a graphics display.}
                   {des:plotlist}

\quickdes{REGISTER}{Determines transformations between lists of positions.}
                   {des:register}

\quickdes{TRANLIST}{Transforms lists of positions.}
                   {des:tranlist}

\quickdes{TRANNDF}{Transforms (resamples) NDFs.}
                  {des:tranndf}

\newpage
\section{Backpage classified listing}

\quickdes{CALCOR}{Performs dark or flash count corrections.}{des:calcor}

\quickdes{CCDALIGN}{Determines general inter-NDF transformations.}
         {des:ccdalign}

\quickdes{CCDBATCH}
         {Prepares a VMS CCDPACK command file for submission to batch.}
         {des:ccdbatch}

\quickdes{CCDCLEAR}{Clears globals parameters.}
         {des:ccdclear}

\quickdes{CCDEDIT}{Edits the CCDPACK extensions of NDFs.}
         {des:ccdedit}

\quickdes{ccdfork}{Prepares a UNIX CCDPACK command file for forking into a
                   background process.}{des:ccdfork}

\quickdes{CCDNDFAC}{Accesses a list of NDFs, writing their names to a file.}
         {des:ccdndfac}

\quickdes{CCDNOTE}{Adds a note to the log file.}{des:ccdnote}

\quickdes{CCDSETUP}{Sets up the CCDPACK global parameters.}{des:ccdsetup}

\quickdes{CCDSHOW}{Displays the current values of the CCDPACK global 
                   parameters.}{des:ccdshow}

\quickdes{DEBIAS}{Debiasses lists of NDFs either by bias NDF
                 subtraction or by interpolation --
                 applies bad data masks --
                 extracts a subset of the data area --
                 produces variances --
                 applies saturation values.}
                 {des:debias}

\quickdes{FINDCENT}{Centroids NDF image features.}
                   {des:findcent}

\quickdes{FINDOBJ}{Locates and centroids NDF image features.}
                  {des:findobj}

\quickdes{FINDOFF}{Performs pattern-matching between unlabeled position lists 
                   related by simple offsets.}{des:findoff}

\quickdes{FLATCOR}{Performs the flatfield correction on a list of NDFs.}
                  {des:flatcor}

\quickdes{IDICURS}{Reads co-ordinates from a graphics device (allows 
                   zooming and panning).}{des:idicurs}

\quickdes{LISTLOG}{Lists the contents of an ICL logfile.}{des:listlog}

\quickdes{MAKEBIAS}{Produces a bias calibration NDF.}{des:makebias}

\end{document}

%% %W%     %G%     %R%
