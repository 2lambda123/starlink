\documentstyle[twoside]{article} 
\pagestyle{myheadings}

%------------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocnumber}    {141.1}
\newcommand{\stardocauthors}   {Alan J. Penny}
\newcommand{\stardocdate}      {8 January 1992}
\newcommand{\stardoctitle}     {Starman --- A Stellar Photometry Package}
%------------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{240mm}
\setlength{\topmargin}{-5mm}
\setlength{\oddsidemargin}{5mm}
\setlength{\evensidemargin}{-5mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

%------------------------------------------------------------------------------
% Add any \newcommand or \newenvironment commands here

% degrees symbol
\newcommand{\dgs}{\hbox{$^\circ$}}        
% centre an asterisk
\newcommand{\lsk}{\raisebox{-0.4ex}{\rm *}}
% an environment for references
\newenvironment{refs}{\goodbreak
                      \vspace{3ex}
                      \begin{list}{}{\setlength{\topsep}{0mm}
                                     \setlength{\partopsep}{0mm}
                                     \setlength{\itemsep}{0mm}
                                     \setlength{\parsep}{0mm}
                                     \setlength{\leftmargin}{1.5em}
                                     \setlength{\itemindent}{-\leftmargin}
                                     \setlength{\labelsep}{0mm}
                                     \setlength{\labelwidth}{0mm}}
                    }{\end{list}}

% SST definitions
% ---------------

%+
%  Name:
%     LAYOUT.TEX

%  Purpose:
%     Define Latex commands for laying out documentation produced by PROLAT.

%  Language:
%     Latex

%  Type of Module:
%     Data file for use by the PROLAT application.

%  Description:
%     This file defines Latex commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by Latex. The
%     contents of this file should be included in the source presented to
%     Latex in front of any output from PROLAT. By default, this is done
%     automatically by PROLAT.

%  Notes:
%     The definitions in this file should be included explicitly in any file
%     which requires them. The \include directive should not be used, as it
%     may not then be possible to process the resulting document with Latex
%     at a later date if changes to this definitions file become necessary.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}

%  Define a \tt font of the required size.
\font\ssttt=CMTT10 scaled 1095

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em} 
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.45pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the output results parameters section (for an application).
\newcommand{\sstresparameters}[1]{
   \item[Results Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the graphics style parameters section (for an application).
\newcommand{\sstgraphparameters}[1]{
   \item[Graphics-style Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{\item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[1]{\item[{\ssttt #1}] \mbox{} \\}

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.0em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  End of LAYOUT.TEX layout definitions.
%.

% End of SST definitions
% ----------------------

%    Starlink definitions for \LaTeX\ macros used in MAN output
%
%  Description:
%    As much as possible of the output from the MAN automatic manual generator
%    uses calls to user-alterable macros rather than direct calls to built-in
%    \LaTeX\ macros. This file is a version of the MAN default definitions for
%    these macros modified for Starlink preferences.
%
%  Language:
%    \LaTeX
%
%  Support:
%    William Lupton, {AAO}
%    Alan Chipperfield (RAL)
%-
%  History:
%    16-Nov-88 - WFL - Add definitions to permit hyphenation to work on
%		 words containing special characters and in teletype fonts.
%    27-Feb-89 - AJC - Redefine \manroutine
%                      Added \manheadstyle
%                      Switch order of argument descriptors
%    07-Mar-89 - AJC - Narrower box for parameter description
%                      Remove Intro section and other unused bits
%
% permit hyphenation when in teletype font (support 9,10,11,12 point only -
% could extend), define lccodes for special characters so that the hyphen-
% ation algorithm is not switched off. Define underscore character to be
% explicit underscore rather than lots of kerns etc.

\typeout{Starlink MAN macros. Released 27th February 1989}

\hyphenchar\nintt=`-\hyphenchar\tentt=`-\hyphenchar\elvtt=`-\hyphenchar\twltt=`-

%\lccode`_=`_\lccode`$=`$

%    Macros used in the .TEX_SUMMARY file
%
%  Description:
%    There is a command to introduce a new section (mansection) and a list-like
%    environment (mansectionroutines) that handles the list of routines in the
%    current section. In addition a mansectionitem command can be used instead
%    of the item command to introduce a new routine in the current section.
%-

\newcommand {\mansection}[2]{\subsection{#1 --- #2}}

\newenvironment {mansectionroutines}{\begin{description}\begin{description}}%
{\end{description}\end{description}}

\newcommand {\mansectionitem}[1]{\item [#1:] \mbox{}}

%    Macros used in the .TEX_DESCR file
%
%  Description:
%    There is a command to introduce a new routine (manroutine) and a list-like
%    environment (manroutinedescription) that handles the list of paragraphs
%    describing the current routine. In addition a manroutineitem command can
%    be used instead of the item command to introduce a new paragraph for the
%    current routine.
%
%    Two-column tables (the ones that can occur anywhere and which are
%    triggered by "=>" as the second token on a line) are bracketed by a
%    new environment (mantwocolumntable). Other sorts of table are introduced
%    by relevant  environments (manparametertable, manfunctiontable and
%    manvaluetable). The definitions of these environments call various other
%    user-alterable commands, thus allowing considerable user control over such
%    tables... (to be filled in when the commands have been written)
%-

\newcommand {\manrule}{\rule{\textwidth}{0.5mm}}

%\newcommand {\manroutine}[2]{\subsection{#1 --- #2}}
\newlength{\speccaption}
\newlength{\specname}
\newcommand{\manroutine}[2]{\goodbreak
                          \rule{\textwidth}{0.5mm}  % draw thick line
                          \settowidth{\specname}{{\Large {\bf #1}}}
                        % left and right box width is text width plus gap
                          \addtolength{\specname}{4ex} 
                        % caption width is width of page less the two names
                        % less than empirical fudge factor
                          \setlength{\speccaption}{\textwidth}
                          \addtolength{\speccaption}{-2.0\specname}
                          \addtolength{\speccaption}{-4.45pt}
                        % move text up the page because \flushleft environ-
                        % ment creates a paragraph
                          \vspace{-7mm}
                          \newline
                          \parbox[t]{\specname}{\flushleft{\Large {\bf #1}}}
                          \parbox[t]{\speccaption}{\flushleft{\Large #2}}
                          \parbox[t]{\specname}{\flushright{\Large {\bf #1}}}
                          }

\newenvironment {manroutinedescription}{\begin{description}}{\end{description}}

\newcommand {\manroutineitem}[2]{\item [#1:] #2\mbox{}}


% parameter tables

\newcommand {\manparametercols}{lllp{90mm}}

\newcommand {\manparameterorder}[3]{#2 & #3 & #1 &}

\newcommand {\manparametertop}{}

\newcommand {\manparameterblank}{\gdef\manparameterzhl{}\gdef\manparameterzss{}}

\newcommand {\manparameterbottom}{}

\newenvironment {manparametertable}{\gdef\manparameterzss{}%
\gdef\manparameterzhl{}\hspace*{\fill}\vspace*{-\partopsep}\begin{trivlist}%
\item[]\begin{tabular}{\manparametercols}\manparametertop}{\manparameterbottom%
\end{tabular}\end{trivlist}}

\newcommand {\manparameterentry}[3]{\manparameterzss\gdef\manparameterzss{\\}%
\gdef\manparameterzhl{\hline}\manparameterorder{#1}{#2}{#3}}


% list environments

\newenvironment {manenumerate}{\begin{enumerate}}{\end{enumerate}}

\newcommand {\manenumerateitem}[1]{\item [#1]}

\newenvironment {manitemize}{\begin{itemize}}{\end{itemize}}

\newcommand {\manitemizeitem}{\item}

\newenvironment {mandescription}{\begin{description}\begin{description}}%
{\end{description}\end{description}}

\newcommand {\mandescriptionitem}[1]{\item [#1]}

\newcommand {\mantt}{\tt}

% manheadstyle for Starlink
\newcommand {\manheadstyle}{}

%\catcode`\_=12
%\catcode`{\undersc}=12

%------------------------------------------------------------------------------
%AJP Additions

\newcommand{\undersc}{{\_}\hspace{0.2ex}}
\pagenumbering{arabic}
\newcommand{\ajhsect}[2]{ \markboth
      { $ \:\:\:\:\:\: \bullet \:\: $ #1 $ \:\: \cdot \:\: $ #2 \hfill SUN/\stardocnumber}
      { SUN/\stardocnumber \hfill #2 $ \:\: \cdot \:\: $ #1 $ \:\: \bullet \:\:\:\:\:\: $ } 
                          }

%------------------------------------------------------------------------------


\begin{document}
\thispagestyle{empty}




SCIENCE \& ENGINEERING RESEARCH COUNCIL \hfill \stardocname\\
RUTHERFORD APPLETON LABORATORY\\
{\large\bf Starlink Project\\}
{\large\bf \stardoccategory\ \stardocnumber}
\begin{flushright}
\stardocauthors\\
\stardocdate
\end{flushright}
\vspace{-4mm}
\rule{\textwidth}{0.5mm}


\vspace{-1.5mm}
\begin{center}
{\LARGE \bf Starman } \\
{ \vspace*{2mm} \Large \bf A Stellar Photometry/Image and Table Handling Package }
\end{center}

{\vspace*{-2mm} \large \bf General \vspace*{-1mm} }


Starman is a stellar photometry package designed for the reduction of data
from imaging systems. Its main components are:- crowded-field photometry
programmes; aperture photometry programmes; a CCD reduction programme; a
star finding programme; 

There are also a large number of programmes which have a general use in all
types of work that deal with images and tables.

The package is a coherent whole for use in the entire process of stellar
photometry from raw images to the final standard-system magnitudes and
their plotting as colour-magnitude and colour-colour diagrams. 


{\vspace*{-1mm} \large \bf Stellar Photometry Programmes \vspace*{-1mm} }

\hspace*{3ex} \begin{tabular}{lp{5.5in}}
- & Converter of raw CCD images to calibrated ones. \\
- & `Dust-ring' flat-field dealer. \\
- & Approximate stellar image radius finder. \\
- & Star position finder. \\
- & Stellar profile determiner. \\
- & Crowded-field, and also simple, stellar photometry measurers. \\
- & Averager of photometry estimates from different images. \\
- & Colour-magnitude and colour-colour diagram plotters. \\ 
- & Adder of `fake' stars to an image. \\
- & Automatic aperture photometry for all bright well isolated stars. \\
\end{tabular}

{\vspace*{-1mm} \large \bf Image Handling Programmes \vspace*{-1mm} }

\hspace*{3ex} \begin{tabular}{lp{5.5in}}
- & Image display for IKON, VWS, and DECWindows, and any Xwindow device. \\
- & Interactive image display for IKON, VWS, and DECWindows, and any Xwindow 
    device. This includes:- zoom/pan, pixel value, `slice', 
    solid-body plots, interactive aperture photometry, colour LUT, interactive 
    position file making, plotting of positions on image, interaction with 
    the output of the crowded-field stellar photometry measurer, `GUI'-like 
    interaction when dealing with some of the image and graphical display 
    on a workstation.  \\
- & Extensive general programmes: Joining, cutting, FITS reading, etc.. \\
\end{tabular}

{\vspace*{-1mm} \large \bf Table Handling Programmes \vspace*{-1mm} }

\hspace*{3ex} \begin{tabular}{lp{5.5in}}
- & Spread-sheet, Calculator. \\
- & Input, Output, Listing. \\
- & Graphical Plot, Star Chart. \\
- & Joining. \\
- & Extensive general programmes: sort, weed, statistics, 
    matching, position transforming, etc.. \\
\end{tabular}

{\vspace*{-0.5mm} \large \bf Details \vspace*{-1mm} }

Starman works in the {\bf Interim} environment, dealing with 16-bit
BDF images. There is an extensive help library; all image display works
with IKON, VWS, and DECWindows and can use any Xwindow display device; all
graphical work is under PGPLOT. There are a number of new or improved
versions of the EDRS/ASPIC table handling programmes. A number of the
existing EDRS/EDRSX programmes may also be used to support Starman work. Those
programmes which are heavily computational have the option to use a
transputer-based parallel processor array. 


{\vspace*{-1mm} \large \bf Not an Acronym \vspace*{-1mm} }

`Starman' is not an acronym, and so should only have the first letter of
its name in capitals.

\newpage

\tableofcontents
\setlength{\parskip}{\medskipamount}
\markright{\stardocname}

\newpage



\section{Classified List of Programmes}
\label{se:class}
\ajhsect{\arabic{section}}{CLASSIFIED LIST}
 
\subsection{Stellar Photometry Programmes}

\label{ap:summary}
\begin{tabular}{ll}
{\bf  Addstars:} &	Adds or subtracts a star to an image with noise \\
{\bf  Automag:} &	Aperture Photometry on isolated stars and extinction correcting \\
{\bf  Average:} &	Takes the average of a number of outputs from MEASURE \\
{\bf  Chi:} &		Puts thresholds on the goodness of fit of MEASURE output \\
{\bf  Diagram:} &	Plots a C-M or 2-Colour diagram \\
{\bf  Dustring:} &      Add or remove 'dustrings' from an image \\
{\bf  Find:} &		Finds stars in an image \\
{\bf  Interact:} &      General image display and interaction programme \\
                 &      \hspace{2ex} -- Zoom, pan, blink\\
                 &      \hspace{2ex} -- Inspect image values, slice, plot,  make hard-copy\\
                 &      \hspace{2ex} -- Set and alter colour Look-Up Table \\
                 &      \hspace{2ex} -- Mark and/or display position lists \\
                 &      \hspace{2ex} -- Perform Aperture Photometry \\
                 &      \hspace{2ex} -- Scrutinise the output of MEASURE \\
{\bf  Measure:} &	Measures stars in an image \\
{\bf  Profile:} &	Finds the mean profile of a number of stars \\
{\bf  Radius:} &        Automatically finds a rough stellar radius from an image \\
{\bf  Simplemag:} &	Simple aperture or profile photometry on isolated stars \\
{\bf  Sprinkle:} &      Makes a table of stars with randomised positions, magnitudes \\
{\bf  Unccd:} &         Processes a raw CCD image to remove detector effects \\
\end{tabular}

\subsection{General Image Handling Programmes}

\begin{tabular}{ll}
{\bf  Imcube:} &         Make a 2-D image from a 3- or 4-D one (real:integer:short) \\
{\bf  Imcut:} &          Make another image (sectioned,binned,inverted) \\
{\bf  Imdes:} &          Look at the descriptors (headers) of an image \\
{\bf  Imfitsin:} &       Read FITS format images off a tape \\
{\bf  Imflash:} &        Simple display of image \\
{\bf  Imjoin:} &         Join a number of images together \\
{\bf  Imrotate:} &       Rotate an image anti-clockwise by 90,180, or 270 degrees \\
{\bf  Imtype:} &         Convert files between (real;integer;16-bit integer) \\
{\bf  Imwrdes:} &        Write descriptors to an image \\
{\bf  }          &       \\
{\bf  Interact:} &      General image display and interaction programme \\
\end{tabular}

\subsection{General Table Handling Programmes}

\begin{tabular}{ll}
{\bf  Tbcalc:} &         Calculate table elements \\
{\bf  Tbchart:} &        Plot out a realistic star map \\
{\bf  Tbcomps:} &        Find stars within/not within an annulus of each other \\
{\bf  Tbcopdes:} &       Copy the descriptors of one table onto another \\
{\bf  Tbcut:} &          Cut out parts of a table \\
{\bf  Tbjoin:} &         Join tables together \\
{\bf  Tbkey:} &          Input numbers from keyboard into a table \\
{\bf  Tblist:} &         Type and/or put in file the contents of a table \\
{\bf  Tbload:} &         Input an ASCII text file into a table \\
\end{tabular}

\begin{tabular}{ll}
{\bf  Tbmatch:} &        Extract entries with matching names in two tables \\
{\bf  Tbnmatch:} &       Put tables in the same order of names \\
{\bf  Tbplot:} &         Plot out graph/histogram \\
{\bf  Tbpmatch:} &       Extract entries with matching or nonmatching positions 
                          in two tables  \\
{\bf  Tbrenum:} &        Renumber names in a table \\
{\bf  Tbsheet:} &        Spread-sheet program for inspection/insertion/etc \\
{\bf  Tbsort:} &         Sort entries in a table \\
{\bf  Tbstat:} &         Perform statistics on column(s) in tables(s) \\
{\bf  Tbtran{\undersc}apply:} &  Apply transformation to positions in a table \\
{\bf  Tbtran{\undersc}load:} &    Load posn transforms from rotn,shift,magn \\
{\bf  Tbtran{\undersc}make:} &    Calc posn transforms between positions in two tables \\
{\bf  Tbweed:} &        Make a table with only those entries with a parameter 
                  in a range \\
{\bf  Tbwrdes:} &        Write descriptors to table \\
{\bf  Tbvalue:} &        Type out a table element and put out as parameter \\
{\bf  }          &       \\
{\bf  Interact:} &      General image display and interaction programme \\
\end{tabular}


\subsection{Additional Programmes}

There are other programmes in the  EDRS and EDRSX packages which are of
use in doing photometry. These can be accessed by typing `GO EDRS'
or `GO EDRSX'. (Type `GO STARMAN' to get the Starman programmes back.)
See Section~\ref{se:packs} for a fuller help on this.

There are no really useful programmes in the ASPIC package, but you may
look at that package by typing `GO ASPDIR'.

\subsubsection{Most Useful}

 In the EDRS set of programmes:-

\begin{tabular}{ll}
{\bf  Arith:} &        Add,subtract,multiply,divide an image with a constant \\
{\bf  Imgarith:} &      Add,subtract,multiply,divide two images \\
{\bf  Maths:} &         Make a Fortran-like combination of a number of images \\
{\bf  Rescale:} &       Rescale an image through the BSCALE/BZERO \\
\end{tabular}

\subsubsection{All Additional Programmes}
\label{se:addi}

The full list of useful additional programmes is:-


  In the EDRS package:-

\begin{tabular}{ll}
{\bf  Arith:} &         Add,subtract,multiply,divide an image with a constant \\
{\bf  Bdfkey:} &        Use keyboard to enter the values of an image \\
{\bf  Blank:} &         Make INVALID a row or column section of an image \\
{\bf  Boxfilter:} &     Smooth an image with a box filter \\
{\bf  Centroid:} &      Centroids of features from a position table in an image \\
{\bf  Cinvert:} &       Find inverse of a linear transformation for positions \\
{\bf  Collapse:} &      Collapse polygonal image section along X or Y axis \\
{\bf  Cut:} &           Make INVALID all image pixels with values outside range \\
\end{tabular}

\begin{tabular}{ll}
{\bf  Ffclean:} &       Remove small blemishes from an image by FFT \\
{\bf  Imgarith:} &      Add,subtract,multiply,divide two images \\
{\bf  Linefit:} &       Replace each line of an image by constant/stright line \\
{\bf  Mask:} &          First image where VALID, second image where INVALID \\
{\bf  Maths:} &         Make Fortran-like maths combination of images \\
{\bf  Normalise:} &     Calc scaling between two images to give same average \\
{\bf  Pixfill:} &       Replace invalid pixels with average \\
{\bf  Pixmap:} &        Move pixels in an image to new positions \\
{\bf  Pixunmap:} &      Resample a 1- or 2-D image at a set of points \\
{\bf  Profile:} &       Plot section through image \\
{\bf  Resample:} &      Resample an image using linear transformation \\
{\bf  Rescale:} &       Rescale an image through BSCALE/BZERO \\
{\bf  Segment:} &       Copy polygonal segments of one image into another \\
{\bf  Starfit:} &       Determine parameters of STARMAG profile \\
{\bf  Starmag:} &       Perform simple stellar photometry \\
{\bf  Surfit:} &        Make a polynomial or bi-cubic spline surface of an image \\
{\bf  Trconcat:} &      Calc the effect of two linear transformation \\
{\bf  View:} &          Make an ASCII text file of the values in an image area \\
\end{tabular}


 In the EDRSX package:-

\begin{tabular}{ll}
{\bf  Bdfgen:} &      Creation of image or table from text file \\
{\bf  Convolve:} &    Convolves an image with a Point Spread Function \\
{\bf  Fixinval:} &    Replaces invalid pixels with a constant   \\
{\bf  Fourier:} &     Makes a Fourier transform of an image  \\
{\bf  Histogram:} &   Plot/make a Histogram of data in an image    \\
{\bf  Imgedit:} &     Change individual pixels of an image  \\
{\bf  Itfhist:} &     Make an Intensity Transfer Function to modify an image  \\
{\bf  Ndfout:} &      Convert an image into NDF format for  ADAM programmes \\
{\bf  Scatter:} &     Make a scatter plot of pixel values in two images \\
\end{tabular}
   
\newpage


\section{Introduction}
\ajhsect{\arabic{section}}{INTRODUCTION}

Starman has been constructed as a package of programmes to aid the reduction of
globular-cluster stellar photometry. After the programmes that deal with
the actual measuring of star magnitudes were written, it became apparent
that it was necessary to have a large number of other programmes to support
those core programmes, if actual astronomy was to be done. Thus the package
has became capable of dealing with many of the diverse problems that occur
when performing stellar photometry on images. For this reason,
it has became worth releasing to the community as a general purpose
stellar-photometry tool. 

In the `support' component of the Starman package, there are a number of
general purpose programmes for image and table handling and for display.
These are thus useful in other, non-stellar-photometry, astronomical data
reduction studies. 

\subsection{Using the Interim Environment}

For historical reasons, the package was written in the Starlink {\bf Interim} 
Environment, in line with the ASPIC suite of programmes. This has the
advantage that there are a number of useful programmes in the 
EDRS/EDRSX packages which supplement Starman, and that some of
the Starman programmes in turn are useful for current users of such
packages. The image display programmes which use the IKON and Workstations
are particularly useful.

Users wishing to know more about the {\bf Interim} Environment and the
ASPIC programmes should read the relevant SUNs; SUN~23 and SUN~24. 

However, following the change-over of Starlink to ADAM, it is intended to
port Starman to ADAM, so that the package can be used with the extensive
KAPPA package, and can also be used on UNIX systems. 

\subsection{Learning to Do Photometry}

This package provides the tools for doing stellar photometry. However the
user will also need some expertise in doing photometry if she is to use the
tools properly. The amount of expertise one needs to do such photometry
depends on the accuracy desired and the precise type of photometry being
done. Starman provides the tools for photometry, but cannot provide the
expertise. There is a later section of this guide which lists some reading
that might be useful for novices in photometry. 

\subsection{`Classical' Photo-electric Photometry}

There is a major photometry mode, that of the `Classical' Photo-Electric
photometry mode (with data either from P-E photometers or CCDs). This mode
is one where a (possibly large) number of individual magnitude estimates
are made during a night, each of a single star, scattered over the sky, and
it is desired to reduce them to a standard-magnitude system. Starman cannot
deal efficiently with  reducing magnitudes made in this mode. 

There is the Starman programme AUTOMAG which is designed to take CCD images
and do part of this work, looking up standard magnitudes and allowing for
extinction. However the output from that programme needs extensive further
work, such as allowing for errors in the night's extinction, allowing for
colour, time, and/or azimuth dependent extinction, determining colour
equations. If there is only a limited amount of such data, this further work 
can be done by hand. If a large amount has to be reduced, then special 
purpose programmes need to be written by the user.

\newpage

\section{Demonstration}
\label{se:demo}
\ajhsect{\arabic{section}}{DEMONSTRATION}

Below is an annotated example  of a Starman  session invocated from
{\small DCL}.  Explanations and commentary associated with each annotation
is given on the facing page.

\begin{quote}
\begin{tabbing} % Not clear why this is needed, but leading spaces get
                % lost otherwise.
\verb#$ Starman                                                                  # \fbox{1}\\
\verb#--  Starman - version 0.5 - October 1991 --                                #\\
\verb#     Get help by typing - HELP STARMAN -or- HELP 'program_name'            #\\
\verb#     Send bug reports to RLVAD::RLSAC::AJP                                 #\\
\verb#    Are your quotas large enough? -  Check in the help                     #\\
\verb#                                                                           #\\
\verb#Starman> Imcut                                                             # \fbox{2}\\
\verb#                                                                           #\\
\verb#IN:=Starman_testdata:measure_in                                            # \fbox{3}\\
\verb#XRANGE/1,100/:=?                                                           # \fbox{4}\\
\verb#  (Default - 1,input image X size     Range - 1 to input image X size)     #\\
\verb#                                                                           #\\  
\verb#  X start and X end of the area of image to cut out and put in new image.  #\\
\verb#                                                                           #\\  
\verb#  If the X end is smaller than the X start, then the output image is       #\\  
\verb#  inverted in X.                                                           #\\  
\verb#                                                                           #\\  
\verb#XRANGE/1,100/:=100,51                                                      # \fbox{5}\\
\verb#YRANGE/1,100/:=                                                            # \fbox{6}\\
\verb#BIN/1,1/:=2                                                                # \fbox{7}\\
\verb#SAMPLE/yes/:=no                                                            # \fbox{8}\\
\verb#IGNORE/no/:=$show time                                                     # \fbox{9}\\
\verb#  21-OCT-1991 17:22:11                                                     #\\
\verb#IGNORE/no/:=                                                               # \fbox{10}\\
\verb#                                                                           # \\
\verb#OUT:=fred                                                                  # \fbox{11}\\
\verb#TITLE/sprinkle + addstars/:=A trail run of Starman                         # \fbox{12}\\
\verb#Starman>show time                                                          # \fbox{13}\\
\verb#  21-OCT-1991 17:22:54                                                     #\\
\verb#Starman>imflash fred dstype=ikon idiname=ikon                              # \fbox{14}\\
\verb#Title is: A trial run of Starman                                           # \fbox{15}\\
\verb#Display values: Min =   245.4008  Max = 23.12070                           #\\
\verb#Size = 25 by 100                                                           #\\
\verb#Starman>exit                                                               # \fbox{16}\\
\verb#$                                                                          #\\
\end{tabbing}
\end{quote}

\newpage

\begin{enumerate} 

\item To run any Starman programme, you must be in the `Starman' system.
The `Starman' command does this.  You can still use {\small DCL} commands
in this mode, with the proviso that an `\@' at the start of a command line
must be preceded by `\$'. `Starman' also changes the prompt from `\$' to
`Starman$>$'. 

\item Let's run a Starman application.  IMCUT cuts a section out of an
image. You will notice that no notice is taken of the case of the letters. 

\item The input image is MEASURE{\undersc}IN.BDF in the sub-directory 
STARMAN{\undersc}TESTDATA (whose logical name was set up in the Starlink login).
You must omit the `.BDF' qualifier.

\item The programme now asks for the X range of pixels to be cut out,
and give the default start and end value. A question mark to any
Starman request will bring the help on that request, as it does here.

\item The request is now repeated, and we put in the limits for the
X range. (As the values are input with the limits reversed, the output
image will in this case be reversed left-to-right.)

\item Now you are asked for the Y range. As you just press the `carriage
return', the default values are assumed.

\item A request on how much to bin the output image. As you put in only
one parameter, and two are asked for, then the second parameter is
taken as the default value of 1. So the image is to binned in bins of
2 pixels in X and 1 pixel in Y.

\item This is asks for how to do the binning. Many questions will be
in this `logical' mode, where the only acceptable answers are `yes',
or `no'.

\item While we are running this program, we suddenly want to know what
the time is. In Starman, any request for input by a programme can be
answered by `\$ {\small DCL} command'. This is often useful in getting
help whilst you are using a programme.

\item The request is repeated.

\item The name of the new file to contain the output image is requested.
You do not out the `.BDF' qualifier. Never use the name of an existing
file, the programmes do not deal with version numbers of files.

\item All images have a `TITLE' header, which can be used to contain
some information and the image.

\item You want to check the time. You can issue any DCL command whilst
in Starman.

\item Now let's run look at the new image. IMFLASH displays the image with
a high contrast around the `sky' level. Notice that the parameters
qualifying IMFLASH are located on the command line, separated by spaces. 
Up to eight such parameters can be input on the command line. Parameter
values on the command line are not subsequently prompted for by the
application. Note also that the name of the image, `fred', has no parameter
name in front of it. A later section of the manual will describe when the
parameter name may be omitted. The display device can either be an IKON
or your workstation ( `vws' will tell it your are on a Vaxstation with VWS.
`decw' will indicate either DECWindows or any Xwindows device.)

\item The programme puts out some information about the image and displays
it on the IKON or on your workstation.

\item To exit from the Starman package, back to DCL. 

\end{enumerate}

\newpage


\section{Getting started}
\ajhsect{\arabic{section}}{GETTING STARTED}

\subsection{Quotas}

Simple programmes in Starman run correctly with normal the normal quotas
set for you by your Starlink node manager. 

However, you may need increased quotas to run some of the more demanding
programmes. If this is the case, then such programmes will fail with
strange error messages. Thus if you get such strange error messages it is
worthwhile checking how large your quotas are. You can do this check from
{\small DCL} via 

\begin{verbatim}
     $ SHOW PROCESS/QUOTA
\end{verbatim}

For full functionality, they should be at least:- 

\begin{tabular}[c]{lrlr}
\\
\hspace{4ex} CPU limit: & Infinite & \hspace{4ex} Direct I/O limit: & 40\\
\hspace{4ex} Buffered I/O byte count quota: & 30000 & \hspace{4ex} Buffered I/O limit: & 40\\
\hspace{4ex} Timer queue entry quota: & 40 & \hspace{4ex} Open file quota: & 74\\
\hspace{4ex} Paging file quota: & 50000 & \hspace{4ex} Subprocess quota: & 10\\
\hspace{4ex} Default page fault cluster: & 32 & \hspace{4ex} AST limit: & 600\\
\hspace{4ex} Enqueue quota: & 100 & \hspace{4ex} Shared file limit: & 0\\
\hspace{4ex} Max detached processes: & 0 & \hspace{4ex} Max active jobs: & 0\\
\hspace{4ex} JTQUOTA: & 3072 & & \\
\end{tabular}

If they are less, consult your system manager about getting them raised,
with her `AUTHORIZE' command. The most likely candidates requiring enlarged
quotas are PGFLQUOTA (paging file quota) and PRCLM (maximum number of
subprocesses). The system itself will have a certain `paging' limit set,
which can override your limit, so the manager will have to check there is
no problem with that. 


\subsection{Running Starman}

To run Starman from {\small DCL} just enter the command

\begin{verbatim}
     $ Starman
\end{verbatim}

This executes a procedure which you stay in while executing Starman 
commands. It also defines some logical names. You now can
mix Starman commands with the familiar {\small DCL} ones.

Starman first of all gives out information about the current version and 
then changes the prompt to:-

\begin{verbatim}
     Starman>
\end{verbatim}

You can now run the Starman programmes by just typing their names.

So what do you get for your trouble?  Section~\ref{se:class} gave a classified
list of the programmes available. These are explained in more detail in
Sections~\ref{se:progs}, \ref{se:progim}, and \ref{se:progtb}.

\subsection{Issuing Commands}

To run an application you then can just give its name---you will be
prompted for any required parameters. Alternatively, you may enter
parameter values on the command line specified by position or by
keyword.  More on this in Section~\ref{se:param}.

Commands are interpreted in a case-independent way, but may not be
abbreviated.


\subsection{Obtaining Help}

The Starman help system may be entered either whilst you inputting the
name of a programme, or whilst you are running a programme and inputting
a parameter value.

When you 
are not actually running a programme, then an introduction to Starman is given via
\begin{verbatim}
     Starman> help 
\end{verbatim}
This puts you in the top level of the Starman help and you can explore all 
the sub-topics. There is a sub-topic for each programme and then more
general helps:-

\begin{tabular}[c]{ll}
\hspace{4ex}  Author  & Information on the Starman author \\
\hspace{4ex}  Guide   & A short run-through on using Starman \\
\hspace{4ex}  Help    & More information on the HELP system \\
\hspace{4ex}  Images  & Information on Images \\
\hspace{4ex}  Menu    & A list of programmes with a one line description \\
\hspace{4ex}  Starman & General information on the Starman package \\
\hspace{4ex}  Tables  & Information on Tables \\
\end{tabular}

When you are inside a programme, the help system is available every time 
you are asked by Starman for a parameter. Then by replying with a
question mark, you get the help on that particular parameter.

\begin{verbatim}
     XXX:=?
\end{verbatim}

If you want more general help on the programme you are running, then
respond to the parameter query with:-

\begin{verbatim}
     XXX:=$help `programme_name'
\end{verbatim}

where `programme{\undersc}name' is the name of the programme you are running.
You can also get into the general Starman help with:-

\begin{verbatim}
     XXX:=$help 
\end{verbatim}


The help system uses the VMS help library, so you can get help on how to
use it by looking at the VMS help on VMS HELP. You can exit from the help
by typing {\tt CTRL/Z} (that is, pressing the CONTROL and Z keys
simultaneously) in response to any prompt. A series of carriage returns has
the same effect. 

\subsection{Exiting a Programme }

In normal circumstances when you've finished using Starman, you type
\begin{verbatim}
     Starman> exit
\end{verbatim}

which returns you to {\small DCL}.

If you are inside a Starman programme and wish to stop running it, then either 
type {\tt CTRL/C} or {\tt CTRL/Y}. This returns you to the Starman system.



\section{A `Run-through'}
\ajhsect{\arabic{section}}{A `Run-through'}

 The first goal of Starman is to provide tools for performing stellar 
 photometry on images. To give an introduction on how to use these tools,
 a list is given below of a basic run through of how to get from the
 data on tape to the output astronomy.
 
 \begin{enumerate}

 \item IMFITSIN \newline
       Read the FITS data off tape into Starman format disk files.

 \item UNCCD \newline
       Process your raw image into one without CCD effects.

 \item INTERACT \newline    Make a table of the (X,Y) positions of about six bright
                isolated stars.

 \item PROFILE \newline    Use those stars to define the mean star profile.

 \item FIND (+INTERACT) or just INTERACT \newline
        Make a table of the (X,Y) positions of all the stars in the image
        you want to measure, and also all the stars that
        affect them. If you are measuring stars on a series
        of exposures to the same field, you should first make a
        'deep' exposure by adding all the exposures together
        with IMJOIN, and then marking the positions on that.
        This will enable you to mark the very faintest stars.
        Wether it is worth the effort if you have to align the
        images first is another matter.
 
 \item MEASURE   \newline Do the fitting, using the profile and star position
                list already made.
 
 \item INTERACT    \newline Have a look at the cleaned image and/or the places
          stars fitted etc, to do a quality control check
          You may at this stage wish to go back a number of steps.
 
 \item  CHI \newline Take the magnitude list output of MEASURE and define
                the Chi-squared values for an acceptable fit.
 
 \item AVERAGE     \newline Average all acceptable fits from several different
                exposures measured using the same star list.
 
 \item DIAGRAM  \newline   Combine the magnitudes to make a colour-magnitude
                or colour-colour diagram.

 \item AUTOMAG \newline Perform automatic aperture photometry on the images
               with the standard stars, and correct for atmospheric 
               extinction.

\end{enumerate}
 

\section{Using ASPDIR, EDRS and EDRSX }
\ajhsect{\arabic{section}}{Using ASPDIR, EDRS and EDRSX}
\label{se:packs}

\subsection{Access}

The additional useful programmes which back up Starman are those already
existing in the EDRS and EDRSX packages which are listed in Section~\ref{se:addi}.

To use these, you must leave the Starman area (but keeping within the 
package. Thus to look at the EDRS package, you do:-

Starman$>$GO EDRS \newline
EDRS$>$HELP EDRS

This will get you into the EDRS area, and you can now run the EDRS 
programmes.

To get back to Starman, do:-

EDRS$>$GO STARMAN

\subsection{Use}

The most relevant programmes are the EDRS 
`ARITH', `IMGARITH', `MATHS'. and `RESCALE' ones.
The others are of varying use for stellar photometry.

The EDRSX programmes were designed for analysis of IRAS images, and are
thus more specialised, but you may find some of them useful. The most
relevant ones are listed in Section~\ref{se:addi}.

\section{Parameters}
\label{se:param}
\ajhsect{\arabic{section}}{PARAMETERS}

Starman is a command-driven package.  Thus to run the programme IMCUT, you 
type `IMCUT'. Commands in their turn have
{\em parameters\/} by which you can qualify their behaviour. Thus to tell 
the IMCUT programme that you want the first 50 pixels in X cut out, you
have to set the IMCUT parameter XRANGE to `1,50'. The values of
parameters are obtained by the programmes in one of six ways:-

\begin{tabular}{ll}
\hspace{4ex} 1) & By your responses to a prompt \\
\hspace{4ex} 2) & When you supply them on the command line when starting the programme \\
\hspace{4ex} 3) & When you set them up globally \\
\hspace{4ex} 4) & From `hidden' values \\
\hspace{4ex} 5) & By using the `Advanced Interfacing described in Section~\ref{se:advance} \\
\hspace{4ex} 6) & By making a new `connection' file \\
\end{tabular}


[This is the {\bf Interim} parameter system which is described in the
{\bf Interim} SUN document. For convenience, the main aspects of this
parameter system as seen by a user of Starman are described below. Most of
what follows is thus applicable to any {\bf Interim} application.] 

\subsection{Response to Prompts}

When a programme is running, and wants to know the value of a parameter, it
will output a request in the format:-
\begin{verbatim}
      XXX:=

  or
  
      XXX/default/:=
\end{verbatim}

You respond with the value that you want the parameter to have. If a single
value is needed, just input that. If more than one value is needed, input
them separated by commas. Character strings may have spaces. If you reply
with a `carriage return', then the default value, if any is taken. There
are rules on defaults (see Section~\ref{se:param_def}), acceptable values
(see Section~\ref{se:param_acc}), and on getting help (see
Section~\ref{se:param_hel}). 

\subsection{Command Line Setting}

Parameters may be assigned values on the command line. Thus to run IMCUT
where you want the cut out first 50 pixels in X of the image, you could
type:-
\begin{verbatim}
     Starman> imcut starman_testdata:measure_in OUT=fred XRANGE=1,50 1,99 BIN= 
\end{verbatim}

The first 50 pixels in X and the first 99 pixels in Y will be cut out with
no binning. This will only now need the on-line input of the `TITLE' whilst
running the programme. 

This example illustrates a number of facets of inputting parameter values on the
command line. The rules about command line input are:- only up to eight 
parameters may be input this way. You have to put the parameter name and an 
equals sign before the parameter value. If you do not, then that parameter 
value is taken to refer to the parameter which is in the same position in 
the programme `connection' file, the file which Starman uses to access 
parameters. Character strings may not include spaces
(that is why we could not say something like " TITLE=`A file' " in the 
example). {\em Generally}, the first two parameters in a connection file
will be the `IN' and `OUT' parameters, but this is not an iron-clad rule.
If the parameter name and `=' are followed by a blank space, the default
values are taken.

To look at the parameter list in a connection file, type::-
\begin{verbatim}
     Starman> look `programme_name'_
\end{verbatim}

Thus the IMCUT connection file is looked at by :-
\begin{verbatim}
     Starman> LOOK IMCUT_
     IN = undefined
     OUT = undefined
     XRANGE = undefined
     YRANGE = undefined
     BIN = undefined
     SAMPLE = undefined
     IGNORE = undefined
     TITLE = undefined
\end{verbatim}

\subsection{Global Setting}

One may set the value of the parameter of a program `permanently'. Thus
\begin{verbatim}
    Starman> LET IMCUT_XRANGE=1,50
\end{verbatim}

means that every for subsequent run of IMCUT, its value for the XRANGE
parameter will be set at `1,50'. This may be cleared by
\begin{verbatim}
    Starman> CLEAR IMCUT_XRANGE

 or 

    Starman> CLEAR IMCUT_
\end{verbatim}

The second command will clear all parameters of IMCUT that have been set.

You can look at the global value, if any, of a parameter by (say):-
\begin{verbatim}
    Starman> LOOK IMCUT_XRANGE

 or 

    Starman> LOOK IMCUT_
\end{verbatim}

There is no limit to the numbers of parameters that can be set this way.
Parameters that have been set do not descend to sub-processes. They are
deleted when you exit from Starman. 

\subsection{`Hidden' Setting}

Some programmes have parameter values that you cannot normally get at. The
programme will automatically assign the default values to these parameters.
These parameters are known as `hidden' parameters. 

These defaulted parameters enable programmes to have many options, say for
controlling the appearance of some graphical output, without making routine
operations tedious because of a large number of prompts. These defaulted
values are described in the HELP for each programme. 

If you wish to change the values of these parameters, you may do so by
inputting them on the command line, or by setting them globally (see 
above).

The `LOOK' command will also tell you which parameters are hidden. Thus:-
\begin{verbatim}
     Starman> LOOK MEASURE_
\end{verbatim}

will show that a number of the MEASURE parameters are `hidden'.

\subsection{Advanced Screen Interface Setting}

For certain parameters in certain programmes, one can use the flexible Advanced
Screen Interface described in Section~\ref{se:advance}.

\subsection{New Connection Files}

The Starman programmes pick up information about the parameters from
the `connection' file. Thus there is a file for the IMCUT programme.
This can be looked at with the normal {\small DCL} TYPE command.
\begin{verbatim}
     Starman> TYPE STARMAN:IMCUT.CON
     ! IMCUT.CON
     !
     IN/FRAME(R)/
     OUT/FRAME(W)/
     XRANGE/VALUE/
     YRANGE/VALUE/
     BIN/VALUE/
     SAMPLE/VALUE/
     IGNORE/VALUE/
     TITLE/VALUE/
\end{verbatim}

You can set you own `permanent' parameter values by making your own
connection file. COPY the file from the `starman' directory into the
directory you are working in (as `NAME'.CON), and alter the lines. Thus to
set the XRANGE to `1,50', replace the XRANGE line with:- 

\begin{verbatim}
     XRANGE/VALUE/1,50
\end{verbatim}

Then every time you run IMCUT {\em when you are in this directory},
the XRANGE parameter will be `hidden' and set at this value. This
will be true even if you exit from Starman and later re-enter. However
this only works if your default directory is this directory where your
new connection file is.

\subsection{Defaults}
\label{se:param_def}

When you are inputting parameters by responding to a prompt, you may be
given a `default' value. Thus if you are using IMCUT, when you are asked
for the range in X pixels to cut out, for an input image with 100 pixels in 
X, you would get:-
\begin{verbatim}
    XRANGE/1,100/:=
\end{verbatim}

Thus the default values are to take the entire X range. There are three 
types of responses you can make. You can:- input your own values to override
the defaults (in this case `2,99' would override); input some of your
own values. If there is more than one value to input, if you do not put
all the values in, the remaining ones are set at the default (in this 
example `2' would results in values of `2,100' being taken); you can
just press `carriage return', when the defaults are taken.

Help on the defaults is given in the normal help system

\subsection{Acceptable Inputs}
\label{se:param_acc}

For some parameters, there are checks on the input. Thus for the
IMCUT XRANGE parameters, any input of X pixel range which would fall
outside the image would be refused.

If an unacceptable value is input, a help on what is wrong is output,
and then either the parameter is asked for again, or the programme will
take some other action.

Help on acceptable values is given in the normal help system.

\subsection{Help on Parameters}
\label{se:param_hel}

Help on the parameters of a programme is available via the normal help
for the programme. Thus to get a list of all the parameters for the 
programme IMCUT, type:-
\begin{verbatim}
     Starman> help imcut param
\end{verbatim}

You will then also be able to get the help on the individual 
parameters.

When you are actually running the programme, respond with `?', and the
help on the parameter will be given.


\subsection{Menus}

Some Starman parameters are menus from which you select an option.
You do not have to enter the full option string, but merely a string 
that selects a choice unambiguously.  In many cases this can be as
little as a single character.  Here is an example from IMCUT:-

\begin{verbatim}
     SAMPLE/yes/:=
\end{verbatim}

The acceptable values you could input now are `yes' or `no'. But `y' or `n'
would also be acceptable. 


\section{Graphics Display}
\ajhsect{\arabic{section}}{GRAPHICS DISPLAY}

\subsection{General}

Starman uses the PGPLOT/GKS packages to output graphs. This means that
nearly all graphical output devices, including hardcopy, on Starlink can be
used. When a graph is to be plotted, you are asked for the value of the
`GTYPE' parameter. You then input the GNS name of the device you want. If
you choose the default `ask', you then get another question and you can
then type `?'. This will give you the list of the names of the available
devices. You will have to consult your system manager to see which physical
device is attached to which name. 

Three common names are `IKON', `VWS', and `XWINDOWS'. These are for the
IKON device, for VAXStation under VWS, and a workstation under DECWindows
or XWindows.

\subsection{Use of Pointer and Buttons}

With PGPLOT, one puts the pointer on the desired position, and marks that
point by pressing any key on the {\em keyboard}.

\section{Image Display}
\ajhsect{\arabic{section}}{IMAGE DISPLAY}

\subsection{General}

Images can be simply displayed on any of four devices:-

\hspace{4ex} \begin{tabular}[c]{|l|l|} \hline
    Type                    &                 Called in Starman \\ \hline
    The IKON image display                  &    `ikon'  \\
    A VAX workstation running VWS           &    `vws'  \\
    A VAX workstation running DecWindows    &    `decw'  \\ 
    Any workstation with Xwindows           &    `decw' \\ \hline
\end{tabular}

The last display is done using the `X-Windows' system, so that if the
programme being used is being run on any VAX machine (and that machine has
DecWindows and TCP/IP installed), then images can be displayed on any
X-windows system (say a Sun or a DecStation) using the Starlink utility
`xdisplay'.  Any display must have at least an 8-bit display (i.e. 256
colours available at any one time).

Also any device, including hardcopy, can be used to output a greyscale plot
of an image by using the image graphical output in the INSPECT option in
the INTERACT programme. 

You can crash the programme by telling it to display on a non-existent
device. Thus if your are on a workstation using VWS, and you tell it
to use DecWindows, then it will open the VWS software and crash in the
attempt. So be careful on this.

\subsection{Use of Pointer and Buttons}

To mark a position, one puts the pointer on the desired position, and marks
that point by pressing one of the buttons on the mouse. Each button will
often have a different effect, and one should look at the `help' for the
programme to see what the buttons actually do in any particular case.
Usually, the right-hand button denotes 'exit' from the particular function
being performed.  Starman can work with either two or three buttons
available for use on the mouse. If only two buttons can be used, then the
action of the third button is simulated by pressing the two buttons
together, with the middle one being pressed shortly before the left-hand
one. In this case also use of the middle button by itself has to followed
by a half-second pause.

(To see how to set up for the actual number, look at the 'help' for
'Numbutt' in the desired programme.)

\subsection{Look-Up Table}

Starman can only be used to display images on devices that have 8-bit
colour displays. This nominally gives the use of 256 different colours.

Starman allocates the first two colours to black and white, the next
eight to the 

`red:green:blue:cyan:magenta:yellow:coral:palegreen'

colours of PGPLOT. The next five are then various shades of grey from
black to white for the `panel' and other uses.

Images are then displayed using the next 150 colours. The default
when you run any of these programs is these colours are black to
white, going through shades of grey. An image is displayed by taking
the pixel values, translating them into numbers between 1 and 150,
and loading them in the display device. The display device then has
has a colour for corresponding to each of the numbers between 1 and
150. These colours are linear combinations of (red, green and blue).
Thus white is (1.0,1.0,1.0), black is (0.0,0.0,0.0), blue is
(0.0,0.0,1.0), and so on.

(When an image is displayed, the default is displayed so that high pixel
values are given low look-up table (LUT) values, and thus come out as
blacked than low pixel values. Thus images are generally shown as
`negatives'.) 

When the LUT is altered, it is the colours that correspond to those 150
numbers that are changed, not the numbers themselves. Thus if a pixel value
has been loaded into the display as (say) 15, it will first of all be a
dark grey (colour - 0.1,0.1,0.1). If the LUT is changed, the colour could
now be anything (say pink - 0.7,0.5,0.5). 

There is an exception to this. For devices using `X-windows' (DECstations,
SUNs, and Vaxstations using DECWindows), some or all of the 256 possible colours may
have already been allocated by another programme, and thus be inaccessible 
to the Starman program. In this case, the Starman programme first of tries
to use only 75 LUT colours, and then only 50 LUT colours. If these are 
available, it uses those, and has to make a coarser binning of the display.
If there are less than 50 colours available, then the programme will use
those `default' colours available to all programmes on the device. They may
well be very few of these, and thus the display may be very simplistic.

\section{Advanced Screen Interaction}
\label{se:advance}
\ajhsect{\arabic{section}}{SCREEN INTERACTION}

Starman has two modes whereby when inside some its programmes, one can get
away from the old-fashioned interaction of typing in lines of commands.

\subsection{Macintosh-like Interaction} 

For a number of programmes, to do with image and graph display the `OPTION'
parameters, where the programme is repeatedly asking for different options,
one can set up a `panel' of `push-buttons' which you click on with the
cursor to choose the desired option. This is much like the way you use
a Macintosh.

To do this you need to be at a workstation. The programmes where this is
possible and the parameters where it can be done are:- 

\hspace{4ex}\begin{tabular}{|l|l|} \hline
Programme    & Option Parameter \\ \hline
Diagram &   `Option' \\
Dustring & `Option' \\
Interact  & `Option' `Aoption' `Coption' `Ioption' `Soption' \\
Profile & `Option' `Dfinter', `Mapinter', `Resinter' `Woption' \\
Tbchart  & `Option' \\
Tbplot & `Option' \\ \hline
\end{tabular}

If, in response to a request for these parameters, one inputs `panel', then
a panel of the various options is put up on the workstation screen, and one
can choose the options by clicking on the `buttons' in the `panel'.

\subsection{Tables Spread-Sheet}

There is a spread-sheet for interacting with tables, which works,
to a limited extent, like the spread-sheet programmes on your PC.
This is the TBSHEET program. If you have a terminal that supports
graphics, however simply, then you can use this to inspect and
change the values in the table. Also simple applications like
SORTing and WEEDing may be done.

The table is put up on the screen in a grid, and all the options
to inspect and/or change the table are put up as boxes. One uses
the cursor to click on values to change them, or on options to
undertake those options.

\section{Proceedures}
\label{se:proc}
\ajhsect{\arabic{section}}{PROCEEDURES}

\subsection{Starman Procedures}
\label{se:proc_star}

In {\bf Interim}, it is possible to write simple procedures that will perform a
number of Starman commands. These are like {\small DCL} procedures. For a
full description, see the SUN on {\bf Interim.}

As an example of a procedure, we can make a file called `DOIT.SCL' (The
`.SCL' qualifier is important, all procedures must have that qualifier) to
perform the instructions done in the demonstration described in
Section~\ref{se:demo}. 

Then the file would have the following contents:-

\begin{verbatim}
   LET IMCUT_XRANGE=100,51
   LET IMCUT_YRANGE=
   LET IMCUT_BIN=2
   LET IMCUT_SAMPLE=no
   LET IMCUT_TITLE=A trial run of Starman
   LET IMCUT_TITLE=A trial run of Starman
   IMCUT STARMAN_TESTDATA:MEASURE_IN FRED IGNORE=no
   CLEAR IMCUT_
   IMFLASH FRED DSTYPE=IKON IDINAME=IKON
\end{verbatim}

This file must now be compiled and then run, by doing:-

\begin{verbatim}
   Starman> COMPILE DOIT
   Starman> DOIT
\end{verbatim}

The COMPILE instruction makes a file called `DOIT.SCC', which is actually
a {\small DCL} procedure, and this can then be run by typing the name of
the procedure.

\subsection{DCL Procedures}

{\small DCL} procedures may be run in the normal way from Starman, but
since they have to be preceded by an `\@' sign, in Starman this must
be further preceded by a `\$' sign. Thus to run a DCL procedure, called
(say) DOIT{\undersc}DCL.COM, one would type:-

\begin{verbatim}
   Starman> $@DOIT_DCL
\end{verbatim}

\section{Batch Jobs}
\ajhsect{\arabic{section}}{BATCH JOBS}

To run Starman programmes as batch jobs, a slightly devious route has to
be adopted. The desired commands have to be put into a Starman command
procedure, and compiled, and then this command procedure to be run in
the batch job. In effect, only one Starman command can be executed
from a batch job, so the procedure is then that single command, but it
can run any number of Starman programmes.

Thus to run the command procedure described in Section~\ref{se:proc_star},
one would make a {\small DCL} command procedure, DOIT.COM. This would
contain the lines:-

\begin{verbatim}
    $ SET NOVERIFY
    $ SET DEFAULT `desired sub-directory'
    $ STARMAN DOIT
    $ EXIT
\end{verbatim}

One can then submit this with the command `SUBMIT/QUE=`desired-queue' DOIT'.


\section{Images}
\ajhsect{\arabic{section}}{IMAGES}

In an ideal world you would not need to know how your data are stored. The
storage mechanism would be transparent, and you would perceive your data
directly through the programmes..  However, for historical reasons there
are numerous data formats in Starlink software, and at the moment you have
to be aware how your data is stored. Starman is no exception to this.
It uses the {\bf Interim} image format and you need to know a
little bit about this to use the programmes properly. 

{\bf Interim} image format is a simple data format for storing images.
Images are stored on disk as `BDF' files. Thus an image called `fred' will
be stored as FRED.BDF;1 on disk. (As with the tables, inside any Starman
programme you do not use the `.bdf' suffix in referring to the image.) 

These files have the `signed 16-bit' format on the disk. It is 
important to understand what this means for the limitations of the 
precision. See the `Precision' Section~\ref{se:im_prec} below.

Starman has some image handlers ready for use. These are the 
IM-programmes, and they have their own help. There is also the
`Interact' programme, the main image display interaction programme.

\subsection{What is in an image}

An image is a 2-D array of numbers. The numbers in an image are 
considered as stored in individual `pixels'. The coordinates are 
called `X' and `Y'.

The numbers are stored with a precision of about 1 in 50000,
but see Section~\ref{se:im_prec} for more detail on this.

Each image also has two descriptors, BSCALE and BZERO. These
are used so that the value of a pixel is:-

\begin{verbatim}
      Value = BSCALE*(disk value) + BZERO
\end{verbatim}

Generally you need not be aware of this, but again see 
Section~\ref{se:im_prec} for more detail.

Each image also has a pixel magic value descriptor, `INVAL'.
This is used to flag `bad' pixels. A pixel having this
value (its `stored' value, not necessarily its `true' value)
will be considered by the programmes as being a `bad' one
and dealt with specially.

The image also has a descriptor `TITLE', a 50 long character 
string. It does not form any part of the image itself, but can 
be accessed by the user as a source of additional personal 
information about the image. Thus for example an image called 
`VFLAT' (stored as vflat.bdf;1 on disk), could have a title of:-
\begin{verbatim}
       `This is a flat field for the V filter'
\end{verbatim}

This title is then available for inspection by the user, say by 
the programme `Imdes', and may be put out to the user by some 
programmes to show the user something about the image).

The image may also have any number of further descriptors,
added by the user, or input via `Imfitsin', or by some other
programmes.

\subsection{Precision}
\label{se:im_prec}

The numbers in an image can have any value, but there is an
actual storage matter. On the disk (or on tape), the
numbers are coded into 16-BIT INTEGERS. Thus if a programme
wants to store a number of value (say) 1,000,000 it cannot
do this directly, as a 16-bit number can only have a value
between -32768 and +32767. So each image has assigned
a scale (BSCALE) and a zero (BZERO), which are applied to all
the numbers in an image. Thus the number actually
stored is:-

\begin{verbatim}
         Stored value = (true value-BZERO)/BSCALE
\end{verbatim}

Thus if an image has $BZERO=900,000.0$ and $BSCALE=10.0$, then
a value of 1,000,000 will be stored as 10,000.
  
Similarly, when a programme reads an image from disk or tape,
it will get the true value by:-

\begin{verbatim}
         True value = (Stored value)*BSCALE + BZERO
\end{verbatim}

The advantage of this is that images are generally half the
size of a `normal' image. This means that disk and tape
storage problems are halved, and reading and writing images
into and out of programmes is faster.

A disadvantage of this is that the precision of stored values is
only about 1 in 60000. This is however good enough for most 
astronomical work.

Another disadvantage is that one has to be careful about
dynamic range. If one wanted to store an image whose values
varied between 0.8 and 1.2, with a precision of 0.0001 (say a
flat field), then it would be no good storing this with
the common default of (BSCALE=1.0,BZERO=0.0), as the values
would actually stored as the INTEGERS `0' and `1', and on
reaccessing them, they would then only have the values
of 0.0 and 1.0. They way round this is to put the BSCALE
and BZERO appropriately. Thus for this example, a BSCALE of
0.0001 and a BZERO of 0.0 would store the numbers as integers
between 8000 and 12000, which would then be able to be
accessed as values between 0.8 and 1.2 with steps of 0.0001,
as is desired.

The programmes deal with this generally without you having
to think about it, but some programmes (IMFITSIN for example in
certain cases) will not do this, so you have to think before you 
use them. 

\subsection{Coordinates}

The bottom-left-hand pixel in an image is called the (1,1) pixel. Each
pixel is thought of stretching for one pixel coordinate wide. Thus the 
blh pixel is thought of as stretching from 0.0 to 0.9999.. in X and Y,
with its centre at (0.5,0.5).


\subsection{Conversion from other systems}

If you have images in the FITS/ADAM/FIGARO formats, there are 
programmes in Starman and in ADAM and Figaro which you can use to 
convert them to the .BDF format used by Starman. 

\hspace{4ex} \begin{tabular}[c]{|l|l|} \hline
   Format              &   Conversion Programme \\ \hline
   ADAM (=HDS/NDF/SDF) &   Ndf2bdf in DCL \\
   Figaro (=DST)       &   Starout in DCL (after typing Figaro) \\
   FITS                &   Imfitsin in Starman \\ \hline
\end{tabular}

As the ADAM and Figaro conversion programmes usually give you `Real'
images, you will then have to use IMTYPE to convert them to the 16-bit
Integer*2 `Short' formats used by Starman. (Remember the possible use 
of scaling to avoid under/overflow.)

The image made from Figaro or HDS may be 3-D or 4-D. As it is
a real image, you can use the IMCUBE programme to extract
the desired 2-D plane out of the image, before using IMTYPE.
    
If you are in real trouble, use those packages to write a FITS tape
and read the files in with IMFITSIN.

Sometimes IMFITSIN will not work. It cannot deal with `byte' or
`double precision' images, nor with FITS tables.
A good way to go then is to use the FIGARO programmes
FITS and then STAROUT or the KAPPA FITSIN and then NDF2BDF to get the
images and then use the Starman IMCUBE programme
to turn it into 2-D and then the Starman programme IMTYPE to get it
to the 16-bit Integer format for Starman.

\subsection{Conversion to other systems}

If you want to put images into the FITS/ADAM/FIGARO formats, there 
programmes in in ADAM and Figaro which you can use to convert them to 
the desired format from the .BDF format used by Starman. 

\hspace{4ex} \begin{tabular}[c]{|l|l|} \hline
   Format              &   Conversion Programme \\ \hline
   ADAM (=HDS/NDF/SDF) &   Bdf2ndf in DCL \\
   Figaro (=DST)       &   Starin in DCL (after typing Figaro) \\
   FITS                &   FITSOUT in KAPPA (after doing Bdf2ndf) \\ \hline
\end{tabular}

As the ADAM and Figaro conversion programmes usually work with `Real'
images, you will then have to use IMTYPE to convert the normal Starman
16-bit Integer*2 `Short' formats to `Real', before using them.

\section{Tables}
\ajhsect{\arabic{section}}{TABLES}

The Starman suite of programs uses a simple table system for passing
tabular information back and forth between programmes and to and
from the user.

These tables are actually stored on disk as `BDF' files. Thus a 
table called `fred' will be stored as FRED.BDF;1 on disk.
(As with the images, inside any Starman programme you do not
use the `.bdf' suffix in referring to the table.)

Starman has some simple table handlers ready for use. These are the 
TB-programs, and they have their own help.

\subsection{What is in a table}

A `table' may be considered as being made up of `rows', where a 
row contains a name and set up numbers. Then the table itself
contains a number of these `rows'.

The numbers in a row are set into `columns'. The information
in a particular column generally concerns the same `aspect' from
row to row.

Each column can also have a name (its header).

Thus, for example, if one wanted to make a table of the positions
of stars, one could put the `X' position in the first column and
the `Y' position in the second column. So if one had three stars,
`fred', `george', and `arthur', with X,Y positions of (1.2,2.3),
(3.4,4.5), and (5.6,6.7) respectively, and the columns are to
have the names `X' and `Y', then the table would look like
this:-

\hspace{4ex} \begin{tabular}[c]{|l|l|l|l|} \hline
          &  Name       & Column 1    & Column 2  \\ \hline
   Header &             &  `X'        &  `Y'      \\ \hline
   Row 1  &  fred       &  1.2        &  2.3      \\
   Row 2  &  george     &  3.4        &  4.5      \\
   Row 3  &  arthur     &  5.6        &  6.7      \\ \hline
\end{tabular}

A table also has a `TITLE'. This is a character string which
can be added to the file containing the table. It does not
form any part of the table itself, but can be accessed by the
user as a source of additional personal information about the
table. Thus for example a table called `BADPIXELS' (stored as
badpixels.bdf;1 on disk), could have a title of:-

\begin{verbatim}
       `This is a list of bad areas on my CCD'.
\end{verbatim}

This title is then available for inspection by the user, say by 
the programme `Tblist', and may be put out to the user by some 
programmes to show the user something about the table).

The `name' of a row may be up to 20 characters long. (A common
default usage is for them not to have names like `arthur', but to
be in the form `\#n', e.g.  `\#201', `\#1456'.

The numbers in the columns are 32-bit real numbers, thus having
a precision of about 6 decimal places, and a possible range
of about -10**38 to + 10**38.

The table may also have any number of further descriptors,
added by the user or some programmes.

(Some of this information is for people who want to access the tables
directly via their own programmes.)

Data are stored in .BDF files as real*4 values. The first 5 values 
in a row code a row name, and the data columns start after that. 
Programs which ask for parameter number or column number start 
their numbering from the first data column. Each file must have at 
least two columns.

There are also file `descriptors' which can contain individual items 
of information, in a way analogous to FITS descriptors.

Some programs assign to each data column a header parameter and some
programs use these parameters to find the column containing the 
desired data. Some programs just rely on the column positions. These 
column header parameters are stored as descriptors of the BDF image. 
The header for column 1 is stored as the value of parameter HEAD001, 
that for 2 in HEAD002, and so on. The headers are character strings 
up to 20 characters long. 

Although in actuality inside the computer the identifier is stored in 
the same way as the columns, taking up five columns, it is not 
thought of as occupying a column, and the data columns are numbered
from 1. The `size' of a row in a file, given by the `NITEM'
descriptor, is thus five more than the number of columns.

The number of rows in a table is given by the `LSTLEN' descriptor of 
the file.

(As a matter of interest to more sophisticated users and programmers ,
this is an enhanced version of the Starlink {\bf Interim} Environment 
EDRS table system, copyright R.F.Warren-Smith.)

\section { A Programmer's Guide to Starman}
\ajhsect{\arabic{section}}{PROGRAMMER'S GUIDE }

\subsection{Introduction}

Starman has evolved from the {\bf Interim} environment ASPIC GRASP suite
of programmes, with the influence of the IRAF SPP programming language.
The aim has been to produce readable code, and to protect against
future changes in the environment.

Thus the code is written in what seems to me to be a nice and neat, but not
too curt, style. Sub-routine calls to the outside world are insulated
through subroutines, and all non-public domain libraries have been
excluded (although see the comment on the NAG routines).

\subsubsection{Use of the INTERIM Environment}

To understand the basic rules of using the {\bf Interim} Environment, read the
Starlink SUN 4.

Starman uses its own version of the Environment. The s/w for the 
environment has been copied into the `.dscl' and `.interim' 
sub-directories, and thus Starman is independent of the official Starlink
{\bf Interim} version. The reason for doing this was to make Starman 
transportable outside of  Starlink, and also to permit some slight
modifications to the Environment to make it more generally useful by 
removing some of its limitations and permitting Starman to be run
directly.

The `.dscl' sub-directory contains the programmes and procedures
for running Starman.

The `.interim' sub-directory contains the {\bf Interim} sub-routines,
some of which have been modified. It also contains a copy of the {\bf 
Interim} Tape I/O library.

The {\bf Interim} use of the `.con' connection files for communication with the 
outside world is as normal.

\subsubsection{Programming Style}

The style generally follows the IRAF SPP style. Features are:-

\begin{enumerate}

\item Use of include files with COMMON for passing numbers around
      the programmes.
\item Use of `implicit none' to check on variables.
\item Use of a standard way of starting a subroutine -

\begin{quote}
\begin{tabbing}
\verb#CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC # \\
\verb#C s/r name -- one line description                           # \\
\verb#C    lines of description                                    # \\
\verb#C                                                            # \\
\verb#C   author              institution              date        # \\
\verb#                                                             # \\
\verb#      subroutine name ( param1, param2, etc. )               # \\
\verb#                                                             # \\
\verb#      include files                                          # \\
\verb#                                                             # \\
\verb#      type       param1       !i: description                # \\
\verb#      type       param2       !o: description                # \\
\verb#C--                                                          # \\
\verb#      types    work variables                                # \\
\verb#Cbegin                                                       # \\
\verb#                                                             # \\
\verb#        s/r code                                             # \\
\end{tabbing}
\end{quote}

\item The use of the ``--'' double minus sign indicates the start and
      end of the s/r description. So in no other location are two
      minus signs to be used.

\item Extensive use of comments.

\item Use of comments to be restricted to after column 80, preceded
      by an exclamation mark. Sometimes comments starting from
      line 1 (with a ``C'') have to be present for readability.

\item No sub-routine to extend over more than 200 lines (including
      start and comment lines).

\item All programmes to work as sub-routines. Thus a programme should
      start:-

\begin{quote}
\begin{tabbing}
\verb#      program name           # \\
\verb#      call t_name            # \\
\verb#      end                    # \\
\verb#      subroutine t_name ()   # \\
\verb#        `contents'           # \\
\verb#      end                    # \\
\end{tabbing}
\end{quote}

\item Use of a common `FAILED' variable to show programme failure.

\item Exit from s/rs on `FAILED' being set.

\item Code to be in lower case.

\item Indentation by three columns at each step.

\item Variables in COMMON to be in upper case.

\item Often used variables relating to images and tables to
      be given standard names and be loaded by the use
      of the `image.inc' and `table.inc' include files.

\item The top level sub-routine to be mainly just a small set of
      calls to sub-routines which do the actual work.

\end{enumerate}

\subsubsection{Starman General Sub-routines}

In the `.lib' sub-directory, there are a large number of subroutines
which are used by more than one programme. The programmer should
browse through the files there. 

The routines which address the {\bf Interim} routines are kept in two
files. There is also a file which has routines that whilst they are
not {\em too} peculiar, do have some VAX specific calls and have
thus been separated to ease in porting.

Amongst the routines are
a number of sets of sub-routines which are of general use in
writing programmes. These general sets include:-

\begin{enumerate}

\item {\bf Typing out: \\ }
       There are two sr/s, {\bf printo} which
      types out a line of text, and {\bf printd} which does the same, but can
      insert variables in it, in the fashion of the C routine {\bf printf}.
      To make that work, you need to start the programme with {\bf pargbeg}
      to set up the system. Then the routines {\bf parg(cilr)} let you load
      character strings, integers, logicals and reals, which are then
      inserted in a {\bf printd} s/r as 

       \hspace*{\fill}  {\bf call printd ( ' text \%c \%d \%l \%f ' ) }  \hspace*{\fill}  

\item {\bf Vector Arithmetic: \\ } 
      Arrays of numbers may be 
      simply manipulated with the routines found in `[.lib]starflibv.for'. 
      An example of this is {\bf call aaddr ( a, b, c, n )} which will add
      the two real arrays, `a' and `b', to produce the array `c', doing it for 
      the first `n' items in the arrays. These routines do not deal with 
      `magic' values.

\item {\bf Image I/O: \\ } 
      Opening images for reading and writing 
      is done with the {\bf opim(isur)(rw)} routines (these in turn use the
      {\bf Interim} environment calls to do the actual work). Images are closed 
      with the {\bf candata } routine. There are also routines for
      accessing descriptors of images.

\item {\bf Table I/O: \\ }
      Opening tables for reading and writing 
      is done with the {\bf optab(rw)} routines (these in turn use the
      {\bf Interim} environment calls to do the actual work). Tables are closed 
      with the {\bf candata } routine. There are also a number of routines
      for accessing names and headers in tables. Headers in tables are
      descriptors with the names `HEAD001', `HEAD002', etc..

\item {\bf Parameter I/O: \\ }
       Getting parameters from the
      user are done with the {\bf get(12345)(bcir)} routines. These 
      parameters are cancelled with the {\bf canpar} routine. These 
      routines in turn call {\bf Interim} ones.

\item {\bf Work Space: \\ }
      Work space is opened with the {\bf gtwrk(irs)} routines, and closed
      with the {\bf candata} one.

\item {\bf Help: \\ }
       There are routines for accessing the {\bf Interim} help system.

\item {\bf Graphics: \\ }
      There are routines which can be used
      as an interface to some of the PGPLOT routines, These are mainly to
      do with opening and closing devices, where it has been found
      useful to have them in a standard form. There are some other packs of
      PGPLOT routines that have been found useful. 
           
\item {\bf Copying Arrays: \\}
      There are a number of routines
      that copy data between arrays in a number of useful fashions.

\item {\bf Maths: \\}
      There are a number of useful mathematical routines. These have been
      provided to escape from the straight-jacket of the NAG system, and 
      thus make the suite portable. There is a complete `sort' set in 
      these.

\item {\bf Parallel Processing: \\}
      There is a suite of routines for talking to the parallel processors.

\item {\bf GUI: \\ } 
      The `panel' buttons which can be used to interact with the user
      in a kind of `Graphical User Interface', are actually very limited.
      There are the {\bf DS\_P\_}xxx routines for opening and closing
      a panel, and doing the interaction with the panel. (These are found 
      in the `.disp' sub-directory.) Then there is the {\bf get\_job} routine 
      for high-level putting the buttons up and finding which button has 
      been pressed. The documentation on how to set up the panel (of which
      there can be only one at one time in a programme) is very limited,
      and the programmer will have to read the code to see how it works.

\end{enumerate}

\subsubsection{Needed Outside Libraries}

The needed libraries, outside of those of Starman, are:-

\begin{list}{{-}}{}

\item {\bf Graphics: \\ }
     The graphics works through PGPLOT. For the Starlink implementation, 
     PGPLOT uses GKS and GNS libraries, and the EMS\_ and CHR\_ libraries.

\item {\bf Image Display: \\ }
     The image display works for IKONs, for VAX VMS VWS windows, and for 
     the DEC X-windows implementation DECWindows. Thus the libraries for
     these are needed

\item {\bf Astrometry: \\ }
      The Starlink SLALIB astrometry library.

\item {\bf NAG: \\ }
      The Numerical Algorithms Group NAG library. This has a very limited
      use. It is only used for two graphical displays in INTERACT and
      in the calculations of TBTRAN\_MAKE. If you do not have the NAG
      library (because of its cost), these two programmes can be compiled
      using the Starman `fake' NAG library, which avoids a crash when these
      programmes are run, merely reporting a null function.

\end{list}

\subsection{Directory Structure}

The Starman directory contains all the executables with their
connection files, the Starman Help library, the parallel processor
executables (the `.app' files) and two DSCL procedures controlling the
prompting the user sees.

The code for each Starman programme lives in a sub-directory below
the Starman directory. The sub-directory contains all the code needed 
for that programme, apart from the code in the libraries.

The code for the libraries live in their own sub-directories, of which 
there are four:-

\begin{list}{{-}}{}
\item {\bf `.lib' -- } This contains the general purpose library which
has the general purpose subroutines and the routines to access the
{\bf Interim} environment.

\item {\bf `.disp' -- } This contains the display subroutines.

\item {\bf `.par' -- } This contains the parallel processor routines. There
                       are some sub-directories.

\item {\bf `.interim' -- } This contains the Starman version of the {\bf Interim} 
                           environment and the tape i/o library

\end{list}

In the `.image' and `.table' sub-directories there are the `image.inc' and
`table.inc' include files used by the codes in many programmes.

There are also the `.docs', `.dscl', `.help', `.link', `.local', and
`.testdata' sub-directories.

\subsection{The {\bf Make} command}

Starman has a {\bf make} command which is used in two ways:-

\begin{list}{{-}}{}
\item To compile and link the code for the individual programmes.
\item To compile and place in the object libraries the code for the
      subroutine libraries.
\end{list}

These perform some of the functions of the UNIX {\bf make} tool, but are
much more simple and limited.

\subsubsection{{\bf Make} for programmes}

\vspace*{3mm}{\bf Using {\bf Make} }\vspace*{3mm}

By running the {\bf make} file (do this by typing `@make') in a programme
sub-directory, the following functions are performed:-

\begin{list}{{-}}{}

\item Each of the Fortran modules are checked to see if there is compiled
      version (the `.obj' file) of a later time present. (The `time' of a 
      file in this sense is the time when it is created.) If one is not, 
      then that module is compiled. Also if there is no such compiled file. 

\item All the modules are then linked (regardless of the state of the 
      present executable) to produce a new executable (the `.exe' file)
      placed in the Starman directory.

\item The previous executable is purged.

\end{list}

The {\bf make} does not look at the time of any include files. So if such
a file has been changed, the user will have to produce the programme herself.
A simple way to do this is to delete {\em all} the compiled files and
run the {\bf make}.

The default executable that is produced has no `traceback'. If a version
with traceback is desired, then the {\bf make} should be run with 
\mbox{`@make\hspace{0.5em}TRACE'}. If a debugging version is desired, then {\bf make}
should be run with \mbox{`\@make\hspace{0.5em}TRACE\hspace{0.5em}DEBUG'}. A debugging
version of a programme has to be run outside of Starman. One must be
in the Starman directory, and then the programme is run by typing
\mbox{`runstar\hspace{0.5em}{\it{programme-name}}'}.

\vspace*{3mm}{\bf Writing a {\bf Make} file  }\vspace*{3mm}

The {\bf make} works in a rigid way. It first of all sets up some logical 
names which tells it what fortran modules to access, and then runs a 
standard procedure to `make' these files. The libraries and type of
executable are told to the {\bf make} at that time. 

The simplest way to describe how to write a {\bf make} file is to discuss
one. Below is the {\bf make} file for the UNCCD programme, with some 
comments added.

\begin{quote}
\begin{tabbing}
\verb#$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                       #\\
\verb#$!  MAKE.COM   for UNCCD                                      #\\
\verb#$!                                                            #\\
\verb#$!                                                            #\\
\verb#$    assign unccd                    z0                       # \fbox{1}\\
\verb#$    assign starman                  z1                       # \fbox{2}\\
\verb#$!                                                            #\\
\verb#$    assign x_unccd                  y1                       # \fbox{3}\\
\verb#$    assign unccd                    y2                       # \fbox{4}\\
\verb#$    assign unccdsub                 y3                       # \fbox{5}\\
\verb#$    assign unccdsubvax              y4                       #\\
\verb#$!                                                            #\\
\verb#$    assign starmanlib:starolib      y5                       # \fbox{6}\\
\verb#$!                                                            #\\
\verb#$    @starmanlink:domake 4 1 'p1' 'p2' 'p3' DISPLAY           # \fbox{7}\\
\verb#$!                                                            #\\
\verb#$    exit                                                     #\\
\end{tabbing}
\end{quote}

The comments are:-

\begin{enumerate}
\item The logical name `z0' is given to the programme name.
\item The logical name `z1' is given to the directory where the executable
      is to be placed.
\item The logical name `y1' is given to the Fortran module with the programme 
      top-level code.
\item The logical name `y2' is given to the Fortran module with the first part 
      of the programme code.
\item The logical name `y3' is given to the Fortran module with any other 
      code. The logical names `y4', `y5', etc. are given to the other 
      Fortran modules.
\item The Starman standard library has then to be given a logical name. 
      This is `yN' where `N' is one more than the last `y' logical name 
      given to the programme modules. If the user wants to give the 
      programme access to other libraries (not dealt with below), then this
      is the place to mention them, as subsequent logical names `yN+1', 
      etc..
\item The `domake' procedure takes these logical names. It also needs some
      control parameters. The first is the number of programme Fortran 
      modules and the second is the number of libraries given logical 
      names. There are then three passing parameters to allow for
      passing parameters down from the command line of the `@make'
      command. There are then the list of standard Starman extra
      libraries that will be needed by the programme. These are:-

      \begin{tabular}{|l|p{3in}|}\hline
       Entry & Library \\ \hline
       DISPLAY & The {\bf dispolib} or {\bf dispolib\_noidi} display library 
                 in the {\bf `.disp'} sub-directory. \\
       NAG     & The {\bf starolib\_nag} or {\bf starolib\_nag\_fake} library
                 in the {\bf `.lib'} sub-directory, used to access the NAG
                 (Numerical Algorithms Group) subroutine library. \\
       PAR     & The {\bf parolib} or {\bf parolib\_fake} parallel processor library 
                 in the {\bf `.par'} sub-directory. \\
       TAPE    & The {\bf tapeio} tape library in the {\bf `.interim'} 
                 sub-directory. \\ \hline
       \end{tabular}

       There are also two control parameters which allow access to the
       standard Starlink libraries. These are:-

      \begin{tabular}{|l|p{3in}|}\hline
       Entry & Library \\ \hline
       ASTROM & Allows access to the SLALIB\_DIR astrometry library. \\
       GRAPH  & Allows access to the PGPLOT\_DIR graphical library. \\ \hline
       \end{tabular}

       Not more than three of these control parameters may be used. (A 
      fourth is possible if the ``{`p3'}'' parameter is omitted.) This 
       is because only eight parameters in all are allowed on the command
       line for an {\bf Interim} procedure.

\end{enumerate}

\subsubsection{Make for Libraries}


\vspace*{3mm}{\bf Using {\bf Make} }\vspace*{3mm}

By running the {\bf make} file (do this by typing `@make') in a library
sub-directory, the following functions are performed:-

\begin{list}{{-}}{}
\item Each of the Fortran modules
are checked to see if there is compiled version (the `.obj' file) of a 
later time present. (The time of a file is that when the last change is 
made to it. A change can be something as simple as a change in its 
protection.) If one is not, then that module is compiled. Also if there
is no such compiled file.

\item All the modules are then loaded (regardless of the state of the 
      library) into the library.

\end{list}

The {\bf make} does not look at the time of any include files. So if such
a file has been changed, the user will have to produce the change in the
library herself.
A simple way to do this is to delete {\em all} the compiled files and
run 

The default library module that is produced is a normal one.
If a debugging version is desired, then {\bf make}
should be run with \mbox{`\@make\hspace{0.5em}DEBUG'}. 

\vspace*{3mm}{\bf Writing a {\bf Make} file  }\vspace*{3mm}

The {\bf make} works in a rigid way. It first of all sets up some logical 
names which tells it what fortran modules to access, and then runs a 
standard procedure to compile and load files. The libraries and type of
executable are told to the {\bf make} at that time. 

The simplest way to describe how to write a {\bf make} file is to discuss
one. Below is a shortened version of the {\bf make} file for the DISPLAY
library, with some comments added.

\begin{quote}
\begin{tabbing}
\verb#$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                       #\\
\verb#$!  MAKE.COM   for Starman Display Library                    #\\
\verb#$!                                                            #\\
\verb#$!                                                            #\\
\verb#$    if ( p1.nes."" .and. p1.nes."DEBUG" )                    # \fbox{1}\\
\verb#$    then                                                     #\\
\verb#$       write sys$output "Dont understand parameter"          #\\
\verb#$       exit                                                  #\\
\verb#$    endif                                                    #\\
\verb#$!                                                            #\\
\verb#$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!         #\\
\verb#$!                                                            #\\
\verb#$    assign dispolib                 z0                       # \fbox{2}\\
\verb#$!                                                            #\\
\verb#$    assign ds_gen                   y1                       # \fbox{3}\\
\verb#$    assign vw_gen                   y2                       # \fbox{4}\\
\verb#$!                                                            #\\
\verb#$    @starmanlink:setcomp 2 'p1'                              # \fbox{5}\\
\verb#$!                                                            #\\
\verb#$    @starmanlink:loadlib 2 Display                           # \fbox{6}\\
\verb#$!                                                            #\\
\verb#$    exit                                                     #\\
\end{tabbing}
\end{quote}

The comments are:-

\begin{enumerate}
\item It is checked that the user has given no entry on the command line,
      except if she wants the debugging versions made.
\item The logical name `z0' is given to the library name.
\item The logical name `y1' is given to the Fortran module with code for the library.
      top-level code.
\item The logical name `y2' is given to another Fortran module with code
      for the library. Further modules would be given names `y3', `'y4', 
      etc.. 
\item The modules which need compiling are the compiled. The first 
      parameter tells how many modules are to be checked, and the
      second, passed down from the user, controls whether the
      normal of the debugging versions are to be made.
\item {\em All} the modules are then loaded into the library. The first 
      parameter tells how many modules are to be loaded, and the
      second gives the name to be shown to the user as she sits at the
      terminal.
\end{enumerate}

\subsection{Linking}

When linking Starman, in the `.link' sub-direcory, the dolink.com 
procedure, which does the actual linking, has at its the beginning a section
which tells it which of some special libraries are present. These are
the `parallel', `NAG', and `idi' libraries. For those that are not
present, their controls should be set as "N", and then the linker knows 
what to do. Either they are not asked for, for `fake' libraries which
have the demanded sub-routines as dummies are called for.

There is also in the [.link] sub-directory, procedures to link:- all 
programmes; just the display programmes; just the `parallel' ones;
to link all programmes from a batch job.
  

\newpage
\section{General Programmes}
\ajhsect{\arabic{section}}{GENERAL PROGRAMMES}
\label{se:progs}

\newpage

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} ADDSTARS}

\sstroutine{ADDSTARS}{
   Adds or subtracts stars into an image}{

   \sstdescription{

 This program adds or subtracts stars into an image. Noise can
 be added to these stars. A sky (with noise) can be added, as can a 
 separate noise level, and as can a separate input image.

 The stars are input via a file with a table of X,Y positions and
 heights. A common star profile can be used to add the stars,
 or they can all have individual profiles (which profiles are fed in 
 as extra parameters of the star table in addition to the normal
 profile image file input).

 The program takes care of pixel averaging (for small radius stars) and
 and calculates the profile out to the point where it has a value of 0.2.

}\sstdiytopic{Use}{
\begin{list}{{--}}{}
 \item Input an image to add to, or input the size of the new
       image to make. 
\item Feed the list of stars as a list of (X,Y star positions,
       and heights, [and optionally profile] ).
\item Feed in a profile file.
      If the list of star positions has profile parameters for
       each star, then they are adopted for each star, otherwise the standard
       profile is used for all the stars. The star heights must be the actual 
      heights. 
 \item Choose whether or not to:-

\begin{list}{{-}}{}
 \item use the profile map 
 \item use the profile file 
 \item override any profile parameters in the input star position table 
 \item have the stars as positive or negative stars 
 \item feed in any scaling for the star noise 
 \item feed in any sky background, and any scaling for the sky noise 
 \item feed in the standard deviation for any extra sky noise 
\end{list}

  \item Specify the output image. 
\end{list}

}\sstdiytopic{Method}{
 Each star is given a profile, and an x,y position and a height. Then
 for each pixel near the star, the mean intensity of the star is 
 calculated. If the radius is small, then when the profile is
 changing rapidly the mean is made from calculations of sub-pixel
 values in the pixel.

 Then this mean is then added or subtracted from each pixel.

 This is done for all pixels round the star, out to the place where
 the star value is 0.2.


 The mathematical expression of this star value is:-



$$I(x,y)= H.\left(\frac{1}{1+d_{1}^{P(1+d_{2})}}+QH.e^{-d_{3}^{QP}}+F(x,y)\right)+A+B.x+C.y$$


where 

\begin{tabular}{l l l}

 $ I(x,y)$ &$=$& the value of the star profile at pixel position x,y \\ 

$H $&$=$&  the star peak height\\

$x_{0}, y_{0} $&$=$& the star centre position\\

 $A, B, C $&$=$& the sloping background \\

$ d_{1} $&$=$&$ \sqrt{\left(\frac{x_{1}}{RX}\right)^2+\left(\frac{y_{1}}{RY}\right)^2}$ \\


$ d_{2} $&$=$&$ \sqrt{\left(\frac{x_{1}}{PRX}\right)^2+\left(\frac{y_{1}}{PRY}\right)^2}$\\ 
$x_{1} $&$=$&$ (x-x_{0}).cos(THETA) + (y-y_{0}).sin(THETA)$ \\
$y_{1} $&$=$&$ -(x-x_{0}).sin(THETA) + (y-y_{0}).cos(THETA)$ \\ 
$d_{3} $&$=$&$\sqrt{\left(\frac{x-x_{0}}{QR}\right)^2+\left(\frac{y-y_{0}}{QR}\right)^2}$ \\

\end{tabular}

(For a full description of this see the `profile' section in the Starman 
manual.)

   If noise is wanted in the star images, then each pixel can be looked
   at and Poisson noise added. The pixel are treated as
   scaled levels. Thus the Poisson noise is calculated as if each
   pixel value is the photon counts divided by some scaling.

   The sky is added as a flat back ground with optional Poisson noise
   (scaled as for the stars, but with a different scaling factor).

   A separate noise level (not scaled) can be added.

   An input image can be added.

}\sstparameters{
\sstsubsection{ADD = LITERAL (Read)}{
  (Default - 'add'   \hspace{6ex}   Choice - 'add:sub' ) 

  Do you want the stars to be added into, or subtracted from the
  image?

}\sstsubsection{DOMAP = LITERAL (Read)}{
  (Default - 'yes'      \hspace{6ex} Choice - 'yes:no')

  Whether to use the empirical profile map in the profile file.

}\sstsubsection{IN = BDF (Read) }{
  (Default - null)

  The name of the file containing the image to add stars to.

  The image has to be an integer*2 .BDF file.

  If a null response is given, then no image is input and a new one of
  a size defined by the user and having a given flat background is
  used to add the stars to.

}\sstsubsection{INSTARS = BDF (Read) }{
  (Default - null)

  The name of the file containing the table of star positions and heights, 
  and optionally profiles.

  The x, y, heights must either be the first three parameters, or
  there must be pointers to them in the standard header format of
  parameter 'HEAD00n' being X, Y, and HEIGHT for parameter being in
  column n.

  If the profile parameters are there, then the list must have the
  standard profile headers RX, RY, P, PRX, PRY, THETA, QH, QR, QP,
  MAPNUM, MAPX, MAPY, MAGNIF.

}\sstsubsection{PIXNOISE = {\undersc}REAL (Read) }{
  (Default - 0.0     \hspace{6ex}     Range - 0.0 to 1.0e8)

  The standard deviation of any extra Poisson noise to be added
  to the sky.

  This is = std dev of (true no of detected photons in pixel).

  This may not be the std dev of the actual sky counts, as the
  `SKYGAIN' parameter, which is used to translate the actual pixel
  counts into their Poisson equivalent, may not be 1.0

  The Std dev of the actual pixel counts added will be = 
  `Pixnoise'/`Skygain'

  If 0.0 is entered, no extra noise is added

}\sstsubsection{PROFILE = BDF (Read) }{
  (Default - null)

  The name of the file containing the image with the 
  standard star profile.
  
  This must not be null. (Although sometimtes its profile may never 
  be used, in the case if, for all the stars, it is overridden by 
  their own (optional) profiles contained in the 'INSTARS' file.)

}\sstsubsection{PYES = LITERAL (Read) }{
  (Default - 'yes'      \hspace{6ex}  Choice - 'yes:no')

  Whether to have the profile parameters in the profile file override
  any profile parameters in the star list.

}\sstsubsection{OUT = BDF (Write) }{
  (Default - null)

  The name of the new file to contain the output image.

  This will be 16-bit integer format.

}\sstsubsection{SEED = {\undersc}INTEGER (Read) }{
  (Default - 1234567891      \hspace{6ex} Range - 1200000001 to 1400000001)

  The random number generator seed. This should be an odd number
  between 1,200,000,001 and 1,240,000,001.

  This applies to the star images or the sky background, depending
  on the previous answer. It is only asked for if the stars or
  sky are/is to be added with noise. The seed is only asked for
  for the sky noise, if there is no star noise.

  The seed only has to supplied once, if at all, as the random
  number generator is not reset after doing the stars.

}\sstsubsection{SKY = {\undersc}REAL (Read) }{
  (Default - 0.0 if input image, 100.0 if no input image.
     \hspace{6ex} Range - -1.0e9 to +1.0e9)

  Sky value to add to output image.

}\sstsubsection{SKYGAIN = {\undersc}REAL (Read) }{
  (Default - 1.0     \hspace{6ex}   Range - 0.0 to 1.0e8)

  The conversion, for the sky, between the numbers that go in
  the image and the number of independant Poisson events.

  This is = (true no of detected photons in pixel)/(pixel counts).

  One way this can be is for a CCD, where it would be 
             = electrons/adu

  If 0.0 is entered, then no sky noise is added

}\sstsubsection{SKYPOIS = LITERAL (Read)}{
  (Default - 'yes'      \hspace{6ex} Choice - 'yes:no')

  Add in noise coming from the Poisson nature of the sky flux?

}\sstsubsection{SIZE = {\undersc}INTEGER(2) (Read) }{
  (Default - 100,100.      \hspace{6ex}    Range - 1 to 4096)

  X and Y size of new image to add stars to.

  This is only asked for if there is no input image, and a  new
  one is to be made.

}\sstsubsection{STARGAIN = {\undersc}REAL (Read) }{
  (Default - 1.0      \hspace{6ex}      Range - 0.0 to 1.0e8)

  The conversion, for the stars, between the numbers that go in
  the image and the number of independant Poisson events.

  This is = (true no of detected photons in pixel)/(pixel counts).

  One way this can be is for a CCD, where it would be 
             = electrons/adu

  If 0.0 is returned, then no noise is added.

}\sstsubsection{STAROIS = LITERAL (Read)}{
  (Default - 'yes'      \hspace{6ex} Choice - 'yes:no')

  Add in noise coming from the Poisson nature of the star flux?

}\sstsubsection{TITLE = LITERAL (Read) }{
 (Default - Input image title or 'Output from ADDSTARS')

  Title to add to the output image.
       }

}
}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} AUTOMAG}

\sstroutine{AUTOMAG}{Simple aperture photometry on stars}{

   \sstdescription{
  This does simple aperture photometry on stars in an image. It works
  automatically, finding the stars, doing the aperture photometry and
  outputting the results. It uses the (optional) presence of an
  exposure time descriptor to correct the magnitude to that for a
  1 second exposure.

  It can also, depending on the presence of the appropriate information
  in the image descriptors and the users wish:-

\hspace{4ex}\begin{tabular}{lp{5in}}
   - &Find the Zenith distance (either from the image or a standards file) \\
   - &Find the Filter used \\
   - &Apply the extinction correction \\
   - &Look up the object name in a file and find the appropriate
      standard magnitude, which it then compares to the measured magnitude \\
   - &Output results to a text file as well as the terminal \\
\end{tabular}

  It is best used if there are only a few (less than about 10) stars
  in the image.

}\sstdiytopic{Use}{
  The programme starts off by asking you what type of measuring
  do you want to do:-

  \begin{list}{{-}}{}
     \item Measure one or a number of images with the same parameters
     \item Use the Gaussian centering after the centroid finding
     \item Make an output results file
     \item Calculate the zenith distance of the image
     \item Use the image filter to determine the extinction correction
        (needs SecZ calculation)
     \item Use a standard position and magnitude file to calculate the
        difference from the standard magnitude (needs SecZ and filter
        calculation)
\end{list}

  It then asks you for a number of parameters associated with the
  the star finding and measuring process.

  Then there are a number of sections of parameter questions that are
  asked depending on which of the measuring options you have chosen

\begin{list}{{-}}{}
    \item Output file
    \item Zenith distance (Star position in RA and Dec and site latitude)
    \item Use of filters for extinction calculations
    \item Use of standard file for standard magnitude calculations
\end{list}

  Then the name of the input image file is asked for, and then the user
  is given the chance to correct the exposure time.

  The programme then does the calculations and outputs the results to
  the terminal and (optionally) the file.

  If the user is doing more than one image, the programme loops back
  to ask for the new image file name ( and the new corrected exposure
  time), and does the new calculations. This loop is repeated until
  a blank is input as the file name.

}\sstdiytopic{Method}{
\vspace*{2mm}{\bf Measuring the Stars}\vspace*{2mm}

  It finds stars as groups of pixels which are more than a certain value
  above the sky level. It then finds the centre of these groups, and puts
  an aperture round them, giving the flux in the aperture. It then
  finds the sky level in up to four apertures located around the star,
  finds the mean sky level, deducts that from the star aperture flux, to 
  give the star flux.

  This flux is then turned into a magnitude by the formula

       $$        Magnitude = 30.0 - 2.5*log_{10}(flux) $$

\vspace*{2mm}{\bf Correcting for Exposure time}\vspace*{2mm}

  This magnitude is then corrected for the exposure time. The flux
  is changed to that it would have had in a 1 second exposure, that is

    $$               Magnitude = magnitude + 2.5*log_{10}(exp time) $$

\vspace*{2mm}{\bf Correcting for Extinction }\vspace*{2mm}

  If the user desires, then the magnitude can be corrected for extinction.

  This is done by taking the RA and Dec and Sidereal time from the image
  descriptors, and working out the Sec Z of the exposure. Then the filter
  that was used in the exposure is found from an image descriptor, and
  used with the extinction input by the user for such a filter to work
  out the extinction.

  The Sec Z is worked out in first order terms as:-

  $$  SecZ =  \frac{1.0}{sin(lat)*sin(dec)+cos(lat)*cos(dec)*cos(ha)} $$

  A corrected magnitude is then worked out as:-

  $$                  Magnitude = magnitude - Extinction*(SecZ-1.0) $$

  It is possible to get the image RA and Dec not from the image 
  descriptors, but from the standards file. In this case the
  star name in the image descriptors is taken, and that name looked
  for in the standards file.

\vspace*{2mm}{\bf   Checking Against a Standard Magnitude}\vspace*{2mm}

  If the user desires, the standard magnitude of the star in the
  waveband used may be found from the input standards file. In this
  case, the star name in the image descriptors is taken, and that 
  name looked for in the standards file. The magnitude in the
  waveband used, for that star is then output, together with the
  difference between the `observed' magnitude and the standard
  magnitude.

}\sstdiytopic{Sky Locations}{
  The number and location of the sky apertures is defined by the
  user. Up to four apertures may be used. These are distributed
  in an X-Y frame around the star aperture, where the X-Y offsets
  give the X-Y distances in pixels between the star aperture
  centre and the sky aperture centres.

  The default is a star aperture diameter of 40 pixels, and four
  sky apertures, each of 20 pixels diameter, located to the left
  right, up and down from the star aperture with star-sky
  centre distances of 40 pixels. Thus the sky apertures come within
  10 pixels of the star aperture.

}\sstdiytopic{Star Finding}{
  The program finds stars by looking for blocks of pixels above the
  sky level.

  The position found by the program is the centroid of the contiguous
  pixels above the threshold level above the overall image sky level.
  This centroid gives equal weight to all these pixels, regardless
  of their pixel values. The search for contiguous pixels is only
  done in a box of size which is input by the user (with a default of
  side 100 pixels). This box is such that the first pixel found
  (in a search along X lines, goin up in the Y direction line-by-line),
  is centered in the box in the X direction, and at the bottom of
  the box in the Y direction.

  If the star images are reasonably in focus, then it is possible
  to refine this position by fitting a Gaussian with a variable
  profile at that location.

  This gives a more accurate centering, but has the risk that the
  star image may be so strange as to cause the Gaussian fitting
  subroutine to fail catastrophically.

  Also if the stars are not in focus, then the fit may well fail
  or give the wrong position.

  Stars with positions within a box of side 16 pixels centered on any
  other star found are rejected.

  Up to 200 stars can be found. If there are more then they are
  ignored. There is the possibility that this may result in less than
  200 stars, as some of them may be close to others, and will thus
  be ignored.

}\sstdiytopic{Sky Levels}{
\vspace*{2mm}{\bf     Level in a Single Aperture}\vspace*{2mm}

 The sky levels are calculated for each sky aperture. All `good'
 pixels are taken in the area, and the mean taken. 

 It is important that this is the mean, because these sky levels
 will be used to subtract a sky from the star aperture. If a 
 value was used which discarded high values (due to faint stars),
 such as medians or other methods, then there will be a systematic
 error introduced into the star magnitudes.

 This is because there will be faint stars in the star aperture
 and these will be simply added in, so the same proceedure must
 be used for the sky apertures.

 The problem of a bright star falling by chance in a sky aperture
 is dealt with in the averaging described below.

\vspace*{2mm}{\bf   Mean Level Used }\vspace*{2mm}

 When more than one sky aperture is used, then a mean level is
 calculated. For the case of two apertures, a simple mean is
 taken. For three or four apertures, the two apertures whose
 levels are closest together is taken, and then any other
 aperture whose level is within +/- 4 percent of that level.
 Then the mean is made from the selected apertures.

\vspace*{2mm}{\bf    Record of Differences }\vspace*{2mm}

 To see if any of the apertures is contaminated (say by a bright
 star), the magnitudes that would have been calculated if each
 aperture in turn was taken as the sole sky level is calculated.
 The differences of these from the actually calculated mean is
 calculated and typed out (as the `Sk1', `Sk2', etc.). So the
 user can see from these if there was any contamination that has
 disturbed the mean. 

 If there are more than two apertures, often only one is contaminated, 
 and this is thrown out by the averaging process described above. So 
 the mean may well be correct. A good indicator of this is that two or
 three of the apertures show very good agreement with the mean, and 
 one is distant from it. This tells you that the mean was made without
 the discordant aperture.

}\sstdiytopic{Image Descriptors}{
  The image can contain much necessary ancillary information as
  descriptors. This is used by the programme. Unfortunately there is
  no standard naming or format scheme. So the programme is as flexible
  as possible on the input. The user can define the names of the
  descriptors carrying the relevant information.

  The user can even say where in some descriptor the information is. 
  This is because sometimes information, such as the object name, does
  not take up the entire descriptor, but is placed within the descriptor.

\hspace{4ex}\begin{tabular}{|l|l|l|}\hline  
  Descriptor Content   &  Default Name  &  Select Location? \\ \hline
  Object name          &   OBJECT       &       yes \\
  Right Ascension      &   RA           &       no \\
  Declination          &   DEC          &       no \\
  Exposure time        &   EXPOSURE     &       yes \\
  Sidereal time        &   SIDTIME      &       yes \\
  Filter name          &   FILTER       &       yes \\ \hline
\end{tabular}

}\sstdiytopic{Input}{
  The input image is the standard Starman image file. It must
  be the integer*2 16-bit image. It can have the `BSCALE' and `BZERO'
  pixel value scaling, and the bad pixel magic value `INVAL'.

  The optional standards file is a Starman table of the
  positions and magnitudes of stars. It has to have:-

\hspace{4ex}\begin{tabular}{ll}
       - &the standard Identifiers (star names) \\
       - &the Right Ascension of the star (in radians) \\
       - &the Declination of the star (in radians) \\
       - &the Equinox of the position (Julian epoch - e.g. 1990.234) \\
       - &at least one magnitude \\
\end{tabular}

  The magnitudes of different colours must be as magnitudes, not colours.
  I.e., a star with V=16.00 and B-V of 1.00 would have two entries, one
  for V=16.00 and one for B=17.00.

  The columns containing the magnitudes must have descriptors telling
  what waveband is in each column. In the example above, for example, the
  V column could have a descriptor with `V', and the B column one of `B'.

  The column descriptors must be in the standard Starman table style, as
  HEADxxx, where xxx = 001, 002, etc. Thus in the example above the
  descriptors would be:-

\hspace{4ex}\begin{tabular}{|l|l|}\hline
          name     & content \\ \hline
          HEAD001  & RA \\
          HEAD002  & DEC \\
          HEAD003  & EQUINOX \\
          HEAD004  & V \\
          HEAD005  & B \\ \hline
\end{tabular}

}\sstdiytopic{Date}{
 If a standard magnitude file is used, then the user has to input the
 date of the exposure. This is because there is no standard format
 for date formats. It should be input in format YYYY/MM/DD. A default 
 reply is acceptable. 

 The date is used for the precession of the standard star positions
 to the date of the observation.

}\sstdiytopic{Error}{
 The error in the output magnitude is calculated. 

 The calculations are done on the assumption that the pixel values in 
 the image are the result of a Poissonian noise signal. There are two 
 modifiers to this. First, that the numbers in the image have been scaled, 
 so that a gain is needed to reconstruct the original Poissonian values. 
 Second, that an extra source of noise has been added to each pixel. Thus 
 if a pixel has a raw value of k (and the image has scale of BSCALE, and
 zero of BZERO), then the true pixel value is BSCALE.k + BZERO. Then if 
 the Poissonian gain is GAIN, and the extra noise is NOISE, the noise in 
 the pixel is:-

  \hspace{4ex}   square root[GAIN.(BSCALE.k+BZERO) + NOISE.NOISE]

 Following on from this assumption, the error in the star magnitude
 is calculated as:-
 
  The variance of the sky estimate is:-

  \hspace{4ex}       varsky = [(BSCALE.skyfl+BZERO).GAIN + skypix.NOISE.NOISE]/skypix

 The variance of the star estimate is then:-

  \hspace{4ex} varstar = (BSCALE.starfl+BZERO).GAIN + starpix.NOISE.NOISE + starpix.varsky

  \hspace{2ex} The RMS star error is then:- \\
  \hspace{4ex} err = sqrt(varstar)/((BSCALE.starfl+BZERO)*GAIN) \\
  \hspace{4ex} RMS = 2.5.alog10(1.0+err)
  
  \hspace{6ex} where   skyfl   = total flux in all used sky apertures \\
  \hspace{14ex} starfl  = total flux in star aperture \\
  \hspace{14ex} skypix  = total no of pixels in all used sky apertures \\
  \hspace{14ex} starpix = no of pixels in star aperture \\
 
}\sstdiytopic{Exposure}{
 The exposure time is used for correcting the magnitude of the star.
 This is done by calculating the flux that the star would have had
 if the exposure had been 1 second long.

 The actual exposure time used in this calculation is not 
 necessarily that in the image descriptor. First of all the image
 exposure time descriptor is read, and then offered to the user as
 the default exposure time. The user can then accept this, or input
 any value she likes. The point of allowing the user to do this is
 that sometimes the time loaded in the exposure time descriptor is
 missing or wrong.

 There is then added an extra time, input by the user via the `EXPOFF' 
 parameter, to give the final adopted exposure time. This extra offset,
 which is added to all the times of the images measured, is intended
 to allow for shutter timing mechanisms which introduce an offset
 between the actual and recorded exposure times.

}\sstdiytopic{Star RA and Dec}{
 The programme takes the position of the star either to be the 
 position in the standards file, precessed to the date of the 
 observation, or the RA, Dec of the image as noted in its header. 
 This second method depends on the telescope pointing being good 
 and the offset of the star in the image from the (RA,Dec) 
 reference point not to be too large.

 If both the standard file and image position descriptors are
 present, then the user has the option of deciding which will
 be used to determine the position.

}\sstdiytopic{Sec Z}{
  The Sec Z is worked out in first order terms as:-

  $$  SecZ =  \frac{1.0}{sin(lat)*sin(dec)+cos(lat)*cos(dec)*cos(ra-sidt)} $$

}\sstdiytopic{Output}{
 The output of the program is typed to the terminal, and can optionally 
 be output to a text ASCII file (with a .DAT modifier). The file contains 
 a copy of what is put out to the terminal, except that there is one line 
 of header information at the start.

 The listing below gives an example of the output:-

 {\bf Example Output of AUTOMAG }

\rule{5in}{0.2mm}
 
\hspace{2ex} Image name is :-  fred{\undersc}1 \\
\hspace{3ex}\begin{tabular}{lllllllll}
   Star     &X      &Y        &Top     &Mag   &Rms    &Sk1   &Sk2 \hspace{3ex}  Sk3   &Sk4 \\
      1    &100.0  &100.0    &1000.0  &23.263 &0.003 &-0.001 &0.002-0.003 &0.003 \\
\end{tabular}


\hspace{3ex}\begin{tabular}{llll}
  Filter:= V &Sec Z= 1.059  &:Exp time= 101.000 & \\
  Image:-    &RA= 13  0 29  & :Dec= +12 12 12   &:Sid T= 12 34 56 \\
   File:-    &RA= 12 13 23  & :Dec= +11 27 30   & \\
\end{tabular}

\hspace{3ex}\begin{tabular}{llll}
  Raw Mag    & Sec Z Corrected    & Std    & Mag-Std \\
      23.263 &   23.245         & 18.100   & 5.145 \\
\end{tabular}

\rule{5in}{0.2mm}

  Comments:- 

  \begin{list}{{-}}{}
   \item The `Sk1', `Sk2', etc., give the corrections that would have to be
      added to the mean magnitude, if the sky level in the associated
      sky aperture alone were to be used to estimate the sky level.
    \item In this particular case, the `File' position was selected to be
      used instead of the `Image' position in calculating the SecZ.
    \item The final magnitude has been calculated using the mean sky
      level from all four sky apertures, as they all lie with 4%,
      that is +/- 0.04mag of the mean.
    \item The exposure time put out is the image exposure time (perhaps
      changed by the user) plus the offset input by the user via the
      `EXPOFF' parameter. It is then time used in the calculations.
   \end{list}

}\sstparameters{
\sstsubsection{ADD = LITERAL (Read)}{
  (Default - `Add'  \hspace{6ex}  Choices - `Add/Sub' ) 

  Do you want the stars to be added into, or subtracted from the
  image?

}\sstsubsection{BOX = {\undersc}INTEGER (Read)}{
  (Default - 100       \hspace{6ex}           Range - 1 to 10000)

  Side of box within which to search for a star's pixels.

  The search for contiguous pixels above the threshold level which
  denote a star is only done in a box of this size. This box is such 
  that the first pixel found (in a search along X lines, goin up in 
  the Y direction line-by-line), is centered in the box in the X 
  direction, and at the bottom of the box in the Y direction.

  If the box is too large, the search takes too long. If it is too
  small (in relation to the star image size), then star pixels may be
  missed, skewing the location of the centroid.

  The default is probably a good compromise for `normal' images. However
  for very out-of-focus images, the star `size' may be larger than than
  100 pixels, so you should select a larger box.

}\sstsubsection{DATE = LITERAL (Read)}{
  (Default - `2001/01/01'         \hspace{6ex}  Range - see below)

  The date of the observation. This is asumed to be the same for all
  of the images to be used. It is input as Julian epoch number. The
  month must be in the range 01 to 12, and the day 01 to the end of
  the month input. The format must be as the default - `YYYY/MM/DD'.

  This is used to precess the standards file positions to the date of
  the observation, so it does not need to be very precise.

}\sstsubsection{DECNAME = LITERAL (Read)}{
  ( Default - `DEC'          \hspace{6ex}  Choice - see below)

  The name of the descriptor in the image file where the declination
  of the exposure may be found.

   `none' is valid entry when the sec Z will be got from the standards.

}\sstsubsection{DOCENTRE = LITERAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - `Yes/No')

  Should the position found by the program be refined by fitting
  a Gaussian to the location?

  The position found by the program is a centroid of the contiguous
  pixels above the threshold level above the overall image sky level.
  (For details on this see the `Method - Star Location' help section.)

  If the star images are reasonably in focus, then it is possible
  to refine this position by fitting a Gaussian with a variable
  profile at that location.

  This gives a more accurate centering, but has the risk that the
  star image may be so strange as to cause the Gaussian fitting
  subroutine to fail catastrophically.

  Also if the stars are not in focus, then the fit may well fail
  or give the wrong position.

}\sstsubsection{DOFILE = LITERAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - 'Yes/No')

  Output a copy of the results, which are put on the output terminal,
  to an output text ASCII file?

}\sstsubsection{DOFILT = LITEAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - `Yes/No')

  Get the filter information in the image descriptors?

  This is used (together with the calculated SecZ and input extinction) 
  to calculate the extinction correction to be applied to the measured
  magnitude.

}\sstsubsection{DOMULT = LITERAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - `Yes/No')

  Do calculations on a number of input images (`Yes'), or on just one 
  (`No')?

}\sstsubsection{DOSECZ = LITERAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - `Yes/No')

  Calculate the zenith distance (as SecZ) of the exposure?

}\sstsubsection{DOSTSD = LITERAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - `Yes/No')

  Use the magnitudes in a standards file to calculate the difference
  between the observed magnitude and the standard magnitude?

}\sstsubsection{EXPLOC = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,79                \hspace{6ex}  Range - 1 to 256)

  The location in the image exposure time descriptor of the 
  characters which give the exposure time.

  If they are the only characters in the descriptor, then the
  default can be taken.

}\sstsubsection{EXPNAME = LITERAL (Read)}{
  ( Default - `EXPOSED'          \hspace{6ex}  Choice - see below)

  The name of the descriptor in the image file where the exposure time
  of the exposure may be found.

  If `none' is input, then no descriptor is looked for, and the
  time is set at 1.0 seconds.

}\sstsubsection{EXPOFF = {\undersc}REAL (Read)}{
  (Default - 0.0             \hspace{6ex}  Range - -1.0e8 to 1.0e8)

  The offset to add to the exposure time when doing all the
  calculations that involve the exposure time.

  This time is added to the exposure time in the image descriptor
  (possibly modified in the programme by the user).

}\sstsubsection{EXTINC1 = {\undersc}REAL (Read)}{
  (Default - 0.68              \hspace{6ex}  Range - 0.0 to 1.0e8)

  The extinction for the first filter input by the user in the
  `FNAME1', `FNAME2', etc. parameters.

}\sstsubsection{ }{
   {\large \bf This is repeated for EXTINC2 to EXTINC9 }

   \vspace*{2mm}

}\sstsubsection{FILTLOC = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,79                \hspace{6ex}  Range - 1 to 256)

  The location in the image filter descriptor of the 
  characters which give the filter used.

  If they are the only characters in the descriptor, then the
  default can be taken.

}\sstsubsection{FILTNAME = LITERAL (Read)}{
  ( Default - `FILTER'          \hspace{6ex}  Choice - see below)

  The name of the descriptor in the image file where the filter
  of the exposure may be found.

}\sstsubsection{FNAME1 = LITERAL (Read)}{
  (Default = ` '               \hspace{6ex}  Choice - see below)

  The name (character string) in the image filter descriptor that 
  will denote the first filter name.

  A null entry will mean that there are no more filter names to
  enter.

}\sstsubsection{ }{
   {\large \bf This is repeated for FNAME2 to FNAME9 }

   \vspace*{2mm}

}\sstsubsection{FSNAME1 = LITERAL (Read)}{
  (Default = name of image first filter name          \hspace{6ex}  Choice - see below)

  The name (character string) in a column header in the standards table
  file that will denote the first filter name in that table.

}\sstsubsection{ }{
   {\large \bf This is repeated for FSNAME2 to FSNAME9 }

   \vspace*{2mm}

}\sstsubsection{GAIN = {\undersc}REAL (Read)}{
  (Default - 1.0          \hspace{6ex}  Range - 1.0e8 to 1.0e8)

  The gain of the numbers in the image.

  This is the number of independent, Poissonian, events per pixel
  value. Thus for a CCD it would be electrons/adu.

}\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - ` '         \hspace{6ex}  Choice - see below)

 The line of text to put at the top the output text file.

 This is used as a way of putting a comment into the output file.

}\sstsubsection{IN = BDF (Read)}{
  (Default - null)

  The name of the file containing the input image.

  The input image is a standard DSCL .bdf image file. It must
  be the integer*2 16-bit image. It can have the `BSCALE' and `BZERO'
  pixel value scaling, and the bad pixel magic value `INVAL'.

}\sstsubsection{LATITUDE = LITERAL (Read)}{
  (Default - `00 00 00'        \hspace{6ex}  Choice - see below)

  A character string giving the latitude of the observatory where
  the exposure was made.

  This is used in calculating the zenith distance of the observation.
  it must be in the default format. Thus possibilities are:-

\hspace{4ex}\begin{tabular}{l}
    +90 00 00 \\
    +01 59 59 \\
    +00 01 23 \\
    -00 01 23 \\
    -30 00 00 \\
    -90 00 00 \\
\end{tabular}

  It is important that the negative sign should be in the right place.

}\sstsubsection{NOIDE = {\undersc}REAL (Read)}{
  (Default - 0.0                \hspace{6ex}  Range - 0.0 to 1.0e8)

  The extra Poisson noise that a pixel value of zero would have.

}\sstsubsection{NSKY = {\undersc}INTEGER (Read)}{
  (Default - 4                   \hspace{6ex}  Range - 1 to 4)

  The number of sky apertures to use for each star estimate.

}\sstsubsection{OBJLOC = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,79                \hspace{6ex}  Range - 1 to 256)

  The location in the image object name descriptor of the 
  characters which give the object name.

  If they are the only characters in the descriptor, then the
  default can be taken.

}\sstsubsection{OBJNAME = LITERAL (Read)}{
  ( Default - `OBJECT'          \hspace{6ex}  Choice - see below)

  The name of the descriptor in the image file where the object name
  of the exposure may be found.
  
  If `none' is input, then no descriptor is looked for, and the
  name is given the value ` '.

}\sstsubsection{OFFSET1 = {\undersc}REAL(2) (Read)}{
  (Default - (star aperture diameter),0.0      \hspace{6ex}    Range - 1.0 to 1.0e8)

  The offset in pixels in X,Y from the centre of the star aperture
  to the centre of the first sky aperture.

}\sstsubsection{ }{
   {\large \bf This is repeated for OFFSET2 to OFFSET4 }

   \vspace*{2mm}

}\sstsubsection{OUT = BDF (Write)}{
  (Default = null)

  The name of the file into which a copy of the terminal output, giving
  the results of the program, is to be written.

  This is a new text ASCII file. It will made with a .DAT modifier.

  The file contains a copy of what is put out to the terminal, except that 
  there is one line of header information at the start.

 The listing below gives an example of the output:-

 {\bf Example Output of AUTOMAG }

\rule{5in}{0.2mm}
 
\hspace{2ex} Image name is :-  fred{\undersc}1 \\
\hspace{3ex}\begin{tabular}{lllllllll}
   Star     &X      &Y        &Top     &Mag   &Rms    &Sk1   &Sk2 \hspace{3ex}  Sk3   &Sk4 \\
      1    &100.0  &100.0    &1000.0  &23.263 &0.003 &-0.001 &0.002-0.003 &0.003 \\
\end{tabular}


\hspace{3ex}\begin{tabular}{llll}
  Filter:= V &Sec Z= 1.059  &:Exp time= 101.000 & \\
  Image:-    &RA= 13  0 29  & :Dec= +12 12 12   &:Sid T= 12 34 56 \\
   File:-    &RA= 12 13 23  & :Dec= +11 27 30   & \\
\end{tabular}

\hspace{3ex}\begin{tabular}{llll}
  Raw Mag    & Sec Z Corrected    & Std    & Mag-Std \\
      23.263 &   23.245         & 18.100   & 5.145 \\
\end{tabular}

\rule{5in}{0.2mm}

  Comments:- 

\begin{list}{{-}}{}
    \item The `Sk1', `Sk2', etc., give the corrections that would have to be
      added to the mean magnitude, if the sky level in the associated
      sky aperture alone were to be used to estimate the sky level.
    \item  In this particular case, the `File' position was selected to be
      used instead of the `Image' position in calculating the SecZ.
    \item  The final magnitude has been calculated using the mean sky
      level from all four sky apertures, as they all lie with 4%,
      that is +/- 0.04mag of the mean.
    \item  The exposure time put out is the image exposure time (perhaps
      changed by the user) plus the offset input by the user via the
      `EXPOFF' parameter. It is then time used in the calculations.
\end{list}

}\sstsubsection{POSNTYPE = LITERAL (Read)}{
  (Default - `degrees'   \hspace{6ex}  Choice - `degrees/radians/string')

  The format that the RA and DEC entries have in the RA and DEC
  descriptors.

  The `degrees' and `radians' choices are obvious. For the string
  input:-

      the RA numbers must be in the HHxMMxSS.SS format 

      the DEC numbers must be in the SDDxMMxSS.SS format
  
   where `x' must not be 0-9, `+', `-', or `.'

   the decimal places are optional

}\sstsubsection{RANAME = LITERAL (Read)}{
  (Default - `RA'          \hspace{6ex}  Choice - see below)

  The name of the descriptor in the image file where the right ascencion
  of the exposure may be found.

   `none' is valid entry when the sec Z will be got from the standrads

}\sstsubsection{SIDTLOC = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,79                \hspace{6ex}  Range - 1 to 256)

  The location in the image sidereal descriptor of the 
  characters which give the sidereal time.

  If they are the only characters in the descriptor, then the
  default can be taken.

}\sstsubsection{SIDTNAME = LITERAL (Read)}{
  ( Default - `STSTART'          \hspace{6ex}  Choice - see below)

  The name of the descriptor in the image file where the sidereal 
  time of the exposure may be found.

}\sstsubsection{SKYDIA = {\undersc}REAL (Read)}{
  (Default - 1/2 the Star aperture diameter     \hspace{6ex}  Range - 1.0 to 1.0e8)

  The diameter of all the sky apertures in pixels.

}\sstsubsection{STARDIA = {\undersc}REAL (Read)}{
  (Default - 40.0              \hspace{6ex}  Range - 1.0 to 1.0e8)

  The diamter of the star aperture in pixels.

}\sstsubsection{STDMAST = LITERAL (Read)}{
  (Default - `Yes'               \hspace{6ex}  Choice - `Yes/No')

  If you are using the standard magnitudes file and there is
  RA and DEC information in the image descriptors, you have two
  ways of calculating the RA and DEC. In this case, do you want
  to use the standards file positions (`Yes'), or the image
  descriptor positions (`No') ?

}\sstsubsection{STDS = BDF (Read)}{
  (Default - null)

  The name of the file containing the input table of standard star
  positions and magnitudes.

  The file is a Starman table of the positions and magnitudes 
  of stars. It has to have:-

  \begin{list}{{-}}{}
       \item  the standard Identifiers (star names)
       \item  the Right Ascension of the star (in radians)
       \item  the Declination of the star (in radians)
       \item  the Equinox of the position (Julian epoch - e.g. 1990.234)
       \item  at least one magnitude
\end{list}

  The magnitudes of different colours must be as magnitudes, not colours.
  I.e., a star with V=16.00 and B-V of 1.00 would have two entries, one
  for V=16.00 and one for B=17.00.

  The columns containing the magnitudes must have descriptors telling
  what waveband is in each column. In the example above, for example, the
  V column could have a descriptor with `V', and the B column one of `B'.

  The column descriptors must be in the standard Starman table style, as
  HEADxxx, where xxx = 001, 002, etc. Thus in the example above the
  descriptors would be:-

\hspace{4ex}\begin{tabular}{|l|l|}\hline
name & content \\ \hline
HEAD001 &  RA \\
HEAD002 &  DEC \\
HEAD003 &  EQUINOX \\
HEAD004 &  V \\
HEAD005 &  B \\ \hline
\end{tabular}

}\sstsubsection{THRESH = {\undersc}REAL (Read)}{
  (Default - 100.0                \hspace{6ex}  Range - 1.0e-8 to 1.0e8)

  The threshold, above the mean sky level for the entire image,
  when a pixel which is above that value is considered to be part
  of a star.

}\sstsubsection{TIME = {\undersc}REAL (Read)}{
  (Default - image exposure time             \hspace{6ex}  Range - 0.0 to 1.0e8)

  A chance to correct the exposure time read off the image.

  The actual time used in the calculations is this time plus the `exposure 
  time offset`, input via the `EXPOFF' parameter.

}

}
}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} AVERAGE}

\sstroutine{AVERAGE}{Averages the Magnitudes from Different MEASURE Outputs}{


   \sstdescription{
 This takes the output tables created by the stellar photometry  
 program MEASURE (or any other program), and averages them to a table
 with weighted mean magnitudes. It also makes a text file with the 
 details of the averaging.

}\sstdiytopic{Method}{
 First of all, criteria for rejecting measures for intrinsic faults are
 input by the user. Then in the rest of the calculations star measures 
 which violate these criteria are ignored.

 The program then calculates, for each (excluding the first) input 
 table, the mean difference in star magnitude of the measures in the 
 table from those in the first input table. This gives the `zero-points'
 of the magnitudes in each table compared to the first table.

 It then plots out, for each input table, the scatter of these
 differences, relative to the `zero-points'. The user can then put (via
 cursor and/or keyboard) in more accurate values for the `zero-points'

 These mean differences are then subtracted from the magnitudes in the
 tables, putting them all on the zero point of the first table.

 Then the rejection criteria for discarding magnitude estimates are set up
 This is either done by setting discordance limits at each magnitude range
 or by using the input magnitude error estimates.

 Then weighted means are made for each star of its magnitudes from the 
 input tables. At this point discordant input magnitudes may be rejected.

 Some of the other parameters in the input tables are noted.

 The results are then put to the output file.

 A text file can also be made which gives some the details of the actual
 star by star averaging and measure rejection.

}\sstdiytopic{Making Means}{
 A mean magnitude is made for a star by:-

\begin{list}{{-}}{}

 \item Taking all the magnitudes from the input tables.

 \item Discarding those magnitudes where the fit parameters for the star in
   that particular input table suggest the measure is `bad'. This 
   method is here refered to as `intrinsic' rejecting.

 \item Taking all the good measures and calculating a weighted mean. This
    is done in a complex way:-

   \begin{list}{{-}}{}
    \item The weights are from the input error for the star in each table
      (subject to a switch `usesigma' and a minimum limit- see 
       `sigmamin'). 

    \item A rejection method is used for discarding measures which lie
      significantly away from the mean. This method is here refered to
      as `means' rejecting. This `means' rejecting may be done in one of
      three ways.
    \end{list}

\end{list}

}\sstdiytopic{Use of Weights}{
 The weights are from the input error for each star in each table.

 The weighting may be switched off and the unweighted means used (see 
 `usesigma'). A minimum error may be set, so that any input error less
 than that minimum is set at that minimum (see `sigmamin').

 Whether to use weights or not, and if so, what value to give to 
 `sigmamin' will depend on your estimate of the validity or otherwise, 
 in each case, of the input error estimates. 

 This method should only be used if the errors in the input magnitude 
 files are good estimates. MEASURE caclculates this error but it is 
 only correct if the correct noises and gains have been input to the 
 MEASURE runs, and there were no other contributory sources of error. 
 It is advisable to check on this, and you can do so by having a trial run 
 with the `means' rejecting method, when the input errors are plotted
 against those found from the scatter between files.

}\sstdiytopic{Intrinsic Rejecting}{
 A star magnitude estimate from a particular input file can be 
 rejected by some of the other characteristics of the fit it was made
 in. These are:-

\begin{list}{{-}}{}
 \item star centering in fit
 \item no of iterations taken in the fit
 \item chi-squared of the fit
 \item theoretical error estimate
 \item important companions
 \item invalid pixels in fit area
\end{list}

 The extent to which these have to be `good' is under the user's
 control.

}\sstdiytopic{`Means' Rejecting}{
  The basic technique here is to look at the scatter of the
  magnitude estimates, for a star, from the input tables. Then
  estimates which diverge too much from the mean are rejected.

  There are three methods of this `means' rejecting, which are, in essence,
  two ways of defining what is meant by `too much':-

\begin{list}{{---}}{}
  \item {\bf `Default' method}

      An estimate is only rejected if it lies more than 0.5mag from the 
      mean.

  \item {\bf Scatter between the different estimates}

      For its magnitude, it differs from the mean by more than the 
      level set for the user (or a default 0.5mag) for that magnitude 
      value.

  \item {\bf Theoretical expected error in each magnitude estimate}

      This method should only be used if the errors in the input
      magnitude files are good estimates. MEASURE caclculates this
      error but it is only correct if the correct noises and gains
      have beeb input to the MEASURE runs, and there were no other
      contributory sources of error. It is advisable to check on
      this, and to look at the check plot described below.

      Use the error estimate from MEASURE for a star for each file:-

      \begin{enumerate}
      \item The weighted mean magnitude for this star from all the files 
         (after the zero point corrections) is calculated.
      \item The theoretical error in the mean (from taking all the input 
         errors for this star from all the files) is calculated. This
         takes the input error estimates and does the proper 
         calculation - akin to sqrt(sum[sigma.sigma]/((n-1)(n-2))) - to 
         calculate what error in the mean magnitude should be expected
         from magnitudes having those errors.
      \item This theoretical error expected for this star from this file 
         is noted.
      \item The difference of the magnitude for this star from this file 
         from the mean is calculated.
      \item The number of standard deviations (diff/theoretical error) 
         from the mean that this difference represents is calculated, 
         using the calculated errors in the mean and in this measure.
      \item If this number of std. devs. is larger than a (user input - 
         ERRMUL parameter) certain value, then that magnitude for that 
         star from that file is rejected.
      \item There is also a (user input - ERRLIM parameter) minimum value 
         below which the `calculated error' cannot fall. This stops 
         unrealistic error estimates causing false rejections.
      \end{enumerate}

      If this method is adopted, then a plot is displayed of the `found 
      error' (the difference of a single magnitude estimate from the 
      mean magnitude) versus the `calculated error' (the expected 
      value of this difference). The plot should show a linear 
      relation with a slope of one. The `found errors' should scatter 
      about the `calculated error'. 

      If the plot looks OK, but the slope is not unity, then a 
      conversion factor is needed to convert the input error estimates 
      into true ones. Read this from the slope, and input it via the
      `ERRFAC' parameter.
               
      If the plot looks strange, then there is probably something 
      strange about the input error estimates from MEASURE, and this 
      method should be viewed with suspicion.

\end{list}

}\sstsubsection{Scatter between Files}{
 This sets at each magnitude (on the zero point of the first table) a 
 maximum difference from the mean that is allowed, and then for each 
 star to reject all measures that exceed that difference for the star. 

 In use, a histogram is plotted of the differences from the means of
 all the measures at each magnitude level. The user then uses a cursor
 to input the rejection level.

 The rejection is done star-by-star, with the most divergent star
 (weighted inversely by a magnitudes tolerance level - remember 
 `Errlim') being rejected first. Then the mean is recalculated, and 
 the process started again, with all previously rejected stars not 
 used. This process continues until no more stars are rejected.

}\sstsubsection{Theoretical Errors}{
 This, for each star and each table, looks at the input calculated 
 theoretical error as given in the tables, and then to reject that 
 measure if it is farther from the mean by some constant times that 
 theoretical error. Thus one might want to reject all star measures
 more than three input theoretical standard deviations from the mean of
 all the measures.

 A problem is that the input theoretical errors may not be a good
 indicator of the actual errors. To help in evaluating this, the
 program, for each table, plots out the run of the theoretical error
 of a measure in a list of a star versus the error calculated from the
 scatter in the measures of that star in the all the tables. (This is
 actually done in bins of the theoretical error levels.) The user can 
 then see if there is any systematic difference.

 If there is (say the difference errors are commonly twice the 
 theoretical ones) then the rejection criteria can be adjusted (in 
 this example by doubling the limit), if the user wants to believe the
 difference errors.

 There is also the option to accept up to a certain limit, even if
 the theoretical errors indicate a smaller limit. Thus for very 
 well-exposed stars, a theoretical error limit of 0.002mag may be 
 indicated, but the user might well feel that measures differing by 
 0.01mag are realy ok.

 Thus after the plot is displayed, the user inputs via the keyboard the
 factor to multiply the theoretical errors to get the rejection limit,
 also the minimum rejection limit.
 
}\sstsubsection{Which is Better?}{
 The scatter method is a good method when the input tables are all on 
 roughly the same zero point, as it shows and uses the actual errors 
 being encountered.

 However, if the tables have different zero points, then a measure from 
 a long exposure will have a smaller error than one from a short one, 
 and one would wish to use stricter criteria in rejecting it. Thus the 
 theoretical method is better. The trouble with using the theoretical
 method is that the theoretical errors are not perfect indicators of 
 the actual errors, and so should only be used (as described above)
 when the input errors are valid.

}\sstdiytopic{Star Names}{
 The files can either have the same stars in the same order (the
 default assumption), in which case there is a simple one-to-one
 correspondance between the stars in the input files and those in the
 output file.

 Or the star names in each file can be matched up. Then the output file
 has all the stars mentioned in all the input files. (Duplicate names
 in any file but the first are to be avoided.) The output file
 magnitudes are then means of those estimates in the input files that
 have estimates for those stars.

 The order of stars in the output file in this case, is:-

\begin{list}{{-}}{}
   \item The order of stars in the 1st input file
   \item The order of any stars in the 2nd input file that were not in the 
       1st file
   \item The order of any stars in the 3rd input file that were not in the 
       1st file or the 2nd file
   \item       etc
\end{list}

}\sstdiytopic{Use of Graphics Buttons}{
  To mark a  point on a graph, place the cursor at the desired point, 
  and press any of the appropriate buttons.

  In this program, the computer will then read the height of the
  horizontal cursor line.

}\sstparameters{

\sstsubsection{AGAIN = LITERAL (Read)}{
  (Default - `No' \hspace{6ex} Choice - `Yes/No')

   Flag for redisplaying plot and reusing cursor. 

}\sstsubsection{CENACC = LITERAL (Read)}{
  (Default - `No'     \hspace{6ex}    Choice - `Yes/No')

  Flag for accepting a star measure if its only fault is that it is 
  too far off centre.

}\sstsubsection{CHIPRIN = {\undersc}REAL (Read)}{
 (Default - 1.0   \hspace{6ex}    Range - 0.0 to 1.0e10)

 Factor for use on the printing of the matches. The Chi-squareds are
 printed as integers. If they are small you may want them put out
 multiplied by a factor so that they dont all look like `0's, `1's,
 `2's, etc.

}\sstsubsection{ERRFAC = {\undersc}REAL (Read)}{
  (Default - 1.0      \hspace{6ex}     Range - 0.0 to 1.0e9)

  When using the input magnitude error estimates to see which input
  magnitudes for a star to reject, this is the factor to multiply
  the input error estimates for a file to get `true' estimates.

  You will already have used a graph to show the relationship
  between the input estimates and the `true' values, as found from
  the scatter between the input magnitudes for this file and the mean 
  from all the input files. This will have then given you the
  factor.

}\sstsubsection{ERRLIM = {\undersc}REAL (Read)}{
  (Default - 0.01      \hspace{6ex}      Range - 0.0 to 1.0e9)

  Used when using the input magnitude error estimates to see which 
  input magnitudes for a star to reject.

  This is the value for the minimum tolerance level.

  This parameter says that this value is then checked to see if it
  is at least as big as `ERRLIM', and if not, then increased to that
  value. This stops a number of unrealistically small input error
  estimates setting a too stringent check level.

}\sstsubsection{ERRMUL = {\undersc}REAL (Read)}{
  (Default - 3.0       \hspace{6ex}     Range - 0.0 to 1.0e9)

  Used when using the input magnitude error estimates to see which 
  input magnitudes for a star to reject.

  The number of standard deviations (of the input error estimates for
  stars in this file) that an input magnitude can be and still be
  accepted.

}\sstsubsection{FILENUM = {\undersc}INTEGER (Read)}{
  (Default - next        \hspace{6ex} Range - 0 to number of input files)

  When calculating the relationship between input error estimates and
  `true' errors, this calculation should be done for all files. This
  parameter allows you to calculate it in any order and to recalculate
  the factors for a file.

}\sstsubsection{FPRINT = TEXT FILE (Write)}{
  (Default - ` '        \hspace{6ex}        Choice - any)

  The name of the file to take the text version of the output. This
  has much informative information that is not in the main table
  output.

  A null response means that no such file is produced.

}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'  \hspace{6ex}            Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question, 
  in a different way. A response here of `?' will bring up a listing 
  of all the possible names of graphics devices which are supported 
  on your machine, and you then input the appropriate name.

}\sstsubsection{IN =  BDF (Read)}{
  (Default - null)
 The names of the input files containing the star magnitude tables.

}\sstsubsection{INCHI = BDF (Read)}{
  (Default - null)

 The name of the file containing the table of Chi-squared values, at
 0.2mag steps, above which a star is rejected. 

 These tables, if used, must have the Chi-squared value of the 
 faintest mag first, and be in steps of 0.2mags starting at the faint
 mag.

 If there are less than 100 values in the table, then the 
 Chi-squared values are filled up to 100 values with the last value. 
 Values after the first 100 values are ignored.

 Such files are automatically produced by Chi (qv).

}\sstsubsection{MEANREJ = LITERAL (Read)}{
  (Default - `mag'  \hspace{6ex}       Choice - `mag:error:default:ok')

  Method to reject a magnitude for a star from a particular file 
  because its value (after the file mean correction) differs too 
  much from the mean of the measures from all the files (including
  the file itself).

  This defines the `means' rejecting method.

  This is asked for repeatedly. At the start the `default' of
  0.5 mag is set up. You can then set up any of the three ways.
  When you are happy, reply `ok' to continue to the next step.

  This rejection can be done in one of three ways.

 {\vspace*{2mm} \bf 1. \hspace{4ex} `Default'  \vspace*{2mm}}

   If mag is more than 0.5 from the mean. 

 {\vspace*{2mm} \bf 2. \hspace{4ex} `Mag'  \vspace*{2mm}}

   For its magnitude, it differs from the mean by more than 
   the level set for the user for that magnitude value. 

              The tolerance levels are user input by the program 
              calculating (at unit magnitude steps) histograms  of the 
              scatter of magnitude estimates from the mean. The user 
              then looks at these histograms and sets tolerance levels 
              where the outliers are rejected. 

 {\vspace*{2mm} \bf 3. \hspace{4ex} `Error'  \vspace*{2mm}}

{\bf See the warning about this method in the sections on `Method'
     and `Making Means'}

      This method should only be used if the errors in the input
      magnitude files are good estimates. MEASURE caclculates this
      error but it is only correct if the correct noises and gains
      have beeb input to the MEASURE runs, and there were no other
      contributory sources of error. It is advisable to check on
      this, and to look at the check plot described below.

              Use the error estimate from MEASURE for a star for each 
              file:- 

               \begin{enumerate}
               \item The weighted mean magnitude for this star from all 
                  the files (after the zero point corrections) is 
                  calculated.
               \item The theoretical error in the mean (from taking all 
                  the input errors for this star from all the files) is
                  calculated. 
               \item This theoretical error expected for this star from 
                  this file is noted.
               \item The difference of the magnitude for this star from 
                  this file from the mean is calculated.
               \item  The number of standard deviations (diff/theoretical 
                  error) from the mean that this difference represents 
                  is calculated, using the calculated errors in the 
                  mean and in this measure.
               \item If this number of std. devs. is larger than a (user 
                  input - ERRMUL parameter) certain value, then that 
                  magnitude for that 
                  star from that file is rejected.
               \item There is also a (user input - ERRLIM parameter) 
                  minimum value below which the `calculated error'
                  cannot fall. This stops unrealistic error estimates
                  causing false rejections.
               \end{enumerate}

               If this method is adopted, then a plot is
               displayed of the `found error' (the difference of a 
               single magnitude estimate from the mean magnitude) 
               versus the `calculated error' (the expected value of 
               this difference). The plot should show a linear 
               relation with a slope of one. The `found errors' should 
               scatter about the `calculated error'. 

               If the plot looks OK, but the slope is not unity, then
               a conversion factor is needed to convert the input
               error estimates into true ones. Read this from the slope,
               and input it via the `ERRFAC' parameter.
               
               If the plot looks strange, then there is probably 
               something strange about the input error estimates from 
               MEASURE, and this method should be viewed with suspicion.

}\sstsubsection{NAMES = LITERAL (Read)}{
  (Default - `no'   \hspace{6ex}        Choice - `yes:no')

  Take the individual measures from the input files by matching
  up the names of the stars in the files.

  If `no' is taken, then it is assumed that each file contains the
  same stars in the same order.

}\sstsubsection{NEWMEAN = {\undersc}REAL (Read)}{
  (Default - default value     \hspace{6ex}      Range - -1.0e10 to 1.0e10)

  After finding the new mean difference between file magnitude systems
  by using the graph plot, the found value can be corrected by this
  parameter.

}\sstsubsection{NUMINV = {\undersc}INTEGER (Read)}{
  (Default - 0         \hspace{6ex}    Range - 0 to 1000000)

 The maximum number of `invalid' pixels noted in a star fit that will 
 be allowed for saying the star magnitude is acceptable.

}\sstsubsection{NUMITS = {\undersc}INTEGER (Read)}{
  (Default - 35       \hspace{6ex}     Range - 0 to 100)

 The maximum number of iterations done in a star fit that will be 
 allowed for saying the star magnitude is acceptable.

}\sstsubsection{OFFCEN = {\undersc}REAL (Read)}{
   (Default - 2.0      \hspace{6ex}      Range - 0.0 to 1000.0)

 Distance in X or Y that the star position can be from the fit 
 starting position for saying the star magnitude is acceptable.

}\sstsubsection{OUT = BDF (Write)}{
 (default - null)
 The name of the new output file containing the mean magnitude table.

}\sstsubsection{PLHISTX = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.5    \hspace{6ex}        Range - 0.0 to 1.0e8)

 The range of differences of individual magnitude estimates from
 the mean to plot out in the histogram of number of stars with
 such differences.

}\sstsubsection{PLHISTY = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,1.2*max number    \hspace{6ex}   Range - 0.0 to 1.0e8)

 The range of numbers of individual magnitude estimates with 
 values differing from the mean in certain ranges to plot out 
 in the histogram of number of stars with such differences.

}\sstsubsection{PLOTLIMX = {\undersc}REAL(2) (Read)}{
  (Default - -5%,+10% of actual range     \hspace{6ex}    Range - -1.0e8 to 1.0e8)

  The range of magnitudes to plot out in the graph of differences,
  of individual magnitudes from the means, versus magnitude.

}\sstsubsection{PLOTLIMY = {\undersc}REAL(2) (Read)}{
  (Default - -5%,+10% of actual range    \hspace{6ex}     Range - -1.0e8 to 1.0e8)

  The range of differences to plot out in the graph of differences,
  of individual magnitudes from the means, versus magnitude.
 
}\sstsubsection{SIGMALIM = {\undersc}REAL (Read)}{
  (Default - 0.5       \hspace{6ex}       Range - 0.0 to 100.0)

 Maximum overall value of the star error that will be allowed for 
 saying the star magnitude is acceptable.

}\sstsubsection{SIGMAMIN = {\undersc}REAL (Read)}{
  (Default - 0.01       \hspace{6ex}      Range - 0.00001 to 100.0)

 The minimum `true' acceptable error value for a star. This is in 
 (+/-)magnitude.

 If a star in an input table has an error less than this, the error is
 read in as though it were this minimum error.

 This is used as the errors are calculated as Poisson noise. This is, 
 for bright stars, often less than the real errors, which have error 
 sources such as flat-field errors, etc. Thus a bright star might have
 such a low error that the weighted averaging would place undue weight
 on that particular measure.

 Generally, if you are uncertain about whether the input error estimates
 are valid, then a high value of `sigmamin', say 0.05mag, is a good idea
 as this will weight all stars equally, except those that have a very
 high error estimate (in this case above 0.05mag).

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - `Output from Average')
 
 The Title to be added as a descriptor to the output file containing 
 the mean magnitude table.

}\sstsubsection{USECHI = LITERAL (Read)}{
  (Default - `No'     \hspace{6ex}     Choice - `Yes/No')

 Flag for testing the chi-squared value when deciding to use a 
 magnitude estimate.

}\sstsubsection{USESIGMA = LITERAL (Read)}{
  (Default - `No'     \hspace{6ex}     Choice - `Yes/No')

 Flag for using the input magnitude error estimates to weight the
 input magnitudes in calculating the mean.


}
}
}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} CHI}

\sstroutine{CHI}{Make a Table of Rejection Chi-squared values}{

\sstdescription{
  This takes the output from MEASURE and makes a table of the
  maximum acceptable Chi-squared value versus magnitude. This can then
  be input to the AVERAGE programme to reject magnitudes with poor fits.

  A graph of the Chi-squared value versus magnitude is plotted out
  from the measures of stars done by the MEASURE programme.

  The user then uses the cursor to define a series of (Magnitude,Chi) 
  pairs. These are then used to define a table defining the run of maximum
  acceptable Chi-squared values versus magnitude, for input to AVERAGE.

}\sstdiytopic{Use}{
  This is used for deciding which stars in the output of MEASURE
  have residuals which are significantly higher than the average for a 
  star of that magnitude and is thus probably a poor measure. It makes 
  a file with a table of max acceptable Chi values at different 
  magnitude levels levels for use in AVERAGE. 

  Before entry, poor measures may be pre-secreened by saying putting
  limits on three of the measure parameters (the number of invalid 
  pixels in the star image, the number of iterations taken to fit the 
  star, and the distance the star was found from its input position).
 
  The values of Magnitude vs Chi excess are plotted out, and the cursor 
  is then used to define the highest acceptable Chi value at any number 
  of Mag values (up to 1000 positions). The cursor is used to draw an 
  imaginary line cutting off the high bad Chis from the low accepetble 
  Chis. The line is not plotted out as you mark the points, but when 
  you finish, straight lines are drawn between the points displaying 
  the line. 

  After the Mag,Chi positions have been input by the cursor the program
  interpolates between them and puts constant  values outside them to 
  get a smooth limit curve. This line is then plotted. The whole 
  display and cursor work can be repeated.  

  The program then calculates the values at 0.2mag intervals from the
  faintest mag up to 20mag brighter, and stores them in an output file
  containing a table for use with the AVERAGE program. 

  With some data, the chi-squared values increase significantly for
  bright stars. The program looks for such a trend, and if it finds
  it, subtracts a curving base level to make the use of the cursor
  easy. See the HELP section on base level.

}\sstdiytopic{Base Level}{
  With some data, the chi-squared values increase significantly for
  bright stars. The program looks for such a trend, and if it finds
  it, subtracts a curving base level to make the use of the cursor
  easy. 

  In such a case, the Chi values plotted are ones scaled down at each 
  magnitude value to try and make some allowance for the fact that, for
  bright stars that are perfectly OK, the Chi value is higher than for a
  faint star.
  
  The value shown is an excess above an estimated typical minimum value 
  at each magnitude. The excess values are displayed by fitting to the 
  envelope of minimum Chi values  a line of the form 

$$           Y = zero + sl.starflux $$

  and displaying the Chi values as

$$            Chi  = zero + \frac{Chi-Y}{\sqrt{error/zero}} $$

  The true Chi values can be seen from the numbers plotted out when 
  using the cursor (or by inspection of the output file).
  
  This makes use of the cursor easy and gives a fair idea of the 
  importance of the relative Chi errors. 

}\sstparameters{

\sstsubsection{AGAIN = LITERAL (Read)}{
  (Default- `no'  \hspace{6ex}    Choice - `yes:no')

   Do you want to put out the graph again and define a new upper limit 
   curve?

}\sstsubsection{ALLSTARS = LITERAL (Read)}{
   (Default - `no'  \hspace{6ex} Choice - `yes:no')

   Flag for accepting a star for plotting out, even if it could be 
   rejected. (i.e. as too far from starting posn, or too many fitting 
   iterations were taken, or image contained invalid points,  or 
   magnitude flagged as 0.0 or 50.0)

}\sstsubsection{DEVLIMX = {\undersc}INTEGER(2) (Read)}{
   (Default - 1,X size    \hspace{6ex}   Range - 1,X size)
   (Whole)  

  The X limits of the plots in Chi residuals and Magnitudes.
  (NB. The Chi residuals are those above the allowance curve.)

  Use this to select the range of magnitudes you really want to use. 

  The default is for the whole range of magnitudes.

  What you do is to plot the whole range, the first time round, look
  at it, decide what limits you really want, exit from the graph and
  replot using your new limits.

}\sstsubsection{DEVLIMY = {\undersc}INTEGER(2) (Read)}{
   (Default - 1,Y size    \hspace{6ex}   Range - 1,Y size)

  The Y limits of the plots in Chi residuals and Magnitudes.
  (NB. The Chi residuals are those above the allowance curve.)

  Use this to select the range of residuals you really want to use. 

  The default is for the whole range of residuals. This shows you the
  overview, but usally you want to look at the residuals near unity,
  and so you should plot just a restricted range.

  What you do is to plot the whole range, the first time round, look
  at it, decide what limits you really want, exit from the graph and
  replot using your new limits.

}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question, 
  in a different way. A response here of `?' will bring up a listing 
  of all the possible names of graphics devices which are supported 
  on your machine, and you then input the appropriate name.

}\sstsubsection{IN = BDF (Read)}{
  (Default - null)

  The name of the file containg the input table of fit results.

}\sstsubsection{NUMINV  = {\undersc}INTEGER (Read)}{
  (Default - 0     \hspace{6ex}        Range - 0 to 1000000)

  If you are going to reject a star for plotting as having too
  many invalid pixels, this is the limit to the number of 
  such pixels that is acceptable. 

}\sstsubsection{NUMITS = {\undersc}INTEGER (Read)}{
  (Default - 35        \hspace{6ex}     Range - 0 to 1000)

  If you are going to reject a star for plotting as having had
  too many fitting iterations, this is the limit to the number of 
  iterations that are acceptable. 

}\sstsubsection{OFFCEN = {\undersc}REAL(2) (Read)}{
   (Default - 2.0          \hspace{6ex}    Range - 0.0 to 1.0e10)

   If going to reject a star for plotting as being too far from 
   the starting position in the fitting, this is the distance away 
   in X or Y that is the limit of acceptance 

}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)

    The name of the file to contain the output table.

}\sstsubsection{TITLE =  LITERAL (Read)}{
  (Default - input table title, or `Output from Chi' \hspace{6ex} Choice - any)

  The charcter string to put into the output table as a title.

}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} DIAGRAM}

\sstroutine{DIAGRAM}{Plot out Colour-Magnitude or Colour-Colour Diagram}{

\sstdescription{

 This plots out an HR or Two-Colour diagram from tables containing 
 star magnitude data. It can also output a file containing the 
 plotted values. 

 There can be up to 48 input files open at once (if your computer set 
 up allows this. Many systems will have lower limits).

 These files must contain a table with the magnitudes in one column having magnitudes. of 
 the table.

}\sstdiytopic{Use}{
 The program works on `sets' of tables. Each set is loaded with data 
 from (up to four) tables, each list of data of the magnitudes in a 
 particular colour comes from a column of data in one of the tables. 
 The tables with the data for an individual set must each contain the 
 same stars in the same  order. Each set can hold up to 10 000 stars.
 
 Up to twelve sets can be handled.
 
 Only the data from one set is plotted out (or written to file) at 
 any one time, but the other sets can accessed at will, and added
 to the diagram. They would however, if stored, be output to different 
 files.
 
 The extent of the diagram (in the sense of the output values) is
 under user control, and the diagram can be cleared and plotting
 started again.
 
 The plotting and storing is done as `$Col_{2}$' vs `$Col_{3}$ - $Col_{4}$ ' 
 or `$Col_{1}$ - $Col_{2}$' vs `$Col_{3}$ - $Col_{4}$'. For example, as
 V vs  B-V or  R  vs  R-I  or U-B vs B-V. 

 Any single character descriptors may be assigned to the colours by the 
 user.
 
 The location of points can be found using the cursor.

 Lines can also be drawn on the diagram from keyboard, cursor or 
 file table posns.

}\sstdiytopic{Colour Equation and Zero Point}{
 Each set can have its input magnitudes corrected by the following
 equation:-
 
$$        Col1_{n}  = Zero_{n}  + Col_{n}  + K_{n}.(C_{3}-C_{4}) $$
 
 Where $Col1_{n}$  is the corrected version of input colour $Col_{n}$  and the
 values $Zero_{n}$  and $K_{n}$ are input by the user. `n' runs from 2 to 4
 for a colour-magnitude type diagram, and from 1 to 4 for a colour-colour type
 diagram.
 
 As you can see, the colour correction is in terms of the `raw' 
 magnitudes $C_{3}$  and $C_{4}$

}\sstdiytopic{Cursor}{
 The plotting software package, PGPLOT,  defines the cursor movement 
 and marking of position by the appropriate method for the device being 
 used. If you are uncertain about how to use the cursor, ask your 
 local computer expert.

}\sstdiytopic{Input}{
 If a waveband is required twice (i.e. V in V vs B-V) the table and 
 column with that waveband is only asked for once.

}\sstdiytopic{Input Controls}{
 Conditions may be imposed on which stars in a set are accepted
 for plotting. All stars are stored, but have an acceptance/rejection
 flag showing whether they would have been plotted.
 
 These are:-

\begin{list}{{-}}{}
  \item {\bf Raw magnitudes:} \hspace{2ex}
                       The acceptable range of input magnitudes in
                       each input waveband in a set can be specified. 
                       (The default is 0.1 - 49.0.)
 
  \item {\bf No of good measures:} \hspace{2ex}
                        Sometimes a table containing a list of
                        magnitudes will for each stars have an entry
                        giving the number of estimates that made that
                        magnitude. (This is the case for the Starman
                        `Average' program output.) Optionally, a
                        magnitude can be rejected if this number is
                        less than a set limit for that waveband in
                        that set. (The default is no checking.)
 
  \item {\bf Position in Diagram:} \hspace{2ex}
                       The output (to plot or file) processed 
                        magnitude/colour or colour/colour may be subject 
                        to a test for location as lying in given
                        rectanglular region.
\end{list}

}\sstdiytopic{Option Input}{
  The options can be selected by responding at the keyboard to the
  `OPTION' question, or, if you are working at a workstation, using
  a panel of buttons. These options are toggled by the `panel'
  choice in the option list.

}\sstdiytopic{Plotting}{
 The symbols used to plot the data are under user control, and any of
 the standard PGPLOT symbols can be used.
 
 The graphical output is done using the PGPLOT package, and can
 thus be sent to any device that has a PGPLOT or GKS driver.

}\sstdiytopic{Output Table}{
 The content of a row in the output file is:-
 
\begin{tabular}{|l|l|}\hline
Column & Content \\ \hline
  1 & Identifier \\
  2 & X \\
  3 & Y  \\
  4 & col(2) or col(1)-col(2)   (optional)  \\
  5 & col(3)-col(4)  (optional)  \\
  6 & input waveband magnitude  (optional)   \\
  7 & number of good estimates in that magnitude  (optional)  \\ \hline
\end{tabular}

 The last two entries are repeated for each of the input magnitudes.

}\sstparameters{

\sstsubsection{ALL = LITERAL (Read)}{
 (Default - `no'     \hspace{6ex}      Choice - `yes:no')

 Apply these to all the sets (yes), or just to the present set (no).

}\sstsubsection{COLCODE = LITERAL (Read)}{
  (Default - one of `U',`B',`V'   \hspace{6ex}       Choice - any single character)

 A single character for labelling each waveband input for dialogue,
 plotting, and output. Reply V or U etc.

}\sstsubsection{COLCOR = {\undersc}REAL (Read)}{
 (Default - 0.0 or previous value   \hspace{6ex}      Range - -1.0e10 to 1.0e10)
 
 The real number in the colour equations to be applied to each input 
 magnitude.
 
 This is the `K' in the equation:-
 
$$        Col1_{n}  = Zero_{n}  + Col_{n}  + K_{n} .(C_{3}-C_{4} )  $$
 
}\sstsubsection{COLUMN = {\undersc}INTEGER (Read)}{
3 Column  
 (Default - 3       \hspace{6ex}      Range - 1 to no of columns in table)
 
 The column in the table that contains the magnitudes.

}\sstsubsection{COMMAND = LITERAL (Read)}{
  (Default - `no'     \hspace{6ex}       Choice - `yes:no')

  This is used when using the `panel' instruction input. It has no
  function other than to permit use of the full help system by
  responding `?' or `??', and to permit use of the `dropping through'
  to the operating system by use of the `\$' symbol before a normal
  DCL instruction, e.g. `\$ DIRECTORY/SIZE'.

  After you have used the help, then just reply `no' with a `return'
  key entry.

}\sstsubsection{DEVLIMX = {\undersc}REAL(2) (Read)}{
 (Default - the minimum and maximum of the data    \hspace{6ex}    Range - -1.0e10 to 
                                                            1.0e10))
 
 The range of mags and cols for the plot which define the size of
 the plotted area in the X direction.
 
 (This does not affect the output to a table.)

}\sstsubsection{DEVLIMY = {\undersc}REAL(2) (Read)}{
 (Default - the minimum and maximum of the data      \hspace{6ex}  Range - -1.0e10 to 
                                                            1.0e10))
 
 For the plot the range of mags and cols to define the size of
 the plotted area in the Y direction.
 
 (This does not affect the output to a table.)

}\sstsubsection{DOTNUM = LITERAL (Read)}{
 (Default - `no'      \hspace{6ex}     Choice - `yes:no')
 
 Flag for points plotted out to have the number (of the row of the star
 making that point in the table) to be plotted by the point.

}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'        \hspace{6ex}        Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question, 
  in a different way. A response here of `?' will bring up a listing 
  of all the possible names of graphics devices which are supported 
  on your machine, and you then input the appropriate name.

}\sstsubsection{HILIM = {\undersc}REAL (Read)}{
 (Default - 49.0 or last value input    \hspace{6ex}    Range - -1.0e10 to 1.0e10)
 
 Stars in this file with input magnitude  fainter than this
 are not accepted.

}\sstsubsection{IDINAME = LITERAL(Read)}{
 (Default - `ikon'      \hspace{6ex}       Choice - any)
    
   The local name defining the display device. The list of names
   call be seen in the file with the logical name `GNS{\undersc}IDINAMES'.
   Remember that the case of the letters matters.

}\sstsubsection{INTAB = BDF (Read)}{
  (Default - null)

 If `file' is chosen in `TYLINE' parameter option, then a table with
 the points defining the line is needed. This is that table

}\sstsubsection{IN1 = BDF (Read)}{
  (Default - null)

 An input file containing a table with one column having magnitudes.

}\sstsubsection{ }{
   {\large \bf This is repeated for IN2 to IN48}

   \vspace*{2mm}

}\sstsubsection{LOLIM = {\undersc}REAL (Read)}{
 (Default - 0.1 or last value input  \hspace{6ex}             Range - -1.0e10 to 1.0e10)
 
 Stars in this file with  input mag brighter than this
 are not accepted.

}\sstsubsection{NCOLUMN = {\undersc}INTEGER (Read)}{
 (Default - 0        \hspace{6ex}        Range - 1 to no of columns in table)
 
 The column in the table that contains the number of good estimates
 of the star magnitudes. If no such column exists, or use of it is
 not desired, input `0'.

}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the Starman programmes use all three, with
  the right-hand button being used mainly as the `exit' button. 

  With two buttons, then the third button is simulated by pressing 
  both of the buttons down, with the middle one being pressed slightly 
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will 
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{NUMGOOD = {\undersc}INTEGER (Read)}{
 (Default - 0 or last value input     \hspace{6ex}      Range - 1 to 100000)
 
 If using this input control, this is the minimum no of estimates
 used in making the star mag for a star in the input file
 that is acceptable. Any star with fewer that that for the
 mag in this file is ignored.

}\sstsubsection{OFFSETS = {\undersc}REAL(2) (Read)}{
 (Default - 0.0,0.0           \hspace{6ex}      Range - -1.0e10 to 1.0e10)
 
 The `x' and `y' offsets to be added to the data in the `INTAB'
 table for plotting.

}\sstsubsection{OPTION = LITERAL (Read)}{
 (Default - last chosen in list below  \hspace{6ex}    Choice  - see list below)
 
 Choice of options is:-

\begin{tabular}{|l|l|}\hline 
  Option   &   Function \\ \hline
  Clear    &   Clear Display \\
  Close    &   Close Display  \\
  Coleq    &   Change colour eqns \\
  Device   &   Open (new) display device \\
  Dotnum   &   Change whether plotted points are numbered \\
  Exit     &   Exit from program \\
  Gcursor  &   Type out locations in the plot chosen by cursor \\
  Getset   &   Open a set of files \\
  Line     &   Draw lines on plot \\
  Maglims  &   Change limits on magnitude selection \\
  Numgood  &   No of good estimates needed  \\
  Panel    &   Toggle between keyboard and panel option input \\
  Plot     &   Plot the points \\
  Plotlim  &   Change the plotting limits \\
  Prange   &   Range in plot points allowed in \\
  Setnumber&   Change number of set being done \\
  Store    &   Output the results to file \\
  Symbol   &   Change plot symbol by PGPLOT code \\
  Zero     &   Change the zero points \\ \hline
\end{tabular}                                   

  When using the cursor to find magnitudes/colours of positions
  on the graph, place the cursor on the desired location, and
  press any keyboard key. To end, place the cursor to the left 
  of the origin and press any key.

}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)

 The Output table for storing the results.

  (See above for its contents.)

}\sstsubsection{PCOLUMN = {\undersc}INTEGER(2) (Read)}{
 (Default - 1,2     \hspace{6ex}    Choice - 2 integers in the range 1 to no of columns)
 
  If `file' is chosen in `TYLINE' option, these  are the numbers of
  the two columns in the table containing respectively the `x' and the
  `y' values which are to be plotted as a line.

}\sstsubsection{PDSTYPE = LITERAL (Read)}{
 (Default - `decw'      \hspace{6ex}    Choice - `none:vws:decw')

  Image display device to put windows-type `panel' of options
  up on.

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Ikon    &    IKON Image display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}

}\sstsubsection{SET = {\undersc}INTEGER (Read)}{
 (Default - present value    \hspace{6ex}    Range - 1 to No of sets input)
 
 The number defining which of the input sets of (up to) four
 tables to deal with. Up to twelve sets can be kept.

}\sstsubsection{STOREXY = LITERAL (Read)}{
 (Default - `yes'       \hspace{6ex}    Choice - `yes:no')
 
  If yes, then the input file will contain in its first two columns, 
  the X and Y positions of the stars, and you desire that these should 
  be output.

}\sstsubsection{SYMBOL = {\undersc}INTEGER (Read)}{
 (Default - 1 or last value input    \hspace{6ex}     Range - 1 to 128)
 
 The PGPLOT symbol code that defines the shape of the symbol
 plotted.

}\sstsubsection{TITLE = LITERAL (Read)}{
 (Default - Input file title or `Output from Diagram'       \hspace{6ex}  Choice - any)
 
 The Title to be inserted in the Output file

}\sstsubsection{TYLINE = LITERAL (Read)}{
 (Default - `return'    \hspace{6ex}     Choice - `cursor:file:keyboard:return')
 
 Flag for method of putting line on diagram. Points given by
 the various inputs are plotted as joined together with straight 
 lines.
 
 If the `cursor' option is used, then a line is drawn joining the
 successive locations marked with the cursor, until a location less
 than the minimum `x' value of the graph is chosen, when this cursor
 entry stops.

}\sstsubsection{TYPE = LITERAL (Read)}{
 (Default - `hr'  \hspace{6ex}     Choice - `hr:twocol')
 
 Flag for choosing colour-magnitude (hr) or colour-colour (twocol) 
 diagram type output.

}\sstsubsection{XRANGE = {\undersc}REAL(2) (Read)}{
 (Default - the range of the data      \hspace{6ex}   Range - -1.0e10 to 1.0e10)
 
 The acceptable range of the value of the output `x' colour, 
 ($col1_{3}$ - $col1_{4}$ ), that a star may have. If it lies outside this range,
 then it will not be plotted, and it will be stored with a warning
 flag.

}\sstsubsection{XYKEY = {\undersc}REAL(2) (Read)}{
  (Default - X max and Y max or present values      \hspace{6ex}     Range - -1.0e10 to 
                                                              1.0e10)

 If `keyboard' is chosen in `tyline', these are the `x',`y' posns 
 to input. 

 If the `x' value input is less than the minimum value that can be 
 displayed then the keyboard entry is halted, otherwise the next
 position is asked for.
 
 Flag for using cursor on devices with a cursor, to get magnitudes of 
 posns on the diagram. If YES, then cursor is enabled, if NO not.

}\sstsubsection{YRANGE = {\undersc}REAL(2) (Read)}{
 (Default - the range of the data    \hspace{6ex}         Range - -1.0e10 to 1.0e10)
 
 The acceptable range of the value of the output `y' colour, 
 $col1_{2}$ or ($col1_{1}$ - $col1_{2}$ ), that a star may have. If it lies outside this range,
 then it will not be plotted, and it will be stored with a warning
 flag.

}\sstsubsection{ZEROP = {\undersc}REAL (Read)}{
 (Default - 0.0      \hspace{6ex}         Range - -1.0e10 to 1.0e10)
 
 The zero point corrections to be added to the input magnitude. 
 
 This is the `Zero' in the equation:-
 
$$        Col1_{n}  = Zero_{n}  + Col_{n}  + K_{n}.(C_{3}-C_{4})  $$
 
}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} DUSTRING}

\sstroutine{DUSTRING}{Remove `Dustring' Shadows from an Image}{

\sstdescription{
  This allows you to add and/or subtract the 'dustring' shadows of dust 
  particles on images.

}\sstdiytopic{Use}{
  It is mainly useful for making a flat field match up to the desired flat 
  field when a dust particle has blocked part of the image from complete 
  illumination since the flat field was made.

  Likewise, by subtracting a ring, the flat can be corrected to before
  the particle fell.

  It is useful for combining flats with different flat field dustrings.

  It can be run either with or without an image display.

}\sstdiytopic{Use Details}{
  The program is a looping one, where you can repeatedly choose various 
  options.

  Basically, you select a dustring, and manually by trial and error
  you adjust the position and background level for a theoretical ring
  which you then add or subtract from the image.

  The ring is added/subtracted as:-

$$            (Background Level).(Profile(xo,yo))  $$

    where:-

\hspace{6ex}\begin{tabular}{lp{4in}}
 Profile(x,y) &    is a fixed profile which is a function of
                           X and Y, and is a percent of the background 
                           level. \\
xo,yo    &  is the position of the ring. \\
       
Background Level    & is the local background level at the ring \\
\end{tabular}

  The ring profile will have previously be determined, again by trail
  and error. (See help subsection on profile.)

  When you are happy with the position, profile, and background level,
  you can also store those parameters in the working table.

  When you done all the adding/subtraction, you can store the output
  image.

  You can also note into a table any ring you wish, and this table can 
  later be output to a file. It would contain the parameters of the rings
  and will only have those rings actually noted, which is NOT necessarily
  the same as those added/subtracted from the image.

}\sstdiytopic{Dustring Profile}{

   The profile is shaped like this:-

\hspace*{0ex}xxxxxxxxxxxxx\hspace{16ex}xxxxxxxxxxxx\hspace{17ex}xxxxxxxxxxx\hspace{\fill}\\
\hspace*{16ex}x\hspace{14ex}x\hspace{14ex}x\hspace{15ex}x\hspace{\fill}\\
\hspace*{17ex}xxxxxxxxxxxx\hspace{16ex}xxxxxxxxxxxx\hspace{\fill}


    Where the shape is determined by the parameters:-

\hspace*{6ex}\begin{tabular}{lp{4in}}
       PERCENT  &   Percentage drop into shadow (in terms of local
                                                 background) \\
       RIN      &   Inner radius of deep part of ring \\
       ROUT     &   Outer radius of deep part of ring \\
       SLOPEIN  &   Inwards distance from RIN to location of no shadow area \\
       SLOPEOUT  &  Outwards distance from ROUT to location of no shadow area \\
\end{tabular} 

}\sstparameters{

\sstsubsection{Back = {\undersc}REAL (Read)}{
  (Default - 1.0   \hspace{6ex}   Range - -1.0e10 to 1.0e10)

   The local background level for the ring to use when being
   added or subtracted.

}\sstsubsection{DSTYPE  = LITERAL (Read)}{
 (Default - 'decw' \hspace{6ex}     Choice - 'ikon:none:vws:decw')

  Type of display to be used:-

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Ikon    &    IKON image display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}

}\sstsubsection{IDINAME = LITERAL(Read)}{
 (Default - `ikon'      \hspace{6ex}       Choice - any)
    
   The local name defining the display device. The list of names
   call be seen in the file with the logical name `GNS{\undersc}IDINAMES'.
   Remember that the case of the letters matters.

}\sstsubsection{IMPOSN = {\undersc}REAL (Read)}{

}\sstsubsection{IN = BDF (Read)}{
  (Default - null)

  The name of the input image file.

}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the Starman programmes use all three, with
  the right-hand button being used mainly as the `exit' button. 

  With two buttons, then the third button is simulated by pressing 
  both of the buttons down, with the middle one being pressed slightly 
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will 
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - last choice        Choices - see below)

   Choice of operations to do:-

\hspace{4ex}\begin{tabular}{|l|l|}\hline
     Choice     & Function \\ \hline
     Add        & Add a dustring to image \\
     Background & Background level to apply \\
     Cvalues    & Look at image values \\
     Display    & Display image \\
     Exit       & Exit program \\
     Flash      & Display image at best contrast \\
     Imstore    & Store -cleaned- image \\
     Level      & Get local level \\
     Note       & Note present ring for storage \\
     Panel      & Switch between panel and keyboard option input \\
     Position   & Set position of ring \\
     Profile    & Change dustring profile  \\
     Reset      & Put zoom/pan of display to unity \\
     Show       & Type out ring profile, position background \\
     Subtract   & Subtract a dustring from image \\
     Tabstore   & Store table of noted rings into a file \\
     Zoom       & Zoom/pan display \\ \hline
\end{tabular}

}\sstsubsection{OUT = BDF (Write)}{
 (Default - null)

  The name of the output image file. This holds the input image 
  with the effect of all rings that have been added or subtracted.

  This is Integer*2 and has BZERO, BSCALE and INVAL from the input
  image.

}\sstsubsection{OUTTAB = BDF (Write)}{
 (Default - null)

   The output table, storing the parameters of the rings noted

   Only those rings actually 'noted' will be in this table. It does
   not passively record all those added or subtracted. from the image

}\sstsubsection{PDSTYPE = LITERAL (Read)}{
 (Default - `decw'      \hspace{6ex}    Choice - `none:vws:decw')

  Image display device to put windows-type `panel' of options
  up on.

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}

}\sstsubsection{PERCENT = {\undersc}REAL (Read)}{
   (Default - 0.5 or last value       Range -  0 to ?)

   The percentage dip into the deep part of the ring profile,
   in terms of the defined background level

}\sstsubsection{POSN = {\undersc}REAL(2) (Read)}{
   (Default - centre or last position        Range - -1.0e10 to 1.0e10)

   The X,Y position to put the ring at

}\sstsubsection{RIN = {\undersc}REAL (Read)}{
   (Default - 8.0 or last value          Range - 01.0 to 1.0e8)

   The radius at the inner ring edge of the deep part of the ring

}\sstsubsection{ROUT = {\undersc}REAL (Read)}{
   (Default - 12.0 or last value          Range - 01.0 to 1.0e8)

   The radius at the outer ring edge of the deep part of the ring

}\sstsubsection{SCREEN = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, size of image      \hspace{6ex} Range - 1 to large)

  Size of screen or window to open. 

  The default size is that of the image, unless the image is too large
  to fit on the screen, when the image will be binned down by an integer
  factor for display. The default size will then be this binned down size.

}\sstsubsection{SIDE = {\undersc}INTEGER (Read)}{
  (Default - 5 or last value      Range - 3 to size of image)

   The size of the side of the box about the last defined
   position to define the area to find the local level

}\sstsubsection{SLOPEIN = {\undersc}REAL (Read)}{
  (Default - 1.0 or last value              Range - -1.0e8 to 1.0e8)

   Inwards distance from RIN to location of no shadow area

}\sstsubsection{SLOPEOUT = {\undersc}REAL (Read)}{
  (Default - 3.0 or last value              Range - -1.0e8 to 1.0e8)

   Outwards distance from ROUT to location of no shadow area

}\sstsubsection{TITLE = LITERAL (Read)}{
 (Default - Title of input image          Choice - any)

   The title to apply to the output image or table

}\sstsubsection{VRANGE = {\undersc}REAL(2) (Read)}{
 (Default - suggested values  \hspace{6ex}  Range - -1.0e10 to 1.0e10)

 The range of values to be displayed as black to white on image display
 display.

}\sstsubsection{WRAP = LITERAL (Read)}{
  (Default - `no'        \hspace{4ex}    Choice - `yes/no')

 When displaying image on image display, for those image pixel values that
 lie above or below the display values for white or black, do you want 
 these values to be shown as white or black (`no'), or do you want them to
 be `wrapped' round - that is considered as modulo the display range 
 (`yes')?

}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} FIND}

\sstroutine{FIND}{Find Stars in an Image}{

\sstdescription{

  This program finds stars in an image. It works by looking for
  boxes of roughly the seeing size which are significantly different
  from their surroundings. It is a good searcher, but slow - about
  an hour cpu on a Vax 8600 for a thousand stars on a 512x320 image,
  although it can be sped up by setting the search limits so it does
  not look for very improbable stars.

  It can deal with variations in the background level, but gets
  thrown by very large galaxies. If it encounters small galaxies, it
  gives them the benefit of the doubt and marks up a double star.

  It is not perfect, and the eye can do better in some cases. It is
  very good on very faint isolated stars, finding (real) things you
  wouldnt believe, but in very crowded fields or very overlapping
  stars, it is good to run FIND and then delete and add the few
  corrections to the star list produced. This can be done by INTERACT.

  The output file is not asked for until the very end of the program,
  after it has found the stars. If you want to input the file name at
  the beginning of the program, do so in the command line when running
  the program, with OUT=`name of file' and TITLE=`title to add to file'.
  This will then permit the program to access these when it needs them

  The program will not work on images smaller than 10x10.

}\sstdiytopic{Use}{
  You first must know the radius (HPHW) of the star images (only 
  roughly - an option is to use the RADIUS program (qv) to do this). 
  Then you start the program. A list of star positions comes out. That 
  is all you have to do. 

  There are two options to omit two parts of the searching to speed 
  things up. Use of these options will result in not finding a few of 
  the tricky stars. 

  There are also two input paramaters to select the range of stars 
  found to differing probability limits.

  There is also a not very critical parameter, the size of the large
  sky box the program uses. I suggest you adopt the computer suggested
  size.

  If you are interested in the progress of the program you can set
  the parameter INFORM to different levels to get different levels of
  output on the terminal as you go along.

}\sstdiytopic{Method}{
 The finding is done by:-

\begin{list}{{---}}{}

 \item Making a `U-map' image of the input image. This is a map of the 
     probability that a pixel is significantly higher than its 
     surroundings, and so is likely to be near the peak of a star.
     Thus a `sharpened' image is made of star-sized objects above the
     local levels.

 \item Looking in the U-map image for:-

   \begin{list}{{-}}{}

     \item Star peaks and plateaus 
     \item Elliptical stars, and saying that is actually two stars
     \item Shoulders running off from stars, and saying they are actually 
        stars
  \end{list}

 \item Weeding the stars found for spurious ones

 \end{list}

 This process has been deliberately tuned to be reasonably generous
 in finding stars, so it should find more than there are. The output
 of this should be put into a proper star measuring program to
 sort out the (small number of) false alarms.

 There is a limit on the number of stars that can be found.

 These matters are described more fully in the sub-headings below.

}\sstdiytopic{Hidden Parameters}{
  The parameters MAXNUM, PLIMIT and WLIMIT are `hidden', that is only
  accessible by putting `FIND MAXNUM=value PLIMIT=value WLIMIT=value'
  on the command line or a previous LET command.

}\sstdiytopic{Inform}{
  The program can output progress information as it goes along.
  What is output to the terminal device by the program is set by
  the INFORM parameter. Thus:-

\begin{tabular}{|l|p{4in}|}\hline
     INFORM  value &   Output information \\ \hline
       0      &        None \\
       1      &   Stages in the finding started and ended \\ 
       2      &   As for 1, but also more detailed information, such 
                  as the U-map level being looked at, and stars found \\ \hline
\end{tabular}

  In the typed-out information when INFORM = 2, those lines relating to
  star finds are similar to the rows in the output table. The 
  star number is however not the same as in the output, as there is a 
  sequence of finding which may affect earlier finds, and so disrupt the
  star numbering. Thus a found star may later in the program be decided 
  to be:-

 \begin{list}{{-}}{}
    \item replaced by two stars since the found star is too elliptical
    \item removed as one of a number of false finds in an `invalid' peak
    \item removed as being too close to another star
\end{list}

  These last two removal processes also have their process informed to
  the terminal.

}\sstdiytopic{U-Map}{
  The U-map is made by:-

 Running a non-parametric test (one tailed mann-whitney U test)
 over every point in the image. At each point it takes a box
 (roughly a seeing size) round that point and compares it with 
 an equal area around that box. It looks at the ranks of points
 when all put together, and assigns a probability 
 (0-1 1=certain) to the chance that the ranks are NOT scattered
 at random, and thus that the data in the box is different
 AND higher from that in the annulus round it. This is then
 repeated with the comparision area separated by 1 pixel from
 the central box, and then with slices on each side,and then
 with slice on top and bottom. The comparision which indicates
 the most difference is taken.

 The U-map image of probabilities is a sharpened (on the scale 
 of the box used) copy of the input. Thus the background (sky, 
 large-scale effects such as galaxies, fringes, etc) is 
 automatically allowed for. The box size is 3x3 for radius less 
 than 1.75, 5x5 for radius less than 2.5 and then 7x7 up to 5.5, 
 and therafter  ( nbox = 1 + 2*int(1.0+(radius-1.5)/2.0) )

}\sstdiytopic{Peaks}{
 The peaks are found by searching the U-map for isolated images. 

 This is done 
    by lowering a threshold and looking for isolated patches 
    above those thresholds. The mean position of the largest size
    patch before it merges in the lowering with another is taken
    as the star position. The lowering continues until the U-map
    probability level of `x' is reached (i.e. their is a `x' chance
    that the values are not different from the surrounds). `x' is
    is a user input number. An `x' value of 0.001 will result in
    about 100 false detections in a 320 by 512 image. Thus
    normally, a value of 0.01 is used.

    The lowering then continues down to the `y' probablity level, 
    but only those patches which have values in the corresponding 
    real image significantly (2.25 std devs) above the local sky 
    level are found. This finds faint stars on the wings of bright
    ones. `y' is normally 0.05, but to speed the process up, can
    be set to the `x' level of step 3).

}\sstdiytopic{Sky}{
 The local sky level referred to above has previously been
 determined by the programme.

 This is done by making a `sky map', that is a temporary image the
 same size as the input image, with its pixel values set to what the
 programme thinks is the value of the background sky at that pixel.

 It also determines another sky map, which have the local values of
 (sky+scatter), where `scatter' is the largest reasonable value the
 sky noise could add to the sky level in a pixel.

 These are determined in one of three ways:-

 \begin{enumerate}
  \item Subdividing the image into largeish (set by you, but suggested
    at 64x64) boxes, finding local modes and scatters, and then
    interpolating between these local modes by linear interpolation
    between the box centres. The scatter about the
    mode of the lowest mode is taken as the sky scatter.

  \item Taking the input image as having uniform background. The mode of 
        the image is found, and the std dev about this mode found. 

        This is the defaulkt way.

  \item Looking for the minimum pixel value and taking that as the sky
    level. The noise is taken as the std dev around the mode of the whole
    image.

\end{enumerate}

 The default should be chosen unless there is smooth and
 significant change in the sky background (say from an elliptical
 galaxy which covers most of the image). If the
 change in the sky background is sharp, say from a globular cluster
 manifesting itself over 50 pixels, choose the default anyway.

}\sstdiytopic{Ellipticity}{
 The found images are searched for ellipticity, an indication of 2 
 stars close together, merging to make one. 

 The program looks at stars and sees if the U-test image shape of the
 star is elliptical. For a star to qualify as elliptical, the
 group of flagged pixels that make up the star (that is the number 
 of contiguous pixels flagged as being below the present 
 significance level) have to satisfy certain criteria:-

\begin{list}{{-}}{}

    \item  the ellipticity has to be greater than a given limit, 0.35
    \item  the semi-major axis has to be larger than a given limit 
              (0.67 times the star image profile radius)
    \item  the area of the star has to be more than seven pixels
    \item  the area of the star must not touch the image edge 
    \item  the area of the star does not contain other stars
\end{list}

 This searching is only done when new stars are found in the main
 program. On these occasions, all the stars are checked for
 ellipticity. Now some of these will have already been found
 to be elliptical when working at a higher contour level
 significance. Such stars are rechecked regardless, as the lower
 significance, larger, image may show up a better ellipticity. This
 rechecking of `existing' doubles is however only done five times.

}\sstdiytopic{Shoulders}{
  Stars on the wings of brighter ones are searched for. These show up 
  in the U-map image as long, narrow projections from the patches. At 
  each lowering level, each image is searched for these projections. 
  These projections are allowed down to a 9.5% probability level.

}\sstdiytopic{Weeding}{
 The stars found are weeded before output to remove spurious
 detections.

 This is done by:-

\begin{list}{{-}}{}

 \item The final list is searched for stars which are too close
    to each other (separation less than 0.66*star radius). These
    are replaced by one star at the mean position.

 \item For CCD images, bright stars have linearity problems and/or
    saturated centres, and these centres should be marked by 
    INVALID flag levels for all pixels above some level. These
    stars are then found to have a number of isolated patches
    in the U-map (since the centre itself has all the same values),
    and so a test is made for these saturated centres, and the
    possibly more than 1 stars found there are reduced to one.

 \item If an image was trailed or by some other cause has elongated
    images, then this program will tend to regard each image
    as a double and mark it as so. If desired, the star list
    is looked at for an excess of close doubles at the same
    angle and separation, and these are reset to be single stars.
\end{list}

}\sstdiytopic{Maximum Number}{
 There is a user defined computer found star storage work space. 
 This limits the number of stars that may be found. The default is
 10,000 stars. If more than this are found, the program stops.
 If more than this are found, the program stops. The resulting star 
 list will have a non-complete and non-uniformly found content and 
 should not be used as an reliable list. Although all the stars 
 actually in it will be good ones, the found/not found distinction 
 may vary with position, brightness, ellipticity, sky background, 
 and presence of nearby stars in an unprdicatble way. If the
 max number of stars is found, then because of the weeding of close
 pairs and of multiple hits on large invalid areas, less than the
 maximum may be put out. Beware of thus thinking that all was ok
 just because of the fact that less than the maximum number were
 output.


}\sstdiytopic{Output}{
   The output table contains six columns. For each star, the entry is:-

\begin{tabular}{|l|p{4in}|}\hline
Column Number & Content \\ \hline
       1 & X posn \\
       2 & Y posn \\
       3 & Height above sky \\
       4 & utest value as 100000.0*(1.0 - [u-test probablity]) \\
       5 & flag for `FIND' type 1:single 2:nipple 3:ellipse 
                              11:single-inval 12:nip-inval 13:ell-inval 
                              4:weeded ellipse centre \\
       6 & elliptical companion number (=0 if none) \\ \hline
\end{tabular}

}\sstparameters{

\sstsubsection{IN = BDF (Read)}{
 (Default - null)

  The name of the file containing the input image

}\sstsubsection{RADIUS = LITERAL (Read)}{
  (Default - 2.0  \hspace{6ex}   Range  - 0.2 to 20.0)

  The approximate Half Power Half Width of the star images. This is what
  RADIUS (qv) and PROFILE (qv) find and what MEASURE (qv) uses

}\sstsubsection{PLIMIT = {\undersc}REAL   [HIDDEN] (Read)}{
  (Default - 0.001   \hspace{6ex}  Range - 0.00001 to 1.0)

  [Hidden variable, only accessible from command line, or presetting, or 
  setting in `find.con' file.]

  The limit of probability that the difference between the area inside
  the search box and the area around it has arisen by chance and that 
  there is not really a star at this position. A value of 0.001 gives
  roughly 100 false detections in a 320by512 image.

}\sstsubsection{WLIMIT = {\undersc}REAL [HIDDEN] (Read)}{
  (Default - 0.05   \hspace{6ex}    Range - 0.0001 to 1.0)

  [Hidden variable, only accessible from command line, or presetting, or 
  setting in `find.con' file.]

  The limit of probability that the difference between the area inside
  the search box and the area around it has arisen by chance and that 
  there is not really a star at this position, FOR A POSITION WHICH HAS
  A SIGNAL VALUE of 2.5std dev above the local sky. This is used for
  looking for stars on the wings of bright stars.

}\sstsubsection{ELLIPSE = LITERAL (Read)}{
  (Default - `yes'   \hspace{6ex} Choice - `yes/no')

  After the first search, repeat, trying to see if any of the objects
  were elliptical and thus maybe double stars. YES/NO will enable/
  suppress this extra search.

}\sstsubsection{FAINT = LITERAL (Read)}{
  (Default - `yes'   \hspace{6ex} Choice - `yes/no')

  After the first search, repeat, trying to see if any of the objects
  were had faint companions that were missed. YES/NO will enable/suppress 
  this extra search.

}\sstsubsection{SMEAR = LITERAL (Read)}{
  (Default - `yes'   \hspace{6ex} Choice - `yes/no')

   If an image was trailed or by some other cause has elongated
   images, then this program will tend to regard each image
   as a double and mark it as so. If desired (YES), the star list
   is looked at for an excess of close doubles at the same
   angle and separation, and these are reset to be single stars.
   
}\sstsubsection{SKYTYPE = {\undersc}INTEGER (Read)}{
  (Default - 2    \hspace{6ex}    Range - 1 to 3)

 Method of making the sky map.

 This is done by making a `sky map', that is a temporary image the
 same size as the input image, with its pixel values set to what the
 programme thinks is the value of the background sky at that pixel.

 It also determines another sky map, which have the local values of
 (sky+scatter), where `'scatter' is the largest reasonable value the
 sky noise could add to the sky level in a pixel.

 These are determined in one of three ways (where the numbers match to
 the `SKYTPE' response) :-

 \begin{enumerate}

  \item Subdividing the image into largeish (set by you, but suggested
    at 64x64) boxes, finding local modes and scatters, and then
    interpolating between these local modes by linear interpolation
    between the box centres. The scatter about the
    mode of the lowest mode is taken as the sky scatter.

  \item Taking the input image as having uniform background. The mode of 
        the image is found, and the std dev about this mode found. 

        This is the default way. 

  \item Looking for the minimum pixel value and taking that as the sky
    level. The noise is taken as the std dev around the mode in the whole
    image.
\end{enumerate}

 The default should be chosen unless there is smooth and
 significant change in the sky background (say from an elliptical
 galaxy which covers most of the image). If the
 change in the sky background is sharp, say from a globular cluster
 manifesting itself over 50 pixels, choose the default anyway.
   
}\sstsubsection{XSKYBOX = {\undersc}INTEGER(2) (Read)}{
  (Default - 64 (or half X size, if less)    \hspace{6ex}        Range - 10 to half X size of image)

  Suggested X size of the box the program uses to average the sky 
  values. Should be small compared to the scale of the sky variations.
  
  (This is only asked for if the `SKYTYPE' parameter is set to '2'.)

}\sstsubsection{YSKYBOX = {\undersc}INTEGER(2) (Read)}{
  (Default - 64 (or half X size, if less)           \hspace{6ex}    Range - 10 to half Y size of image)

  Suggested Y size of the box the program uses to average the sky 
  values. Should be small compared to the scale of the sky variations.

  (This is only asked for if the 'SKYTYPE' parameter is set to `2'.)

}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)

  The name of the file to contain the output table of star positions.

  The output file is not asked for until the very end of the program,
  after it has found the stars. If you want to input the file name at
  the beginning of the program, do so in the command line when running
  the program, with OUT=`name of file' and TITLE=`title to add to file'.
  This will then permit the program to access these when it needs them

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title, or `Output from FIND'  \hspace{6ex} Choice 
   - any)

  The Title to add to file ( named with `OUT') containing the output
  star position table.

}\sstsubsection{INFORM = {\undersc}INTEGER (Read)}{
  (Default - 1      \hspace{6ex}   Range - 0 to 2)

  Switch to enable monitoring of the progress.

  [See the section on `Inform']

}\sstsubsection{USAVE = LITERAL [HIDDEN] (Read)}{
  (Default - `no'   \hspace{6ex} Choice - `yes/no')

  Flag for saving the U-test image made in the calculations.

  [Hidden variable, only accessible from command line, or presetting, or 
  setting in `find.con' file.]

}\sstsubsection{OUTIM = BDF [HIDDEN] (Write)}{
  (Default - null)

  The name of the file to contain output U-test image.

  This is only output, if `YES' has been responded to `Usave'.

  [Hidden variable, only accessible from command line, or presetting, or 
  setting in `find.con' file.]

}\sstsubsection{MAXNUM = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - 10000      \hspace{6ex}   Range - 1 to 1 000 000)

  [Hidden variable, only accessible from command line, or presetting, or 
  setting in `find.con' file.]

  The maximum number of stars that can be found. 

  If more than this are found, the program stops. The resulting star 
  list will have a non-complete and non-uniformly found content and 
  should not be used as an reliable list. Although all the stars 
  actually in it will be good ones, the found/not found distinction 
  may vary with position, brightness, ellipticity, sky background, and 
  presence of nearby stars in an unprdicatble way. If the
  max number of stars is found, then because of the weeding of close
  pairs and of multiple hits on large invalid areas, less than the
  maximum may be put out. Beware of thus thinking that all was ok
  just because of the fact that less than the maximum number were
  output.

}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} INTERACT}
 
\sstroutine{INTERACT}{Interact with Image Display}{
 
\sstdescription{ 
                                                                               
  This is the main Starman programme for interacting with an image
  displayed on a display device.
                                                                               
  The Main functions are:-

  \begin{list}{{-}}{}
     \item Display of image(s)
     \item Inspection of the image
     \item Changing look up tables and use of colours
     \item Inspection of pixel values in sub-areas in various ways
     \item Plotting (X,Y) positions from an input table
     \item Getting (X,Y) positions for storage in an output table
     \item Interactive aperture photometry
     \item Scrutiny of the Starman MEASURE program output
   \end{list}                     
                                                          
  These are divided into five groups:-
                                                                               
  `Interact' is the main group, the one you are in at the start. You may 
 perform a certain number of functions in this `group', such as getting
 an image and displaying it. You can then do other functions in this group,
 or go into one of the other four groups and perform the functions
 available there. From these groups, one has to go back to the main, 
 `Interact', group to get into another one of the groups, or to exit.
   
\begin{tabular}{|c|l|}\hline 
     Group    &    Function \\ \hline
     Interact &    Image input, display, table XY positions display/get \\
     Aperture &    Aperture photometry in an interactive way \\
     Colour   &    Changing the colour LUT of the image display \\
     Inspect  &    Look at pixel values in different ways \\
     Scrutiny &    Look at the output of Starman:Measure \\ \hline
\end{tabular}                                                                 
                                                                               
  The groups are each driven by a menu system, which may be of the 
  `push-button' type.

}\sstdiytopic{Use}{
As the use of Interact is interactive, there is (nearly) an infinite number
of ways of using it. To give you some ides of its use, the following 
`run-through' of one possible session is given.

Explanations and commentary associated with each annotation are given
afterwards. The parts in italics are instructions to you The parts in san
serif are typed output by the programme, or comments on the display.

It is assumed the user is at a colour workstation (either an Xwindows
device used as an image display or a Vaxstation running Decwindows). (Of
course, the use of an IKON of VWS windows is also possible.) 

\begin{tabular}{p{5.5in}l}
Starman$>$ Interact starman{\undersc}testdata:measure{\undersc}in  \hspace*{\fill}  & \fbox{1} \\
                                                                          & \\
OPTION/image/:=                                                           & \fbox{2}\\
XRANGE/1,100/:=                                                           & \fbox{3}\\
YRANGE/1,100/:=                                                           & \\
OPTION/flash/:=                                                           & \fbox{4}\\
DSTYPE/decw/:=                                                            & \fbox{5}\\
SCREEN/100, 100/:=200,200                                \hspace*{\fill}  & \fbox{6}\\
{\sf Display contrast: low =   324.9188 ; high =   -19.3838}   \hspace*{\fill}  &\\
{\sf The image is displayed in the window} \hspace*{\fill}  &\\
OPTION/panel/:=                                                           & \fbox{7}\\
PDSTYPE/decw/:=                                                           & \fbox{8}\\
{\sf The `push-buttons' are displayed }                  \hspace*{\fill}  &\\
\hspace*{4em}     {\it Click cursor on 'cvalues' button}  \hspace*{\fill}  & \fbox{9}\\
\hspace*{4em}     {\it Move cursor around image}          \hspace*{\fill}  & \fbox{10}\\
\hspace*{4em}     {\it Click cursor right-hand button }   \hspace*{\fill}  & \fbox{11}\\
\hspace*{4em}     {\it Click cursor on 'inspect' button}  \hspace*{\fill}  & \fbox{12}\\
\hspace*{4em}     {\it Click cursor on 'slice' button}    \hspace*{\fill}  & \fbox{13}\\
\hspace*{4em}     {\it Click cursor on image top margin}  \hspace*{\fill}  & \fbox{14}\\
\hspace*{4em}     {\it Position cursor inside and near b.l.h. corner of image and click} \hspace*{\fill}  & \fbox{15}\\
X = 13  Y = 17                              \hspace*{\fill}  &\\
\hspace*{4em}     {\it Position cursor inside and near t.r.h. corner of image and click} \hspace*{\fill}  & \fbox{16}\\
X = 85  Y = 86                               \hspace*{\fill}  & \\
VRANGE/-540.4000, 6928.400/:=                \hspace*{\fill}  & \fbox{17}\\
GTYPE/ask/:=xwindows                                                      & \fbox{18}\\
\hspace*{4em}     {\it Click cursor on 'RETURN' button}    \hspace*{\fill}  & \fbox{19}\\
\hspace*{4em}     {\it Click cursor on 'EXIT' button}     \hspace*{\fill}  & \fbox{20}\\
Starman$>$xdestroy "GKS{\undersc}3800"                       \hspace*{\fill}  & \fbox{21}\\
Starman$>$                                                                  & \\
\end{tabular}

Comments on above run-through:-

\begin{enumerate}

\item By putting the target image file name on the command line, the 
      first time the name is asked for, it will be got from this 
      command line. As the image parameter, (`IN'),is the first in 
      the INTERACT connection file, we do not have to say `IN=name'.
\item We are now in the main, `Interact', group and have available all 
      the functions of this group. We are offered the option of 
      getting an image. By just doing `carriage return', we get that 
      option. As we have put the image file name on the command line, 
      it is not asked for again here.
\item We are now asked what area of the input imagewe wish to deal with.
\item We are now asked again for what `Interact' option we want, and are
      offered the default of displaying the image with standard display
      settings. We take that default.
\item As we are going to display the image, the programme needs to know 
      which device to put it out on, and offers `DECW' as the default.
      This will put it out on any Xwindows device. We take the default.
\item What size of window is to be put up? The default is the size of 
      the image. We choose a window twice as large. The programme opens
      the window and displays the image at a contrast suitable for
      images which are `normal' pictures of astronomical objects. It
      types out the lower and upper pixel values displayed as black
      and white.
\item Again, what `Interact' option? We choose the default, which is
      to switch over from keyboard entry of the desired options to
      `push-button' mode.
\item The programme has to know where to display the push buttons.
      When we have told it, a panel of push buttons appears on that
      display device.
\item We now have the options available to use the `Interact' group.
      We choose that which will let us look at the pixel values.
\item Note the display of the cursor position and pixel values in the
      panel.
\item Return to the panel option selection.
\item Leave the `Interact' group of functions and go to the `Inspect'
      group. See how the panel display changes.
\item Select the option to get a graphical slice through the image.
\item Sometimes, one has to transfer the attention of the curor
      to the desired window. Naturally you would omit this stage
      if you are using the IKON.
\item Choose the start of the `slice'. Note the cross marking your
      position, and the typing out of the location.
\item Choose the end of the `slice'. Note that the location of
      the slice is drawn.
\item The programme now asks you for the `Y' range of the graph
      to display trhe results. The default is +/- 10 percent
      larger than the actual range of pixel values in the slice.
      We take the default.
\item The programme now has to display the slice. It does this
      using the Starlink graphics system, GKS. It asks for the
      name of the graphics device. We give it `xwindows', the
      graphics name of our workstation. The programme opens up
      a window and displays the graph.
\item We are again able to choose an `Inspect' option. We select
      the one to get us back to the main, `Interact' group of
      functions.
\item We are again able to choose an `Interact' option. We select
      the one to exit from the programme.
\item The graphics system leaves the graphics window displayed.
      We could leave it there, ready for its next use. We choose
      however to delete it. (See the Starlink SUN on GWM for more
      about this.)
\end{enumerate}


}\sstdiytopic{Panel}{
 In the menu-driven mode of this programme, there is the capability
 to interact with this menu in a `windows' type mode. If you choose
 the `Panel' option in the `Option' choice, then if you have a
 workstation (with Xwindows or a Vaxstation with VWS windows or
 Decwindows) a small panel appears on the screen. This has what look
 like buttons with all the available options. You select these by
 putting a cursor on the `button' and then pressing a cursor button.
                                                                               
 The panel has a `help' button which lists out one line
 descriptions of the options. It also has a `command' button which
 gives you access to no useful command in itself, but you can
 then enter the full programme help system.

                                                                               
}\sstdiytopic{Interact Menu}{
  This has two menus, the main, and the XY position getting one.
                                                                               
{\bf \hspace*{4ex} Main }\newline\vspace*{3mm}
\hspace*{4ex}\begin{tabular}{|l|p{4.5in}|}\hline
  Option   &  Function \\ \hline
  Aperture &  Aperture photometry \\
  Area     &  Select area of image to display \\
  Clear    &  Clear display \\
  Close    &  Close display \\
  Colour   &  Change colour Look-up Table \\
  Cross    &  Set position marking cross size \\
  Cvalues  &  Use cursor to get image values \\
  Display  &  Display image as you choose \\
  Exit     &  End program \\
  Flash    &  Display full image at best contrast \\
  Getposns &  Use cursor to get positions, pixel values \\
  Image    &  Get image from file \\
  Inspect  &  Look at an area of image \\
  Open     &  Open display \\
  Panel    &  Switch between panel and keyboard option selection \\
  Plotposns&  Plot table positions \\
  Reset    &  Reset zoom and pan to unity and centre \\
  Scrutiny &  Look at MEASURE output table on image \\
  Zoom     &  Zoom/pan display \\ \hline
\end{tabular}                                                                               
                                                                               
                                                                               
{\bf \hspace*{4ex} XY Positions Getting Menu }\newline\vspace*{3mm}
\hspace*{4ex}\begin{tabular}{|l|p{4.5in}|}\hline
  Option   & Function \\ \hline
  Cvalues   & Use cursor to get image values \\
  Empty   &  Forget all positions \\
  File    &  Put positions into a table \\
  Panel   &  Switch between panel and keyboard option selection \\
  Position & Use cursor to get positions \\
  Remove   & Use cursor to remove positions already marked \\
  Reset    & Reset display pan/zoom to unity/centre \\
  Return   & Return to main options - no storage of posns \\
  Zoom     & Zoom/pan display \\ \hline
\end{tabular}                                                                               
                                                                               
}\sstdiytopic{Aperture Menu}{
\hspace*{4ex}\begin{tabular}{|l|p{4.5in}|}\hline
  Option     &  Function \\ \hline
  Base     &     Change the magnitude zero base point \\
  Centre    &    Toggle centering option:- 
                 Cursor posn/Max pixel/Centroid/Gauss  \\
  Flash      &   Redisplay image \\
  Help       &   List these options \\
  Level      &   Toggle mean/median method for sky level \\
  List       &   List the measures so far \\
  Magnitude  &   A fresh calc for the last star and last sky \\
  Measure    &   Measure star/sky flux via cursor and aperture
                  size and star/sky choice. The star flux in
                  the aperture is found (or sky level in the
                  aperture), and typed. If star, then the star
                  and last sky level (separate or annulus) is
                  taken and the calc done for the magnitude;
                  Mag = 30 + Z - 2.5Log((star-sky level)/Exp) \\
  Method     &   Sky determined from annulus or from separate area \\
  Noise      &   Level of extra noise/pixel in pixel counts \\
  Output     &   Store results in file \\
  Panel      &   Switch between panel and keyboard option selection \\
  Poisson    &   Change the Poisson scaling factor for Error \\
  Remove     &   Remove a circle of a measure from display \\
  Reset      &   Reset zoom/pan to unity and centre \\ \hline
 \end{tabular}

\hspace*{4ex}\begin{tabular}{|l|p{4.5in}|}\hline
  Return     &   Return to main program \\
  Showap     &   Show apertures when getting positions \\
  Size{\undersc}k &       Keyboard change the size of the apertures \\
  Size{\undersc}c &       Cursor change the size of the apertures \\
  Time     &     Change zeropoint by using exposure time,
                  so  delta mag = -2.5*log(exptime) \\
  Zoom      &    Zoom and pan image by using mouse location
                  for pan and buttons for zoom \\ \hline
\end{tabular}                                                                               
                                                                               
}\sstdiytopic{Colour Menu}{
\hspace*{4ex}\begin{tabular}{|l|p{4.5in}|}\hline
  Option      &   Function \\ \hline
  Bar{\undersc}clear   &  Remove display of look-up table bar \\
  Bar{\undersc}display &  Display look-up table bar \\
  Cvalues   &    Look at values using cursor \\
  Ends{\undersc}bw   &    Values below/above LUT as black/white \\
   Ends{\undersc}cc  &     Values below/above LUT as col/col \\
  Ends{\undersc}wb   &    Values below/above LUT as white/black \\
  Ends{\undersc}wrap &    Values below/above LUT as wrapped \\
  Flip      &    Flip LUT \\
  Load      &    Load LUT from store \\
  Paint     &    Pick a colour on LUT bar and paint it along the bar \\
  Panel     &    Toggle panel/keyboard use \\
  Read{\undersc}long  &   Read a full look-up table \\
  Read{\undersc}short &   Read a short LUT into store \\
  Reset     &    Reset zoom/pan to unity and centre \\
  Return    &    Return to main program \\
  Rotate    &    Rotate LUT by moving cursor \\
  Scale     &    Shift and scale LUT by moving cursor \\
  Wrap      &    Toggle between Image values above/below limits 
                 displayed as:- 1) the limits (no wrap)
                                2) wrapped values (wrap) \\
  Write     &    Write a look-up table   \\
  Zoom      &    Zoom and pan image by using mouse location
                  for pan and buttons for zoom \\ \hline
\end{tabular}                                                                               
                                                                               
}\sstdiytopic{Inspect Menu}{
\hspace*{4ex}\begin{tabular}{|l|p{4.5in}|}\hline
  Option   & Function \\ \hline
  Area{\undersc}c  &   Choose new area using cursor \\
  Area{\undersc}k &    Choose new area using keyboard \\
  Blink    &  Blink the presently displayed image with one underneath \\
  Controls &  Type out present control parameters \\
  Cvalues  &  Look at values using cursor \\
  Display  &  Display image \\
  Flash    &  Display image at max contrast \\
  Gclose   &  Close (PGPLOT) graph window on device (maybe hardcopy) \\
  Gdisplay &  Display (PGPLOT) image area to device (maybe hardcopy) \\
  Gcontour &  Contour (PGPLOT) image area to device (maybe hardcopy) \\
  Gsolid   &  Display (PGPLOT) solid body plot - hidden lines \\
  Gsolid{\undersc}p &  Display (PGPLOT) solid body plot - pixel celled \\
  Gsolid{\undersc}t &   Display (PGPLOT) solid body plot - transparent \\
  Header     & Type out a selected image keyword \\
  Histogram & Display area histogram \\
  Image    &  Get new image \\ \hline
\end{tabular}

\hspace*{4ex}\begin{tabular}{|l|p{4.5in}|}\hline
  Panel    &  Switch between keyboard and panel option choice \\
  Pvalues  &  Type out the look area values as a picture \\
  Radius   &  Get Gaussian radius and other details of star \\
  Return   &  Return to main program \\
  Reset    &  Put zoom and pan of dispay to unity \\
  Slice    &  Plot a slice across the image \\
  Stats    &  Calculate areas mean  std dev max min \\
  Steps    &  Change sampling steps in Areas \\
  Typeform &  Change format of typing out of values in area \\
  Values   &  Type out the values in the area \\
  Zoom     &  Zoom/pan display \\ \hline
\end{tabular}                                                                               
                                                                               
}\sstdiytopic{Scrutiny Menu}{
      No display device needed:-
                                                                               
\hspace*{4ex}\begin{tabular}{|l|p{4.5in}|}\hline
  Option   & Function \\ \hline
  Full     &  Type out all of a star fit (from number/name) \\
  Image    &  Load a new image (discard the old one) \\ 
  List     &  Load a new star table (discard the old one) \\
  Lselect  &  Select a list portion by number or area \\
  Profile  &  Load a new star profile (discard the old one) \\
  Printlist&  Put a neat summary of the fits into an ascii file \\
  Return   &  Return to main part of program \\ 
  Typelist &  Put a neat summary of the fits onto the terminal\\ 
  Writenew &  Write to file the -Add- used (extra,removed) list \\ \hline
\end{tabular}                                                                               
                                                                               
     Display device needed:-
                                                                               
\hspace*{4ex}\begin{tabular}{|l|p{4.5in}|}\hline
  Option   & Function \\ \hline
  Blink     & Blink the presently displayed image with one underneath \\
  Clear     & Clear the display \\
  Cvalues   & Use cursor to get image values \\
  Display   & Display the loaded image on the main display frame \\
  Hiden     & Hide the dots marking the star list new posns \\
  Hideo     & Hide the dots marking the star list old posns \\
  Idisplay  & Display the loaded image on chosen display frame \\
  Lookclist & -Looklist- for next list star with a distant comp \\
  Looklist  & Show posn of a star and those stars done in its fit \\
  Nearest   & Give nearest list star to cursor position \\
  Oclear    & Clear all the overlay planes (the dots and lines) \\
  Panel     & Switch between panel and keyboard option selection \\
  Remove    & Display the box round a list star with it removed \\
  Replace   & Replace the -Remove- box by the original image data \\
  Reremove  & Display the -Remove- box again \\
  Reset     & Clear the complete display ( image and graphics) \\
  Ring      & Place a ring outside the -Remove- box \\
  Shnposn   & Display list star posns (red=fitted,green=failed) \\
  Shoposn   & Display the input (old) list star posns \\
  Stars{\undersc}add &  Use cursor to add stars to star list \\
  Stars{\undersc}rem &  Use cursor to remove stars from star list \\
  Uncover  &  Reveal any - hidden overlay display \\
  Zoom     &  Pan/zoom the display \\ \hline
\end{tabular}                                                                               
                                                                               
}\sstdiytopic{Functions}{
\begin{tabular}{|c|l|}\hline 
     Group    &    Function \\ \hline
     Interact &    Image input, display, table XY positions display/get \\
     Aperture &    Aperture photometry in an interactive way \\
     Colour   &    Changing the colour LUT of the image display \\
     Inspect  &    Look at pixel values in different ways \\
     Scrutiny &    Look at the output of Starman:Measure \\ \hline
\end{tabular}                                                                 
                                                                               
}\sstdiytopic{Aperture Function}{
  The 'Aperture' function is for doing interactive aperture photometry.
                                                                               
  There are two basic modes, both of which use a star aperture, moveable
  by the users with the mouse/cursor, one of which determines the sky
  value, to be subtracted from the star aperture counts, from the
  pixels in an annulus around the star aperture, and one which
  determines the sky from a seperate sky aperture (which must have
  previously been used to measure the sky).
                                                                               
  In both modes, repeated measurements can be done. For the
  `non-annulus' mode, when a sky level is determined, that level is
  used for all subsequent star measures, until a new sky level
  aperture location is chosen and a sky measure made.
                                                                               
   The result is calculated as:-
                                                                               
   $$ Output{\hspace{0.3em}}magnitude = 30.0 + `Zero{\hspace{0.3em}}point' - 2.5*log_{10}[\frac{Star{\hspace{0.3em}}flux}{Exposure{\hspace{0.3em}}time}] $$
                                                                               
   With
                                                                               

$$ {\hspace*{-2em}}     1) {\hspace*{3em}}   Sky{\hspace{0.3em}}flux  = \frac{Flux{\hspace{0.3em}}in{\hspace{0.3em}}sky{\hspace{0.3em}}aperture}{area{\hspace{0.3em}}of{\hspace{0.3em}}sky{\hspace{0.3em}}aperture} $$

$$   Or {\hspace*{2em}}   2) {\hspace*{3em}} Sky{\hspace{0.3em}}flux  = Median{\hspace{0.3em}}pixel{\hspace{0.3em}}value{\hspace{0.3em}}in{\hspace{0.3em}}sky{\hspace{0.3em}}aperture  $$
                                                                               
   When making a star measure, the aperture can be centered on the star.
   The default method is to have no centering, but just to take the
   cursor position. A more accurate way is to fit a Gaussian to the
   star aperture data and centre on the centre of the Gaussian.
                                                                               
   There is an option, ('CENTRE'), which changes the method of
   centering on a star before measuring. By toggling through 'CENTRE',
   you can choose one of the four ways:-
                               
\hspace*{4ex}\begin{tabular}{|c|l|}  \hline
    Option    &  Action \\ \hline
    None      &  No centering \\
    Max Pixel &  Centre on the pixel with maximum value in star aperture \\
    Centroid  &  Centre on the centroid of the pixel values in star aperture \\
    Gauss    &   Fit a Gaussian to the star aperture pixels \\ \hline
\end{tabular}
                                                                               
   With the 'Gauss' mode, one can set the Gauss radii to be fixed or
   floating.
                                                                               
   The whole subject of aperture photometry is not as simple as
   it looks at first appearence. It is recommended that the
   inexperienced user should read a book on astronomical photometry
   if she wishes to understand the problems and possibilities fully.
                                                                               
   Some examples of this:-

\begin{enumerate}
                                                                               
\item The use of the `median' mode in determining the sky level
      inside the sky aperture is better than using the `mean'
      mode, as this rejects against stars better? No! The main
      problem in aperture photometry is the presence of field stars
      in the star and sky apertures. If you reject strongly against
      the faint (ones you cant see by eye) stars in the sky
      aperture by using the `median', then the similar faint stars
      in the star aperture will not be balanced by those in the
      sky aperture, and the star will be measured too bright.
                                                                               
\item In choosing a location for the sky aperture, one should
      choose a place that is entirely free from field star? No!
      Again, such a place might be too free, compared to the star
      aperture location, and the star might be measured too bright.
                                                                               
\item When measuring a very faint star on a number of exposures,
      then when the flux in the star aperture is less than the
      sky level, so that one gets a negative flux, those exposures
      should be ingnored? No! You must average everything together.
                                                                               
\item When comparing a bright star and a faint star, it is better
      to use a smaller aperture on the faint star to cut down the
      sky noise? No! The profile of the bright and faint stars are
      the same, and thus using a smaller aperture on the faint
      star will cut out a greater fraction of the light of the
      faint star compared to the bright one.
                                                                               
\item When comparing stars in different exposures, one can use
      different size apertures? No! For the same reason as for 4).
                                                                               
\item When comparing stars in different exposures, one can use
      the same size apertures as when doing a single exposure?
      No! As the seeing will have varied between the different
      exposures, then the apertures must be large ones, so that
      the effect of the variable seeing does not cause a
      significantly diffrent amount of light to be lost out of
      the apertures in the different exposures. Typically apertures
      less than 10 or 20 arcsec diameter will lead to bad photometry.
\end{enumerate}      
                                                                         
}\sstdiytopic{Function{\undersc}colour}{
  There is an option to show the form of the Look{\undersc}Up{\undersc}Table. A
  bar can be painted across the bottom of the screen, containing
  from left to right the colours associated with the displays cells
  from 1 to 150, which are used to code the image values to display
  the image.
                                                                               
  This bar can be displayed or not at will. One problem may be that
  with those displays with a built in hardware zoom, the bar is painted
  across the bottom of the screen as it is shows when the pan/zoom are
  at unity. Then if the pan/zoom have been used, that `bottom' may no
  longer be visible on the actual screen. In this case, just `reset'
  the pan/zoom to unity to see it.
                                                                               
     NO DETAILED HELP AVAILABLE YET ON THIS FUNCTION - SEE THE
     MENU FOR THIS FUNCTION TO SEE THE OPTIONS
                                                                               
}\sstdiytopic{Function{\undersc}inspect}{
     NO DETAILED HELP AVAILABLE YET ON THIS FUNCTION - SEE THE
     MENU FOR THIS FUNCTION TO SEE THE OPTIONS
                                                                               
}\sstdiytopic{Function{\undersc}interact}{
     NO DETAILED HELP AVAILABLE YET ON THIS FUNCTION - SEE THE
     MENU FOR THIS FUNCTION TO SEE THE OPTIONS
                                                                               
}\sstdiytopic{Function{\undersc}scrutiny}{
     NO DETAILED HELP AVAILABLE YET ON THIS FUNCTION - SEE THE
     MENU FOR THIS FUNCTION TO SEE THE OPTIONS
                                                                               
}\sstdiytopic{Buttons}{
  This section deals with the use of the mouse buttons. It is
  assumed that three buttons are present.
                                                                               
  There are two general, major uses for the buttons, for the
  `Zoom' mode and the `Cvalues' mode:-
                                                                               
  For workstation use, the Cursor must be in image window area
  for the cursor buttons to work when in 'WORKING' mode. The window
  also must be 'active' - that is the bar at the top must be set.
  Click on this bar if it is not before using the buttons.
                                                                               
{\bf \hspace*{4ex}      Buttons for Zoom/Pan work:- }

\hspace*{4ex}\begin{tabular}{|c|l|}\hline
Action                         & Effect \\ \hline
Left Button twice              & zoom /2 \\
Centre Button twice            & zoom x2 \\
Left Button then Centre Button & pan \\
Right button once              & return \\ \hline
\end{tabular}
                                                                               
(Zoom means zoom around present position of cursor.) \newline
(Pan means set present position of cursor to screen centre.)
                                                                               
{\bf \hspace*{4ex}      Buttons for Blink work:- }

\hspace*{4ex}\begin{tabular}{|c|c|c|c|}\hline
      Buttons from left:- &   (1)    &       (2)   & (3) \\ \hline
  & slow blink by x2 & speed blink by x2 & switch to hand blink \\ \hline
\end{tabular}
                                                                               
The hand blink is done using the keyboard.
                                                                               
{\bf \hspace*{4ex}      Buttons for Cvalues work:- }

The values are output continuously again on the panel, or by
request on the terminal if the panel is not being used.

\hspace*{4ex}\begin{tabular}{|p{2in}|c|l|} \hline
         Device      &`Panel' mode?  &  Button actions \\ \hline
X-, VWS-, or DECW- windows &  Yes  &          all give return \\
     \hspace*{6ex}        "       &   No       &     Left, Centre give values;
                                        Right gives return \\
       IKON device   &   No        &    Left, Centre give values;
                                        Right gives return \\ \hline
\end{tabular}                                                                               
                                                                               
  There are then separate uses in three of the groups of functions
  that can be done:-
                                                                               
                                                                               
{\bf \hspace*{4ex}      INTERACT }
                                                                               
      The main group:- Image input, display, table XY positions
                       display/get
                                                                               
      In the Table XY position getting mode:-
                                                                               
                                                                               
\hspace*{4ex}\begin{tabular}{|c|c|c|c|}\hline
      Buttons from left:- &   (1)    &       (2)   & (3) \\ \hline
        Position work: &  pick posn   &  go to zoom work & return \\
          Remove work:& remove posn &    go to zoom work & return \\ \hline
\end{tabular}
                                                                               
                                                                               
{\bf \hspace*{4ex}      APERTURE }
                                                                               
       Aperture photometry in an interactive way
                                                                               
\hspace*{4ex}\begin{tabular}{|c|c|c|c|} \hline
      Buttons from left:- &   (1)    &       (2)   & (3) \\ \hline
        Aperture work:  & pick star    &   pick sky  &    return \\
          Remove work: & remove circle &   remove circle & return \\
       Ap change work:  & dec aperture  &  inc aperture  & next aperture/return \\ \hline
\end{tabular}
                                                                               
{\bf \hspace*{4ex}      COLOUR }
                                                                               
How to change the colour LUT of the image display:-
                                                                               
\hspace*{4ex}\begin{tabular}{|c|p{3.5in}|c|} \hline
      Buttons from left:- &   (1)   \hspace*{4ex} (2)   & (3) \\ \hline
       Rotate LUT      &Operate when held down; Move cursor left/right &       
Return \\ \hline
       Scale  LUT  &        Operate when held down;  Move cursor left/right and up/down &    
       Return \\ \hline
\end{tabular}

How to use the `Paint' Function:-

\begin{enumerate}
  \item              Place cursor on displayed LUT bar
  \item                Press left or centre button
  \item                Release
  \item                Place cursor on displayed LUT bar
  \item                Press left or centre button
  \item                Move cursor along LUT bar
  \item                Release button
  \item                Repeat or press right button to return
\end{enumerate}
                                                                        
                                
                                                                               
{\bf \hspace{4ex}     INSPECT }
                                                                               
         Measuring the Gaussian radii of stars
                                                                               
\hspace*{4ex}\begin{tabular}{|c|c|c|c|} \hline
      Buttons from left:- &   (1)   & (2)   & (3) \\ \hline
    & Variable radius & Fixed radius & Return \\ \hline
\end{tabular}
                                                                               
{\bf \hspace{4ex}         SCRUTINY }
                                                                               
     'Stars{\undersc}Add/Rem' options :-

\hspace*{4ex}\begin{tabular}{|c|c|c|} \hline
      Buttons from left:- &   (1) \hspace*{4ex} (2)   & (3) \\ \hline
    & Add/remove star from list & Return to Option Choice \\ \hline
\end{tabular}
                                                                               
}\sstdiytopic{Colour}{
  The standard image display uses a grey-scale display. However, by
  use of the Interact:Colour group of functions, colour displays can
  be made. There are eight standard LUT tables available, and others
  can be read in from files.
                                                                               
  Also the user can adjust the LUT table currently being applied. This
  can be done directly:- `flip' the LUT;Change display of values above
  and below ends of LUT. It can also be done interactively using a
  cursor:- with the use of the display of a colour bar, pick a colour
  with the cursor and `paint' this colour over a range of the LUT; Use
  horizontal movement of the cursor (with a button pressed) to rotate
  the LUT; Use horizontal and vertical movement of the cursor (with a
  button pressed) to shift and scale the LUT.
                                                                               
  The eight standard LUT tables are:-
  
\begin{enumerate}                                                                             
   \item Grey scale
   \item Purple with light at top
   \item Rainbow
   \item Black/blue/green/yellow/purple/white
   \item Black/blue/greeny-yellow/dark red
   \item Black/blue/greeny-yellow/light red/white
   \item Discrete steps (black/blue/green/light blue/red/purple/yellow/
                       white)
   \item Inverted grey scale
\end{enumerate}                                                              
                                                                               
  The LUTs can be output in one format, the `full' format, and input
  in two formats, the `short' and 'full' formats.
                                                                               
  {\bf The `full' format is:-}
                                                                               
  This is a table containing the R,G,B fractional colour contributions
  in columns 1,2,3 of the table (ignoring the 1st 5 for table row
  names - which are not used). There are 150 rows in this table.
  Starting from the first row, there is the R,G,B set for the lowest
  location on the table, carrying onto the 150th row, where there is
  the highest LUT entry.
                                                                               
  There is also a scale `LUTSC', and a zero `LUTZE', in descriptors.
  These scale the LUT. A given entry point, say RV, which is
  bewteen 0.0 and 1.0, would normally go to the R,G,B set of the
  RV*150th row in the input LUT. Where it actually goes is
  the [(RV-LUTZE)/LUTSC]*150th entry. If this entry is below 1 or
  above 150, then the entry is either, set at 1 or 150, or set at
  its modulo 150 value.
                                                                               
  {\bf The `short' format is:-}
                                                                               
  This is a way of making a simple table to input to the program.
                                                                               
  It is a table with 6 rows, and between 3 and 25 columns.
             
\begin{tabular}{|l|c|c|c|c|c|c|} \hline                                                                  
  Each row is allocated to as:- &  1      &2      &3       &4     &5      &6 \\ \hline
                               &  Red &  Red  & Green &  Green&   Blue &  Blue \\
                               & Posn & Value &  Posn &  Value &  Posn & Value \\ \hline
\end{tabular}
                                                                               
  The first column in a row indicated how many columns in that row are
  active, excluding itself.
                                                                               
  This is then converted into the LUT by:-
                                                                               
  Taking the proportion for each colour at a step in the LUT. This
     is done by moving along the `Colour Posn' row until one reaches
     the point that the step in the LUT table is. Thus if the step is
     number 59 out of 150 steps, then its location is 0.252. In the
     example below, this for red would be just after the 2nd (0.25)
     Posn.

   Calculating the corresponding `Colour Value'. In the example below,
     this would be between the 2nd and 3rd values, so the Red fraction
     would be :-

$$     Fraction = [2nd value] + [3rd-2nd values]*[fraction of step to 3rd `Colour Position'] $$

in this case
$$     Fraction = 0.00 + (1.0-0.0)*(\frac{0.252-0.25}{0.5-0.25}) $$
                                                                               
  An example of this is the `short' LUT used for the `rainbow' LUT, no 3
  above. It is:-

\begin{tabular}{ccccccc}                                                                               
     4.0& 0.0& 0.25&  0.5&  1.0&  0.0& 0.0 \\
     4.0& 0.0& 0.00&  1.0&  1.0&  0.0& 0.0 \\
     6.0& 0.0& 0.125& 0.5& 0.64& 0.77& 1.0 \\
     6.0& 0.0& 0.000& 1.0& 0.50& 0.00& 0.0 \\
     5.0& 0.0& 0.25&  0.5& 0.77&  1.0& 0.0 \\
     5.0& 0.0& 1.00&  0.0& 0.00&  1.0& 0.0 \\
\end{tabular}
                                                                               
}\sstdiytopic{Cursor}{
 The cursor is used to pick up positions, change the zoom, and other
 miscellaneous purposes.
                                                                               
 The tracker ball moves the cursor. It is assumed that a 3 button
 cursor is used. The cursor buttons are worked like this:-
             
   General position marking:- \hspace*{6ex} Press any button \\ 
                                                                               
   Zoom work:- \hspace*{6ex}\begin{tabular}{|l|l|}\hline
                               Button & Action \\ \hline
                               Left twice &             zoom /2 \\
                              Centre twice &            zoom x2 \\
                              Left then Centre &  pan \\
                              Right once             & return \\ \hline
                              \end{tabular}
                                                                               
  Zoom means zoom about present position of cursor. \newline
  Pan means set present position to screen centre.
                                                                               
  For workstation use, the Cursor must be in image window area
  for the cursor buttons to work when in 'WORKING' mode. The window
  also must be 'active' - that is the bar at the top must be set.
  Click on this bar if it is not before using the buttons.
                                                                               
  If the cursor is outside a displayed area, often pressing the button
  will result in no actions.
                                                                               
  For many of the groups of functions, then when a cursor is being
  used, the X,Y position and image pixel value are continuously
  displayed on the `panel', if the panel mode is being used.
                                                                               
  There is in some of the groups, an option for selecting this
  monitoring mode specifically, by selecting the `Cvalues' option.
  Then the values are output continuously again on the panel, or by
  request on the terminal if the panel is not being used.
  When the panel is not being used, then the monitoring output is only
  by request.
                                                                               
   Buttons for `Cvalues' work:-

\hspace*{4ex}\begin{tabular}{|p{2in}|c|l|} \hline
         Device      &`Panel' mode?  &  Button actions \\ \hline
      X-, VWS-, or DECW- windows &  
                                      Yes  &          all give return \\
       \hspace*{6ex} "       &   No       &     Left Centre give values;
                                        Right returns \\
       IKON device   &   No        &    Left, Centre give values;
                                        Right gives return \\ \hline
\end{tabular}                                              

                                                                               
  `Interact-Getting Positions' work:-

\hspace*{4ex}\begin{tabular}{|c|c|c|c|}\hline
  Buttons from left:-   & (1)      &     (2)    & (3) \\ \hline
   Position work: &  pick posn &    go to zoom work & return \\ 
     Remove work: &remove posn &    go to zoom work & return \\ \hline
\end{tabular}
                                                                               
  `Interact-Colour' work:-
                                                                               
       Paint Function Use:-

\begin{enumerate}
\item    Place cursor on displayed LUT bar
\item    Press left or centre button
\item    Release
\item    Place cursor on displayed LUT bar
\item    Press left or centre button
\item    Move cursor along LUT bar
\item    Release button
\item    Repeat or press right button to return
\end{enumerate}
                                                                               
\hspace*{4ex}\begin{tabular}{|c|p{3in}|c|}\hline
  Buttons from left:-   & (1)      \hspace{6ex}  (2) &       (3) \\ \hline
       Rotate LUT       &   Operate when held down; Move cursor left/right   &   
Return \\
       Scale  LUT      &    Operate when held down; Move cursor left/right and up/down 
                                                    &      Return \\ \hline
\end{tabular}                             
                                
                                                                               
 `Inspect{\undersc}Radius' work:-
                                                                               
\hspace*{4ex}\begin{tabular}{|c|c|c|c|}\hline
  Buttons from left:-   & (1)      & (2) &       (3) \\ \hline
   &                      Variable radius   & Fixed radius    & Return \\ \hline
\end{tabular}                                                                               

  `Scrutiny{\undersc}Stars{\undersc}Add/Rem' work:-
                                                                               
\hspace*{4ex}\begin{tabular}{|c|c|c|}\hline
  Buttons from left:-   & (1)  \hspace*{6ex} (2) &       (3) \\ \hline
     & Add/remove star from list & Return to Option Choice \\ \hline
\end{tabular}
                                                                               
}\sstdiytopic{Display}{
  IMAGE DISPLAY
                                                                               
  The programme puts out the images for the display on two
  main types of image displays, DEC workstation DECW and VWS window
  devices, and IKON devices.
                                                                               
  The VWS option needs an eight-plane device, preferably colour.
  The programme generates its own `overlay' type plane.
                                                                               
  There is also the option to use PGPLOT to do one single image
  output to a device with a GKS driver. This is to output a
  grey-scale picture of an area of the image. This has the use
  that hard copies can be made, and unusal devices utilised to
  look at the image.
                                                                               
  GRAPHICAL DISPLAY
                                                                               
  In the programme, there are many different types of graphical
  plotting. These are usually PGPLOT driven via GKS to any
  device that has a GKS driver.
                                                                               
  There are also some NAG driven outputs (again to GKS devices),
  whose availability may be limited by the absence of the
  commercial NAG package.
                                                                               
}\sstdiytopic{Input}{
  The input files needed by this programme are:
                                                                               
\begin{tabular}{|c|c|p{3in}|}\hline 
   Group      & Parameter &    Contents \\ \hline
   General   &  `IN'      &   The input image \\
   Colour    &  `INLUT'   &   Table of Starman:Interact Look-Up Table -
                             either in `short' or `full' format. \\
   Interact  &  `INTAB'   &   Table of X,Y positions for plotting \\
   Scrutiny  &  `INSTARS' &   Table of the Output of Starman:Measure \\
   Scrutiny   & `PROFILE' &   Image with profile parameters and profile
                             map in the normal Starman `Profile' image \\ \hline
\end{tabular}
                                                                               
   Tables are in the normal Starman real image .BDF format.
                                                                               
   To look more closely for:-

\begin{tabular}{ll}
      `INLUT'   &  - see the output:colour for Starman:Interact \\
      `INSTARS' &  - see the output for Starman:Measure \\
      `PROFILE' &  - see the output for Starman:Profile \\
\end{tabular}
                                                                               
                                                                               
}\sstdiytopic{Output}{
  There can be output from this programme. If there is, it is in the
  form of one or more tables:-

\hspace*{4ex}\begin{tabular}{|l|l|l|}\hline
  Function &   Parameter  &  Table Contents \\ \hline
  Aperture&  `OUT'      &  Results of aperture photometry \\
  Colour  &  `OUTLUT'   &  New colour Look-up Table \\
  Interact & `OUTTAB'   &  X,Y Pixel value tables from cursor \\
  Scrutiny & `OUTSTARS' &  Starman:Measure results table with `extra'
                           stars \\
  Scrutiny & `OUTFILE' &   Text file with a formatted selection of input
                           Starman:Measure table \\ \hline
\end{tabular}                                                                               
                                                                               
  
   The tables are in the normal Starman/EDRS real image .BDF file format.
                                                                               
}\sstdiytopic{Aperture Output}{
  The `Aperture' output, `OUT', is a table of the aperture photometry
  results.
                                                                               
  It is has contents:-  (it may only have the name,X,Y,Magnitude
  columns)
                                
\begin{tabular}{|l|p{3in}|}\hline                                               
   Table Column Header & Contents \\ \hline
   Name               &	Star name \\
   X 			& Star X position \\
   Y			& Star Y position \\
   Magnitude		& Star magnitude (see below) \\
   Error		& Estimate of std dev error in star magnitude \\
   Flux			& Flux (above sky) in star aperture \\
   Flux error		& Estimate of std dev error in star flux \\
   Max Value 		& Maximum pixel value in star aperture area \\
   Area 		& Area of star aperture (Straddles pixels) \\
   No Bad Pixels 	& No of `bad' pixels in star aperture \\
   Total Flux		& Total flux in star aperture \\
   Sky level 		& Sky level used for star magnitude \\
   Sky flux 		& Total flux in sky aperture used for sky level \\
   No sky bad pixels	& Number of `bad' pixels in sky aperture area \\
   Sky area 		& Area of sky aperture (Straddles pixels) \\
   Sky X 		& X position of sky aperture \\
   Sky Y  		& Y position of sky aperture \\
   Star ap dia 		& Star aperture diameter \\
   Sky ap dia 		& Sky aperture diameter \\
   Sky inner annulus diameter   & If sky area is annulus, inner diameter of annulus \\
   Sky outer annulus diameter  &  If sky area is annulus, outer diameter of annulus \\
   Annulus flag 	& Sky area circle (0.0), or annulus around star(1.0)? \\
   Centering flag 	& Star position been:- `none' `max' `pixel' 
                          `centroid' `Gauss' method -- (1/2/3/4) -- centered \\
   Median flag 		& Sky level taken as mean (0.0), or median (1.0)? \\
   Extra noise 		& Extra noise level assumed per pixel \\
   Events/pixel values 	& Square roor[Flux*(this)] = effective Poisson noise \\
   Exp time 		& Exposure time \\
   Zero point		& Zero point applied to output mag \\ \hline
\end{tabular}
                                                                               
                                                                               
   Where:-
                                                                               
   $$ Output{\hspace{0.3em}}magnitude = 30.0 + `Zero{\hspace{0.3em}}point' - 2.5*log_{10}[\frac{Star{\hspace{0.3em}}flux}{Exposure{\hspace{0.3em}}time}] $$
                                                                               
$$   Star{\hspace{0.3em}}flux = Flux{\hspace{0.3em}}in{\hspace{0.3em}}star{\hspace{0.3em}}aperture -               (Sky{\hspace{0.3em}}level)*(Star{\hspace{0.3em}}ap{\hspace{0.3em}}area) $$

$$ {\hspace*{-2em}}     1) {\hspace*{3em}}   Sky{\hspace{0.3em}}flux  = \frac{Flux{\hspace{0.3em}}in{\hspace{0.3em}}sky{\hspace{0.3em}}aperture}{area{\hspace{0.3em}}of{\hspace{0.3em}}sky{\hspace{0.3em}}aperture} $$

$$   Or {\hspace*{2em}}   2) {\hspace*{3em}} Sky{\hspace{0.3em}}flux  = Median{\hspace{0.3em}}pixel{\hspace{0.3em}}value{\hspace{0.3em}}in{\hspace{0.3em}}sky{\hspace{0.3em}}aperture  $$
                                                                               
   In the annulus work, the sky area is taken as that between the
   sky annulus inner ring and the sky annulus outer ring.
   In non-annulus work, the sky aperture is a simple circle, placed
   as specified.
                                                                               
   `Bad pixels' are ignored. Thus in the sky estimates this should
   not make much trouble, but in the Star estimates it will if the
   relevant pixel has a value above the sky level.
                                                                               
   The apertures have `smooth' edges. The circle that gives the
   edge of the aperture will fall `through' the body of some of the
   pixels at the edge of the aperture. What happens then is that these
   `edge' pixels are subdivided into a 5x5 subarray, and each sub-pixel
   is looked at to see if it is in or out of the aperture. The area of
   the pixel, for the programme purposes, is then (number/25.0). The
   flux in the pixel is then scaled down to the same extent.
                                                                               
   Errors:-
                                                                               
   The errors are calculated assuming that the pixel values are due
   to a source with Poisson noise (which has suffered scaling) and
   an extra `magic' source of noise (with zero effect on the mean
   pixel value).

   Thus the pixel variance = Flux*(`Poiss' value) +
                          (no of pixels)*(`Noise' value)*(`Noise' value)
                                                                               
   [Std dev = square root(variance)]
                                                                               
   The star error is then calculated assuming that noise in the star
   flux, and noise due to the error in calculating the sky level.
                                                                               
}\sstdiytopic{Colour Output}{
  The output of the Interact:Colour group, `OUTLUT', is a file
  containing a table describing the Colour Look-Up Table made in the
  group.
                                                                               
  This is a table containing the R,G,B fractional colour contributions
  in columns 1,2,3 of the table (ignoring the 1st 5 for table row
  names - which are not used). There are 150 rows in this table.
  Starting from the first row, there is the R,G,B set for the lowest
  location on the table, carrying onto the 150th row, where there is
  the highest LUT entry.
                                                                               
  There is also a scale `LUTSC', and a zero `LUTZE', in descriptors.
  These scale the LUT. A given entry point, say RV, which is
  bewteen 0.0 and 1.0, would normally go to the R,G,B set of the
  RV*150th row in the input LUT. Where it actually goes is
  the [(RV-LUTZE)/LUTSC]*150th entry. If this entry is below 1 or
  above 150, then the entry is either, set at 1 or 150, or set at
  its modulo 150 value.
                                                                               
}\sstdiytopic{Interact Output}{
  The output of the Interact:Interact group, `OUTTAB', is a file
  containing a table of the X,Y positions and pixel values of the
  locations chosen by the cursor.
                                                                               
}\sstdiytopic{Scrutiny Output}{
  One output of the Interact:Scrutiny group, `OUTSTARS', is a file
  containing a table in the format of the Starman:Measure programme,
  of that input Starman:measure table, but with (optionally) some stars
  removed, and (optionally) some extra stars added. These extra stars
  are picked up in the Interact:Scrutiny group of functions
                                                                               
  The other output, `OUTFILE', is a text file containing a selection
  of the input Starman:Measure table of fitted results. The user
  selects the option to `print' the table in a defined format to
  this file. The file is a normal ASCII text file
                                                                               
}\sstparameters{
 
\vspace*{3mm}

\sstsubsection{\large \bf Introduction:- }{
                                                                              
  The parameters are split into groups in this manual - a general one for
  parameters which are used by more than one of the programme
  groups, and then a group for each of the five programme groups themselves.
                                                                               
\begin{tabular}{|c|l|}\hline 
     Group    &    Function \\ \hline
     Interact &    Image input, display, table XY positions display/get \\
     Aperture &    Aperture photometry in an interactive way \\
     Colour   &    Changing the colour LUT of the image display \\
     Inspect  &    Look at pixel values in different ways \\
     Scrutiny &    Look at the output of Starman:Measure \\ \hline
\end{tabular}                        

\hspace*{3mm}                                         
                                                                               
}\sstsubsection{\large \bf General:- }{
                                                                               
  The parameters that are used by more than one programme group.
                

}\sstsubsection{COMMAND = LITERAL (Read)}{
  (Default - `no'     \hspace{6ex}       Choice - `yes:no')

  This is used when using the `panel' instruction input. It has no
  function other than to permit use of the full help system by
  responding `?' or `??', and to permit use of the `dropping through'
  to the operating system by use of the `\$' symbol before a normal
  DCL instruction, e.g. `\$ DIRECTORY/SIZE'.

  After you have used the help, then just reply `no' with a `return'
  key entry.
                                                                               
}\sstsubsection{DSTYPE  = LITERAL (Read)}{
 (Default - `decw' \hspace{6ex}     Choice - `ikon:none:vws:decw')

  Type of display to be used:-

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Ikon    &    IKON image display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question, 
  in a different way. A response here of `?' will bring up a listing 
  of all the possible names of graphics devices which are supported 
  on your machine, and you then input the appropriate name.

}\sstsubsection{IDINAME = LITERAL (Read)}{
 (Default - `ikon'      \hspace{6ex}       Choice - any)
    
   The local name defining the display device. The list of names
   call be seen in the file with the logical name `GNS\_IDINAMES'.
   Remember that the case of the letters matters.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
 The name of the file containing the input 2-D image.
                                                                               
 A null `return' entry is not allowed at the very start of the
 programme. Later on, it may be, in which case the programme
 will continue. Sometimes four repeated 'null' entries will be
 needed to get to this continue.
                                                                               
 This image must be in the standard DSCL .BDF 16-bit interger*2
 format.
                                                                               
}\sstsubsection{IMPOSN = {\undersc}INTEGER(2) (Read)}{
  (Default - so as to centre image in screen    \hspace{6ex}    
   Range -  -100000 to 100000)
                                                                               
  Place to put b.l.h. corner of displayed image onto the
  screen. Thus an answer of `1,1' would put the b.l.h. pixel
  of the displayed image at the b.l.h corner of the screen.
                                                                               
}\sstsubsection{MORE = LITERAL (Read)}{
  (Default - `yes'      \hspace{6ex}       Choice - `yes:no')
                                                                               
  Do you want more of the menu of options for this action?
                                                                               
}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the Starman programmes use all three, with
  the right-hand button being used mainly as the `exit' button. 

  With two buttons, then the third button is simulated by pressing 
  both of the buttons down, with the middle one being pressed slightly 
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will 
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{PLANE = {\undersc}INTEGER (Read)}{
  (Default - see below              \hspace{6ex}    Range - -1 to 2)
                                                                               
  Controls the blinking of the displayed image.
                                                                               
  For Vax VWS and DECwindows displays, the blinking is done by
  alternately pushing the displayed image behind any other display and
  poping it in front. If there is another image displayed by another
  program at the same display location, then the two images will blink.
                                                                               
  The options of 'PLANE' are:-
                                          
\hspace*{4ex}\begin{tabular}{|c|l|}\hline
  Value &   Function \\ \hline
   -1   &    Exit from blinking \\
    0   &    Do automatic blinking \\
    1   &    Push displayed image behind \\ 
    2   &    Pop  displayed image in front \\ \hline
\end{tabular}
                                                                       
  In automatic blinking, then the displayed image is alternately
  'popped' and 'pushed'. The time interval starts of at 1/2 second,
  and is lengthed or shortened by pressing keys on the mouse.

  The keys have the functions:-

\hspace*{4ex}\begin{tabular}{|c|c|c|c|}\hline
      Buttons from left:- &   (1)    &       (2)   & (3) \\ \hline
  & slow blink by x2 & speed blink by x2 & switch to hand blink \\ \hline
\end{tabular}
                                                                               
The hand blink is done using the keyboard.
                                                                               

}\sstsubsection{PDSTYPE = LITERAL (Read)}{
 (Default - `decw'      \hspace{6ex}    Choice - `none:vws:decw')

  Image display device to put windows-type `panel' of options
  up on.

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}

}\sstsubsection{SCREEN = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, size of image      \hspace{6ex} Range - 1 to large)

  Size of screen or window to open. 

  The default size is that of the image, unless the image is too large
  to fit on the screen, when the image will be binned down by an integer
  factor for display. The default size will then be this binned down size.

}\sstsubsection{STORE = (Read)}{
  (Default - `yes'      \hspace{6ex}       Choice - `yes:no')
                                                                               
  After you have been in the getting information mode, and want
  to get back to the main `Interact' mode, the programme checks
  whether you have written out the information to a file. If your
  have not, it then gives you another chance to do so.
                                                                               
  This is used by Interact:Getposns when getting X,Y positions, and
  by Interact:Aperture when getting aperture photometry results.
                                                                               
  Thus:-

\begin{tabular}{|c|l|}\hline
   Response &  Action \\ \hline
    'Yes'    & Given chance to write to a new file, then go back to
                'Interact' \\
    'No'     & Carry on, go back to 'Interact' \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{TITLE = (Read)}{
  (Default - various            \hspace{6ex}    Choice - any character string)
                                                                               
  The title to put into the `TITLE' descriptor of the output
  file you are making at the moment. This deals with the output files
  accessed through the `OUT', `OUTLUT', `OUTTAB', `OUTSTARS' parameters
  (see the `Output' sections above).
                   
}\sstsubsection{VRANGE = \_REAL(2) (Read)}{
 (Default - suggested values  \hspace{6ex}  Range - -1.0e10 to 1.0e10)

 The range of values to be displayed as black to white on image display
 display.

                                                            
  The display of pixel values above and below these limits is
  controlled by the value of the `wrap' parameter. They are shown
  as either:-

  \begin{list}{{-}}{}
     \item Black below and white above
     \item Modulo the `Vrange' display range
\end{list}
                
}\sstsubsection{WRAP = LITERAL (Read)}{
  (Default - `no'        \hspace{4ex}    Choice - `yes/no')

 When displaying image on image display, for those image pixel values that
 lie above or below the display values for white or black, do you want 
 these values to be shown as white or black (`no'), or do you want them to
 be `wrapped' round - that is considered as modulo the display range 
 (`yes')?

\vspace*{3mm}
                                                                               
}\sstsubsection{ \large \bf Interact}{
                                                                               
  The parameters that are used by the `Interact' programme group.
                                                                               
}\sstsubsection{CRCOL = LITERAL (Read)}{
  (Default - 'Blue'           \hspace{6ex}    Choices - see below)
                                                                               
  Colour of crosses to paint up either when marking new or old
  X,Y positions, or when marking up positions from the input
  `INTAB' table.
                                                                               
  Choice is:- red:green:blue:cyan:magenta:yellow:coral:palegreen
                                                                               
}\sstsubsection{CROSSL = {\undersc}REAL (Read)}{
  (Default - Present value, start=3.0           \hspace{6ex}    Range - 1.0 to 1.0e8)
                                                                               
  Length in pixels, of cross arms (from side to side) of the
  crosses written up marking old or new X,Y positions.
                                                                               
}\sstsubsection{GOPTION = LITERAL (Read)}{
  (Default - present value, start=''       \hspace{6ex}    Choices - see below)
                                                                               
  What operation, from a menu of possible choices, to do next?
                                                                               
  The menu selection of options for getting X,Y positions from the
  display. You repeatedly come back to this parameter after
  performing `Getting Position' operations. You select one of the
  menu operations. You return to the main `Interact' group by entering
  the `return' option.
                                  
  The functions are listed at the start of this section.
                                                                               
  For workstation use, the Cursor must be in image window area
  for the cursor buttons to work when in 'WORKING' mode. The window
  also must be 'active' - that is the bar at the top must be set.
  Click on this bar if it is not before using the buttons.

  The uses of the buttons are listed at the start of this section.

}\sstsubsection{INTAB = BDF (Read)}{
  (Default = null)
                                                   
  Name of the existing file with the input table of X,Y positions to
  plot on the display.
                                                                               
}\sstsubsection{XRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, X size if image         \hspace{6ex}    Range - 1 to X size of image)
                                                                               
  X limits of area of input image to use.
                                                                               
}\sstsubsection{YRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, Y size if image         \hspace{6ex}    Range - 1 to Y size of image)
                                                                               
  Y limits of area of input image to use.
                                                                               
}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - present value, start=see below       \hspace{6ex}    Choices - see below)
                                                                               
 What operation, from a menu of possible choices, to do next?
                                                                               
 It is the general option choice, which you repeatedly come back to,
 after performing operations. You select one of the menu operations.
                                                                               
 When you started the programme, you were asked for the input image and
 input star table. Then you started on this option choice. Generally the
 default option is a repeat of the last option. However at the start,
 a standard set of options is given as the default.

 The list of functions is given at the start of this section. 
                                                                               
  For workstation use, the Cursor must be in image window area
  for the cursor buttons to work when in 'WORKING' mode. The window
  also must be 'active' - that is the bar at the top must be set.
  Click on this bar if it is not before using the buttons.
                                                                               
 The uses of the buttons are given at the start of this section.
                                                                               
}\sstsubsection{OUTTAB = BDF (Write)}{
  (Default - null)
                                            
  Name of the new file to load with the output table of X,Y positions
  that have been obtained from the display.

\vspace*{3mm}
                                                                               
}\sstsubsection{ \large APERTURE:- }{
                                                                               
  The parameters that are used by the `Aperture' programme group.
                                                                               
}\sstsubsection{APDIAM = {\undersc}REAL (Read)}{
  (Default - present value, start=see below          \hspace{6ex}    Range - 0.0 to 1.0e8)
                                                                               
  The diameter in pixels of the apertures used in the measuring.
                                                                               
  These are :-   

  \begin{list}{{-}}{}
  \item the star aperture diameter   (start=20.0)
  \item               the sky aperture diameter for non-annulus work
                                              (start=20.0)
   \item              the sky aperture inner diameter for annulus work
                                              (start=30.0)
  \item               the sky aperture outer diameter for annulus work
                                              (start=40.0)
  \end{list}
                                                                               
  In the annulus work, the sky area is taken as that between the sky
  inner annulus ring and the sky outer annulus ring.
  In non-annulus work, the sky aperture is a simple circle, placed
  as specified.
                                                                               
}\sstsubsection{AOPTION = LITERAL (Read)}{
  (Default - present value, start='size{\undersc}c'       \hspace{6ex}      Choices - see below)
                                                                               
 What operation, from a menu of possible choices, to do next?
                                                                               
 It is the Aperture Photometry option choice, which you repeatedly come
 back to, after performing operations. You select one of the menu
 operations. You return to the main `Interact' option list by
 entering the `return' key.
                                                                               
 Generally the default option is a repeat of the last option. However
 at the start of doing `Aperture', the default is `Size{\undersc}c'.
                                                                               

 The list of functions is given at the start of this section. 
                                                                               
  For workstation use, the Cursor must be in image window area
  for the cursor buttons to work when in 'WORKING' mode. The window
  also must be 'active' - that is the bar at the top must be set.
  Click on this bar if it is not before using the buttons.
                                                                               
 The uses of the buttons are given at the start of this section.
                                                                               
}\sstsubsection{EXPTIM = {\undersc}REAL (Read)}{
  (Default - present value, start=1.0              \hspace{6ex}    Range - 1.0e-8 to 1.0e8)
                                                                               
  The exposure time of the image. This is applied to the output
  magnitude. It applies a correction of -2.5*log  (Exptim), and
                                                10
  thus the starting exposure time of 1 second applies a zero
  correction.
                                                                               
}\sstsubsection{FIXGRAD = LITERAL (Read)}{
  (Default - `no'      \hspace{6ex}       Choice - `yes:no')
                                                                               
  Use fixed radii when doing Gauss centering with fixed radii ('Yes').
  If floating radii are desired, use 'No'.
                                                                               
}\sstsubsection{GRADII = {\undersc}REAL (Read)}{
  (Default - present value, start=2.0,2.0     \hspace{6ex}    Range - 0.1 to 100.0)
                                                                               
  Gaussian radii to use when doing Gauss centering with fixed radii.
                                                                               
}\sstsubsection{KEEP = LITERAL (Read)}{
  (Default - `no'      \hspace{6ex}       Choice - `yes:no')
                                                                               
  If some aperture measures done have been `removed', then this
  gives the user a chance to resurrect all such removed ones
  when loading the output results table file.
                                                                               
}\sstsubsection{LIST = LITERAL (Read)}{
  (Default - `no'      \hspace{6ex}       Choice - `yes:no')
                                                                               
  If some aperture measures done have been `removed', then this
  gives the user a chance to have them all output when doing the
  the type-out of the results table.
                                                                               
}\sstsubsection{METHOD = LITERAL (Read)}{
  (Default - present value, starting 'annulus'    \hspace{6ex}    
   Choice - 'annulus:separate')
                                                                               
  Method to determine the area used to get the sky level.
                                                                               
  There are two ways of selecting areas the area to be used for
  determining the sky level. These are an annulus round the star,
  and a separate circular area elsewhere in the image.
                                                                               
  The advantage of using an annulus is that this gives a good
  estimate of the mean level at the star itself. The disadvantage
  is that a significantly bright star may be present in that
  annulus. With the use of a separate area, an area free of
  significant stars can be chosen.
                                                                               
  If the `separate' mode is used, then the sky level adopted
  for each star is that determined from the last sky level
  determination. Such determinations can be made as frequently as
  desired.
                                                                               
  In the `annulus' mode, the inner and outer radii of the annulus
  can be set separately.
                                                                               
  For a fuller discussion on the problems of determining sky levels,
  see the `Functions' - `Aperture Function' section.
                                                                               
}\sstsubsection{NOISE = {\undersc}REAL (Read)}{
  (Default - present value, start=0.0              \hspace{6ex}    Range - 0.0 to 1.0e16)
                                                                               
  The amount of extra noise that is actually present in each pixel,
  above the amount the programme can find.
                                                                               
  The programme thinks that the only source of noise is the Poisson
  noise of the counts (scaled by the `Poiss' parameter input factor).
  This `Noise' parameter allows you to put in another source of
  noise. An example could be the `read-out' noise of a CCD.
                                                                               
  The `Noise' is the standard deviation ofsuch an extra source of
  noise.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)                                               

  The name of the output file to contain the `Aperture' output results
  table.

  The contents are described in the start of this section.
                                                                               
}\sstsubsection{OUTTYPE = LITERAL (Read)}{
  (Default - 'full'              \hspace{6ex}    Choice - 'Short/Full')
                                                                               
  Do you want the output `Aperture' results table file to contain
  all the information, or just a shortened subset? The shortened
  subset just has the X,Y positions and the measured magnitudes.
                                                                               
}\sstsubsection{POISS = {\undersc}REAL (Read)}{
  (Default - present value, start=1.0          \hspace{6ex}    Range - 1.0e-8 to 1.0e16)
                                                                               
 The scaling that would have to be applied to pixel values so that
 their values would have a Poissonian distribution.
                                                                               
 This is used to calculate the error on a flux level.
                                                                               
 The error used (squared) = Flux*(`Poiss' value) +
                         (no of pixels)*(`Noise' value)*(`Noise' value)
                                                                               
 This enables the output error estimates to be reasonably correct.
                                                                               
}\sstsubsection{TYPE = LITERAL (Read)}{
  (Default - 'Star'              \hspace{6ex}    Choice - 'Star/Sky')
                                                                               
  When using the cursor to change the size of the aperture, this
  is used to define whether the sky aperture diameter is to be changed,
  of the star aperture.
                                                                               
   In the annulus work, the sky area is taken as that surrounding the
   star aperture out to the sky annulus diameter. In non-annulus work,
   the sky aperture is a simple circle, placed as specified.
                                                                               
}\sstsubsection{ZEROP = {\undersc}REAL (Read)}{
  (Default - present value, start=0.0             \hspace{6ex}    Range - -1.0e8 to 1.0e8)
                                                                               
  The zero point to be added to the output star magnitudes.
                               
\vspace*{3mm}
                                                
}\sstsubsection{\large \bf Colour:-}{
                                                                               
  The parameters that are used by the `Colour' programme group.
                                                                               
}\sstsubsection{COPTION = LITERAL (Read)}{
  (Default - present value,start='load'        \hspace{6ex}     Choices - see below)
                                                                               
  What operation, from a menu of possible choices, to do next?
                                                                               
  The menu selection of options for changing the colour Look-up Table
  of the image display.
                                                                               
  You repeatedly come back to this parameter after performing `Colour'
  operations. You select one of the menu operations. You return to the
  main `Interact' group by entering the `return' option.
                                  
  The functions and button uses are listed at the start of this section.
                                                                               
  For workstation use, the Cursor must be in image window area
  for the cursor buttons to work when in 'WORKING' mode. The window
  also must be 'active' - that is the bar at the top must be set.
  Click on this bar if it is not before using the buttons.
                                                                               
                                                                               
}\sstsubsection{INLUT = BDF (Read)}{
  (Default = null)
                                                                               
  The name of a file containing a LUT Table in the `full' format of the
  Interact:Colour output `OUTLUT', or as a `short' LUT in a brief
  form. In the later case the file is read into the internal programme
  storage, but not loaded to the display LUT. It may, of course, be
  later read from the storage to be applied to the display LUT.
                                                                               
  The formats are more fully described in the `colour' section.
                                                                               
  This enables you to input a new LUT.
                                                                               
}\sstsubsection{LUTNUM = {\undersc}INTEGER (Read)}{
  (Default - 1             \hspace{6ex}    Range - 1-15)
                                                                               
  Choose the number of the stored LUT table you want to apply to the
  display.
                                                                               
  The programme has eight standard LUT tables, numbered as 1-8. You
  can input others, or store modified ones, and store them in numbers
  9-15. These are then available for use. However these are not
  kept when you exit from the programme.
                                                                               
  The eight standard LUT tables are desribed at the start of this section.
                                                                               
}\sstsubsection{NUM{\undersc}LUT = {\undersc}INTEGER (Read)}{
  (Default - 1st number not yet used                  \hspace{6ex}    Range - 9 to 15)
                                                                               
  When reading in a file containing a `short' Look-up Table, this
  is the storage number inside the program where it is kept.
                                                                               
  You can put it in any of the 9 - 15 slots, but you may overwrite a
  previously stored short LURT.
                                                                               
}\sstsubsection{OUTLUT = BDF (Write)}{
  (Default - null)
                                            
  The name of the new file, into which you wish to load the LUT
  presently in use. This is stored as a `full' LUT, in a standard
  format:-
                                                                               
  This is a table containing the R,G,B fractional colour contributions
  in columns 1,2,3 of the table (ignoring the 1st 5 for table row
  names - which are not used). There are 150 rows in this table.
  Starting from the first row, there is the R,G,B set for the lowest
  location on the table, carrying onto the 150th row, where there is
  the highest LUT entry.
                                                                               
  There is also a scale `LUTSC', and a zero `LUTZE', in descriptors.
  These scale the LUT. A given entry point, say RV, which is
  bewteen 0.0 and 1.0, would normally go to the R,G,B set of the
  RV*150th row in the input LUT. Where it actually goes is
  the [(RV-LUTZE)/LUTSC]*150th entry. If this entry is below 1 or
  above 150, then the entry is either, set at 1 or 150, or set at
  its modulo 150 value.

\vspace*{3mm}
                                                                               
}\sstsubsection{\large \bf Inspect:-}{
                                                                               
  The parameters that are used by the `Inspect' programme group.
                                                                               
}\sstsubsection{AZALT = {\undersc}REAL(2) (Read)}{
  (Default - 45.0,45.0         \hspace{6ex}    Range - 0.0 to 360.0)
                                                                               
  The azimuth and altitude of the viewpoint for looking at the
  `celled' 3-D solid body hidden lines graphical plot of the data.
  The entries are in degrees.
                                                                               
  Thus if you return `90.0,0.0', you will get a view as though you
  were a long way away, in the base XY plane of the data, and off to
  the right.
                                                                               
}\sstsubsection{BASE = {\undersc}REAL (Read)}{
  (Default - present value, start=0.0           \hspace{6ex}    Range - -1.0e20 to 1.0e20)
                                                                               
  The base level that is applied to the values in the typing out of
  pixel values.
                                                                               
  A pixel value of(say) RV, is typed out as  (RV-BASE)/SCALE.
                                                                               
  SCALE is the typing out scale, input by the user via the
  `SCALE' parameter, and whose default is 1.0
                                                                               
}\sstsubsection{CONTOUR = {\undersc}REAL(2) (Read)}{
  (Default - see below             \hspace{6ex}    Range - -1.0e20 to 1.0e20)
                                                                               
  The lower and upper limits of values that are plotted out
  in the contour map, and the step between the contour levels.
                                                                               
  Thus an input of `10.0,100.0,20.0' would put out contour
  levels of (10.0,30.0,50.0,70.0,90.0).
                                                                               
  The default is `(minimum of data),(maximum of data),(1/10th of range)'
                                                                               
}\sstsubsection{DECPL = {\undersc}INTEGER (Read)}{
  (Default - present value, start=0           \hspace{6ex}    Range - 0 to 10000)
                                                                               
  No of decimal places to show in the typing out of pixel values.
                                                                               
  If = 0, then the decimal point is suppressed.
                                                                               
}\sstsubsection{DESNAME = LITERAL (Read)}{
  (Default - null)
                                                                               
  The name of the descriptor that you want to get the value of.
                                                                               
}\sstsubsection{HRANGE = {\undersc}REAL(3) (Read)}{
  (Default - see below             \hspace{6ex}    Range - -1.0e20 to 1.0e20)
                                                                               
  The lower and upper limits of values whose number of pixels
  having those values are plotted out in a histogram. Also the
  width of the bins in the histogram.
                                                                               
  Thus an input of `10.0,70.0,20.0' would put out a histogram
  with bins of [(10.0-30.00,(30.0-50.0),(50.0-70.0)].
                                                                               
  The default is `(minimum of data),(maximum of data),(1/10th of range)'
                                                                               
}\sstsubsection{IGBOX = {\undersc}INTEGER(2) (Read)}{
  (Default - 20,20                 \hspace{6ex}    Range - 5 to 100)
                                                                               
  X and Y size of box round the cursor position to be used
  in measuring the Gaussian radius of a star.
                                                                               
}\sstsubsection{IGRADII = {\undersc}REAL(2) (Read)}{
  (Default - 3.0,3.0              \hspace{6ex}    Range - 0.2 to 60.0)
                                                                               
  When using fixed Gaussian radii in measuring the Gaussian
  radius of a star, these are the values to fit.
                                                                               
}\sstsubsection{IOPTION = LITERAL (Read)}{
  (Default - present value,start='area{\undersc}c'        \hspace{6ex}     Choices - see below)
                                                                               
  What operation, from a menu of possible choices, to do next?
                                                                               
  The menu selection of options for inspecting the pixel values of
  the image in various ways.
                                                                               
  You repeatedly come back to this parameter after performing `Inspect'
  operations. You select one of the menu operations. You return to the
  main `Interact' group by entering the `return' option.
                                  
  The functions and the uses of buttons are described at the start of this
  section.
                                                                               
  For workstation use, the Cursor must be in image window area
  for the cursor buttons to work when in 'WORKING' mode. The window
  also must be 'active' - that is the bar at the top must be set.
  Click on this bar if it is not before using the buttons.
                                                                               
}\sstsubsection{ORIENT = {\undersc}REAL (Read)}{
  (Default - present value, start=1.0     \hspace{6ex}          Range - 0.0 to 360.0)
                                       
  Azimuth in degrees from which to view displyed `solid' plot of image 
  area.

  The value input is internally used as though it was in steps of
  30 degrees. Thus 330, 0, and 30 show three different views of the
  `solid' looking at the XZ plane from the direction of -Y, but
  from the left, straight on, and from the right respectively.
                                                                               
  It is not a true viewpoint, but is pretty good.
                                                                               
}\sstsubsection{SCALE = {\undersc}REAL (Read)}{
  (Default - present value, start=1.0       \hspace{6ex}        Range - -1.0e20 to 1.0e20)
                                                                               
  The scale that is applied to the values in the typing out of
  pixel values.
                                                                               
  A pixel value of(say) RV, is typed out as  (RV-BASE)/SCALE.
                                                                               
  BASE is the typing out base, input by the user via the
  `BASE' parameter, and whose default is 0.0.
                                                                               
}\sstsubsection{STEPS = {\undersc}INTEGER(2) (Read)}{
  (Default - present value, start=1,1         \hspace{6ex}      Range - 1 to [max(nx,ny)-1])
                                                                               
  The X and Y step between pixels that are selected to have their pixel
  values output in the typing out of values.
                                                                               
  The upper limit of the steps is the largest side of the image - 1.
                                                                               
}\sstsubsection{VPRANGE = {\undersc}REAL(2) (Read)}{
  (Default - 10% below/above data range      \hspace{6ex}       Range - -1.0e20 to 1.0e20)
                                                                               
  The minimum and maximum pixel values that are plotted. (PGPLOT is
  used in this option.)
                                                                               
  This can be asked for for:-
 
  \begin{list}{{-}}{}
  \item      3-D plot
  \item      3-D celled plot (solid or transparent)
  \item      Slice of pixel values along a pre-defined line
  \item      A grey-scale plot of the image.
  \end{list}
                                                                               
  The default is large enough to cover the actual range.
                                                                               
  This can be a hard copy device.
                                                                               
}\sstsubsection{WIDTH = {\undersc}INTEGER (Read)}{
  (Default - present value, start=8          \hspace{6ex}     Range - 1 to 10000)
                                                                               
  Width of the character string shown for a value in the typing out of
  pixel values. This include any `-' sign and any decimal point. If
  this width is wider than the number of charactes actually in the
  number, then blanks are shown before.
                                                                               
}\sstsubsection{WINDOW = {\undersc}REAL(2) (Read)}{
  (Default - present values, start=-1.0e20,1.0e20    \hspace{6ex}    
   Range - -1.0e20 to 1.0e20)
                                                                               
  The `window' that controls the values in the typing out of values.
  Numbers that are above this value are typed out as `****' and
  those below as `   '.
                                                                               
}\sstsubsection{XYPPLOT = {\undersc}REAL(2) (Read)}{
  (Default - 0.8,0.8 scaled         \hspace{6ex}      Range - 0.101 to 0.9)
                                                                               
  X, Y fraction of graphical display physical window that will be
  used in writing graph or image. The default sizes will result
  in a correct shape being written out. (PGPLOT is used in this
  output.)
                                                                               
  The actual area covered will be:- (0.1 to X, 0.1 to Y) where
  0.0-1.0 is the entire range in each direction.
                                                                               
  This can be a hard copy device.
                                           
\vspace*{3mm}
                                    
}\sstsubsection{\large SCRUTINY:- }{
                                                                               
  The parameters that are used by the `Scrutiny' programme group.
                                                                               
}\sstsubsection{BYLIST = LITERAL (Read)}{
  (Default - present value, start='Yes'         \hspace{6ex}     Choice - 'Yes/No')
                                                                               
  In selecting stars from the input table to deal with, do you want
  to select choosing only those stars that lie in a defined section
  of the table? If not, then the selection will be only those stars
  that lie in a defined rectangle in the image.
                                                                               
                                                                               
}\sstsubsection{COL{\undersc}ALL = LITERAL (Read)}{
  (Default - 'Yellow'        \hspace{6ex}       Choices - see below)
                                                                               
  Colour of spots or crosses to use when painting up stars in the
  Starman:Measure table, using their `old' positions. That is the
  positions that the Starman:Measure programme run had, as input,
  before it was run.
                                                                               
  Choice is:- red:green:blue:cyan:magenta:yellow:coral:palegreen
                                                                               
}\sstsubsection{COL{\undersc}BAD = LITERAL (Read)}{
  (Default - 'Green'         \hspace{6ex}      Choices - see below)
                                                                               
  Colour of spots or crosses to use when painting up stars which have
  `bad' fits, that is fits that have failed in the Starman:Measure.
                                                                               
  Choice is:- red:green:blue:cyan:magenta:yellow:coral:palegreen
                                                                               
}\sstsubsection{COL{\undersc}OK = LITERAL (Read)}{
  (Default - 'Red'       \hspace{6ex}        Choices - see below)
                                                                               
  Colour of spots or crosses to use when painting up stars which have
  `ok' fits, that is fits that have been done ok in the Starman:Measure.
                                                                               
  Choice is:- red:green:blue:cyan:magenta:yellow:coral:palegreen
                                                                               
}\sstsubsection{COL{\undersc}STAR = LITERAL (Read)}{
  (Default - 'Red'      \hspace{6ex}         Choices - see below)
                                                                               
  Colour of spots or crosses to use when painting up stars which have
  been added or removed from the star list.
                                                                               
  Choice is:- red:green:blue:cyan:magenta:yellow:coral:palegreen
                                                                               
}\sstsubsection{CONTRAST = LITERAL (Read)}{
  (Default - present value, start='No'       \hspace{6ex}       Choice - 'Yes/No')
                                                                               
  When displaying the removal of a fitted star from the image, is
  the effect to be shown at a `high' contrast, that is the contrast
  suitable for the small area that is removed? If not, then it is
  displayed at the contrast used in the display of the whole image.
                                                                               
  For the 'Yes' option, one can often see good detail about the
  fit itself, whilst for the 'No' option one sees best the quality
  of the fit in relation to the whole image.
                                                                               
}\sstsubsection{DOFORM = LITERAL (Read)}{
  (Default - present value, start='No'        \hspace{6ex}      Choice - 'Yes/No')
                                                                               
  In typing out, to terminal or file, of the Starman:Measure table,
  format the numbers in the way you want? If not, then the standard
  format is used.
                                                                               
  If you choose to format, you control which columns of the table
  are output and the width of the field for each column, and the
  number of decimal places of the number in the field.
                                                                               
  The standard format is, depending on whether the X,Y positions are
  out, :-
                                                                               
   Star   \hspace{1em} Mag   \hspace{1em} Height   \hspace{1em} Dx    \hspace{1em} 
   Dy  \hspace{1em} Rms  \hspace{1em} Its \hspace{1em} Inval \hspace{1em} Comps 
   \hspace{1em} Imp  \hspace{1em} Diff-2
                                                                               
  or:-
                                                                               
   Star   \hspace{1em} X      \hspace{1em} Y      \hspace{1em} Mag \hspace{1em} Height   
   \hspace{1em} Dx    \hspace{1em} Dy    \hspace{1em} Rms  \hspace{1em} Its 
   \hspace{1em} Inval \hspace{1em} Imp
                                                                               
                                                                               
}\sstsubsection{DOPREF = LITERAL (Read)}{
  (Default - present value, start 'Yes'        \hspace{6ex}    Choice - 'Yes/No')
                                                                               
  When writing the output table of Interact:Scrutiny, this controls
  how the names of the 'new' stars are to be made.
                                                                               
  If there have been no new stars input by the user then this
  parameter is not asked for.
                                                                               
  If 'Yes', then the input stars are output with their same names.
            The new stars are output with names \#'X'1, \#'X'2, , ... ,
            where 'X' is a character string, input via the parameter
            'Prefix'. 'X' has a default of 'A', and it is recommended
            that only a short character string be used, since the
            total name length is only 20.
                                                                               
  If 'No', then all the output stars are renamed as \#1, \#2, ...
                                                                               
  The names are the 'identifiers', placed in the first 5 columns of
  each row of the output table. They are 20 characters long, and
  usually are in the form '\#1', '\#2', ...
                                                                               
}\sstsubsection{DOMAP = LITERAL (Read)}{
  (Default - `yes'      \hspace{6ex}       Choice - `yes:no')
                                                                               
  The profile map is non-zero. Do you want to use it in
  Interact:Scrutiny?
                                                                               
}\sstsubsection{DONEW = LITERAL (Read)}{
  (Default - `yes'      \hspace{6ex}       Choice - `yes:no')
                                                                               
  In marking up the positions of stars around the subject star
  that were fitted along with it, should the starting positions
  be used, or the 'new' fitted ones?
                                                                               
}\sstsubsection{DOSLOPE = LITERAL (Read)}{
  (Default - present value, start='Yes'       \hspace{6ex}     Choice - 'Yes/No')
                                                                               
  When subtracting fitted star from display, subtract the sloping
  background as well. This is not the overall backgound but the
  sloping component above (or below) the background value at the
  b/l/h corner of the fitting box.
                                                                               
}\sstsubsection{DOSPOT = LITERAL (Read)}{
  (Default - present value, start='Yes'      \hspace{6ex}        Choice - 'Yes/No')
                                                                               
  In marking up the positions of stars in the Starman:Measure input
  file table, should the positions be marked with a single pixel
  spot? If not, then they will be marked with a cross of adjustable
  length.
                                                                               
}\sstsubsection{FRAME = {\undersc}INTEGER (Read)}{
  (Default - 1           \hspace{6ex}            Range - 1 to 3)
                                                                               
  Images that are to be blinked are loaded into one of three `frame's.
                                                                               
  Then in the blinking a pair of them are blinked between
                                                                               
             THIS BLINKING OPTION NOT YET FUNCTIONING
                                                                               
}\sstsubsection{FRAMES = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,2             \hspace{6ex}          Range - 1 to 3)
                                                                               
  Frames that are to be blinked. Images will have been loaded into
  two or more of the frames, and you can choose which pair to
  blink between.
                                                                               
             THIS BLINKING OPTION NOT YET FUNCTIONING
                                                                               
}\sstsubsection{INSTARS = BDF (Read)}{
  (Default - null)
                                                                               
  Name of file containing the output of a run of the Starman:Measure
  programme.
                                                                               
}\sstsubsection{LENGTH = {\undersc}REAL (Read)}{
  (Default - 2.0             \hspace{6ex}         Range - 0.5 to 100.0 )
                                                                               
  Length, in pixels,  across arms of the crosses that are to be
  painted up.
                                                                               
}\sstsubsection{LISTXY = LITERAL (Read)}{
  (Default - present value, start='Yes'  \hspace{6ex}     Choice - 'Yes/No')
                                                                               
  In typing out, to terminal or file, the table of the Starman:Measure
  table input file in the standard format, do you want the X,Y
  position of each star to be output?
                                                                               
  The standard format is, depending on whether the X,Y positions are
  out, :-
                                                                               
   Star   \hspace{1em} Mag   \hspace{1em} Height   \hspace{1em} Dx    \hspace{1em} 
   Dy  \hspace{1em} Rms  \hspace{1em} Its \hspace{1em} Inval \hspace{1em} Comps 
   \hspace{1em} Imp  \hspace{1em} Diff-2
                                                                               
  or:-
                                                                               
   Star   \hspace{1em} X      \hspace{1em} Y      \hspace{1em} Mag \hspace{1em} Height   
   \hspace{1em} Dx    \hspace{1em} Dy    \hspace{1em} Rms  \hspace{1em} Its 
   \hspace{1em} Inval \hspace{1em} Imp
                                                                               
}\sstsubsection{LRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - present values, start=1,no of rows   \hspace{6ex}  
   Range - 1 to no of rows)
                         
  This parameter is accessed when selecting which stars in the
  input MEASURE table to use. It defines which ones by taking those
  in the table  in the defined range of rows in the table
 
  This parameter defines the start and end row numbers to define that
  range.
                                                                               
}\sstsubsection{LXRANGE = {\undersc}REAL(2) (Read)}{
  (Default - present values, start=-1.0e6,1.0e6     \hspace{6ex}  
   Range - -1.0e10 to 1.0e10)
                                                                               
  This parameter is accessed when selecting which stars in the
  input MEASURE table to use. It defines which ones by taking those
  in the table  which lie in a defined range of X positions.
 
  This parameter defines the start and end of that X range.
                                                                               
}\sstsubsection{LYRANGE = {\undersc}REAL(2) (Read)}{
  (Default - present values, start=-1.0e6,1.0e6    \hspace{6ex}  
   Range - -1.0e10 to 1.0e10)
                                                                               
  This parameter is accessed when selecting which stars in the
  input MEASURE table to use. It defines which ones by taking those
  in the table  which lie in a defined range of Y positions.
 
  This parameter defines the start and end of that Y range.
                                                                               
}\sstsubsection{NAME = LITERAL (Read)}{
  (Default - null)
                                            
  Name of star in input Starman:Measure table to put out all its
  details for.
                                                                               
}\sstsubsection{NUMAFT = {\undersc}INTEGER (Read)}{
  (Default - 2       \hspace{6ex}           Range - 0 to 130)
                                                                               
  When setting up format for typing out, to terminal or file, details
  of fit of star, this is the number of decimal places to show in a
  number. If `0' is replied, the decimal point itself is suppressed.
                                                                               
}\sstsubsection{NUMBEF = {\undersc}INTEGER (Read)}{
  (Default - 4      \hspace{6ex}            Range - 0 to 130)
                                                                               
  When setting up format for typing out, to terminal or file, details
  of fit of star, this is the number of characters to show before the
  decimal point.
                                                                               
}\sstsubsection{NUMBER = {\undersc}INTEGER (Read)}{
 (Default -  see below \hspace{6ex}   Range - see below)                   
                                             
  A general request for a number. The possible occasions this can
  be asked for are:-
                   
\begin{tabular}{|c|l|p{3in}|}\hline
  Default    & Range         &  Remarks \\ \hline
  1   &       1-no of rows & Star in input Starman:Measure table to
                             display the residuals to fit, in the
                             displayed image. \\
  1    &      1-no of rows & Star in input Starman:Measure table to type
                             out to terminal all details for. \\
  next not removed &  0-no of rows &  When choosing stars to mark with their
                             companions in their fits, this is the
                             number of the star to select. Replying
                             `0' will stop the looping asking for next
                             star. \\
  next not removed &  0-no of rows & When choosing stars to mark with distant
                             companions, the programme will search
                             through the list, from this star on, for
                             such a star and output the details and
                             mark up the star. Replying `0' will stop
                             the looping asking for next star. \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{NUMCHAR = {\undersc}INTEGER (Read)}{
  (Default - 12   \hspace{6ex}       Range - 1 to 20)
                                                                               
  Number of characters in the star's name (identifier) to output in the
  typing out, to terminal or file, of star details from the input
  Starman:Measure table.
                                                                               
}\sstsubsection{NUMCOL = {\undersc}INTEGER (Read)}{
  (Default - present value, start=1   \hspace{6ex}      Range - 0 to No of columns)
                                                                               
  The number of the column in the input Starman:Measure table that
  is to be put in this typing out, to terminal or file, column.
                                                                               
}\sstsubsection{OUTFILE = BDF (Write)}{
  (Default - null)
                                                                               
  The name of the new file to contain the formatted version of a
  selection of the input Starman:Measure table of fitted results. The
  file is a normal ASCII text file
                                                                               
}\sstsubsection{OUTSTARS = BDF (Write)}{
  (Default - null)
                                                                               
  The name of the new file to contain a table, in the format of the
  Starman:Measure programme, of that input Starman:measure table,
  but with (optionally) some stars removed, and (optionally) some
  extra stars added. These extra stars are picked up in the
  Interact:Scrutiny group of functions
                                                                               
}\sstsubsection{PREFIX = LITERAL (Read)}{
  (Default - 'A'       \hspace{6ex}  Choice - any character string)
                                                                               
  The character string to add to the names of new stars in the
  'Outstars' output table file.
                                                                               
  This is asked for if there have been new stars made for the
  output in the 'Outstars' table of the Interact:Scrutiny, and it
  is desired (via the 'Dopref' parameter) that the names of these new
  stars are distinguished by having a character string between the '\#'
  that usually starts a star name and the number that ends it.
                                                                               
  The new stars are output with names \#'X'1, \#'X'2, , ... ,
  where 'X' is a character string, input via this parameter.
  'X' has a default of 'A', and it is recommended that only a short
  character string be used, since the total name length is only 20.
                                                                               
  The names are the 'identifiers', placed in the first 5 columns of
  each row of the output table. They are 20 characters long, and
  usually are in the form '\#1', '\#2', ...
                                                                               
}\sstsubsection{PROFILE = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the existing file containing the `profile' of the stars
  to be used in Interact:Scrutiny.
                                                                               
  It is an image with the profile parameters and profile map in the
  normal Starman `Profile' format.
                                                                               
}\sstsubsection{SEEK = LITERAL (Read)}{
  (Default - `Number'                \hspace{6ex}  Choice - 'Number/Name')
                                                                               
  When typing out the full details of the fit for a star in the input
  Starman:Measure table, select that star by name or number in the
  table.
                                                                               
}\sstsubsection{SOPTION = LITERAL (Read)}{
  (Default - present value,start='list'      \hspace{6ex}   Choice - see below)
                                                                               
  What operation, from a menu of possible choices, to do next?
                                                                               
  The menu selection of options for looking and adding to, the output
  results table of the Starman:Measure program.
                                                                               
  You repeatedly come back to this parameter after performing
  `Scrutiny' operations. You select one of the menu operations. You
  return to the main `Interact' group by entering the `return' option.
                                  
  The functions and the uses of the buttons are described at the start
  of this section.

  For workstation use, the Cursor must be in image window area
  for the cursor buttons to work when in 'WORKING' mode. The window
  also must be 'active' - that is the bar at the top must be set.
  Click on this bar if it is not before using the buttons.
                                                                               
                                                                               
}\sstsubsection{WLIST = LITERAL (Read)}{
  (Default - 'New'    \hspace{6ex}        Choice - 'Old/New')
                                                                               
  This deals with the removal of stars from the input Starman:Measure
  star list.
                                                                               
  The removal is done by the user using the cursor to mark a position
  in the image and the program thens removes the `nearest' star in the
  list to that position. This choice is whether the nearest star is
  defined from the output positions of the Starman:Measure table (the
  normal positions) or the positions that the Starman:Measure programme
  run had, as input, before it was run.
                                                                               
}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} MEASURE}
 
\sstroutine{MEASURE}{Perform Crowded-Field Stellar Photometry}{
 
\sstdescription{ 
                                                                               
   This performs photometry of the stars in a image of a crowded star field.
                                                                               
   A 2D Lorentz-Gaussian-empirical profile is fitted to the stars near the
   positions given by an input position table. The magnitudes and positions
   of the stars are found, and the fit details typed out and stored.
                                                                               
   The profile is a full 2-D one and is a good match to typical star
   images, so the program has a good S/N performance. It can also deal
   with severe crowding and severe pixel under-sampling.
                                                                               
   The program can deal with stars of different profiles. For each star
   you can feed in a separate profile. ( If they all have the same profile,
   as usual for many ground-based observations, this is done automatically
   when inputting the standard profile.) This enables you to deal with
   position and/or colour dependent profiles. Whilst this option is fully
   functional, some helpful ancillary programs are still being documented,
   so in the future dealing with differing profiles will be easier than
   it is now.
                                                                               
                                                                               
}\sstdiytopic{Algorithm}{
\hspace*{4ex}{\bf What the program actually does}

\begin{enumerate}                                                                               
 \item A rough estimate of the magnitude, height and position of each star in
       the input list is made, looking for the peak pixel value within one 
       radius of the input position.
                                                                               
 \item These estimates are looked at to see if any of the stars have nearby
    stars (that is stars in the input list) which (given their distance in 
    terms of the star profile and
    distance and relative magnitude) will affect the star. This is done
    as :-
                                                                               
   Go through the input star position table and find for each star its
   importance according to the formula
                                                                               
             Imp = mag(star) - mag(main star) - 6 + d/(star radius)
                                                                               
   Thus the more important the star is the more -ve Imp is. If the
   star is important enough to worry about (Imp less than 0) then the star
   is noted with the more important stars first. Stars inside the
   measuring box (width of about 10 radii) are also included.
   
   If more than fourteen stars
   are important enough to be noted, only the fourteen most important are
   noted.
                                                                               
 \item This gives a group of stars. A rectangular box is drawn round the
   the target star, large enough to take all of it in - about 10 times
   the half height radius in X and Y, allowing for the possible
   rotation of the star profile from the X-Y axes.
   The group of stars are solved together (stars whose centres are
   outside the box are fitted all the same, but their positions are not
   allowed to vary).
   The result for the target star is typed out and also stored.

   Thus this is the stage at which the actual measurement occurs.

   It will be noted that stars, if any,  which are not in the input list 
   are neither fitted, nor taken into account when fitting other stars.
                                                                               
 \item At the end, there is an option to clean the image by subtracting all
   the stars that have had successful fits.
                                                                               
 \item Optionally it can then go over the cleaned image, trying to fit the
    stars that it failed on before.
                                                                               
 \item Optionally, it can then look at close undone pairs and try to fit
    one star between them.
                                                                               
 \item Optionally, it can repeat the entire process, using the new
    estimates of posns and heights to deal better with large stars adjacent
    to each target star. If on this redoing, an isolated star has been
    previously fitted on the first loop, and its calculated position was
    within 0.1 pixels of its input position, it is assumed that the fit was
    good, and it is not recalculated.
                                                                               
 \item It types out each fit as it does it, as well as storing to file.
\end{enumerate}
                                                                               
}\sstdiytopic{Fitting}{
 The fit is done applying, to single stars or groups of stars, a proper
 iterative least squares fitting proceedure with a function of a sloping
 plane background and up to fourteen identical fully 2D star profiles.
                                                                               
 The profile that is fitted is one that has been found to give a good fit
 to typical star images. It is an elliptical rotated Lorentzian sitting
 on top of a wide low circular modified Gaussian, with an empirical
 residuals map. The actual fitting is a scaling of this profile, added
 onto a linear sloping background, which is fitted at the same time as
 the star.  The mathematical expression of this is:-
                                                                               



$$I(x,y)= H.\left(\frac{1}{1+d_{1}^{P(1+d_{2})}}+QH.e^{-d_{3}^{QP}}+F(x,y)\right)+A+B.x+C.y$$


where 

\begin{tabular}{l l l}

 $ I(x,y)$ &$=$& the value of the star profile at pixel position x,y \\ 

$H $&$=$&  the star peak height\\

$x_{0}, y_{0} $&$=$& the star centre position\\

 $A, B, C $&$=$& the sloping background \\

$ d_{1} $&$=$&$ \sqrt{\left(\frac{x_{1}}{RX}\right)^2+\left(\frac{y_{1}}{RY}\right)^2}$ \\


$ d_{2} $&$=$&$ \sqrt{\left(\frac{x_{1}}{PRX}\right)^2+\left(\frac{y_{1}}{PRY}\right)^2}$\\ 
$x_{1} $&$=$&$ (x-x_{0}).cos(THETA) + (y-y_{0}).sin(THETA)$ \\
$y_{1} $&$=$&$ -(x-x_{0}).sin(THETA) + (y-y_{0}).cos(THETA)$ \\ 
$d_{3} $&$=$&$\sqrt{\left(\frac{x-x_{0}}{QR}\right)^2+\left(\frac{y-y_{0}}{QR}\right)^2}$ \\

\end{tabular}

$F$  is an empirical function, the 'Profile Map'. This is
sampled on a grid which can be finer than the pixel
grid. The grid has a spacing of $int((1 + 2.9/min(RX,RY)))$
times finer than the pixel grid. Thus the empirical
function is sampled at spacings better than the Nyquist frequency.
Unless the star is distorted, the values in this map are zero, and 
even if the star is distorted, they are usually very 
small, with peak values less than 1 percent of the 
main profile. The map is not an empirical representation of the image
residuals from the analytical profile, but of those residuals averaged
over the pixels. Thus depending on the pixel size relative to the star
radius, the map values will change, unlike the analytical profile
parameters.

QH is often zero, and is always small, of the order of 0.01; 
P and QP are usually about 2; the PRs are usually about 6*(the Rs);
QR is usually greater than 5*(the Rs). This gaussian deals with 
any extremely wide wings in the image.


Thus the profile is a rotated elliptical Lorentzian, with the possibilities
of adding on a low wide circular modified Gaussian and of adding on a
small empirical correction.

In fitting profiles where the radius is less than 3 pixels, full account
is taken of the pixel undersampling in the analytical part and (where used) 
in the empirical part.
                                                                               
 The parameters X0,Y0,A,B,C, and D are not parts of the profile, as
 they can be different for each star.
                                                                               
 The fitting is done by starting with trial values of the star heights
 and positions and of the background, and then improving these by the
 iterative linearised least squares method until an acceptable fit is
 made, or until too many iterations have been done.
                                                                               
 Features of the fit are:-

\begin{list}{{-}}{}
\item It can deal with close companions.
\item It can deal with areas of 'bad' pixels, in that such areas are
     ignored in the fits. Again you have to define these areas. (Such
     pixels can also be so flagged before entering the program - see
     the Starman package help for the method of flagging invalid
     pixels.)
\end{list}                                                                               
                                                                               
  The fitting takes account of pixel averaging, that is what happens
  when the star radius is small, and there is significant change in
  the profile across one pixel. As the profile is not a straight line,
  the normal practice of taking the profile value at the centre of the
  pixel will be wrong. The program subdivides the profile over the
  pixel and calculates a more accurate average. So the bad effects of
  a narrow profile and star centres being at different distances from
  the pixel sides are minimised.
                                                                               
  The 'volume' of this profile, that is the numerical integration under
  the 2-D profile out to a defined distance, can be calculated. (The
  calculation is done with a fine mesh, so there is no effect from the
  pixel averaging for small radii.) This enables the magnitudes of
  stars with different profiles to be estimated.
                                                                               
                                                                               
   So each star has a height, A, and a position X0, Y0.
                                                                               
                                                                               
   The program also calculates a magnitude from the star height. This
   is :-

$$   Mag  =  30  -  2.5*log_{10}(star{\hspace{0.3em}}height*profile volume) $$

   The profile volume is the numerical integration (on a fine grid)
   over the standard profile for a star of unit height out to a large
   distance. So (star height*profile volume) is an estimator of the
   total flux in the target star.
   The value 30 is an arbitrary constant to give magnitudes of a
   comfortable level.
                                                                               
   The relative magnitudes of the stars in the image will be measured
   correctly, and the absolute level will be roughly right (apart from
   the arbitrary zero point), but for the best comparision with stars
   in other images with different profiles, the zero point is best
   determined by aperture photometry on the bright stars.
                                                                               
}\sstdiytopic{Hidden Parameters}{
  A number of input control parameters that the user can set to control
  the way the program works are 'hidden' from the user. That is, the
  default values are used unless overridden on the Command Line or
  by the 'LET MEASURE{\undersc}' command in a .SCL file, or in a local '.CON'
  file.
                                                                               
  This is done because the parameters need only be changed for special
  needs. The parameters are:-
     
\begin{tabular}{|l|p{3.5in}|l|}\hline 
  Name   &   Function                                       & Default\\ \hline
  BOX    &   Set size of box round stars to be fitted       & Appropriate Size \\
  DOTWOS &   Fit close undone pairs as single star on       
            cleaned image                                & Yes \\
  FIX    &   Fix all star positions at input values         & No \\
  INFORM &   Type of information output.                    & Simplest \\
  NUMBER &   Number of stars to fit (brightest first)       & All \\
  OFIX1  &   Fix posns and hts of stars some distance from   
            box at rough values, in first cycle            &Yes \\
  OFIX2  &   Fix posns and hts of stars some distance from   
            box at 1st cycle values, in second cycle &      Yes \\
  RADIUS &   Radius out to which 'volume' under profile is   
            to be found to add to mag zero point. &         30.0 \\
  RECYCLE &   After the fits, repeat the entire process,   
            to get better estimates. &                       Yes \\
  REDOCL &   After the first fit, image cleaned and the 
            failed stars fitted on the cleaned image. &      Yes \\
  SCREEN  &  Size of screen to open up if displaying image. &  Image size \\ \hline
\end{tabular}
   
  Further information is available in the individual sections on the
  parameters.
                                                                               
}\sstdiytopic{Miscellaeneous}{
}\sstdiytopic{Misc Errors}{
   The program calculates two error parameters for each star. There
   are:-

\begin{enumerate}
                                                                               
\item    The Chi-squared value from the difference between the fitted
         (maybe multiple) profile and the actual data over a small
         area around the fitted star position. The area is an
         orthogonal rectangle of X size (2*RX+1) and Y size (2*RY+1),
         and so no account here is taken of any rotation of the star
         from the X-Y axes. The RX, RY are as defined in the profile
         equation above.
\item    An estimate of the error of the star magnitude itself. This is
         calculated from the goodness of the fit itself, made during
         the least-squares fitting, falling out of the error matrix.
\end{enumerate}
                                                                               
}\sstdiytopic{Misc Input Positions}{
   It should be noted that the program cannot find stars for itself, or
   decide if a star is actually a multiple one. It takes the stars in the
   input position table as all the stars it has to know about. A consequence
   of this is that the input positions have to be rather good, for two
   reasons. First the program only looks a short way round each input
   position for a star (this is to avoid trouble in crowded areas). Second
   if stars are really crowded, the fitting tends to fail unless the
   input positions are good. For the first case, the positions have to
   be within a radius, and for the second even better.
                                                                               
}\sstdiytopic{Misc Output File}{
  The output file may be formatted for printing by using the program
   SCRUTINY. The program stores output as it goes along, so a crash is not
   fatal. You can also rerun the program using the part completed output as
   input so it doesnt have to do those stars again, by use of the
   BEFORE option.
                                                                               
  The output file is in the Starman table format, with the entries in the
   order:-
                    
\begin{tabular}{|c|c|p{3in}|}\hline
   Column & Identifier &   Content \\ \hline
     1    &   X        &   fitted X position \\
     2    &   Y        &   fitted Y position  \\
     3    &   MAG      &   magnitude \\
     4    &   DX       &   difference in fitted X posn from input posn \\
     5    &   DY        &  difference in fitted Y posn from input posn \\
     6    &   ITERATIONS&  no of iterations done in the fitting \\
     7    &   CHI       &  calculated Chi-squared value of the fit \\
     8    &   NUMINVAL  &  number of INVALID points in the Chi-squared 
                         error estimating area \\ 
     9    &   HEIGHT    &  height of the fitted star above the sky \\
    10    &   BASE      &  sky (or background) level \\
    11    &   MAPNUMBER &  number of profile map used \\
    12-20 &   as contents & profile parameters:-  RX, RY, P, PRX, PRY, THETA,
                                               QR, QH, QP \\
    21    &   NUMCOMPS  &  no of companion stars that have been fitted with the
                         target star \\
    22-28 &   COMP1, etc & numbers (as ranks in the input table) of the
                         first block of companion stars, in order of
                         importance (as defined above) to the target star \\
    29    &   XBOX    &    X size of the box used for the fitting \\
    30    &   YBOX     &   Y size of the box used for the fitting \\
    31    &   IMPORTANCE OF COMPS & total importance of all the companion stars used \\
    32    &   XSLOPE    &  X sky slope fitted \\
    33    &   YSLOPE    &  Y sky slope fitted  \\
    34    &   FLAG1     &  Flag 1 for internal program use \\
    35    &   FLAG2     &  Flag 2 for internal program use \\
    36    &   VOLUME    &  'volume' of a star, with this profile, of unit height \\
    37    &   ORDER     &  order this star was done in the fit  \\
    38    &   MAPX      &  empirical map X size \\
    39    &   MAPY      &  empirical map Y size \\
    40    &   MAGNIF    &  empirical map magnification \\
    41-47 &   COMP8, etc & 22-28 for second block of stars \\
    48    &   DIFF LAST ITS &  change in the magnitude estimate between the final
                               fit and the iteration two before it \\
    49    &   GUESS HEIGHT   &   temporary internal height estimates \\
    50    &   ERROR     &  Estimate of the star magnitude error \\
    51    &   DAMPING   &  final value of the damping factor used in the star fit \\ \hline
\end{tabular}
                                                                               
}\sstdiytopic{Misc Fitting Order}{
   The actual order of fitting is to start with the brightest star, solve
   it, and go onto the next brightest. This is so that in fitting the
   difficult faint stars, the any nearby bright stars will already have
   more accurate psoitions and heights for use in setting up the starting
   conditions of the fit, and thus make the fit willbe both more
   accurate and faster. Doing the stars in this way also means that the
   bright easy stars are done first, and so monitoring of the process at
   the beginning of running the program is more rewarding in that
   the results come more quickly than later on, and also the results for
   the most prominent stars become available first.
                                                                               
                                                                               
}\sstdiytopic{Tips}{
  The main decision is do you want to do the two refining options,
  REDO and DOTWOS, and do you want to do the RECYCLE.
                                                                               
  The simplist and fastest, is NO to all of the above. Some
  more difficult stars are done with the REDO and DOTWOS options,
  and slightly more accurate results are given by RECYCLE. It depends
  a lot on what your interest in the image is, and how much
  computer time you want to spend.
                                                                               
  The default choice is a reasonable choice.
                                                                               
  The secondary decision is the OUTFIX1 and OUTFIX2 details about the
  fits. See the help on them for more details, but again the default
  is a reasonable choice.
                                                                               
  On both these matters, some experimentation by you will give you
  an idea on the best combination to suit you.
  
}\sstdiytopic{Parallel Processors}{
 The program can use Caplin transputer arrays as parallel processors.
 These speed up the fitting of the stars as compared to using
 a single processor.

 So this section is of interest only if you have such a set-up.

 There are a number of set-up files which can load the software needed
 onto a number of different set-ups, each of which matches the cases
 of different numbers of transputers being available.

 To see what the choice is
 in numbers to load, see what files with names in the form of
 'starman:measure{\undersc}farm{\undersc}xxx.app' (where 'xxx' is the number loaded
 by that file) exist.
                                                                             
}\sstparameters{
                                                                               
\sstsubsection{BEFORE = BDF (Read)}{
   (Default - null)
                                                                               
   The name of a file containing the table which was the 'OUT' measures
   from a previous run of MEASURE. if no such file is to be input,
   enter the 'null' response.
                                                                               
   This table must contain the same stars with the same positions as the
   main input star position table 'IN'. The purpose of this
   is that if a run was interrupted, and only some stars solved, the
   run can be repeated, but the stars done dont have to be redone.
   If there is not such a file, just press 'return'.
                                                                               
}\sstsubsection{BOX = {\undersc}INTEGER(2) [HIDDEN] (Read)}{
  (Default - 0,0   \hspace{4ex}   Acceptable range for each - 0 to 200)
                                                                               
  The X,Y size of the box round each star that is to be used in the
  fitting. If either size is set at 0 (which is the default), then the
  program calculates for each star what it thinks the best box size is.
  This is done from the width of the profile for that star.
                                                                               
  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{DODISP = LITERAL (Read)}{
  (Default - `no'    \hspace{4ex}   Choice - `yes:no')
                                                                               
  Display the results as they are calculated.
                                                                               
}\sstsubsection{DOMAP = LITERAL (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')
                                                                               
   If you have an empirical map in your profile file, do you want it used?
                                                                               
}\sstsubsection{DOPAR = LITERAL (Read)}{
  (Default - `no'    \hspace{4ex}   Choice - `yes:no')
                                                                               
  Use a parallel processor array for the main calculations?

  As of Oct 91, the available choice is only that of a transputer array
  on the Caplin system using 3L Parallel Fortran.
                                                                               
}\sstsubsection{DOTWOS = LITERAL [HIDDEN] (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

  After the first fit (and any redo -see 'Redocl' parameter), do you
  want the image cleaned and an attempt made to fit close undone
  pairs as a single star.
                                                                               
  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{DSTYPE  = LITERAL (Read)}{
 (Default - `decw' \hspace{6ex}     Choice - `ikon:none:vws:decw')

  Type of display to be used:-

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Ikon    &    IKON image display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{EXTRA = BDF (Read)}{
   (Default - null)
                                                                               
   The name of a file with a table of extra star positions. If no
   extra file is to be input, enter the 'null' response.
                                                                               
   Is there another table of stars, additional to the input table, which
   should be solved for?
                                                                               
   The is for use when you have solved for a lot of stars in an image, but
   you want to do a few more and these new stars could be crowded by the
   old stars, as well as by themselves. Rather than redoing the combined
   tables together, when all the stars would have to be redone, the new
   ones are input here and the program works out which stars of the old
   table have to be redone since stars of the new table affect them and
   which stars of the new table are affected by stars in the old table.
   The output table has the stars from the old table and then those from
   the new table in it.
                                                                               
}\sstsubsection{FIX = LITERAL [HIDDEN] (Read)}{
  (Default - `no'    \hspace{4ex}   Choice - `yes:no')

  Option to fix the positions of all the stars at the input positions. This
  can enable more accurate magnitudes to be calculated. Use of this option
  should be done with care, as even a small inaccuracy in the input
  position (say a 1/10th of the seeing diameter will result in very poor
  fits.
                                                                               
  (Hidden parameter - not asked for, has to be set if default not wanted)
                                                                               
}\sstsubsection{GAIN = {\undersc}REAL (Read)}{
  (Default - 1.0          \hspace{4ex}  Range - 1.0e-8 to 1.0e8)
                                                                               
  The gain of the original detector. in terms of counts stored in
  a pixel for each independent event detected. Thus something like
  counts/photon.
                                                                               
}\sstsubsection{HEIGHTS = LITERAL (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')
                                                                               
   If the input table of stars has a column called 'HEIGHTS', then this
   is the choice for using the fitted heights in that file for the
   program to use as first estimators of the star heights when looking
   for important neighbours to allow for in the fitting. Say no only
   when the numbers in the 'HEIGHTS' column are not the heights.
                                                                               
}\sstsubsection{IDINAME = LITERAL (Read)}{
 (Default - `ikon'      \hspace{6ex}       Choice - any)
    
   The local name defining the display device. The list of names
   call be seen in the file with the logical name `GNS\_IDINAMES'.
   Remember that the case of the letters matters.
                                                                               
}\sstsubsection{IMPOSN = {\undersc}INTEGER(2) [HIDDEN] (Read)}{
  (Default - Centre of window)
                                                       
  Location of image in display window. This is set at the centre.                        
                                                                               
  (Hidden parameter - not asked for, has to be set if default not wanted)
                                                                               
}\sstsubsection{IN = BDF (Read)}{
   (Default - null)
                                                                               
   The name of the input image. This must be the name of a .bdf image
   file.
                                                                               
}\sstsubsection{INFORM = {\undersc}INTEGER [HIDDEN] (Read)}{
   (Default - 1    \hspace{4ex}  Acceptable range - 0 to 3)

   Flag for outputting via the terminal to the user informative measures.

\begin{tabular}{|c|l|}\hline
   Flag &  Terminal Output \\ \hline
    0   &  Only the results \\
    1   &  results + stage reached \\
    2   &  results + stage reached + times at various subroutine entries \\
    3   &  results + companion fits + stage reached + times at various
          subroutine entries \\ \hline
\end{tabular}
                                                                               
  (Hidden parameter - not asked for, has to be set if default not wanted)
                                                                               
}\sstsubsection{INSTARS = BDF (Read)}{
   (Default - null)
                                                                               
  The name of the file with the table of the star positions. This
  must be the name of a Starman table format file, with the first two
  columns containing the X,Y positions.
                                                                               
}\sstsubsection{NOISE = {\undersc}REAL (Read)}{
  (Default - 0.0   \hspace{4ex}  Acceptable range - -1.0e8 to 1.0e8)
                                                                               
  The additional noise per pixel present in a pixel if there was no
  signal noise. An example of this is the read-out noise in a CCD.
                                                                               
  This should be in the std dev of the numbers in the image pixels.
                                                                               
  This is used when calculating the error in a measure.
                                                                               
}\sstsubsection{NUMBER = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - All of them.    \hspace{4ex}  Acceptable range - 0 to all)

  The number of stars to be analysed. Remember that the stars are
  done in rough order of brightness, so 'number' does not mean do
  the first 'number' in the input table, but 'number' of the bright
  stars, though not necessarily the brightest ones.
                                                                               
  (Hidden parameter - not asked for, has to be set if default not wanted)
                                                                               
}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the Starman programmes use all three, with
  the right-hand button being used mainly as the `exit' button. 

  With two buttons, then the third button is simulated by pressing 
  both of the buttons down, with the middle one being pressed slightly 
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will 
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{NUMPAR = {\undersc}INTEGER (Read)}{
  (Default - 16          \hspace{4ex}         Range - 1 to 10000)
                                                                               
  Number of parallel processors available.
                                                                               
  This is only asked for if you have chosen to use the parallel
  processors You then have to tell it the number of processors
  available in the present configuration. This lets it know which
  software to load into the processors.
                                                                               
 Commonly, the choice is 2, 4, 16, and 20.
                                                                               
 To see what the choice is
 in numbers to load, see what files with names in the form of
 'starman:measure{\undersc}farm{\undersc}xxx.app' (where 'xxx' is the number loaded
 by that file) exist.

}\sstsubsection{OFIX1 = LITERAL [HIDDEN] (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

  In the first loop, fix, for each star fit, the positions and heights of
  those stars some distance outside the fitting  box at roughly found
  values (or the input heights)?
                                                                               
  The advantage in fixing is that if you already have the right heights,
  then the fit will be better. The danger is that if the heights are
  wrong, then the fit might be inaccurate. If you are only doing one
  loop, you have to let the stars vary as the input geusses are
  just rough estimates. If doing two loops, then the error will not
  be too large, and fixing them will speed things up.
                                                                               
  If you are doing once (RECYCLE=NO) then
  say NO, otherwise the common answer is YES, but you might
  to try otherwise and see what difference it makes to the results.
                                                                               
  (Hidden parameter - not asked for, has to be set if default not wanted)
                                                                               
}\sstsubsection{OFIX2 = LITERAL [HIDDEN] (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

  In the second loop (if doing one), fix, for each star fit, the positions
  and heights of those stars some distance outside the fitting  box at the
  values found in the first loop?
                                                                               
  The advantage in fixing is that if you already have the right heights,
  then the fit will be better. The danger is that if the heights are
  wrong, then the fit might be inaccurate. By the second loop, the
  fits from the first loop should be reasonable.
                                                                               
  The common answer is YES, but you might
  try NO and see what difference it makes to the results.
                                                                               
  (Hidden parameter - not asked for, has to be set if default not wanted)
                                                                               
}\sstsubsection{OIMTIT = LITERAL (Read)}{
  (Default-  'Output from MEASURE'    \hspace{4ex}  Choice - any)
                                                                               
  The title to be attached to the output cleaned IMOUT image.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
   (Default - null)
                                                                               
  The name of the file to contain the output table of measurements.
                                                                               
  Its contents are described in the 'Misc' section of the help.
                                                                               
  This table can be looked at, and formatted for listing, by the program
  'INTERACT' in its 'SCRUTINY' section.
                                                                               
}\sstsubsection{OUTIM = BDF (Write)}{
   (Default - null)
                                                                               
  If you do want the image to be cleaned of the fitted stars, then input
  here the name of the output image to hold the cleaned image.
                                                                               
}\sstsubsection{OUTTIT = LITERAL (Read)}{
   (Default - 'Output from MEASURE'   \hspace{4ex}   Choice - any))
                                                                               
  The title to be added as a descriptor to the 'Outstars' file.
                                                                               
}\sstsubsection{PROFILE = BDF (Read)}{
   (Default - null)
                                                                               
  Input the name of the image made by PROFILE (qv) which has the
  image parameters. This can be just one profile ( the usual
  ground-based choice) or it can be the store of many profiles
  empirical maps for when stars have differing profiles. In this
  latter case, then the profiles parameters are input in the INSTARS
  table in a manner explained elsewhere.
                                                                               
}\sstsubsection{PYES = LITERAL (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')
                                                                               
  If you have profiles in the star table, do you want the profile
  parameters in the profile file to override the profiles in the table?
                                                                               
}\sstsubsection{RADIUS = {\undersc}REAL [HIDDEN] (Read)}{
   (Default - 30.0.     \hspace{4ex}   Acceptable range - 1.0 to 1.0e8 )
                                                                               
  When calculating the magnitude, the volume under the profile has
  to be calculated. How far out from the star (in pixels) shall this
  be carried out? This is only important if you want to compare with
  aperture photometry, or have stars with differing profiles in the
  image.
                                                                               
  (Hidden parameter - not asked for, has to be set if default not wanted)
                                                                               
}\sstsubsection{RECYCLE = LITERAL [HIDDEN] (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

  After the fits has been done, repeat the entire process, to use the
  better estimates of star heights and positions for starting input,
  and for better fits where a star is affected by stars some distance
  away.
                                                                               
  (Hidden parameter - not asked for, has to be set if default not wanted)
                                                                               
}\sstsubsection{REDOCL = LITERAL [HIDDEN] (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

  After the first fit, do you want the image cleaned and an attempt
  made to fit the failed stars on the cleaned image.
                                                                               
  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{SCREEN = {\undersc}INTEGER(2) [HIDDEN] (Read)}{
  (Default - 1, size of image      \hspace{6ex} Range - 1 to large)

  Size of screen or window to open. 

  The default size is that of the image, unless the image is too large
  to fit on the screen, when the image will be binned down by an integer
  factor for display. The default size will then be this binned down size.

  (Hidden parameter - not asked for, has to be set if default not wanted)
                                                                               
}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} PROFILE}
 
\sstroutine{PROFILE}{Determine Profile of Stars in an Image}{
 
\sstdescription{ 
 This program determines the mean stellar profile (the shape) from
 a number of stars. 
                                                                 
 The user inputs the locations of a number of bright stars in an 
 image, and the programme then (interactively with the user)estimates
 the parameters of an analytic/empirical profile that give the best 
 mean fit for the profiles of these stars.
     
 The profile that it fits is one which combines a Lorentz type profile
 with an empirical map of the residuals from the analytical profile.
 Also an extra component of a base of a wide Gaussian type profile can
 be added. residuals. Usually, the Lorentz component of the profile
 plus the empirical map gives an adequate fit.
  
 The program is heavily interactive and needs an image display. It is
 also computationally heavy. A mode to use transputers as parallel
 processors in a `go fast box' mode exists.
  
}\sstdiytopic{Method}{
 The user inputs in the image which the stars are in and a table
 of a small (about 5-10) list of (X,Y) star positions. The programme
 takes a small area round each of those stars, and fits the data in
 the boxes with a sloping sky and a star profile. The sky and the
 profile are adjusted until there is a good fit. The parameters of
 the profiles for each of the stars are then averaged together to
 make a mean profile.

 At first, only the Lorentz part of the profile is used. Then, if it
 is necessary, the empirical map of any remaining residuals may be 
 fitted, and then even the mean wide Gaussian wing can be fitted.

 The resultant profile is then stored in a file (as an image with
 the profile parameters as descriptors. This profile can then be used
 as the input to MEASURE, ADDSTARS, or INTERACT.

 The programme works by looping round, offering the repeated option
 of performing functions. One can leave the `Main' section and
 go into subsidary sections -- this is indeed needed for removing
 stars and bad areas near to the target stars, for making the
 empirical map, and for making the Gaussian wing.

 There are many other operations that can be done inside PROFILE.
  
 The elliptical rotated Lorentz profile that is fitted is one that has 
 been found to give a good fit to typical star images. 

 The actual fitting of a star in an image is a scaled (according to the
 height of the star) version of this total profile, added onto a 
 linear sloping sky background. The fitting for the background is done 
 at the same time as the fitting for the star.

 The mathematical expression of this is:-
                                                                               


$$I(x,y)= H.\left(\frac{1}{1+d_{1}^{P(1+d_{2})}}+QH.e^{-d_{3}^{QP}}+F(x,y)\right)+A+B.x+C.y$$


where 

\begin{tabular}{l l l}

 $ I(x,y)$ &$=$& the value of the star profile at pixel position x,y \\ 

$H $&$=$&  the star peak height\\

$x_{0}, y_{0} $&$=$& the star centre position\\

 $A, B, C $&$=$& the sloping background \\

$ d_{1} $&$=$&$ \sqrt{\left(\frac{x_{1}}{RX}\right)^2+\left(\frac{y_{1}}{RY}\right)^2}$ \\


$ d_{2} $&$=$&$ \sqrt{\left(\frac{x_{1}}{PRX}\right)^2+\left(\frac{y_{1}}{PRY}\right)^2}$\\ 
$x_{1} $&$=$&$ (x-x_{0}).cos(THETA) + (y-y_{0}).sin(THETA)$ \\
$y_{1} $&$=$&$ -(x-x_{0}).sin(THETA) + (y-y_{0}).cos(THETA)$ \\ 
$d_{3} $&$=$&$\sqrt{\left(\frac{x-x_{0}}{QR}\right)^2+\left(\frac{y-y_{0}}{QR}\right)^2}$ \\

\end{tabular}

$F$  is an empirical function, the 'Profile Map'. This is
sampled on a grid which can be finer than the pixel
grid. The grid has a spacing of $int((1 + 2.9/min(RX,RY)))$
times finer than the pixel grid. Thus the empirical
function is sampled at spacings better than the Nyquist frequency.
Unless the star is distorted, the values in this map are zero, and 
even if the star is distorted, they are usually very 
small, with peak values less than 1 percent of the 
main profile. The map is not an empirical representation of the image
residuals from the analytical profile, but of those residuals averaged
over the pixels. Thus depending on the pixel size relative to the star
radius, the map values will change, unlike the analytical profile
parameters.

QH is often zero, and is always small, of the order of 0.01; 
P and QP are usually about 2; the PRs are usually about 6*(the Rs);
QR is usually greater than 5*(the Rs). This gaussian deals with 
any extremely wide wings in the image.


Thus the profile is a rotated elliptical Lorentzian, with the possibilities
of adding on a low wide circular modified Gaussian and of adding on a
small empirical correction.

In fitting profiles where the radius is less than 3 pixels, full account
is taken of the pixel undersampling in the analytical part and (where used) 
in the empirical part.
                                                                               
 The parameters X0,Y0,A,B,C, and D are not parts of the profile, as
 they can be different for each star.
                                                                               
 The fitting is done by starting with trial values of the star heights
 and positions and of the background, and then improving these by the
 iterative linearised least squares method until an acceptable fit is
 made, or until too many iterations have been done.
                                                                               
 Features of the fit are:-

 \begin{list}{{-}}{}
 \item It can deal with close companions. You have to tell it where
     these stars are.
  \item It can deal with areas of 'bad' pixels, in that such areas are
     ignored in the fits. Again you have to define these areas. (Such
     pixels can also be so flagged before entering the program - see
     the GRASP suite of programs for the method of flagging invalid
     pixels.)
\end{list}
                                                                               
 The fitting takes account of pixel averaging, that is what happens
 when the star radius gets small, and there is significant change in
 the profile across one pixel. As the profile is not a straight line,
 the normal practice of taking the profile value at the centre of the
 pixel will be wrong. The program subdivides the profile over the
 pixel and calculates a more accurate average. So the bad effects of
 a narrow profile and star centres being at different distances from
 the pixel sides are minimised.
                                                                               
 The 'volume' of this profile, that is the numerical integration under
 the 2-D profile out to a defined distance, can be calculated. (The
 calculation is done with a fine mesh, so there is no effect from the
 pixel averaging for small radii.) This enables the magnitudes of
 stars with different profiles to be estimated.
                                                                               
 At the programme start, the values of the profile parameters are:-
      RX=2.0, RY=2.0, P=2.2, PRX=10.0, PRY=10.0, THETA=0.0
      QH=0.0, QR=10.0, QP=2.0

 (A note for people looking inside the programme source)
                                                                               
 Inside the programme, the parameters have slightly different names:-
                              
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}\hline                                                 
 Here     &RX    &RY     &P     &PRX    &PRY   &THETA 
& QH           & QR           & QP \\ \hline
 Inside  &{\small Rmaj}  &{\small Rmin}  &{\small Power}  &{\small PRmaj}
  &{\small PRmin}  &{\small Angle}
&{\small Wing} &{\small Wing} & {\small Wing } \\ 
 & & & & & & & {\small Height} & {\small Radius}  & {\small Power} \\ \hline
\end{tabular}
                                                                               
}\sstdiytopic{Run-through}{
As the use of Profile is interactive, there is (nearly) an infinite number
of ways of using it. To give you some ides of its use, the following 
`run-through' of one possible session is given.

This run-through does not deal with the major features:- rejection of companion 
stars; rejection of bad areas; fitting the empirical map. There are also
many minor features that are not explored.

Explanations and commentary associated with each annotation are given
afterwards. The parts in san serif are abbreviated versions of typed output 
or are comments on the display. The parts in italics are instructions to 
you.

It is assumed the user is at a colour workstation (either an Xwindows
device used as an image display or a Vaxstation running Decwindows). (Of
course, the use of an IKON or VWS windows is also possible.) 

{\hspace*{4ex} \bf `Run-through':-}

\begin{tabular}{p{5.5in}l}
Starman$>$ Profile                                    & \fbox{1} \\
                                                      & \\
IN:=starman{\undersc}testdata:profile{\undersc}in   & \fbox{2} \\
INSTARS:=starman{\undersc}testdata:profile{\undersc}instars & \fbox{3} \\
DOPAR/no/:=                                           & \fbox{4}\\
\hspace*{4em}  {\it Information on input star list and present fit set-up typed out}  
                                     \hspace*{\fill}  & \\
OPTION/rough/:=                                       & \fbox{5}\\
\hspace*{4em}  {\it Information on rough fits typed out}  \hspace*{\fill}  & \\
OPTION/boxsize/:=                                     & \fbox{6}\\
 \hspace*{1ex} {\sf Old X Y sides of box 20 20}   \hspace*{\fill}  & \\
 \hspace*{1ex} {\sf Suggested X Y sides of box 22 20}   \hspace*{\fill}  & \\
SIZE/22,20/:=20,20                                    & \fbox{7}\\
 \hspace*{1ex} {\sf Old X Y sides of Profile Map 20 20}   \hspace*{\fill}  & \\
 \hspace*{1ex} {\sf Suggested X Y sides of Profile Map 20 20}   \hspace*{\fill}  & \\
SIZE/20,20/:=                                         & \fbox{8}\\
OPTION/fitall/:=                                      & \fbox{9}\\
FITTYPE/old/:=                                        & \fbox{10}\\
                                                      & \\

{\sf Box  X length =   20  Y length =   20 }\hspace*{\fill}  & \fbox{11}\\
{\sf \begin{tabular}{ccccccccc}
  No   &Height &Its     &Rmaj    &Rmin    &P       &PRmaj   &PRmin  &Theta \\
   1   &7479.7   &9     &2.150   &1.855  &2.192    &9.81   &17.19   &26.34 \\
   2   &2700.9  &12     &2.127   &1.873  &2.048    &6.33    &6.83   &18.77 \\ 
   3   &5098.8  &15     &2.221   &1.891  &2.305    &7.40   &17.60   &20.34 \\
   4  &26088.2   &5     &2.464   &2.213  &2.192    &9.37    &9.77   &80.85 \\
\end{tabular}} \hspace*{\fill}  & \\
OPTION/fitall/:=fitalldisp                            & \fbox{12}\\
DSTYPE/decw/:=                                        & \fbox{13}\\
SCREEN/396,496:=                                      & \fbox{14}\\
\hspace*{4em}     {\sf The raw and cleaned areas round each star are 
                        displayed }  \hspace*{\fill}  & \\
OPTION/fitalldisp/:=panel                             & \fbox{15}\\
PDSTYPE/decw/:=                                       & \fbox{16}\\
\hspace*{4em}     {\sf The `push-buttons' are displayed }  
                                     \hspace*{\fill}  & \\
\hspace*{4em}     {\it Click cursor on 'mean' button}  \hspace*{\fill}  & \fbox{17}\\
\hspace*{4em}  {\sf Information on mean typed out}  \hspace*{\fill}  & \\
FLIP/0/:=                                       & \fbox{18}\\
REJECT/0/:=                                       & \fbox{19}\\
\hspace*{4em}  {\sf Information on fit progress typed out}  \hspace*{\fill}  & \\
\hspace*{4em}     {\it Click cursor on 'store' button}  \hspace*{\fill}  & \fbox{20}\\
{\sf You have not calculated the Profile Map since the last change. Is this OK? 
}\hspace*{\fill}  & \\
OK/no/:=yes                                          & \fbox{21}\\
{\sf Image to put profile parameters into}       \hspace*{\fill}  & \\
OUTPROF:=fred1                                    & \fbox{22}\\
TITLE/Profile from PROFILE/:= Fred1 profile       & \fbox{23}\\
OUTSTAR:=                                        & \fbox{24}\\
\hspace*{4em}     {\it Click cursor on 'EXIT' button}  \hspace*{\fill}  & \fbox{25}\\
Starman$>$                                        & \\
\end{tabular}

Comments on above run-through:-

\begin{enumerate}

\item Start the programme.
\item The input image.
\item The input table of a list of four star positions.
\item We do not want to use the parallel processors.
\item We have now entered the looping part of the programme. We are at 
      present in the `Main' section. We are offered the default of making a 
      rough fit to the stars. (This gives us a check on their quality). We 
      accept this choice.
\item We are offered the default of changing the size of the box
      round each star which is used in the fitting. We accept this choice.
\item We set the size of the box to be fitted round each star.
\item We set the size of the empirical map of the profile.
\item We fit the profile of the stars.
\item We choose as the starting values of the parameters, the last
      values they had.
\item The programme types out the results of the fits as it goes
      along.
\item We want to look at the data. We will see the original areas
      and the areas after the central star has been removed with the
      parameters of its own fit. If the fit is good, the star should
      have disappeared cleanly.
\item The programme wants to know where to display the image.
\item The programme wants to know how large a window to open.
\item We now enter the `push-button' mode of option choosing.
\item The programme wants to know where to display the push buttons.
\item We like the fits, so we make a mean fit.
\item We do not see any orientations of the fitted elliptical profiles
      that have to be flipped by 180 degrees.
\item We do not see any stars that have to be rejected.
\item We like the mean profile, so we decide to store it into
      a file.
\item That is not a problem.
\item The name of the file to put the profile image into
\item The `title' to add to the profile image.
\item We do not want to store the present stage of the star fitting,
      so we make a `null' return here.
\item We have finished with the PROFILE programme.
\end{enumerate}

}\sstdiytopic{Use}{
  WARNING -- Use only bright stars as the fit will blow up and/or give a poor
   fit if used on noisy data.
             
   {\bf An explanation of the use of the program}

\begin{enumerate}
                                                                               
 \item {\bf Input of image and list of positions of stars to define the 
        profile}
   The image and an table of (X,Y) positions of the stars are fed in by you.
   It is recommended that the stars should be as isolated as possible,
   bright, but not so bright that their peaks are saturated. About 5
   to 10 stars are enough.
                                                                               
   After this stage, you then enter the interactive part of the program.
   A recommended course of action is to do the following (and then repeat
   as needed some stages):-
                                                                               
 \item {\bf First rough profile derivation}
   You can use the 'rough' option to make a rough profile estimate. Other
   options are:- If you do know the rough stellar radius, input it. 
   If you don't, then choose a good (isolated) star, and make a fit on 
   that, and make the mean (of one!). If you don't know which are the 
   good stars, display them and look.
                                                                               
 \item {\bf Rough box size}
   You can now set the fitting box size roughly right. In the course of
   the program, each time you calculate the Mean profile, the proper
   fitting box size is recalculated. If it differs from the size, you
   are using, then it is advisable to change to the recommended size
   and redo the fits.
                                                                               
 \item {\bf Fitting of the lorentzian and calculation of mean}
   Then fit a Lorentzian at each star. The program types out the fits.
   You can display the fits and look at them, then estimate the mean
   profile, rejecting bad fits.
                                                                               
 \item {\bf Dealing with companions, faint companions,and bad areas}
   You can then look at the stars and see if there are companions that
   need dealing with or if there are bad areas. These things are dealt
   with in three stages :-

   \begin{list}{{-}}{}                                                                               
   \item   Faint companions on the wings of the main star. These are
        iteratively subtracted during the fitting process. Thus they are
        allowed for, but do not really define the profile. Their posit-
        ions are fed in by lists or by your using the cursor to point
        them out.
                                                                               
   \item  Bright companions or companions close to the main star. These are
        fitted in the same process as the main star. Thus they are fully
        used to define the profile, along with the target star. Their
        positions are fed in by lists or by your using the cursor to
        point them out.
                                                                               
   \item Bad areas. These are ignored during the fit. Their
        positions are fed in by lists or by your using the cursor to
        point them out.
   \end{list}                                                                       
                                                                               
   In this stage, the area displayed round each star is roughly twice the
   linear size of the area actually used in the fit, so you need not
   worry about bad areas or faint stars near the edge, but stars whose
   profiles get near the central region should be marked.
   You can also mark and remove mistaken points using the cursor in the
   same way.

   You can then re-estimate the fit.
                                                                               
 \item {\bf Making the empirical profile map}
   If on inspection of the fits, you have a suspicion there is a system-
   atic pattern to the residuals, you can confirm this by making a map
   of the mean residuals. If on smoothing (or not) you remain convinced,
   then the empirical profile map can be loaded from this residual map.
   At this stage it is best to go back and refit the Lorentz, to see if
   the residuals map has really gone away, as it should.
                                                                               
   If no pronounced pattern  can be seen it is safest  not to make these
   residuals, or if made, not to copy them over to the profile map. To do
   otherwise is merely to introduce noise.
                                                                               
   It is also wise only to make the profile map where there is good
   signal to noise (usally at the centre of the image). Set the profile
   map to zero in the middle and outer regions where it is just sky
   noise.
                                                                               
 \item {\bf Fitting the modified gaussian wings}
   If on inspection of the fits, you have a suspicion there is a system-
   atic tendency for the profiles to have wide unfitted wings, then you
   can fit the wide low modified Gaussian wings of the profile. This is
   done by the program taking the current mean Lorentz/empirical fit, and
   fitting it to the accepted stars out to a distance of twice the box
   size previously used.
   You may have to add more companion stars and/or bad areas for the
   larger boxes.
   The mean radial plot and radial fit around the star centre is then
   shown. You can then refine this by using the cursor to define a fid-
   ucial set of points giving the proper profile as you see it, and the
   program will fit to them, rather than the data points.
                                                                               
   At this stage, it may be necessary to refit the empirical map.
                                                                               
   It is important to note that if no definite trend in the residuals
   can be seen, or it looks as though the wings are so wide that they do
   not go to zero within the plot, it is best to set the wings to zero.
   This avoids bright stars producing unrealistic wide wings in MEASURE
   (qv).
                                                                               
 \item {\bf Invalid pixels}
   If any of the pixels used are flagged as INVALID, they are ignored.
                                                                               
 \item {\bf Storage of the results}
   The profile is stored as an image containing the empirical map with
   the profile parameters as descriptors. The information of the fits to
   the stars and of the companions and bad areas is also stored in tables.
\end{enumerate}

}\sstdiytopic{Cursor}{
 The cursor is used to pick up positions, change the zoom, and other
 miscellaneous purposes.
                                                                               
 The tracker ball moves the cursor. It is assumed that a 3 button cursor
 is used. The cursor buttons are worked like this:-
                                                                               
   General position marking:-   Press any button
                                                                               
Zoom/pan work:- \hspace*{4ex}\begin{tabular}{|c|l|}\hline
Action                         & Effect \\ \hline
Left Button twice              & zoom /2 \\
Centre Button twice            & zoom x2 \\
Left Button then Centre Button & pan \\
Right button once              & return \\ \hline
\end{tabular}
                                                                               
  If the cursor is outside a displayed area, often pressing the button
  will result in no actions.
                                                                               
}\sstdiytopic{Data}{
  The input data comes from the image. The program then deals with,
  interacts with, and displays the image data and other types of
  data concerned with the fitting process.
                                                                               
  There are three sorts of data concerned. In each case you can
  display them on the image display, inspect them, and interact with
  the data.

\begin{tabular}{|l|p{4in}|}\hline
  Types of data   &   Description \\ \hline
  Fits            &  Display of     a) the image round each star \newline
                     \hspace*{7ex}  b) the image minus the stars fitted \\
  Residuals       &  Display of     a) the residuals to the mean fit \newline
                     \hspace*{7ex}  b) the filling of the residuals array \\
  Profile map     &  Display of the profile map array \\ \hline
\end{tabular}
                                                                               
}\sstdiytopic{Fits}{
  When the fits are displayed on the image display, the display
  consists of two parts. The top half contains the actual pictures round
  each target star. The bottom half contains the residuals when the fits
  are subtracted from the actual image.
                                                                               
  The displayed boxes have sides that are twice the actual fitting
  boxes. (The edges of the fitting boxes are indicated by the purple
  dots at the sides of the displays.) The reason for this is to help
  you in marking the positions of stars just outside the fitting boxes
  which are bright enough that they affect the data inside the fitting
  boxes.
                                                                               
  The intensity scaling in the top half is uniform. In the bottom half,
  each box has its own scaling to bring up the residuals as well as
  possible. An idea of the relative scaling may be gained by looking at
  the intensity variations in the sky background.
                                                                               
  You can inspect and interact with this data (see the OPTION parameter).
                                                                               
}\sstdiytopic{Residuals}{
  When the residuals are displayed, there is also shown the filling map
  of the residuals. This filling map shows which pixels in the
  residuals array actually have data.
                                                                               
  The residuals are displayed at the right size. The intensity scaling is
  such as to show the residuals up as much as possible.
                                                                               
  The residuals map covers the same number of image pixels as the
  fitting box. But the residuals map may well contain more pixels, and
  thus be `larger', by an integral number factor, than the fitting box.
  This happens when the profile is so small that pixel averaging
  becomes important. In this case the residuals map is subdived, with
  each pixel becoming a nxn box (where n=1+int[2.9/(min radius)] ).
                                                                               
  Then for each star, the residual from the profile at each pixel is
  calculated and stored in the nearest subdivision. For example, if a
  star with radius 1.5 had its centre at [100.2,100.8], the residual of
  pixel [105,105] at distance (4.8,4.2), would be stored at the (1,3)
  subdivision of the (4,4) pixel.
                                                                               
  Alongside the residuals, in a red box, are displayed the
  filling factors, that is, which pixels (shown as white) have data,
  and those that do not (shown as black).
                                                                               
  You can inspect and interact with this data (see the RESINTER parameter).
                                                                               
}\sstdiytopic{Profile map}{
  The display of the profile map, shows the current state of the
  profile map.
                                                                               
  This is much like the residuals map, except that there is no filling
  factor display, as the profile map can only be filled from a full
  residuals map (one either naturally full, or smoothed full, or boxed
  or polygoned so, or zeroed so).
                                                                               
  You can inspect and interact with this data (see the OPTION parameter).
                                                                               
  The profile map does not have to be the same size as the fitting
  area.
                                                                               
  Its size is the number of pixels of the image that the profile map
  covers. This can be different than the computer storage size and the
  size of the profile file image, since the profile map may map to
  sub-divided image pixels, and thus contain more data points.
                                                                               
}\sstdiytopic{Display}{
  You can display on an image display the three types of data the
  programme deals with. You are in fact encouraged to do so, so as
  to understand the profile.
                                                                               
  In each case you can inspect and interact with the data displayed.
                                                                               
\begin{tabular}{|l|p{4in}|}\hline
  Types of data   &   Description \\ \hline
  Fits            &  Display of     a) the image round each star \newline
                     \hspace*{7ex}  b) the image minus the stars fitted \\
  Residuals       &  Display of     a) the residuals to the mean fit \newline
                     \hspace*{7ex}  b) the filling of the residuals array \\
  Profile map     &  Display of the profile map array \\ \hline
\end{tabular}

  A fuller description of the types of data is given in the `Data'
  section.
                                                                               
}\sstdiytopic{Graphics}{
  Graphics are done under the control of the `PGPLOT' package. In Starlink
  this sits over the `GKS' package. The use is quite simple, but the
  users' guide to those two pacakages should be consulted if there is
  any problem.
                                                                               
  One point to note is that using the cursor to mark a position on the
  graph, you place the cursor and press a keyboard key. You cannot use
  the cursor mouse buttons (if any).
                                                                               
}\sstdiytopic{Menu}{
 The programme works in a menu mode, where you repeatedly select
 operations to do, until you are satisfied.
                                                                               
 Your choices are:-
                                                                               
\begin{tabular}{|c|p{4.5in}|}\hline
 Command  &   Result \\ \hline
 Angle   &    Change Fix/Vary angle and/or angle \\
 Boxsize  &   Change size of box round stars \\
 Clear     &  Clear the display \\
 Compzero  &  Delete all stars from the comp/faint comp lists \\
 Dispinter &  Interact with the display:-
               Pan/zoom the fits display; change the companions
               to and/or bad areas near the stars; move the
               main stars; type out the image or residuals
               values; remove/replace coloured lines \\
 Display   &  Display the areas \\
 Dsclose   &  Close the display \\
 Exit      &  Exit \\
 Fitall    &  Fit all the accepted stars \\
 Fitalldisp & Display the residuals to the fits \\
 Fitchange  & Fit only those stars with changed circumstances \\ 
 Fitinter   & Interact with the display of fits:-
               Pan/zoom the fits display; change the companions
               to and/or bad areas near the stars; move the
               main stars; type out the image or residuals
               values; remove/replace coloured lines \\ \hline
\end{tabular}

\begin{tabular}{|c|p{4.5in}|}\hline
 Fitnumber  & Fit a certain star \\
 Fitnumdisp & Display the residuals to a single fit \\
 Fitparam   & Change the parameters of the fitting calculations \\
 Fixxy      & Change stars with fixed positions and/or their
               positions \\
 Infiles    & Load any previous fit details (Companions, Faint
               Companions, Bad Areas, Fits) \\
 Listcomp   & List the fit, comps, bads of a star \\
 Listfit    & List the present fits \\
 Ignore     & No action \\
 Mapadd     & ADD the Residuals onto the Profile Map \\
 Mapdisp    & Display the profile map \\
 Mapinter   & Interact with the display of Profile Map \\
 Mapscale   & Change Profile Map scale (i.e. multiply/divide its
               values) \\
 Mapsize    & Change Profile Map size \\
 Mapuse     & Change the option as to wether to apply the 
               Profile Map \\
 Mapzero    & Zero the Profile Map \\
 Mean       & Decide which stars to use and find mean weighted
               profile \\
 Newimage   & Input a new image to replace the present one under
               analysis \\
 Newstars   & Input a new list of star positions to replace the
               present one being used \\
 Panel      & Switch between panel/keyboard choice \\
 Parallel   & Switch between parallel processors/not choice \\
 Plot       & Put a 1-D profile plot into an output file \\
 Printinter & Print out intermediate step results in the fitting \\
 Profchange & Change the profile parameters \\
 Proffix    & Change fixed/variable control on profile params \\
 Reject     & Change which stars are accepted/rejected \\
 Rescalc    & Calculate the map of residuals \\
 Resdisp    & Display the mean fit residuals \\
 Resinter   & Interact with the display of residuals:-
               Pan/zoom the residuals display; change the
               residuals values in a number of ways \\
 Ring       & Put a mauve border round rejected stars on the
               display \\
 Rough     &  Make rough estimates of star posns, heights, radii \\
 Shiftxy   &  Shift the XY positions of all the stars and comps \\
 Store     &  Save the profile and fits \\
 Trial     &  Get a guess at the profile from one star \\
 Volume    &  Calculate the profile volume \\
 Wing      &  Fit a broad Gaussian wing - zero broad wing start \\ \hline
\end{tabular}
                                                                   
}\sstdiytopic{Detailed descriptions}{
}\sstdiytopic{Shiftxy}{
 This shifts the X,Y positions of all the stars and companions and
 faint companions. It leaves the bad areas unmoved. This enables
 you to use the lists from one expsoure on another where the field
 centre is different, but where the detector bad areas are at the same
 positions.
                                                                               
}\sstdiytopic{Wing}{
 Option for wether to fit low wide Gaussian wings to the profile.
 If the wings are to be done, the program sums up all the accepted
 stars, subtracts the fitted fixed Lorentzian profiles, folds the data
 round the centre and fits the modified Gaussian. The program then plots
 the data and draws the Gaussian it has fitted. If you have
 chosen an intercative terminal, you can then modify the fit by marking
 (via the cursor) points which you think best show the actual profile
 and the program then fits the Gaussian to these points and draws the
 fitted curve on the device. You can then redefine a new set of points
 as often as you like until you are satisfied with the fit.
                                                                               
}\sstdiytopic{Output}{
  The output is done by the files of the parameters OUT:- FIT STARS
  COMPS FCOMPS BADS. These are described in the parameter lists.
                                                                               
}\sstdiytopic{Panel}{
 In the menu-driven mode of this programme, there is the capability
 to interact with this menu in a `windows' type mode. If you choose
 the `Panel' option in the `Option' choice, then if you have a
 workstation (at present only a Vaxstation with VWS windows and
 Decwindows) a small panel appears on the screen. This has what look
 like buttons with all the available options. You select these by
 putting a cursor on the `button' and then pressing a cursor button.
                                                                               
 The panel has a `help' button which lists out one line
 descriptions of the options. It also has a `command' button which
 gives you access to no useful command in itself, but you can
 then enter the full programme help system.
                                                                               
}\sstdiytopic{Parallel Processors}{
 The program can use Caplin transputer arrays as parallel processors.
 These speed up the fitting by each star being worked on by a separate
 processor.
                                                                               
 It takes about 20 secs to load each processor at the beginning of
 the program, so if you only have a limited number of stars to do,
 load the minimum number of processors. To see what the choice is
 in numbers to load, see what files with names in the form of
 'starman:profile{\undersc}farm{\undersc}xxx.app' (where 'xxx' is the number loaded
 by that file) exist.
                                                                               
}\sstdiytopic{Nomencluture}{
\begin{tabular}{|l|p{4in}|}\hline
    Word        &     Meaning \\ \hline
   The profile   &  Usally the nine profile parameters and the profile
                   map. Sometimes just the nine parameters. \\
   Residuals map &  The map of differences of the data from the fits
                   using the mean profile at the time the RESCALC
                   option was run. \\
   Profile Map   &  The empirical array,  F(x,y), described in the
                   method section. This can only be loaded by
                   adding in a processed residuals map. \\ \hline
\end{tabular}
                                                                               
}\sstdiytopic{Tips}{
   Getting a good fit is still an art, although I am working on
   making it a science, so it can be automated. But for now you
   will have to suck it and see. It is a good idea to play around
   for a while, trying the effects of various things on the fit
   and displaying the fit residuals ( not the residuals map ).
                                                                               
   Various points:-

\begin{list}{{-}}{}                                                            
\item   Use bright stars (ESPECIALLY if making a profile map).
                                                                               
\item   Repeat the fit using OLD, to see if the fit has converged. This
        can be checked that only a few iterations are done. (not the 30
        allowed).
                                                                               
\item   The fit carries on till none of the parameters are changing
        fractionally by more than 0.001. This can be changed with the
        FITPARAM option - both for the normal fits and the wing fits.
        This also enables you to change the damping factor to speed up
        the fits, AT THE COST OF A RISK of edging AWAY from the right
        answer, rather than towards it.
                                                                               
\item   Choose which stars you are going to use by the rejection in
        MEAN and REJECT.
                                                                               
\item   It is often good to fix the angle once you have some idea what
        it is.
                                                                               
\item   After you have decided on a fit, run FIT with FIXMEAN and look
        at the results with DISPFITALL, DFINTER. Are you still happy?
                                                                               
\item   Remember, if you have rejected some stars, and then do a fit
        and DISPFITALL, the display for the stars not done shows the old
        fits.
\end{list}
                                                                               
}\sstparameters{

\sstsubsection{ANGLE = {\undersc}REAL (Read)}{
 (Default - the present calculated value   \hspace*{6ex}       Range - 90.0 to 90.0)
                                                                               
 Input the angle, in degrees, of the major axis of the profile,
 anti-clockwise from +ve X direction.
                                                                               
 At the programme start, the value is 0.0
                                                                               
 The first use is to change if needed the angle found by the preliminary
 fit. Thereafter it is used only if the angle is to be fixed.
                                                                               
 By inputting a suitable angle, you can speed the fit up, as it starts
 from a value near its proper one. Also if you have said, via the
 `FIXANGLE' parameter, that the want the angle fixed, then you need
 to say what you want it fixed at. Then both the fit will go faster,
 and the angle will stay at a good value.
                                                                               
 This should be used in practice if you:-

\begin{list}{{-}}{}
\item Want to start the fit near the proper angle.
\item Are sure of the angle.
\item Are sure the stars are round (in which case set the angle to zero).
\item Want to speed the fit up and do not care what the angle is.
\end{list}
                                                                        
}\sstsubsection{BASE = {\undersc}REAL (Read)}{
  (Default - present value    \hspace*{6ex}    Range - -1.0e10 to 1.0e10)
                                                                               
  The value of the base level that underlies the Gaussian wing fit.
  Sometimes the fit does not do a very good fit to the base, and
  this enables you to set (and perhaps fix with `Fixem') this base
  level.
                                                                               
}\sstsubsection{COMMAND = LITERAL (Read)}{
  (Default - `no'       \hspace*{6ex}     Choice - `yes:no')
                                                                               
  This is used when using the `panel' instruction input. It has no
  function other than to permit use of the full help system by
  responding `?' or `??', and to permit use of the `dropping through'
  to the operating system by use of the `\$' symbol before a normal
  DCL instruction, e.g. `\$ DIRECTORY/SIZE'.
                                                                               
  After you have used the help, then just reply `no' with a `return'
  key entry.
                                                                               
}\sstsubsection{DAMP = {\undersc}REAL (Read)}{
  (Default - present value   \hspace*{6ex}     Range - 0.0 to 100.0)
                                                                               
  The damping factor in the fitting least squares method, whilst
  doing the main Lorentz profile fitting.
                                                                               
  This controls the spize of the adjustments in the fitting. The
  smaller the number, the less the internal damping, and so the
  bigger the steps, the faster the fitting, and also the risk of
  shooting out of the best `least squares' path and so mis-fitting.
  In general, values are such that:-
                                                                               
        0.0 = no damping, 0.5 = normal, 1.0 = a lot of damping.
                                                                               
                                                                               
}\sstsubsection{DFINTER = LITERAL (Read)}{
  (Default - last choice   \hspace*{6ex}     Choices - see below)
                                                                               
 Which of the following options, to do with looking at the fits 
 and modifying them, do you want to do?

  This is the interaction with the display of the raw images round
  each star and those images after the fit made has been subtracted
  from the image.
                                                                               
 Enables you to pan and zoom at the display of the stars and the
 residuals of the fits. You can also insert and remove companion
 stars, faint companions, and bad areas; get the values in the
 images or residuals; remove/replace the coloured lines; display
 star positions as spots or crosses.
                          
\begin{tabular}{|c|l|}\hline                                                     
  Option   &   Function \\ \hline
  Blank    &   Remove an area from the calculations \\
  Clear    &   Clear the display \\
  Comp{\undersc}br  &   Add a bright or close companion \\
  Comp{\undersc}fa  &   Add a faint or distant companion \\
  Dsclose  &   Close display window \\
  Grid     &   Display calculating box in each display box \\
  Main     &   Reposition a main star \\
  Ohide    &   Hide all the overlay colours \\
  Oshow    &   Reveal all the overlay colours \\
  Paint    &   Paint up companions and boxes \\
  Posntype &   Change posn markers between spot and crosses \\
  Return   &   Return to the main program \\
  Rvalues  &   Type out values in residuals image in cursor
               specified area \\
  Uncomp{\undersc}br &  Remove a bright or close companion \\
  Uncomp{\undersc}ft &  Remove a faint or distant companion \\
  Ungrid    &  Remove display of calc box in each display box \\
  Unblank   &  Restore an area to the calculations \\
  Values    &  Type values in main image in cursor specified area \\
  Zoom      &  Zoom and pan display with the cursor \\ \hline
\end{tabular}
                                                                   
Buttons for Zoom/pan work:- 

\hspace*{4ex}\begin{tabular}{|c|l|}\hline
Action                         & Effect \\ \hline
Left Button twice              & zoom /2 \\
Centre Button twice            & zoom x2 \\
Left Button then Centre Button & pan \\
Right button once              & return \\ \hline
\end{tabular}
                                                                               
                                                                               
}\sstsubsection{DSTYPE  = LITERAL (Read)}{
 (Default - `decw' \hspace{6ex}     Choice - `ikon:none:vws:decw')

  Type of display to be used:-

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Ikon    &    IKON image display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{FITLIM = {\undersc}REAL (Read)}{
  (Default - present value       \hspace*{6ex} Range - 0.0 to 100.0)
                                                                               
  The `limit' in the profile parameter changes when the fit is thought to
  have settled, while doing the main Lorentz profile fit.
                                                                               
  It is the fractional change, at an iteration step in the least squares
  fit, in each of the profile parameter values that are changing. Their
  changes must be less than this before the least squares iterations
  stop. Normal value = 0.001.
                                                                               
  See the 'Htlim' parameter for the limit on the fractional change
  in the star height.
                                                                               
}\sstsubsection{FIXANGLE = LITERAL (Read)}{
 (Default - `no'     \hspace*{6ex}    Choice - `yes:no')
                                                                               
 Option for fixing the angle to the X axis of the major axis of the
 Lorentzian component of the profile. (THETA in the profile equation.)
 This is measured in an anti-clockwise direction, starting from the
 +ve X axis direction.
                                                                               
 At the programme start, it is not fixed.
                                                                               
 This should only be used if you are either certain of the angle, or
 sure the stars are round (in which case set the angle to zero).
                                                                               
}\sstsubsection{FIXEM = {\undersc}INTEGER(4) (Read)}{
  (Default - present values    \hspace*{6ex}    Choices - 0 or 1)
                                                                               
  This inputs four integer values, each either 0 or 1. These are input
  as (say) `1,0,1,0'. These values are then switches as to whether the
  wing parameters are fixed or varying when doing the wing fit.
                                                                               
  0 = Fix ;    1 = Free (varying)
                                                                               
                                                                               
}\sstsubsection{FIXPROF = LITERAL (Read)}{
 (Default - present value     \hspace*{6ex}    Choice - `yes:no')
                                                                               
 Option for whether to have the main profile parameter, that you are
 being asked about, fixed or not.
                                                                               
 At the programme start, none are fixed.
                                                                               
 You are asked about five of the parameters in the main profile
 (Rmaj, Rmin, Power, PRmaj, PRmin) in turn. (The angle parameter is
 then asked for with the control `FIXANGLE', but that is separate
 to this particular bit of help.)
                                                                               
 The usual reason for fixing these parameters is that you are sure
 of what they are, and/or you do not want them to change, and/or
 you want to speed the fit up.
                                                                               
 The values of the profile can be input via the OPTION:PROFCHANGE
 and then the 'VALUE' input. But in this case, all the profile
 parameters are asked for, the 6 of the Lorentzian and the 3 of the
 Gaussian.
                                                                               
}\sstsubsection{FLIP = {\undersc}INTEGER (Read)}{
 (Default - 0    \hspace*{6ex}  Choices -  -n to +n, n being the number of stars in list)
                                                                               
 The number of the star to have its fitted angle flipped by 180 degs.
 If +n, then the nth star has its angle increased by 180deg, if -n
 then the nth star has it decreased by 180. This sometimes helps
 in the calculation of the mean.
                                                                               
 For no more changes, type 0.
                                                                               
                                                                               
}\sstsubsection{HEIGHT = {\undersc}REAL (Read)}{
  (Default - present value       \hspace*{6ex} Range - -1.0e10 to 1.0e10)
                                                                               
 Set the value of the `Wing height' parameter in the modified
 Gaussian profile. This is the fractional height of the Gaussian
 wing compared to the main Lorentz profile.
                                                                               
 It is usual to set this to more than 0.0. If it is less than
 zero, then if the wing fit to determine the wing profile is done,
 the result is unpredictable.
                                                                               
                                                                               
}\sstsubsection{HTLIM = {\undersc}REAL (Read)}{
  (Default - present value       \hspace*{6ex} Range - 0.0 to 100.0)
                                                                               
  The `limit' in the height changes when the fit is thought to
  have settled, while doing the main Lorentz profile fitting.
                                                                               
  It is the fractional change, at an iteration step in the least squares
  fit, in the height of the main star that is  changing. Its changes must
  be less than this before the least squares iterations stop.
  Normal value = 0.001.
                                                                               
  See the 'Fitlim' parameter for the limit on the fractional change
  in the profile values.
                          
}\sstsubsection{IDINAME = LITERAL (Read)}{
 (Default - `ikon'      \hspace{6ex}       Choice - any)
    
   The local name defining the display device. The list of names
   call be seen in the file with the logical name `GNS{\undersc}IDINAMES'.
   Remember that the case of the letters matters.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                      
 The name of the file containing a 2-D image which has the stars
 in it whose profile it is desired to measure.
                                                                               
 A null `return' entry is not allowed.
                                                                               
 This image must be in the standard DSCL .BDF 16-bit interger*2
 format.
                                                                               
}\sstsubsection{INSTARS = BDF (Read)}{
  (Default - null)
                                                                               
 The name of the file containg the table of the positions of the stars
 to be fitted.
                                                                               
 A null `return' entry is not allowed.
                                                                               
 This can be  either a simple (X,Y list), or it could contain more
 information. For example, the output star table of the `OUTSTAR' parameter
 of PROFILE can be fed in here, and all the PROFILE information on the
 fitting to the stars would be available.
                                                                               
 Thus a run on PROFILE could take off from where it stopped.
 (If other information on companion stars and bad areas is needed that
 can also be input with the OPTION:FILELOAD command.) Also the output
 table from MEASURE could be used as this input, and the profile and
 height information would be taken as wellas the X,Y positions. Indeed,
 for any table with 'HEIGHT' as one ofthe descriptors, the heights would
 be input. This kind of preliminary information is useful in speeding up
 the fitting.
                                                                               
}\sstsubsection{MAPINTER = LITERAL (Read)}{
 (Default - last option     \hspace*{6ex}   Choice - see below)
                                                                               
 Which of the following options, to do with
 looking at the empirical map closely and modifying it, do you want to do?

 This enables you to look at the empirical profile map closely and to
 modify it.

\begin{tabular}{|c|l|}\hline                                                                               
  Option    &   Function \\ \hline
  Clear     &   Clear the display \\
  Original  &   Load map as it was before entering this MAPINTER \\
  Return    &   Return to main OPTION choice \\
  Spolyin   &   Define a polygon with the cursor and smooth the
                area inside \\
  Spolyout  &   Define a polygon with the cursor and smooth the
                area outside \\
  Smooth    &   Smooth profile map by >top hat> NxM box \\
  Values    &   Type out values for an area of the profile map \\
  Zero      &   Zero all profile map \\
  Zoom      &   Zoom and pan display \\
  Zpolyin   &   Define a polygon with the cursor and zero the area
                inside \\
  Zpolyout  &   Define a polygon with the cursor and zero the area
                outside \\
  Zrect     &   Define a rectangle with the cursor and zero the
                area inside \\ \hline
\end{tabular}
                                                                  
 When defining the polygons, you use the cursor and the buttons. Place
 the cursor at consecutive vertices of the desired polygon, and press
 any button. To end the input of vertices, do a repeat press, without
 moving the cursor, on the last vertex. A line showing where the
 polygon lies is output whilst you are doing this
                                                                               
}\sstsubsection{MORE = LITERAL (Read)}{
 (Default - `yes'     \hspace*{6ex}    Choice - `yes:no')
                                                                               
  Do you want more of the lines of the help on the option listing?
                                                                               
  Used in the help system for in-line help on 'option'-type
  parameters, which gives an immeadiate help. This is, as it were,
  an preliminary stage before the main programme help stage.
                                                                               
}\sstsubsection{NUMBER = {\undersc}INTEGER (Read)}{
  (Default - see below   \hspace*{6ex}     Choice - se below)
                                                                               
  This is asked for in a number of different contexts. It thus has
  a number of various uses, depending on option in the `OPTION'
  paremter that you have selected:-
                                           
\begin{tabular}{|c|p{4in}|}\hline                                    
  Option  &   Use \\ \hline
  Listcomp&   Number of star you want the complete fit details for. \\
  Fixxy    &  Number of star you whose position you want fixed (Minus
              that number frees the position; 0 exits from this
              option). \\
  Fitnumber & Number of the star you want fitted. \\
  Dispfitnum & Number of the star you want displayed. \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the Starman programmes use all three, with
  the right-hand button being used mainly as the `exit' button. 

  With two buttons, then the third button is simulated by pressing 
  both of the buttons down, with the middle one being pressed slightly 
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will 
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{NUMPAR = {\undersc}INTEGER (Read)}{
  (Default - 16      \hspace*{6ex} Range - 1 to 100000)
                                                                               
 The number of parallel processors to load for use.
                                                                               
 Commonly, the choice is 2, 4, 16, and 20.
                                                                               
 It takes about 20 secs to load each processor at the beginning of
 the program, so if you only have a limited number of stars to do,
 load the minimum number of processors. To see what the choice is
 in numbers to load, see what files with names in the form of
 'starman:profile{\undersc}farm{\undersc}xxx.app' (where 'xxx' is the number loaded
 by that file) exist.
                                                                               
}\sstsubsection{OK = LITERAL (Read)}{
  (Default - `various'    \hspace*{6ex} Choice - `yes:no')
                                                                               
 This can be demanded at various stages in the programme,

 What is wanted here will be clear from the previous operation, or 
 information line just typed out. It generally gives you
 a chance to agree or disagree with some question that the programme
 wants answering.
                                                                               
 Often the programme will suggest the 'usual' answer. For example, you
 may have chosen to calculate the residuals map before you have
 calculated a mean profile, which would be a silly thing to do.
 The programme checks if you really mean this. Then by typing NO, you
 can escape back to the OPTION choice. (Of course, you may want to do
 this for some reason, perhaps the default profile is usable, in which
 case just type YES.)
                                                                               
}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - see below     \hspace*{6ex}   Choice - see below)
                                                                               
 What operation, from a menu of possible choices, to do next?
                                                                               
 It is the general option choice, which you repeatedly come back to after
 performing operations. You select one of the menu operations.
                                                                               
 When you started the programme, you were asked for the input image and
 input star list. Then you started on this option choice. Generally the
 default option is a repeat of the last option. However at the start,
 a standard set of options is given as the default
                                                                               
 Your choices are:-

\begin{tabular}{llllll}                         
 Angle      &Boxsize    &Clear      &Compzero   &Dispinter  &Display \\
 Dsclose    &Exit       &Fitall     &Fitalldisp &Fitchange  &Fitinter \\
 Fitnumber  &Fitnumdisp &Fitparam   &Fixxy      &Infiles    &Listcomp \\
 Listfit    &Ignore     &Mapadd     &Maddisp    &Mapinter   &Mapscale \\
 Mapsize    &Mapuse     &Mapzero    &Mean       &Newimage   &Newstars \\
 Panel      &Parallel   &Plot       &Printinter &Profchange &Proffix \\
 Reject     &Rescalc    &Resdisp    &Resinter   &Ring       &Rough \\
 Shiftxy    &Store      &Trial      &Volume     &Wing       & \\
\end{tabular}
                                                                               
 For a more detailed description of these, see the `Menu' section which
 gives a one line description of all of these options, and for a more
 extensive help on some of them, see the 'Detailed Description' section.
                                                                               
}\sstsubsection{OUTPLOT = BDF (Write)}{
  (Default - null)
                                                                               
  Name of file to put 1-D profile Gaussian wing plot into.
                                                                               
  This is output as a table, with rows given the values at
  different radial distances from the centre. The columns
  contain the data as:-

\begin{tabular}{|c|c|l|}\hline                                                                               
 Column &    Header           &Contents \\ \hline
  1 &    DISTANCE    & Distance from centre \\
  2 &    FIT         & Value of fitted Gaussian profile \\
  3 &    DATA        & Actual data values fitted to \\
  4 &    RESIDUALS    & Data - fit \\ \hline
\end{tabular}
                                                                               

}\sstsubsection{PDSTYPE = LITERAL (Read)}{
 (Default - `decw'      \hspace{6ex}    Choice - `none:vws:decw')

  Image display device to put windows-type `panel' of options
  up on.

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{POSN = {\undersc}REAL(2) (Read)}{
  (Default - present position.     \hspace*{6ex}   Range - -1.0e10 to 1.0e10)
                                                                               
  Position in image to fix star at.
                                                                               
}\sstsubsection{POWER = {\undersc}REAL (Read)}{
 (Default - Present value       \hspace*{6ex}  Range - 0.1 to 100.0)
                                                                               
 Set the value of the `Wing power' parameter in the modified
 Gaussian profile.
                                                                               
 It is usual to have it fixed, as this prevents low values of it being
 found which give unrealistically high values of the profile at great
 distances (which are not shown in the display of the fitting.)
                                                                               
}\sstsubsection{RADIUS = {\undersc}REAL (Read)}{
  (Default - `Present Value'   \hspace*{6ex} Range - 1.0e-20 to 1.0e20.0)
                                                                               
  The Radius, QR, in the modified Gaussian wing part of the profile.
                                                                               


$$I(x,y)= H.\left(\frac{1}{1+d_{1}^{P(1+d_{2})}}+QH.e^{-d_{3}^{QP}}+F(x,y)\right)+A+B.x+C.y$$


where 

\begin{tabular}{l l l}

 $ I(x,y)$ &$=$& the value of the star profile at pixel position x,y \\ 

$H $&$=$&  the star peak height\\

$x_{0}, y_{0} $&$=$& the star centre position\\

 $A, B, C $&$=$& the sloping background \\

$ d_{1} $&$=$&$ \sqrt{\left(\frac{x_{1}}{RX}\right)^2+\left(\frac{y_{1}}{RY}\right)^2}$ \\


$ d_{2} $&$=$&$ \sqrt{\left(\frac{x_{1}}{PRX}\right)^2+\left(\frac{y_{1}}{PRY}\right)^2}$\\ 
$x_{1} $&$=$&$ (x-x_{0}).cos(THETA) + (y-y_{0}).sin(THETA)$ \\
$y_{1} $&$=$&$ -(x-x_{0}).sin(THETA) + (y-y_{0}).cos(THETA)$ \\ 
$d_{3} $&$=$&$\sqrt{\left(\frac{x-x_{0}}{QR}\right)^2+\left(\frac{y-y_{0}}{QR}\right)^2}$ \\

\end{tabular}

(For a full description of this see the `profile' section in the Starman 
manual.)

}\sstsubsection{RESINTER = LITERAL (Read)}{
 (Default - last option    \hspace*{6ex}    Choice - see below)

 Which of the following options, to do with
 looking at the residuals map closely and modifying it, do you want to do?
                       
                                                        
\begin{tabular}{|c|p{4in}|}\hline                
  Option    &   Function \\ \hline
  Clear      &  Clear the display \\
  Fill       &  Fill the empty subdivisions by interpolation from
                full ones \\
  Original   &  Go back to original values form last calculation
                from fits \\
  Relclear   &  Clear display and reload with present values \\
  Return     &  Return to main OPTION choice \\
  Smooth     &  Smooth residuals by >top hat> NxM box. Array must
                be full \\
  Spolyin    &  Define a polygon with the cursor and smooth the
                area inside \\
  Spolyout   &  Define a polygon with the cursor and smooth the
                area outside \\
  Values     &  Type out values for an area of the residuals map \\
  Zero       &  Zero all residuals \\
  Zoom       &  Zoom and pan display \\
  Zpolyin    &  Define a polygon with the cursor and zero the area
                inside \\
  Zpolyout   &  Define a polygon with the cursor and zero the area
                outside \\
  Zrect      &  Define a rectangle with the cursor and zero the
               area inside \\ \hline
\end{tabular}
                                                                               
 When defining the polygons, you use the cursor and the buttons. Place
 the cursor at consecutive vertices of the desired polygon, and press
 any button. To end the input of vertices, do a repeat press, without
 moving the cursor, on the last vertex. A line showing where the
 polygon lies is output whilst you are doing this
                                                                               
                                                                               
}\sstsubsection{SCREEN = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, size of image      \hspace{6ex} Range - 1 to large)

  Size of screen or window to open. 

  The default size is that of the image, unless the image is too large
  to fit on the screen, when the image will be binned down by an integer
  factor for display. The default size will then be this binned down size.

}\sstsubsection{USEMAP = LITERAL (Read)}{
 (Default - present state    \hspace*{6ex}    Choice - `yes:no')
                                                                               
 A choice as to wether to use whatever Profile Map exists in the
 fitting or residuals display. Generally any action that zeroes the
 Profile Map, sets this option to no, and any that loads a non-zero
 one sets it to yes.
                                                                               
}\sstsubsection{WOPTION = LITERAL (Read)}{
  (Default - last choice     \hspace*{6ex}  Choices - see below)
                                                                               
 Which of the following options, to do with
 looking at the wing profile closely and modifying it, do you want to do?

  This is the option to determine the wide Gaussian wing part of the
  profile. You can:-

\begin{list}{{-}}{}
                                                                               
\item Look at a larger area round each star to see if there are areas
      to be blanked off, or stars to be marked so that the fits can
      be redone.
\item Fit the stars. This does a fit, and calculates the residual
      radial distribution of data that is left.
\item Look at the 1-D distribution of residual data on a graph,
      and if it looks corrupted input your own residual distribution.
\item Fit the wing profile parameters to the 1-D residual profile,
      either by fitting to calculated points, or fitting to the
      hand input points.
\item Look at the wing profile parameter fit to the 1-D distribution.
\item Put in your own estimates of the wing profile parameters, and
      say if they should be fixed or not.
\end{list}
                                                                               
 The point about the option for hand inputting is that sometimes
 the raw points are disturbed by miscellaneous things in the large
 areas used in determining the wing profile. You can thus use
 some judgement and put the radial distribution where you think it
 should be.
                                                                               
 In putting your own set of points of the radial distribution, be sure
 to put in enough that the fit can make a good fit to them.
  
\begin{tabular}{|c|l|}\hline 
  Option    &    Function \\ \hline
  Display   &    Display/refine large area round the stars \\
  Fit       &    Fit stars in the large areas round each star \\
  Setval    &    Insert your own wing profile values \\
  Return    &    Return to main option \\
  Type      &    Type out wing profile parameters \\
  Wdisplay   &   Display the wing points graphically \\
  Wfitcursor  &  Fit to wing points input by cursor \\
  Wfitdisplay &  Plot out fitted wing profile on the graph \\
  Wfitraw     &  Fit to actual wing data points \\
  Wputcursor  &  Input wing points by cursor \\ \hline
\end{tabular}
                                                                
  A normal course might be to:-

\begin{list}{{-}}{}

\item {\bf Display \hspace*{2ex}} Display the x2 area and blank off or mark up
                  the extra stars in the large wing area
\item {\bf Fit \hspace*{2ex}}    Fit the stars in the large wing area and calc
                  the distribution of wing data points
\item {\bf Wdisplay \hspace*{2ex}}    Look at the wing data points
\item {\bf Wputcircosr \hspace*{2ex}}    Put your own smoothly distributed wing data
                   points by using the graphics cursor
\item {\bf Wfitcursor \hspace*{2ex}}    Fit the wing parameters to your cursor input
\end{list}
                                                                               
  After this you can loop round changing the cursor positions
  and/or refining the fit. The fit is usally very delicate
  and it is common to adjust the profile parameters by hand
  before a number of fits to get a good fit.
                                                                               
  Then -Return-  back to the main option.
                                                                               
  One point to note is that using the cursor to mark a position on the
  graph, you place the cursor and press a keyboard key. You cannot use
  the cursor mouse buttons (if any).
                                                                               
}\sstsubsection{FITTYPE = LITERAL (Read)}{
   (Default - 'old'    \hspace*{6ex} Choice - 'fixmean:fixold:mean:none:old:update')
                                                                               
   Method of inputting starting values to the profile parameters
   in the fit iterations
                                                                               
   This is done either to speed things up, or get better values out of
   the fit. This can also provide a temporary override on the `fixing'of
   the profile parameters, by fixing them for this go.
                                                                               
   Choices:-

\begin{tabular}{|c|p{4in}|}\hline
   Option   &   Function \\ \hline
   Fixold   &   Fix profile at last fit of each star (no profile 
                fitting) \\
   Fixmean  &   Fix at the last calculated mean profile (no profile 
                fitting) \\
   Mean     &   Take last calculated mean profile \\
   None     &   Do not do fit \\
   Old      &   Take last fit for each star \\
   Update   &   Take mean of fits made of previous stars in this 
                list \\ \hline
\end{tabular}
                                                                   
}\sstsubsection{VALUE = {\undersc}REAL (Read)}{
  (Default - present value  \hspace*{6ex} Range  -1.0e20 to 1.0e20)
                                                                               
  After the OPTION:PROFCHANGE choice, you are then asked for the values
  of the 9 parameters of the entire profile. The 6 of the Lorentx profile
  (Rmaj, Rmin, Power, PRmaj, PRmin, Angle) and the 3 of the Gaussian
  wing (Fractional height, Radius, Power). The angle should be input
  in degrees.
                                                                               
  At the programme start, the values are:-

     (2.0, 2.0, 2.2, 10.0, 10.0, 0.0; 0.0, 10.0, 2.0).
                                                                               
  (These can be changed as a result of doing the OPTION:ROUGH choice.)
                                                                               
  Depending on which of the parameters you have/have not fixed (at the
  start none are fixed), these cannot/can vary during a fit.
                                                                               
}\sstsubsection{SCALE = {\undersc}REAL (Read)}{
  (Default - last   \hspace*{6ex}    Range - 1.0e-8 to 1.0e8)
                                                                               
  Value to scale the standard empirical profile map by. (Not the
  factor to multiply the last scaled map, but the absolute scale, i.e.
  `scale=10, and then `scale=2' has the same effect as scale=2).
                                                                               
  This is not really useful.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
   (Default - various   \hspace*{6ex}    Choice -any)
                                               
  Title to add as a descriptor to the output file.
                                                                               
  The output file in question is the one you are opening and
  writing to. It can be:-

 \hspace*{3ex} - \hspace*{2ex} the profile image file \newline
 \hspace*{3ex} - \hspace*{2ex} the stars table file \newline
 \hspace*{3ex} - \hspace*{2ex} the companions/bad areas table file \newline
 \hspace*{3ex} - \hspace*{2ex} the Gaussian wing profile table file 
                                                                               
                                                                               
}\sstsubsection{VOLRAD = {\undersc}REAL (Read)}{
  (Default - present value  \hspace*{6ex}   Range - 1.0 to 1.0e6)
                                                                               
  If calculating profile volume, how many pixels out to carry calculations.
                                                                               
  This is a rather minor parameter. The programme will normally start with
  a value of 30 pixels. This may be changed when a `profile' image file is
  read in, as that file contains its own 'volrad' parameter.
                                                                               
}\sstsubsection{REJECT = {\undersc}INTEGER (Read)}{
 (Default - 0   \hspace*{6ex}  Choice - -n to +n, n being the number of stars in list)
                                                                               
 The number of the star to be rejected (+n), or to be accepted in spite
 of having been rejected (-n). If any star has been rejected or accepted,
 the mean fit is recalculated and another chance given for the fit.
                                                                               
 If there are no more changes to be made, type 0.
                                                                               
}\sstsubsection{INCOMPS = BDF (Read)}{
  (Default - null)
                                                                               
 Input an existing table with the companions, faint companions and
 bad areas in it.
                                                                               
 A `blank' entry of just typing `return' will result in no table being
 input.
                                                                               
 The table must be in the format of the `OUTCOMP' output of PROFILE, and
 will almost certainly have been made from a previous run of PROFILE.
                                                                               
 A 'Companion' is a star that is close and comparably bright
 to the target star. A faint star in the fitting box is not a companion,
 neither is a bright star on the edge of the box. (These are the faint
 companions.) In the fitting, companion stars are fitted along with
 the target stars, with their profiles being varied with the target stars
 to minimise the total residuals of the joint fit. Up to seven
 companion stars are allowed for each target star, and eight faint
 companions. Up to sixteen bad areas can be marked near each target star.
                                                                               
}\sstsubsection{INPROF = BDF (Read)}{
  (Default - null)
                                                                               
 Input an existing image containing the profile.
                                                                               
 This image, contained in a file, holds the profile in the standard
 Starman way, that is the profile parameters are the descriptors
 of the image and the profile empirical map, if any, is contained
 in the image itself.
                                                                               
 A `blank' entry of just typing `return' will result in no image being
 input.
                                                                               
 The image must be in the standard format. It may have been produced via
 the `OUTPROF' output of PROFILE during this or a previous run, or
 may have been generated by another means.
                                                                               
}\sstsubsection{OUTPROF = BDF (Write)}{
  (Default - null)
                                                                               
 The name of the new output file containing the image into which the
 present profile parameters and empirical profile map are to be written
 into.
                                                                               
 A `blank' entry of just typing `return' will result in no file being
 made.
                                                                               
 The parameters of the profile (RX,RY,P,PRX,PRY,THETA,QH,QR,QP,VOL)
 are written as descriptors of this file, together with the
 XMAG and YMAG descriptors which show the subdivision of the image
 pixels into a finer spaced grid in which the profile mean residuals
 are calculated. The size of this image is about 7*max(YMAG,XMAG)*RX,RY
 with the precise factor depending on the angle of the
 profile to the X-Y directions.
                                                                               
 The file is an Integer*2 (16bit) file and the residuals are stored
 as the residuals that a star of peak height 10 000 would have (but
 this is noted by the BSCALE factor, so other programs get the right
 values.)
                                                                               
 This file can be used as input to MEASURE (qv), and can be re-input
 into PROFILE, via (INPROF) at any time.
                                                                               
                                                                               
}\sstsubsection{OUTSTAR = BDF (Write)}{
  (Default - null)
                                                                               
 The name of the new output file containing the table with the details
 of the present individual fits to the stars.
                                                                               
 This table can be re-input (via INSTARS) into PROFILE to carry on the
 analysis when starting again.
                                                                               
                                                                               
}\sstsubsection{OUTCOMP = BDF (Write)}{
  (Default - null)
                                                                               
 The name of the new output file containing the table with the positions
 and fitted heights of the companions and faint companions, and the
 positions of the boxes containing the bad areas near the stars.
                                                                               
 This file can be re-input into PROFILE, via (INCOMPS) at any time.
                                                                               
                                                                               
}\sstsubsection{XAREA = {\undersc}INTEGER(2) (Read)}{
 (Default - 1,X size.     \hspace*{6ex} Range - 1 to X size, 1 to X size)
                                                                               
 The X region of the profile or residuals map you want to type out.
                                                                               
                                                                               
}\sstsubsection{YAREA = {\undersc}INTEGER(2) (Read)}{
 (Default - 1,Y size.   \hspace*{6ex}   Range -  1 to Y size, 1 to Y size)
                                                                               
 The Y region of the profile or residuals map you want to type out.
                                                                               
                                                                               
}\sstsubsection{SIZE = {\undersc}INTEGER(2) (Read)}{
  (Default - present values.   \hspace*{6ex}     Range - 1 to 200)
                                                                               
  Input two numbers as (say) 10,12.
                                                                               
  Input the X and Y size of the area of either of:-
                                            
\begin{list}{{-}}{}                                   
\item The fitting box (the area that the fits are done in, and
      which is displayed on the image display).
\item The profile map. This does not have to be the same size
      as the fitting area. The size is the number of pixels of
      the image that the profile map covers. This can be
      different than the computer storage size and the size
      of the profile file image, since the profile map may
      map to sub-divided image pixels, and thus contain more
      data points.
\end{list}                                                                               
                                                                               
}\sstsubsection{SMSIZE = {\undersc}INTEGER(2) (Read)}{
 (Default - 3   \hspace*{6ex}  Choices - all +ve odd integers 3 to 32767)
                                                                               
  Input two number as (say)  `5,5'.
                                                                               
 These are the sizes of the sides of the box to be used in the
 smoothing of the residuals or profile maps.
                                                                               
 The smoothing is done by replacing each pixel with the average
 value of the pixels in the box surrounding that pixel. ('Top hat'
 smoothing.) This is why the sides must have an odd number of
 pixels.
                                                                               
 If the sides of the box are larger than the map to be smoothed
 or if the area of the box is more than 32767 pixels, the
 input wont work, and you are asked again.
                                                                               
                                                                               
}\sstsubsection{SHIFTXY = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0        \hspace*{6ex}   Ranges - -1.0e20 to 1.0e20)
                                                                               
  Input as two real numbers as (say)  1.5,20.2
                                                                               
  The shift in X and Y on the input image to be applied to all the
  star positions, with their companions, but not to the bad areas.
                                                                               
  This is useful when you are doing an image, and you have an input
  list of star positions, which is displaced for this image.
                                                                               
                                                                               
}\sstsubsection{WDAMP = {\undersc}REAL (Read)}{
  (Default - present value      \hspace*{6ex}   Range - 0.0 to 100.0 )
                                                                               
  The damping factor in the fitting least squares method, whilst
  doing the 1-D Gaussian wing profile fitting.
                                                                               
  This controls the spize of the adjustments in the fitting. The
  smaller the number, the less the internal damping, and so the
  bigger the steps, the faster the fitting, and also the risk of
  shooting out of the best `least squares' path and so mis-fitting.
  In general, values are such that:-
                                                                               
        0.0 = no damping, 0.5 = normal, 1.0 = a lot of damping.
                                                                               
}\sstsubsection{WFITOK = LITERAL (Read)}{
 (Default - `no'     \hspace*{6ex}    Choice - `yes:no')
                                                                               
  Have the good stars been fitted with a fixed profile to the present
  data with the present companions and blank areas? By the present
  data is meant the data in the normal 'small' boxes, not that in the
  'large', 'wing' boxes round each star.
                                                                               
  If not, a fit will be done to the 'small' boxes.
                                                                               
}\sstsubsection{WFITLIM = {\undersc}REAL (Read)}{
  (Default - present value     \hspace*{6ex}   Range - 0.0 to 100.0)
                                                                               
  The `limit' in the profile parameter changes when the fit is thought to
  have settled, while doing the 1-D Gaussian wing profile fitting.
                                                                               
  It is the fractional change, at an iteration step in the least squares
  fit, in each of the profile parameter values that are changing. Their
  changes must be less than this before the least squares iterations
  stop. Normal value = 0.001.
                                                                               
  See the 'Whtlim' parameter for the limit on the fractional change
  in the star height.
                                                                               
}\sstsubsection{WHTLIM = {\undersc}REAL (Read)}{
  (Default - present value     \hspace*{6ex}   Range - 0.0 to 100.0)
                                                                               
  The `limit' in the height parameter changes when the fit is thought to
  have settled, while doing the 1-D Gaussian wing profile fitting.
                                                                               
  It is the fractional change, at an iteration step in the least squares
  fit, in the star fractional height parameter value that is changing.
  Its changes must be less than this before the least squares iterations
  stop. Normal value = 0.001.
                                                                               
  See the 'Wfitlim' parameter for the limit on the fractional change
  in the profile values.
                                                                               
                                                                               
}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} RADIUS}
 
\sstroutine{RADIUS}{Finds Mean Radius of Stars in an Image}{
 
\sstdescription{ 

  This finds the mean star radius for stars in an image. It does this
  by making a Fourier transform of the image and looking for the 
  right scale length in the transform. 


  It thus works well when there are only stars, even when very crowded or
  if there are saturated stars in the image. It does not work so well
  (or indeed can do very badly), if there is significant signal at other
  scales, from objects such as lots of small galaxies, or a single large
  galaxy, or any other extended source, or any artifacts in the image.
                                                                               
  The user can select an area of the image for the programme to confine 
  its attention to, and to select one of three ways to allow for the
  sky background.

  The radius output is the Half Power Half Width.
                                                                               
}\sstdiytopic{Use}{
\begin{enumerate}
\item Input the image
\item Select the area to use
\item Select the sky removal method
\item Decide whether to look at the fit to the Fourier transform
\item Get the star profile radius typed out
\end{enumerate}

  The radius is also output as a parameter of the program, so other 
  programs can access it. To get round contaminating objects, optionally 
  a sub-area of the image can be used.
                                                                               
 One can also get a graphical output of the fitting to the folded
 Fourier transform, to see how well it is doing.

}\sstdiytopic{Method}{
 The area is extracted from the image. The sky level at each pixel is removed in
 one of three ways:-

\begin{enumerate}
\item The sky is mapped as interpolated between the means in sub-areas 
      of the selected area of the image.
\item The sky is set at the mean of selected area of the image (Default)
\item The sky is set at the value of the pixel with the minimum value
      in the selected area of the image 
\end{enumerate}

Then a 2-D FFT is fitted to the area, and shifted into a 1-D plot. A 
modified Gaussian is fitted to this, and the radius of that Gaussian
is then translated back to a `star' radius through an empirical look-up
table.

}\sstparameters{
                                                                               
\sstsubsection{ENOUGH = LITERAL (Read)}{
  (Default - `yes'  \hspace*{6ex}   Choice - `yes:no')
                                                                               
  Had enough of the display of the FFT fit?
                                                                               
}\sstsubsection{DOPLOT = LITERAL (Read)}{
  (Default - `no'  \hspace*{6ex}   Choice - `yes:no')
                                                                               
  Plot as a graph the plot of the fit to radially binned data from
  the FFT of the image?
                                                                               
}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question, 
  in a different way. A response here of `?' will bring up a listing 
  of all the possible names of graphics devices which are supported 
  on your machine, and you then input the appropriate name.
                                                                               
}\sstsubsection{IMAGE = BDF (Read)}{
  (Default - null)
                                                                               
   The name of the file containing the input image
                                                                               
}\sstsubsection{POWER = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The output parameter giving the power in the fit to the FFT.
                                                                               
}\sstsubsection{RADIUS = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The ouput parameter which is loaded with the result. This number
  is also typed out on the command line.
                                                                               
  The radius is the Half Power Half Width.
                                                                               
}\sstsubsection{RAD1 = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The output parameter giving the first approximation to the final
  radius estimate.
                                                                               
}\sstsubsection{RFFT = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The output parameter giving the radius of the FFT fit.
                                                                               
}\sstsubsection{SIGNAL = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The output parameter giving the fraction of area of image covered
  by stars.
                                                                               
}\sstsubsection{SIZE = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The output parameter giving the FFT size.
                                                                               
}\sstsubsection{SKYTYPE = {\undersc}INTEGER (Read)}{
  (Default - 2        \hspace*{6ex} Range - 1 to 3)
                                                                               
  Choice of method to be used when the programme estimates the sky
  level at each pixel of the selected area of the image. Which choice 
  you use depends on the type of data in the image.

\begin{tabular}{|c|p{4in}|}\hline 
  Choice     & Method \\ \hline
    1        & Sky chosen as interpolated between means in sub-areas of image \\
    2        & Sky chosen as value of mean of image \\
    3        & Sky chosen as value of minimum pixel in image \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{XAREA = {\undersc}INTEGER(2) (Read)}{
   (Default - 1, Xlength  \hspace*{6ex}   Range - 1 to X length)
                                                                               
   The X coords of the start and end of the image sub-area to use.
   Usually, take the default entire image
                                                                               
}\sstsubsection{XBOXSIXE = {\undersc}INTEGER(2) (Read)}{
   (Default - ?    \hspace*{6ex}   Range - 64 to half X size of area selected)
                                                                               
   A relatively unimportant parameter giving the X scale on which slow
   variations are to be ignored. Usually you should adopt the default
                                                                               
}\sstsubsection{YAREA = {\undersc}INTEGER(2) (Read)}{
   (Default - 1, Xlength \hspace*{6ex}   Range - 1 to X length)
                                                                               
   The Y coords of the start and end of the image sub-area to use.
   Usually, take the default entire image
                                                                               
}\sstsubsection{YBOXSIXE = {\undersc}INTEGER(2) (Read)}{
   (Default - ? \hspace*{6ex}   Range - 64 to half Y size of area selected)
                                                                               
   A relatively unimportant parameter giving the Y scale on which slow
   variations are to be ignored. Usually you should adopt the default
                                                                               
}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} SIMPLEMAG}
 
\sstroutine{SIMPLEMAG}{Simple Aperture or Profile Photometry }{
 
\sstdescription{ 
                                                                               
  This programme does three kinds of photometry. They are:-
                                                             
  \begin{list}{{-}}{}                  
   \item Simple aperture photometry on isolated stars.
                                                                               
   \item A simple determination of a mean Gaussian profile from isolated
     stars.
                                                                               
   \item Simple Gaussian profile photometry on isolated stars.
   \end{list}
                                                                               
 The three kinds are executed by entirely different sections of
 the programme. These sections can be thought of as separate
 programmes, one of which is chosen after entering SIMPLEMAG.
                                                                               
 In all cases, an image and a list of star positions is input and
 the work done using those inputs.
                                                                               
}\sstdiytopic{Aperture Measure}{
 Does aperture photometry on stars in an image. An aperture of
 specified size is placed at a specified position, optionally centered
 on the star that is there. Then the flux in anaperture round that
 position is calculated. An annulus, with specified inner and outer
 radii, round that position is then used to calculate the mean `sky'
 level. After subtracting that sky level from the flux in the
 aperture, the star magnitude is calculated as:-
                                                                               
      $$   Mag = 30 - 2.5*log_{10}(star-sky.a1) $$
                           
                                                                               
                         \hspace*{\fill}  where a1 = star aperture area
                                                                               
 The results are (optionally) typed out, and stored in an output table.
                                                                               
 The error in the star magnitude and sky level are also calculated
 from the pixel values. The pixels are presumed to be Poisson noised,
 with a scale level put in by the user. This is a number such that
 if the pixel values are multiplied by this number, then the pixels
 would have proper Poisson noise. There is also a user input value
 for an extra noise level that is added to each pixel. This noise can
 be thought of as the noise that would be there if the pixel values
 had a mean level of zero.
                                                                               
}\sstdiytopic{Aperture Output}{
 The file output by this programme uses the `OUT' parameter, and
 is a table of results. The contents of the table are the parameters
 measured for each star:-

 \begin{tabular}{|l|l|p{3in}|}\hline                                                                               
  Column Number   & Header       & Contents \\ \hline
    1  &    X          &  X position used (optionally centered) \\
    2  &    Y          &  Y position used (optionally centered) \\
    3  &    Magnitude  &  Magnitude \\
    4  &    Error      &  Error (std dev) in magnitude \\
    5  &    Peak       &  Maximum pixel value in star aperture \\
    6  &    Dx         &  X distance from input to measured position \\
    7  &    Dy         &  Y distance from input to measured position \\
    8  &    Flux       &  Sum of pixel values in star aperture \\
    9  &    Number     &  Number of valid pixels in star aperture \\
   10  &    Invalid    &  Number of invalid pixels in star aperture \\
   11  &    Sky        &  Sky level (mean) \\
   12  &    Sky Error  &  Error (std dev) in sky level \\
   13  &    Sky Number &  Number of valid pixels in sky annulus \\
   14  &    Sky Invalid & Number of invalid pixels in sky annulus \\ \hline
   \end{tabular}
                                                                               
  The magnitudes are calculated as:-
                                                                               
      $$   Mag = 30 - 2.5*log_{10}(star-sky.a1) $$
                           
                                                                               
                         \hspace*{\fill}  where a1 = star aperture area
                                                                               
 If the star flux is negative, the magnitude is set to 50. It is
 also set at that level if there are no good pixels in the star aperture
 and/or none in the sky annulus.

}\sstdiytopic{Fit Gauss}{
  Estimates the Mean Gaussian Radii of stars in a table of
  star positionss in an uncrowded image.
                                                                               
  It does this in three ways:-
                                                       
\begin{list}{{-}}{}                        
\item Fit each star individually and average the measured radii
                                                                               
\item Take the pixels round each star and add them together to
      make one star, and then measure its radii. The adding is
      done assuming that each star centre is at the blh corner of the
      pixel in which it actually falls.
                                                                               
\item Take the pixels round each star and add them together to
      make one star and then measure its radii. The adding is
      done by taking the star centres to be at their calculated
      positions and using an interpolation method to put the best
      pixel values into the summed star.
\end{list}
                                                                               
  This programme takes no account of sub-pixel variations.

}\sstdiytopic{Fit Method}{
   The position, radii, and height of each of the stars in the table
   are found by taking a small box round each star in the image, and
   fitting a single 2-D Gaussian (with different X and Y radii), but
   no rotation. No allowance is made for the fact that there may be
   contamination by nearby stars. The results may be typed out.
                                                                               
   Bad stars are then rejected, on the basis of `invalid' pixels
   in the fitting boxes, radii too large or small, heights too small.
                                                                               
   The mean of the fits is then calculated and typed out.
                                                                               
   The program then makes a `grand' star by taking the data around
   each individual good star centre and adding each pixel value into
   a total array at its appropriate position. The radii of this mean
   star are then calculated, typed, and stored as parameters of the
   programme.
                                                                               
   An even better radii is then calculated by doing the summing in a
   better way, in which the programme allows for the fact that the
   stars are not centred at integral pixel values by interpolating
   between pixels before adding into the mean array. The radii of
   this mean star are then calculated, typed, and stored as parameters
   of the programme.
                                                                               
   The star profile is of the form:-
                                                                               
                                                                               
                                                                               
  $$ I = exp^{-1.0.d^2} $$
                                                                               
  Where d = sqrt((X/RX)**2+(Y/RY)**2)
                                                                               
                                                                               
    Beware that, as stars are not exactly Gaussian, the fitted profile
    will vary with box size.
                                                                               
  This programme takes no account of sub-pixel variations.

}\sstdiytopic{Fit Output}{
 The files output by this programme are:-

\begin{tabular}{|l|p{4.5in}|}\hline
   Parameter    &     Content \\ \hline
    OUTIM1     &    An image with the residuals after a fit has been to
                   done to the array made by summing up all the areas 
                   round each star in the input table. \\

    OUTIM2      &   An image with the residuals after a fit has been to
                   done to the array made by summing up all the areas 
                   round each star in the input table, with the 
                   summing done using pixel interpolation when adding 
                   the data from an individual star into the array. \\

    OUTTAB1      &  A table with the radial plot of the fit and the data
                   after a fit has been to done to the array made by 
                   summing up all the areas round each star in the 
                   input table. The table contains three columns, the 
                   first the distance from the centre of the fitted 
                   star, the second the summed data values, and the 
                   third the value of the fit at that point. \\

    OUTTAB2      &  A table with the radial plot of the fit and the data
                   after a fit has been to done to the array made by 
                   summing up all the areas round each star in the 
                   input table, with the summing done using pixel 
                   interpolation when adding the data from an 
                   individual star into the array. The table contains 
                   three columns, the first the distance from the 
                   centre of the fitted star, the second the summed 
                   data values, and the third the value of the fit at 
                   that point. \\ \hline
\end{tabular}

                                                                               
}\sstdiytopic{Gauss Measure}{
  Does photometry on isolated stars in an image, fitting a 2-D
  Gaussian to stars whose positions are given in an input list.
                                                                               
  It estimates the flux of stars in an image, by taking a small area
  around the star position and fitting a background and a 2-D Gaussian
  profile to the data in that area. The star positions are taken from
  an input table, and the results are (optionally) typed out and
  stored in an output table.
                                                                               
  This programme takes no account of sub-pixel variations. Thus a
  profile whose value changes significantly inside a pixel will
  be assumed to have the mean value as the value at the centre of
  that pixel. For narrow profiles, this will introduce errors.
                                                                               
}\sstdiytopic{Gauss Method}{
   The star profile is of the form:-
                                                                               
                                                                               
                                                                               
  $$ I = exp^{-1.0.d^2} $$
                                                                               
  Where d = sqrt((X/RX)**2+(Y/RY)**2)
                                                                               
                                                                               
  Beware that, as stars are not exactly Gaussian, the fitted profile
  will vary with box size.
                                                                               
  This programme takes no account of sub-pixel variations. Thus a
  profile whose value changes significantly inside a pixel will
  be assumed to have the mean value as the value at the centre of
  that pixel. For narrow profiles, this will introduce errors.
                                                                               
  Star profiles are not strictly Gaussian, so for stars with whose
  profiles differ, there will be a small, systematic, error in their
  relative magnitudes. That is the magnitude is not a `correct'
  estimate from the `volume' of a star. However for stars with the
  same profile, for example in many cases, stars in one image, this
  error has the same fractional size, and so the relative magnitudes
  are correct.
                                                                               
  For very faint stars, letting the profile radii vary can cause
  significant errors.
                                                                               
}\sstdiytopic{Gauss Output}{
 The file output by this programme uses the `OUT' parameter, and
 is a table of results. The contents of the table are the parameters
 measured for each star:-
                                                                               

 \begin{tabular}{|l|l|p{3in}|}\hline
  Column Number & Header & Contents \\ \hline
    1 & X         & X position \\
    2 & Y         & Y position \\
    3 & Magnitude & Magnitude \\
    4 & Dx        & X distance from input to measured position \\
    5 & Dy        & Y distance from input to measured position \\
    6 & Iterations & Number of iterations taken in the fitting
                     (the maximum allowed is 20) \\
    7 & Rms       & The RMS of the residuals between the fit and the
                    data, in an area around the star centre \\
    8 & Numinval  & Number of `invalid' pixels in the area used
                    in the fit\\
    9 & Height    & The height of the Gaussian fitted \\
   10 & Base      & The `sky' level on which the star sits \\
   11 & Rx        & The fitted X radius of the elliptical profile \\
   12 & Ry        & The fitted X radius of the elliptical profile \\ 
                    \hline
 \end{tabular}
                                                                               
  The magnitudes are calculated as:-
                                                                               
     $$   Mag = 30.0 - 2.5.log_{10}(pi.height.rx.ry) $$
                                                                               
  where (pi.height.rx.ry) is the `volume' of a Gaussian.
                                                                               
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{ \large \bf General:- }{
                                                                               
  The following parameters are used in more than one of the
  three types of photometry done in this program.
                                                                               
}\sstsubsection{BOX = {\undersc}REAL(2) (Read)}{
  (Default - 20,20       \hspace*{6ex}     Range - 2 to 200)
                                                                               
  The X and Y size of the box round each star to take when
  making the individual fits.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The input image.
                                                                               
}\sstsubsection{INSTARS = BDF (Read)}{
  (Default - null)
                                                                               
  The input list of star positions.
                                                                               
}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - `aperture'   \hspace*{6ex}    Choice - `aperture:fitgauss:gauss' )

  Which of the three types of fit do you want to do?

 \begin{tabular}{|l|l|}\hline
  Choice  &    Function \\ \hline
  Aperture   & Aperture Photometry \\
  Fitgauss   & Determine mean Gaussian radii \\
  Gauss      & Profile phtometry \\ \hline
 \end{tabular}
  
                                                                              
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                               
  The output table of results.
                                                                               
  This can be either from the aperture measuring or from the
  profile measuring. For the contents of the table, see the
  sections on the functions.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - title of input table     \hspace*{6ex}  Choice - any)
                                                                               
  The title to add into the output table.
                                                                               
}\sstsubsection{TYPING = LITERAL (Read)}{
  (Default - `yes'   \hspace*{6ex}    Choice - `yes:no' )
                                                                               
  Do you want to have typed out the individual fits to each star?
                                                                               
}\sstsubsection{\large \bf Aperture Measure:- }{
                                                                               
  The following parameters are for the Aperture Photometry.
                                                                               
}\sstsubsection{APDIA = {\undersc}REAL (Read)}{
  (Default - 20.0       \hspace*{6ex}     Range - 0.1 to 200.0)
                                                                               
  The diameter of the star aperture.
                                                                               
}\sstsubsection{CENTRE = LITERAL (Read)}{
  (Default - `no'     \hspace*{6ex}      Choice - `yes:no')
                                                                               
  Do you want the input positions corrected before the measuring is
  done?
                                                                               
  If so, then the programme will fit a Gaussian to the data near the
  input position, and take the fit centre as the new position.
                                                                               
}\sstsubsection{NOISE = {\undersc}REAL (Read)}{
  (Default - 0.0      \hspace*{6ex}     Range - 0.0 to 1.0e10)
                                                                               
  In calculating the errors, is there a hidden source of noise, and
  if so what is its level?
                                                                               
  If an image had a mean level of zero, what would be the std dev of the
  pixel values? There might be such a source of noise from say the
  removal, before the use of this programme, of a mean level.
                                                                               
  A knowledge of such a hidden noise is necessary for the correct
  estimate of the error in the calculated magnitudes.
                                                                               
}\sstsubsection{POISV = {\undersc}REAL (Read)}{
  (Default - 1.0    \hspace*{6ex}        Range - 1.0e-10 to 1.0e10)
                                                                               
  In calculating the errors, it is necessary to know if the pixel
  values have a Poisson noise. Sometimes, the pixel values are
  scaled values
                                                                               
}\sstsubsection{SKYDIAS = {\undersc}REAL(2) (Read)}{
  (Default - 30.0,40.0         \hspace*{6ex}     Range - 0.1 to 200.0)
                                                                               
  The inner and outer diameters of the sky annulus.
                                                                               
}\sstsubsection{\large \bf Fit Gauss:-}{
                                                                               
  The following parameters are for the Determination of the
  Mean Gaussian profile.
                                                                               
}\sstsubsection{DOINT = LITERAL (Read)}{
  (Default - `yes'     \hspace*{6ex}      Choice - `yes:no' )
                                                                               
  Do you want the make the grand star, amde  by summing the data round
  the individual stars (using interpolation), for fiting?
                                                                               
}\sstsubsection{DOSUM = LITERAL (Read)}{
  (Default - `yes'     \hspace*{6ex}      Choice - `yes:no' )
                                                                               
  Do you want the make the grand star, amde  by summing the data round
  the individual stars, for fiting?
                                                                               
                                                                               
}\sstsubsection{OUTIM1 = BDF (Write)}{
  (Default - null)
                                                                               
  The name of the image to contain the summed star.

  The image is the residuals after a fit has been to done to the 
  array made by summing up all the areas round each star in the 
  input table.

  If a null repsonse is made, this image is not made.
                                                                               
}\sstsubsection{OUTIM2 = BDF (Write)}{
  (Default - null)
                                                                               
  The name of the image to contain the summed star, with the
  summing done using interpolation.

  The image is the residuals after a fit has been to done to the 
  array made by summing up all the areas round each star in the 
  input table, with the summing done using pixel interpolation 
  when adding the data from an individual star into the array.

  If a null repsonse is made, this image is not made.
                                                                               
}\sstsubsection{OUTTAB1 = BDF (Write)}{
  (Default - null)
                                                                               

  The name of the table to contain radial profile fitted and a
  radial plot of the data of the data for the summed star. The fit 
  and the data are folded around the centre of the fit.

  No account is made of sub-pixel variations.

  The table contains three columns, the first the distance from
  the centre of the fitted star, the second the summed data values,
  and the third the value of the fit at that point.

  This is a table with the radial plot of the fit and the data
  after a fit has been to done to the array made by summing up all 
  the areas round each star in the input table.

  If a null repsonse is made, this table is not made.
                                                                               
}\sstsubsection{OUTTAB2 = BDF (Write)}{
  (Default - null)
                                                                               
  The name of the table to contain radial profile fitted and a
  radial plot of the data of the data for the summed star, using
  interpolation. The fit and the data are folded around the centre of 
  the fit.

  No account is made of sub-pixel variations.

  The table contains three columns, the first the distance from
  the centre of the fitted star, the second the summed data values,
  and the third the value of the fit at that point.

  This is a table with the radial plot of the fit and the data
  after a fit has been to done to the array made by summing up all 
  the areas round each star in the input table, with the summing 
  done using pixel interpolation when adding the data from an 
  individual star into the array.

  If a null repsonse is made, this table is not made.
                                                                               
}\sstsubsection{RADLIMS = {\undersc}REAL(2) (Read)}{
  (Default - 0.5*fitted radius,1.5*fitted radius or 1.0,10.0 \hspace*{6ex}    
   Range - 0.1 to 100.0)
                                                                               
  The lower and upper limits to the range of acceptable radius
  (average of the X and Y radii) for a star.
                                                                               
  If an individual star has a fitted radius outside these limits,
  it will not be used in making the mean radius, nor will the box
  round it be used in making the grand summed star which is later
  fitted.
                                                                               
}\sstsubsection{RX1 = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The mean X radius, calculated from the mean of the individual
  radii.
                                                                               
}\sstsubsection{RX2 = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The mean X radius, calculated from fitting to the summed data of
  the boxes round the indivual stars.
                                                                               
}\sstsubsection{RX3 = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The mean X radius, calculated from fitting to the summed data of
  the boxes round the indivual stars, with the summing done using
  interpolation.
                                                                               
}\sstsubsection{RY1 = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The mean Y radius, calculated from the mean of the individual
  radii.
                                                                               
}\sstsubsection{RY2 = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The mean Y radius, calculated from fitting to the summed data of
  the boxes round the indivual stars.
                                                                               
}\sstsubsection{RY3 = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The mean Y radius, calculated from fitting to the summed data of
  the boxes round the indivual stars, with the summing done using
  interpolation.
                                                                               
}\sstsubsection{SUMBOX = {\undersc}REAL(2) (Read)}{
  (Default - 6*X radius, 6*Y radius  \hspace*{6ex}   Range - 2 to 200)
                                                                               
  The X and Y size of the box round each star to take when
  making summing up the data to make a grand star.

}\sstsubsection{\large \bf Gauss Measure:- }{
                                                                               
  The following parameters are for the Gaussian Profile Photometry.
                                                                               
}\sstsubsection{PARFIX = (Read)}{
  (Default - `no'        \hspace*{6ex}      Choice - `yes:no')
                                                                               
  Are fixed radii to be used in the fitting?
                                                                               
  Either the programme can determine the best values of the
  profile radii for each star, or it can keep those radii
  fixed throughout the programme with user-determined values.
                                                                               
  If they are allowed to vary, then the starting values, of the
  iterative process in the fitting, are taken as 2.0,2.0.
                                                                               
}\sstsubsection{RADII = {\undersc}REAL(2) (Read)}{
  (Default - 3.0,3.0    \hspace*{6ex}     Range - 0.1 to 200.0)
                                                                               
  X and Y radii of the star profile to be used in fitting the
  stars. If the profile is fixed, then these are used. If it is
  allowed to vary, then these are used as the starting points
  of the iterative fitting.
                                                                               
}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} SPRINKLE}
 
\sstroutine{SPRINKLE}{Make a Table of Random Stars}{
 
\sstdescription{ 
                                                                               
  Makes a table of stars with random positions, magnitudes, colours and 
  heights. This table represents the stars in a star field. It can be
  used with ADDSTARS to make an image of a `random' star field, either 
  as a uniform distribution, or as a cluster. The colours and magnitudes
  can be set in a number of diverse ways.
                                                                               
  It thus outputs two types of stars, cluster stars and field stars.
                                                                               
  The cluster stars are distributed in position to mimic a cluster with
  a King profile and in magnitude and colour to follow either an
  input colour-magnitude diagram (specified by an input file designed to
  model a cluster CMD) or one of randomly scattered magnitudes.
                                                                               
  The field stars have a random x,y distribution and a cmd of again
  either an input CMD (designed in a different way to model a field
  star distribution) or a random scatter in colour and magnitude.
                                                                               
  The range in position, colour and magnitude allowed can be specified.
                                                                               
}\sstdiytopic{Use}{

 \begin{enumerate}
\item Make a table of the cluster CMD and field star CMD. (See the help
      on 'Cluster' and 'Field' on how to do this.) Or you can (for
      either) decide to have a CMD with random magnitudes and colours
      evenly scattered over a chosen mag and colour range.
                                                                               
\item Decide:- \newline \begin{list}{{-}}{}
      \item What reddening and distance modulus you want them both to have.
      \item Where in the field you want the cluster centre to be.
      \item How large the field is (for both field and cluster stars).
      \item What region of the CMD you want filled (for field/cluster stars).
      \item On the cluster King core and tidal radii.
      \item On the number of cluster and field stars to make.
      \item On the random seed numbers.
      \end{list}
                                                                               
\item Run the program.
                                                                               
\item The output is a table of star positions, heights, magnitudes,
      and colours.
\end{enumerate}
                                                                               
}\sstdiytopic{Method}{
                                                                               
}\sstdiytopic{Cluster stars}{
                                                                               
  {\bf The selection of a random magnitude and colour}
                                                                               
  The colour-magnitude diagram is input as lines in the CMD. Each line
  is specified by [a start mag,col; an end mag,col; the number of stars
  in that line]. The program then sums the total number of stars in all
  the lines. To choose a random (mag,col), it selects a random number in
  the range 0.0 to 1.0, and finds in which line segment the ratio of
  (sum of stars in lines so far)/(total no of stars) is first greater
  than the number chosen. Thus the lines are selected in proportion to
  the number of stars in them. Then a (mag,col) is chosen from a uniform
  random distribution along the chosen line.
                                                                               
  Thus the line segments do not have to be contiguous in the CMD, but
  no smoothing in the number distribution from one line to the next is
  made (which if they are not touching would be incorrect). Thus to
  insure no falsely rapid changes in the number distribution are made,
  the line segments must be short enough that in each one, a uniform
  number distribution is suitable.
                                                                               
  After this the input distance modulus and reddening are applied (after
  the table (m-M) and Eb-v (say) have been removed).
                                                                               
  Then the input limits on magnitude and colour are checked. If the
  chosen mag,col lies within the limits, they are accepted; if not,
  then the process is repeated.
                                                                               
  {\bf Alternative}
                                                                               
  No table is input, and the mag,cols are uniformly distributed within
  the mag,col limits.
                                                                               
                                                                               
  {\bf The selection of a random X,Y Position}
                                                                               
  The King core and tidal radii are used to make a random selection
  of distance from the cluster centre, which results in the King
  radial distribution. These are then uniformily distributed in
  position angle around the cluster. They are accepted if they fall
  within the input position limits.
                                                                               
  The core and tidal radii have thus to be input as 'pixel' values.
                                                                               
  The King distribution is that defined by Ivan King in:- AJ 67,471;
  AJ 70,376; AJ 71,64
                                                                               
}\sstdiytopic{Field stars}{
                                                                               
  {\bf The selection of a random magnitude and colour}
                                                                               
  The colour-magnitude diagram is input as numbers of stars in uniform
  areas in a grid in the CMD.
                                                                               
  The table specifying the CMD gives the location of the top left hand
  area and the area size. The table then contains the number of stars
  in each area. The program then sums the total number of stars in all
  the areas. To choose a random (mag,col), it selects a random number in
  the range 0.0 to 1.0, and finds in which area the ratio of
  (sum of stars in areas so far)/(total no of stars) is first greater
  than the number chosen. Thus the areas are selected in proportion to
  the number of stars in them. Then a (mag,col) is chosen from a uniform
  random distribution within the chosen area.
                                                                               
  Thus no smoothing in the number distribution from one area to the
  next is made. So to insure no falsely rapid changes in the number
  distribution are made, the areas must be small enough that in each
  one, a uniform number distribution is suitable.
                                                                               
  After this the input distance modulus and reddening are applied (after
  the table (m-M) and Eb-v (say) have been removed).
                                                                               
  Then the input limits on magnitude and colour are checked. If the
  chosen mag,col lies within the limits, they are accepted; if not,
  then the process is repeated.
                                                                               
  {\bf Alternative}
                                                                               
  No table is input, and the mag,cols are uniformly distributed within
  the mag,col limits.
                                                                               
                                                                               
  {\bf The selection of a random X,Y Position}
                                                                               
  A uniform random distribution within the input limits is made.
                                                                               
                                                                               
}\sstdiytopic{Random seeds}{
                                                                               
  The choosing of the random values is done with the a simple
  algorithm, which starts from an input seed and creates a pseudo-random
  number form 0 to 1 from that and updates the seed.
                                                                               
  This seed number is fed in by the user.
                                                                               
  So if you feed in the same seed, you will get the same distribution
  of star mag,col and positions. A different seed will give a different
  pattern. These seeds have to be large (over a billion) to ensure
  good randomising. There are separate seeds for the cluster and field
  stars, so one pattern can be repeated, whilst holding the other
  constant.
                                                                               
}\sstdiytopic{Hidden Parameters}{
  The parameter LOG is `hidden', that is only
  accessible by putting `SPRINKLE LOG=yes' on the command line or a 
  previous LET command.
                                                                               
}\sstdiytopic{Output}{
                                                                               
   The table contains seven columns. For each star, the entry is:-

\begin{tabular}{|c|c|p{4in}|}\hline
    Column  & Header    & Content \\ \hline
     1  &    X       &  X posn \\
     2  &    Y       &  Y posn \\
     3  &    HEIGHT1 &  height of star in the 1st colour band (e.g. 'V') \\
     4  &    HEIGHT2 &  height of star in the 2nd colour band (e.g. 'B') \\
     5  &    MAG1    &  1st colour band magnitude (e.g. 'V') \\
     6   &   COL     &  colour (e.g. 'B-V') \\
     7   &   MAG2    &  2nd colour band magnitude (e.g. 'B') \\ \hline
\end{tabular}
                                                                               
     Thus from the input table(s) of (say) 'V' and 'B-V', an output
     table of X, Y, V height, B height, V, B-V, and B is made.
                                                                               
     The stars are named as \#1, \#2, \#3, etc.
  
 It is also possible, through the LOG parameter, to get a typing out as
 the programme goes.
                                                                             
}\sstparameters{
                                                                               
\sstsubsection{LOG = LITERAL [HIDDEN] (Read)}{
  (Default - `no'  \hspace*{6ex}   Choice - `yes:no')
                                                                               
  This is a 'hidden' parameter, only accessable through the
  command line or the connection file.
                                                                               
  Put out a log as the program goes?
                                                                               
}\sstsubsection{DOCLUST = LITERAL (Read)}{
  (Default - `yes'  \hspace*{6ex}   Choice - `yes:no')
                                                                               
  Do the cluster stars?
                                                                               
}\sstsubsection{CEVEN = LITERAL (Read)}{
  (Default - `yes'  \hspace*{6ex}   Choice - `yes:no')
                                                                               
  Use a uniform cmd distribution instead of the cluster cmd for the
  cluster stars.
                                                                               
}\sstsubsection{CLUSTER = BDF (Read)}{
  (Default - null)
                                                                             
  Input table giving cluster CMD. It contains rows describing line
  segements of the cluster.

\begin{list}{{-}}{}
\item Each row of the table contains a description of a line segment of
      the cluster CMD. It has, in order,:-
                                                                               
      Mag start, Col start, Mag end, Col end, Number of stars
                                                                               
                                                                               
\item See the section on 'Method' as to how this is used.
                                                                               
                                                                               
\item The table also has, as descriptors, the reddening and distance modulus
      of the CMD. Thus when the user inputs the desired reddening and
      distance modulus, the table descriptor values are first subtracted.
                                                                               
      Thus, for example, if the user puts in the same reddening and distance
      modulus as the value in the cluster file, the values in the cluster
      table for the stars are used unaltered.
                                                                               
      The table descriptors are:-

\begin{tabular}{|c|l|}\hline                                                                               
      Name   &  Content \\ \hline
      RED    &  The reddening \\
      DISMOD &  The distance modulus \\ \hline
\end{tabular}                                                                               
                                                                               
\item The table can be made at the keyboard by the program TBKEY, and the
      decriptors added with the program TBWRDES.
\end{list}                                                                               
                                                                               
}\sstsubsection{CDISMOD = {\undersc}REAL (Read)}{
  (Default - Value in cluster file, if any, or 0.0 \hspace*{6ex}  
   Range - -1.0e8 to 1.0e8)
                                                                               
  Cluster distance modulus. If there has been the input of a cluster file
  with its own distance modulus, that distance modulus is first subtracted.
                                                                               
}\sstsubsection{CREDDEN = {\undersc}REAL (Read)}{
  (Default - Value in cluster file, if any, or 0.0 \hspace*{6ex}  
   Range -   -1.0e8 to 1.0e8)
                                                                               
  Cluster reddening. If there has been the input of a cluster file
  with its own reddening, that reddening is first subtracted.
                                                                               
                                                                               
}\sstsubsection{CMRANGE = {\undersc}REAL(2) (Read)}{
  (If there is a cluster file:- \newline
     Default - brightest to faintest magnitude in cluster file \hspace*{6ex}  
     Range -  brightest to faintest magnitude in cluster file \newline
   If the cluster is to have a uniform magnitude distribution:- \newline
     Default -  -50,50  \hspace*{6ex}  Range-  -50 to +50)
                                                                               
  Magnitude range that cluster stars can have.
                                                                               
}\sstsubsection{CCRANGE = {\undersc}REAL(2) (Read)}{
  (If there is a cluster file:- \newline
     Default - bluest to reddest colour in cluster file \hspace*{6ex}  
     Range - bluest to reddest colour in cluster file \newline
   If the cluster is to have a uniform magnitude distribution:- \newline
     Default - -20, 20 \hspace*{6ex}  
     Range - -20 to +20)
                                                                               
  Colour range that cluster stars can have.
                                                                               
}\sstsubsection{CXYPOSN = {\undersc}REAL(2) (Read)}{
  (Default - 50.0,50.0  \hspace*{6ex}  Range - -1.0e8 to 1.0e8)
                                                                               
  X,Y position of the cluster.
                                                                               
}\sstsubsection{RADCORE = {\undersc}REAL (Read)}{
  (Default - 10.0  \hspace*{6ex}  Range - -1.0e8 to 1.0e8)
                                                                               
  King core radius of cluster ( in pixels )
                                                                               
}\sstsubsection{RADTIDE = {\undersc}REAL (Read)}{
  (Default - 100.0  \hspace*{6ex}  Range - -1.0e8 to 1.0e8)
                                                                               
  King tidal radius of cluster ( in pixels )
                                                                               
}\sstsubsection{CXRANGE = {\undersc}REAL(2) (Read)}{
  (Default - 1.0,100.0  \hspace*{6ex}  Range - -1.0e8 to 1.0e8)
                                                                               
  X start and end of acceptable area for cluster stars to lie in

}\sstsubsection{CYRANGE = {\undersc}REAL(2) (Read)}{
  (Default - 1.0,100.0  \hspace*{6ex}  Range - -1.0e8 to 1.0e8)
                                                                               
  Y start and end of acceptable area for cluster stars to lie in
                                                                               
}\sstsubsection{CNUMBER = {\undersc}INTEGER (Read)}{
  (Default - 1  \hspace*{6ex}  Range - 0 to 100000000)
                                                                               
  Number of cluster stars to make
                                                                               
}\sstsubsection{CSEED = {\undersc}INTEGER (Read)}{
  (Default - 1234567891  \hspace*{6ex}  Range - 1200000001 to 1400000001)
                                                                               
  Random number to seed making of random cluster stars. Should
  be an odd number
                                                                               
}\sstsubsection{DOFIELD = LITERAL (Read)}{
  (Default - `yes'  \hspace*{6ex}   Choice - `yes:no')
                                                                               
  Do the field stars?
                                                                               
}\sstsubsection{FEVEN = LITERAL (Read)}{
  (Default - `yes'  \hspace*{6ex}   Choice - `yes:no')
                                                                               
  Use a uniform cmd distribution instead of the field cmd for the
  field stars.
                                                                               
}\sstsubsection{FIELD = BDF (Read)}{
  (Default - null)
                                                                               
  The input table giving the field star CMD. It contains rows which
  have the number of stars in areas in a CMD.

\begin{enumerate}
                                                                               
\item The CMD (magnitude increasing down, colour increasing to right) may
      be thought of being divided up into a rectangular grid of areas of
      equal size. The CMD is then described by the number of stars in each
      area. Each row of the input table then contains the numbers of stars
      in the areas in one horizontal row of the grid, and the rows in toto
      make up the whole CMD. The number of columns in a row gives the
      horizontal number of areas in the grid and the number of rows gives
      the vertical number. The size of each area is described in the table
      descriptors, and the location of the grid in the CMD is also described
      there.
                                                                               
\item See the section on 'Method' for further description.
                                                                               
\item The table also has, as descriptors, the reddening and distance moculus
      of the CMD. Thus when the user inputs the desired reddening and
      distance modulus, the table ones are first subtracted.
                                                                               
      Thus, for example, if the user puts in the same reddening and distance
      modulus as the value in the field file, the values in the field
      table for the stars are used unaltered.
                                                                               
      The table has descriptors:-
      
\begin{tabular}{|c|p{4.0in}|}\hline
      Name   &  Content \\ \hline
      RED    &  The reddening \\
      DISMOD &  The distance modulus \\
      MSTART &  The magnitude of tlh corner of the tlh area in the CMD grid \\
      MSTEP  &  The vertical (magnitude) size of the areas \\
      CSTART &  The colour of tlh corner of the tlh area in the CMD grid \\
      CSTEP  &  The horizontal (colour) size of the areas \\ \hline
\end{tabular}
                                                                  
      MSTEP and CSTEP MUST BE POSITIVE
                                                                               
\item The table can be made at the keyboard by the program TBKEY, and the
      decriptors added with the program TBWRDES.
                
\end{enumerate}                                                               
                                                                               
                                                                               
}\sstsubsection{FDISMOD = {\undersc}REAL (Read)}{
  (Default - Value in field file, if any, or 0.0  \hspace*{6ex}  
   Range -  -1.0e8 to 1.0e8)
                                                                               
  Field distance modulus. If there has been the input of a field file
  with its own distance modulus, that distance modulus is first subtracted.
                                                                               
}\sstsubsection{FREDDEN = {\undersc}REAL (Read)}{
  (Default - Value in field file, if any, or 0.0 \hspace*{6ex}  
   Range - -1.0e8 to 1.0e8)
                                                                               
  Field reddening. If there has been the input of a field file
  with its own reddening, that reddening is first subtracted.
                                                                               
}\sstsubsection{FMRANGE = {\undersc}REAL(2) (Read)}{
  (If there is a field file:- \newline
     Default - brightest to faintest magnitude in field file  \hspace*{6ex}  
     Range - brightest to faintest magnitude in field file \newline
   If the field is to have a uniform magnitude distribution:- \newline
     Default - -50 \hspace*{6ex}  
     Range - -50 to +50)
                                                                               
  Range in magnitude that field stars can have.
                                                                               
}\sstsubsection{FCRANGE = {\undersc}REAL (Read)}{
  (If there is a field file:- \newline
     Default - bluest to reddest colour in field file \hspace*{6ex}  
     Range - bluest to reddest colour in field file \newline
   If the field is to have a uniform magnitude distribution:- \newline
     Default - -20,20 \hspace*{6ex}  
     Range - -20 to +20)
                                                                               
  Range in colour that field stars can have.
                                                                               
}\sstsubsection{FXRANGE = {\undersc}REAL (Read)}{
  (Default - 1.0,100.0   \hspace*{6ex}  Range - -1.0e8 to 1.0e8)
                                                                               
  X start and end of acceptable area for field stars to lie in.
                                                                               
}\sstsubsection{FYRANGE = {\undersc}REAL (Read)}{
  (Default - 1.0,100.0   \hspace*{6ex}  Range - -1.0e8 to 1.0e8)
                                                                               
  Y start and end of acceptable area for field stars to lie in.

}\sstsubsection{FNUMBER = {\undersc}INTEGER (Read)}{
  (Default - 1   \hspace*{6ex}  Range - 0 to 100000000)
                                                                               
  Number of field stars to make
                                                                               
}\sstsubsection{FSEED = {\undersc}INTEGER (Read)}{
  (Default - 1234567891  \hspace*{6ex}  Range - 1200000001 to 1400000001)
                                                                               
  Random number to seed making of random field stars.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                 
  The name of the file to conatin the output table.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - `Output from SPRINKLE')
                                                                               
  The Title to add to the output table
                                                                               
}\sstsubsection{M1FACT = {\undersc}REAL (Read)}{
  (Default - 1000.0   \hspace*{6ex}  Range - 1.0e-8 to 1.0e8)
                                                                               
  This is the scale conversion from magnitude to height for the first
  colour band. You input the height  (linear flux equivalent) a star
  of magnitude 20.0 in the input magnitude (e.g. 'V') should have.
                                                                               
  This is used in the conversion in the output table between the
  magnitudes in column 5 (MAG1) and the heights of column 3 (HEIGHT1).
                                                                               
}\sstsubsection{M2FACT = {\undersc}REAL (Read)}{
  (Default - M1fact  \hspace*{6ex}   Range - 1.0e-8 to 1.0e8)
                                                                               
  This is the scale conversion from magnitude to height for the second
  colour band. You input the height  (linear flux equivalent) a star
  of magnitude 20.0 in 'Mag' + 'Col' = 2nd magnitude band
  (e.g. 'V' + 'B-V' = 'B') should have.
                                                                               
  This is used in the conversion in the output table between the
  magnitudes in column 7 (MAG2) and the heights of column 4 (HEIGHT2).
                                                                               
                                                                               
}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} UNCCD}
 
\sstroutine{UNCCD}{Calibrate raw CCD images}{
 
\sstdescription{ 

  This takes the raw image from a CCD and turns it into a clean image,
  corrected for many of the CCD characteristics such as Bias, Flat
  Field, etc.
                                                                               
  In effect it takes the CCD image which is a picture of the sky, with
  CCD artifacts imposed, and undoes the effects of these artifacts to
  restore the sky picture. It thus un-ccds the image, thus its name.
                                                                               
}\sstdiytopic{Use}{
  This is used for removing the CCD characteristics as far as possible
  from the image and turning it into nice image.
                                                                               
  The program can do any or all of the following actions:-

\begin{list}{{-}}{}                                                                               
\item Select a rectangular area in the image
\item estimate and subtract a mean bias level for the image
\item subtract a bias image
\item correct for non-linearity
\item subtract a dark image (scaled to the exposure time)
\item subtract a preflash image (scaled to the preflash time)
\item divide by a flat field image
\item subtract a night sky fringe pattern (scaled to the exposure time)
\item flag `bad' areas
\end{list}
                                                                               
   It can also:-
                                                                               
\begin{list}{{-}}{}                                                                               
\item    normalise the output
\item   display the output
\end{list}
                                                                               
}\sstdiytopic{Guide}{
 This is a brief guide on how to use UNCCD in calibrating CCD images
                                                                               
 First of all, you must have a general background in CCDs and Photometry
                                                                               
{\hspace*{4ex} \bf   Understand the way a CCD works}
                                                                               
 You can read all about the mechanics, the problems and the
 possibilities CCDs in many books. Two good examples are:-
                                                                               
   1) Chapter 2 of The University of Leeds thesis of John Buttress

   2) McClean's book on Electronic Astronomy.
                                                                               
{\hspace*{4ex} \bf   Learn about Photometry in general}
                                                                               
 See, for example, the University of Leeds thesis of Richard Noble.
 There are also many other books and articles are general photometry,
 such as Andrew Young's articles in `Methods in Experimental Physics',
 or Welch in the JRAS Canada.
                                                                               
                                                                               
{\hspace*{4ex} \bf   Learn about UNCCD}
                                                                               
 Read this section
                                                                               
{\hspace*{4ex} \bf   Learn about the EDRS program MATHS}
                  
 You can do thsi by:-
                                                             
 Starman$>$go edrs \newline
 EDRS$>$help maths \newline
 EDRS$>$go starman \newline
                                                                               
 This enables you to add images together, divide by constants,
 etc. (Useful in scaling to 1 second equivalents or to
 mean levels of 1.0)
                                                                               
{\hspace*{4ex} \bf   Learn about the IMSTAT program }
                                                                               
 Starman$>$help imstat

 This enables you to determin mean and std dev in an area inan image.
 Useful in determining levels so that `MATHS' can be used to make
 1.0 level mean exposures.
                                                                               
{\hspace*{4ex} \bf   Learn about the range of programs available}
                                                                               
 Use the Help to browse through the Starman, ASPDIR and EDRS suites
 of programs, seeinmg the range of tools available.
                                                                               
 Beware that some of the more specific ones (e.g. the LORENTZ programs
 in ASPDIR) are now redundant. Also many of the programs are irrelevant
 to your needs.
                                                                               
{\hspace*{4ex} \bf   Be methodical in your work}
                                                                               
 Make a record of what you do, so you can go back over it later if you 
 think that will be useful. Be prepared to justify on scientific grounds 
 any decision you take (or fail to take).
                                                                               
{\hspace*{4ex} \bf   Make a list of the various categories of the exposures}
                                                                               
 I.e., Bias; dark; preflash; flat field (called `sky', `dark sky',
 `flat', etc); the different star fields; the E-region standard
 exposures
                                                                               
{\hspace*{4ex} \bf   Look at all the images}
                                                                               
 Use INTERACT

\begin{enumerate}
                                                                               
\item OPTION/image/:=image
\item IN:=  file name
\item XRANGE:= 1,320     \hspace*{4ex}      (whatever cuts out the overscan)
\item YRANGE:= 1,512
\item OPTION/flash/:=display
\item DSTYPE/vws/:=decw
\item VRANGE/a,b/:=\hspace*{7ex}\begin{list}{{-}}{}
                                \item and make a note of mean and std dev
                                \item the two numbers are mean + 3 std dev
                                                  and mean - 2 std dev)
                                \end{list}
\item WRAP/no/:=
\item IMPOSN/1,1/:=
\end{enumerate}
                                                                               
   GO BACK TO STEP 1 for next image. (steps 6 and 7 not repeated)
                                                                               
 Are they what you expect? Make a note of the mean and std dev. Are they
 what other similar images have. Make a rough note of the seeing
 on the star field exposures (bad, average, good).
                                                                               
 Are there any funny effects in any exposure?
                                                                               
{\hspace*{4ex} \bf  Determine if there are any Bad Pixel Areas}
                                                                               
 Look at a variety of types of exposures - Bias; flat field; star field;
 standards. Are then any areas that look 'bad', i.e. the signal
 is clearly wrong. Too high, too low, etc. (A common fault
 is a part of a column can be significantly low.)
                                                                               
 Use  INTERACT, with:- zoom, cvalues, area, inspect, etc, to determine
 the location of such areas. Make a bad pixel list (use Tbkey),
 as described in the UNCCD help for the `bad' parameter.
                                                                               
                                                                               
{\hspace*{4ex} \bf   Determine if there is any pattern in the BIAS exposures}
                                                                               
 1) Have a look;

 2) Smooth a bias image by the EDRS program `Boxfilter', on scales of
    10x10, 50x50, and 100x100 to see if there is any overall pattern.
                                                                               
 If there is no pattern, ignore the Bias frames. If there is one, then
 make a mean BIAS frame with as little noise as possible consistent
 with preserving any detectable pattern.
                                                                               
{\hspace*{4ex} \bf    Use UNCCD to make each individual BIAS frame}

  First, strip out the overscan area, and then subtract its mean level.
 Then add, average,sum, scale, smooth etc. to make a mean BIAS frame.
                                                                               
 Then consider the output Bias frame. Is it worthwhile using? Will 
 it actually correct the exposures to any significant degree, or
 will it just add noise?
                                                                               
                                                                               
{\hspace*{4ex} \bf  Determine what a 1sec Dark current exposure is like}
                                                                               
 Use UNCCD to make each individual BIAS frame:-

\begin{list}{{-}}{}
\item to strip out the overscan area, and to subtract its mean level
\item Subtract any useful BIAS frame
\item Flag bad areas with the bad pixel list
\end{list}
                                                                               
 Then add, average, sum, scale, etc. to make a mean DARK frame,
 scaled to 1 sec.
                                                                               
 Is the output Dark frame worthwhile? For the Star field exposures will
 it actually correct the exposures to any significant degree, or
 will it just add noise?
                                                                               
 Why do we need to make a `1 second' master frame?
                                                                               
                                                                               
{\hspace*{4ex} \bf   Determine what a 1sec preflash current exposure is like}
                                                                               
 Use UNCCD to make each individual PREFLASH frame.

\begin{list}{{-}}{}
\item to strip out the overscan area, and to subtract its mean level
\item Subtract any useful BIAS frame
\item Flag bad areas with the bad pixel list
\end{list}
                                                                               
 Then add, average, sum, scale, etc. to make a mean PREFLASH frame,
 scaled to 1 sec.
                                                                               
 Is the output PREFLASH frame worthwile? For the exposures will
 it actually correct the exposures to any significant degree, or
 will it just add noise?
                                                                               
 Why do we need to make a `1 second' master frame?
                                                                               
{\hspace*{4ex} \bf  Make Master Flat Fields}
                                                                               
 You only have enough exposures to make one grand mean in B and one
 in V. This should be enough for the accuracy you need.
                                                                               
 Use UNCCD to make each individual FLAT frame.

\begin{list}{{-}}{}
\item to strip out the overscan area, and to subtract its mean level
\item Subtract any useful BIAS frame
\item Subtract any useful PREFLASH frame
\item Flag bad areas with the bad pixel list
\end{list}
                                                                               
 Then take the individual ones and average them together to make
 a mean. (IMSTAT, MATHS, etc.)
                                                                               
                                                                               
{\hspace*{4ex} \bf  Calibrate all the Star Field and E-region standard star 
exposures}
                                                                               
 Use UNCCD to make each individual calibrated frame:-

\begin{list}{{-}}{}
\item to strip out the overscan area, and to subtract its mean level
\item Subtract any useful BIAS frame
\item Subtract any useful PREFLASH frame
\item Subtract any useful DARK frame
\item Divide by the FLAT frame
\item Flag bad areas with the bad pixel list
\end{list}
                                                                               
 Why does UNCCD do it so that step 5 is done AFTER steps 1 to 4?
 Why would it be wrong to do step 5 before any of the steps 1 to 4?
                                                                               
}\sstdiytopic{Details}{
  There are various details as to the use of the program which
  the sub-helps here will tell you about.
                                                                               
}\sstdiytopic{Bad Areas}{
  A 'magic value' bad pixel flagging scheme is used. This may result in
  pixels being flagged as bad by the input of a 'bad pixel list' (qv),
  or by any of the input calibration images containing 'bad' pixels. Any
  pixel which is bad in the bad pixel list or any of the calibration
  images is flagged as 'bad'
                                                                               
}\sstdiytopic{Bad Pixel Lists}{
  In the input image (both in the area that will be output and in the
  bias level area), pixels may be flagged as bad by a 'bad pixel list'.
  These pixels will be set to 'invalid' in the output image.
                                                                               
  The list is a table which consists of rows of data, each of
  which describe a rectangular 'bad' area. Each row has 4 integers
  giving x,y ranges. Thus if the first 'bad' area to be described has a
  blh corner at x1,y1, and a trh corner at x2,y2, then the first row
  in the table will be x1,x2,y1,y2. Then the second entry will have
  the ranges for the second area, and so on.
                                                                               
  The coordinates are relative to the entire input image.
                                                                               
}\sstdiytopic{Bias Level}{
  Whether or not the subtraction of the mean bias level of the exposure
  is done is controlled by the 'BIAS' parameter. If it is done, then an
  area of the input image is selected (defined in the 'NBIAS'
  parameter) and its mean calculated, with the non-use of pixels
  defined by the, optional, bad pixel list file given via the
  'BIASBAD' parameter.
                                                                               
  This mean value is then selected, and subtracted from the input.
                                                                               
}\sstdiytopic{General}{
\begin{enumerate}
\item A non-linearity in the input can be dealt with.
                                                                               
\item Special corrections can be done. At present, these are:-
                                                                               
       - AAT 1988 RCA CCD band correction
                                                                               
\item The image can be normalised, either scaled so that the average
      value in a selected area to be unity, or scaled by the exposure
      time to an exposure time of 1 second, or having a mean value
      subtracted.
                                                                               
\item The final image can be displayed on a image display.
                                                                               
\item The exposure time of the image is needed if an input calibration
      'dark' image or 'fringe' image is used. This exposure time is
      picked up from a descriptor, whose name is input by the user
      with the 'EXPNAME' parameter.
\end{enumerate}
                                                                               
}\sstdiytopic{Input/output}{
\begin{enumerate}
                                                                              
\item  The input image can be in one of a number of formats.
                                                                               
    The formats and the value of the 'DTYPE' parameter to select them
    are:-
  
\begin{tabular}{|c|l|}\hline
 `DTYPE' value & Format \\ \hline
 `SIGNED' & Signed 16-bit integer (-32768 to 32767)  \\
 'UNSIGNED' &  Unsigned 16-bit integer (0-65535)  \\
 'BADSIGNED' & Which is flagged as signed but actually 
       contains unsigned numbers (0-65535) \\
 'REAL' & Real 32-bit numbers  \\ \hline
\end{tabular}
                                                                               
\item The  input calibration images are all 16-bit integers
                                                                               
\item All calculations inside the program are done in REAL*4 (32-bit)
      precision.
                                                                               
\item The final image can be output to file. This output is done with
      user-chosen BSCALE and BZERO  to deal with the 16-bit
      resolution of the output pixel values.
\end{enumerate}
                                                                               
}\sstdiytopic{How To Normalise}{
  The output image may be normalised (that is its mean level set to
  1.0), before the final output if desired.
                                                                               
  Whether this is done, and if it is then how, is controlled by the
  'NORM' parameter. The options are:-

\begin{tabular}{|c|p{4.5in}|}\hline
     'NORM' value    &      Method \\ \hline
      Flux      &  Normalise average val to 1.0 (divide by mean) \\
      Time      &  Norm values to what they would have been if the
                  exposure time had been 1.0 seconds \\
      None      &  No normalisations \\
      Sub       &  Subtract mean \\ \hline
\end{tabular}
                                                                               
  If normalisation is done, and 'Flux' or 'Sub' is chosen, then the
  the mean has to calculated. The area of the image used to calculate
  the  mean can be set by the 'NNORM' parameter.
                                                                               
  The 'NNORM' parameter defines the (X start, X end, Y start, Y end) of
  the chosen area.
                                                                               
  The default is the whole of the area that will be stored as the
  output image.
                                                                               
}\sstdiytopic{Display}{
  The output image may be displayed. This is controlled by the 'DISP'
  parameter.
                                                                               
  If the display has been chosen, then the 'NDISP' parameter is used
  to select an area of the image to display. The area is input as
  (X start, X end, Y start, Y end of the input image area).
                                                                               
  The default is the entire output area.
                                                                               
  After the display the user is ask, via the 'ENOUGH' parameter, for
  when the program should continue, as some displays remove the
  picture when the program ends.
                                                                               
  The display is done with a pixel value contrast of +/- 3 std dev
  about the mean, with high pixels values set as black, and low as
  white.
                                                                               
}\sstdiytopic{Hidden Parameters}{
  There is a hidden parameter, 'SCREEN', which is used if you
  are displaying the images after they are processed. This the size of
  the screen or window to use. It is set automatically by the program,
  and should not be touched by the user.

}\sstparameters{
                                                                               
\sstsubsection{BAD = BDF (Read)}{
  (Default - null)
                                                                               
  The table containing the bad pixel list of 'bad' areas (if none,
  press 'return').
                                                                               
  These will be set to 'invalid' in the output image.
                                                                               
  The list is a table which consists of rows of data, each of
  which describe a rectangular 'bad' area. Each row has 4 integers
  giving x,y ranges. Thus if the first 'bad' area to be described has a
  blh corner at x1,y1, and a trh corner at x2,y2, then the first row
  in the table will be x1,x2,y1,y2. Then the second entry will have
  the ranges for the second area, and so on.
                                                                               
  The coordinates are relative to the entire input image.
                                                                               
}\sstsubsection{BIAS = LITERAL (Read)}{
  (Default - 'yes'  \hspace*{6ex}         Choice - 'yes:no')
                                                                               
  Do you want to find a mean bias level from an `overscan' area?
                                                                               
  This mean will be subtracted from the image.
                                                                               
  The area is defined by the `NBIAS' input.
                                                                               
}\sstsubsection{BIASBAD = BDF (Read)}{
  (Default - null)
                                                                               
  The table containing the bad pixel list for the bias 'overscan'
  area (if none, press `return').
                                                                               
  These will define the areas of the bias 'overscan' area not to use in
  calculating the mean bias.
                                                                               
  The list is a table which consists of rows of data, each of
  which describe a rectangular 'bad' area. Each row has 4 integers
  giving x,y ranges. Thus if the first 'bad' area to be described has a
  blh corner at x1,y1, and a trh corner at x2,y2, then the first row
  in the table will be x1,x2,y1,y2. Then the second entry will have
  the ranges for the second area, and so on.
                                                                               
  The coordinates are relative to the entire input image.
                                                                               
}\sstsubsection{CORRECT = LITERAL (Read)}{
  (Default - 'none'    \hspace*{6ex}         Choice - 'none:mode1')
                                                                               
  Do you want to correct the image for some type of fault?
               
\begin{tabular}{|c|p{4in}|}\hline 
  Choice  &  Result \\ \hline
  None   &   No correction \\
  Mode1  &   The AAT type row/column fault. In this, at present the
            high/low adjacent rows are just averaged. \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{DOLIMS = LITERAL (Read)}{
  (Default - 'no'         \hspace*{6ex}   Choice - 'yes:no')
                                                                               
  Do you want to flag values above and below certain values as `bad'?
                                                                               
  If you do, then you will be asked in the `lims' parameter what
  limits to acceptable values you want to input.
                        
}\sstsubsection{DSTYPE  = LITERAL (Read)}{
 (Default - `decw' \hspace{6ex}     Choice - `ikon:none:vws:decw')

  Type of display to be used:-

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Ikon    &    IKON image display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{DTYPE = LITERAL (Read)}{
  (Default - 'signed'   \hspace*{6ex}        Choice  - 'unsigned:signed:badsigned:real')
                                                                               
  The input image is taken as made of Integer*2 16-bit numbers, or
  real 32-bit numbers. (The calculations inside the program use
  real numbers.)
                                                                               
                                                                               
  The formats and the value of the 'DTYPE' parameter to select them
  are:-
                                                                               
\begin{tabular}{|c|l|}\hline
 `DTYPE' value & Format \\ \hline
 `SIGNED' & Signed 16-bit integer (-32768 to 32767)  \\
 'UNSIGNED' &  Unsigned 16-bit integer (0-65535)  \\
 'BADSIGNED' & Which is flagged as signed but actually 
       contains unsigned numbers (0-65535) \\
 'REAL' & Real 32-bit numbers  \\ \hline
\end{tabular}
                                                                               
  The data is read in in the proper way. The input image may have
  BSCALE and BZERO parameters, and these are applied, but any
  magic value INVAL parameter is ignored.
                                                                               
}\sstsubsection{EXPNAME = LITERAL (Read)}{
  (Default - 'exposed'    \hspace*{6ex}            Choice - any)
                                                                               
  The name of the descriptor in the input image giving the exposure
  time. A choice of 'None' indicates there is no such descriptor.
                                                                               
}\sstsubsection{EXPTIME = {\undersc}REAL (Read)}{
  (Default - 1.0      \hspace*{6ex}      Range - 0.0 to 1.0e8 )
                                                                               
  Length of exposure in seconds.
                                                                               
  This is only used if the user inputs that the exposure time
  cannot be found from the input image header.
                                                                               
}\sstsubsection{ENOUGH = LITERAL (Read)}{
  (Default - 'yes'       \hspace*{6ex}     Choice - 'yes:no')
                                                                               
  Finished looking at screen?
                                                                               
}\sstsubsection{GAIN = {\undersc}REAL (Read)}{
  (Default - 0.0      \hspace*{6ex}    Range - )
                                                                               
  The gain of the chip, in terms of electrons per adu. This is added
  as information to the output image descriptors. If 0.0 (the default)
  is input, then this is not added.
                     
}\sstsubsection{IDINAME = LITERAL (Read)}{
 (Default - `ikon'      \hspace{6ex}       Choice - any)
    
   The local name defining the display device. The list of names
   call be seen in the file with the logical name `GNS\_IDINAMES'.
   Remember that the case of the letters matters.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the input image file.
                                                                               
  This sould be a standard .BDF file, but can be in a number of
  fromats (real, signed 16-bit, unsigned 16-bit, badsigned 16-bit).
                                                                               
}\sstsubsection{IM\_B = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file with the bias frame to subtract from
  the input image.
                                                                               
  A null response means that no bias is to be input.
                                                                               
}\sstsubsection{IM\_D = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file with the dark frame to subtract from
  the input image.
                                                                               
  A null response means that no dark is to be input.
                                                                               
  It should be a dark frame scaled so as to be that which would
  result from a 1 second dark exposure.
                                                                               
  This is scaled in the programme to the actual exposure time of the
  exposure.
                                                                               
}\sstsubsection{IM\_FL = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file with the flat field frame to divide into the
  processed (bias, preflash, dark) input image.
                                                                               
  A null response means that no flat field is to be input.
                                                                               
  This should be the sensitivity function of the chip, thus a pixel
  of high sensitivity will have a high value, and one with low
  sensitivity will have a low value. It should have a mean level of
  1.0.
                                                                               
}\sstsubsection{IM\_FR = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file with the fringe frame to subtract from
  the input image.
                                                                               
  A null response means that no fringe is to be input.
                                                                               
  It should be a fringe frame scaled so as to be that which would
  result from a 1 second exposure.
                                                                               
  This is scaled in the programme to the actual exposure time of the
  exposure.
                                                                               
}\sstsubsection{IM\_P = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file with the preflash frame to subtract from
  the input image.
                                                                               
  A null response means that no preflash is to be input.
                                                                               
  It should be a Preflash frame scaled so as to be that which would
  result from a 1 second preflash exposure.
                                                                               
  This is scaled in the programme to the actual preflash time of the
  exposure.
                                                                               
}\sstsubsection{LIMS = {\undersc}REAL(2) (Read)}{
  (Defaults -  0.0,32767.0 or 0.0,65535.0         \hspace*{6ex}   Range - )
                                                                               
  The low and high limits to acceptable values in the input image.
                                                                               
  If you have answered 'YES' to the `dolims' query, then you are
  asked this.
                                                                               
  The values wanted are those after scaling for BSIZE and BZERO of
  the input image. Thus they are not the file storage 16-bit values,
  but the true, proper values they should be if it were not for the
  need to work with 16-bit images.
                                                                               
}\sstsubsection{LIN = LITERAL (Read)}{
  (Default - 'none'   \hspace*{6ex}         Choice - 'none:mode1')
                                                                               
  Do you want to correct the input data for non-linearity?
                
\begin{list}{{-}}{}
\item {\bf None: \hspace*{3ex}} No linearity correction
\item {\bf Mode:  \hspace*{3ex}}    This correction is of the form:- \newline
           Raw-bias = (Corrected-bias)*[1.0 + factor*(Corrected-bias)]
\end{list}
                                                                               
}\sstsubsection{LINF = {\undersc}REAL (Read)}{
  (Default - 3.2*10-6   \hspace*{6ex}         Range - )
                                                                               
  The factor 'factor' in the linearisation equation to use in correcting
  for the non-linearity of the CCD. (see paramater 'lin'.)
                                                                               
}\sstsubsection{NAREA = {\undersc}INTEGER(4) (Read)}{
  (Default - input area   \hspace*{6ex}              Range - 1 to end)
                                                                               
  This is the X start, X end, Y start, Y end of the image area to be
  taken, processed and output.
                                                                               
  This is input as four integers, separated by commas.
                                                                               
}\sstsubsection{NBIAS = {\undersc}INTEGER(4) (Read)}{
  (Default - 1, end     \hspace*{6ex}              Range - 1 to end)
                                                                               
  This is the X start, X end, Y start, Y end of the bias `overscan'
  area to be used.
                                                                               
  This is input as four integers, separated by commas.
                                                                               
}\sstsubsection{NDISP = {\undersc}INTEGER(4) (Read)}{
  (Default  -  Output area {\undersc}REAL   Range - 1 to end)
                                                                               
  This is X start, X end, Y start, Y end of the input image area to be
  displayed.
                                                                               
  This is only asked for if the query `disp' has been answered `YES'.
                                                                               
  This is input as four integers, separated by commas.
                                                                               
}\sstsubsection{NNORM = {\undersc}INTEGER(4) (Read)}{
  (Default  -  Output area {\undersc}REAL   Range - 1 to end)
                                                                               
  This is the X start, X end, Y start, Y end of the image area to be
  used in calculating the normalising value for the scaling.
                                                                               
  This is only asked for if the query `norm' has been answered `FLUX,
  or `SUB'.
                                                                               
  This is input as four integers, separated by commas.
                                                                               
}\sstsubsection{NOISE = {\undersc}REAL (Read)}{
  (Default - 0.0        \hspace*{6ex}      Range - to )
                                                                               
  The read-out noise of the chip. This is added as information to the
  output image descriptors. If 0.0 (the default) is input, then this
  is not added.
                                                                               
}\sstsubsection{NORM = LITERAL (Read)}{
  (Default - 'none'    \hspace*{6ex}      Choice - see below)
                                                                               
  The method of normalising the image.
                                                                               
\begin{tabular}{|c|p{4.5in}|}\hline
     'NORM' value    &      Method \\ \hline
      Flux      &  Normalise average val to 1.0 (divide by mean) \\
      Time      &  Norm values to what they would have been if the
                  exposure time had been 1.0 seconds \\
      None      &  No normalisations \\
      Sub       &  Subtract mean \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the Starman programmes use all three, with
  the right-hand button being used mainly as the `exit' button. 

  With two buttons, then the third button is simulated by pressing 
  both of the buttons down, with the middle one being pressed slightly 
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will 
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{OBJNAME = LITERAL (Read)}{
  (Default - 'OBJECT'     \hspace*{6ex}      Choice - any)
                                                                               
  The name of the descriptor in the input image giving the object
  name. A choice of 'None' indicates there is no such descriptor.
                                                                               
}\sstsubsection{OFFSET = {\undersc}REAL (Read)}{
  (Default - 0,0       \hspace*{6ex}    Range - )
                                                                               
  The (X,Y) offset, relative to the entire raw input image, of the
  pixels of the reference (dark, flat field, etc.) images and bad
  pixel lists.
                                                                               
  Thus if the reference images were made in such a way that the (1,1)
  pixel of the reference images should be applied to the (11,11) pixel
  of the ENTIRE input image (not, that is, to the location of the
  pixel in the area in the input image that will become the output
  image), then the `offset' would be (10,10).
                                                                               
  The non-default option is mainly used for two cases:-
                                                                               
     When a window of the normal CCD image has been used, so that only
     a part of the CCD image is read out. In this case, then the
     reference images will have normally been made for the `normal'
     entire CCD area - a bigger area. In these cases, the `offset'
     will always be two positive numbers, being the shift of the start
     of the windowed small image from the start of the normal large
     CCD image.
                                                                               
     When an `overscan' bias area is at the left of the image, so that
     the reference images and the bad pixel lists, while refering,
     normally, to the de-biased image, thus start not at the (1,1)
     pixel of the raw input image, even if it is a whole CCD image.
                                                                               
  If, further, the output image blh has an offset from the (1,1) pixel
  of the input image, then this does NOT affect the `offset'.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Defaulty - null)
                                                                               
  The output frame.
                                                                               
  This is Integer*2 and has BZERO and BSCALE as chosen by the
  user.
                                                                               
  The BZERO and BSCALE are taken from the first input frame.
                                                                               
  If you put a null response in, then the output image is not stored.
                                                                               
}\sstsubsection{SCALE = {\undersc}REAL(2) (Read)}{
  (Default - as described below.)
                                                                               
   The two output image constants of BSCALE and BZERO.
                                                                               
   The output image is Integer*2, and has BSCALE and BZERO headers so
   that
                                                                               
       Real pixel value = BSCALE*(file pixel value)  + BZERO
                                                                               
   The BSCALE parameter:-
                                                                               
   Thus normally this is 1.0, or that of the input image.
                                                                               
   If the output image has been scaled for averaging, then a
   different scale may be appropriate.
                                                                               
   Thus for the flat field output, the pixels would all contain 1!
   So in these cases the default scale is 0.0001, and so in the case
   of the flat field the values would be about 10000, allowing for a
   reasonable dynamic range. For the averaging of preflash, and bias,
   a scale of 1.0 would be ok, but for dark and fringe, a scale of
   0.0001 might be ok, as these are scaled to 1 second exposure times.
   Anyway for these, have a look at the output, to see if the dynamic
   range has been chosen ok.
                                                                               
   The BZERO parameter:- 
                                                                               
   Normally this is 0.0 or the input value.
                                                                               
   However for UNSIGNED or BADSIGNED input (16-bit unsigned numbers),
   the default is put at 32766, so the full range of numbers can be
   dealt with in the output. The value is 32766, not 32767, and thus
   a number of 65536 is put out as invalid (flagged with INVAL value).
   The reason for so chopping the highest unsigned number, is that
   -32768 is reserved as the INVAL number, and it was thought better
   to loose the 65536s than the 0s.
                                                                               
                                                                               
}\sstsubsection{PLHISTX = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.5      \hspace*{6ex}      Range - 0.0 to 1.0e8)
                                                                               
  The limits to the 'X' range of the plot of the histogram of
  the number of stars with the given magnitude differences for
  the different magnitude difference bins.
                                                                               
  It is the range of magnitude differences bins that you want
  displayed.
                                                                               
}\sstsubsection{PLHISTY = {\undersc}REAL(2) (Read)}{
  (Default - Min,1.2*Max   \hspace*{6ex}         Range - 0.0 to 1.0e8)
                                                                               
  The limits to the 'Y' range of the plot of the histogram of
  the number of stars with the given magnitude differences for
  the different magnitude difference bins.
                                                                               
  It is the range in number of stars in the different magnitude
  difference bins that you want displayed.
                                                                               
}\sstsubsection{PLOTLIMX = {\undersc}REAL(2) (Read)}{
  (Default - outside min,max    \hspace*{6ex}        Range - -1.0e8 to 1.0e8)
                                                                               
  The limits to the 'X' range of the plot of the differences
  of mags of stars from that in file 1 versus their
  magnitudes.
                                                                               
  It is the range of magnitudes that you want displayed.
                                                                               
}\sstsubsection{PLOTLIMY = {\undersc}REAL(2) (Read)}{
  (Default - outside min,max    \hspace*{6ex}        Range - -1.0e8 to 1.0e8)
                                                                               
  The limits to the 'Y' range of the plot of the differences
  of mags of stars from that in file 1 versus their
  magnitudes.
                                                                               
  It is the range of mag differences that you want displayed.
                                                                               
}\sstsubsection{PREFNAME = LITERAL (Read)}{
  (Default - 'PREFLASH'    \hspace*{6ex}         Choice - any)
                                                                               
  The name of the header in the input image which holds the
  length of the preflash exposure in seconds.
                                                                               
  If 'None' is entered, the user is asked for the preflash
  time.
                                                                               
  This parameter is only asked for if a preflash frame is used.
                                                                               
}\sstsubsection{PREFTIME = {\undersc}REAL (Read)}{
  (Default - 1.0       \hspace*{6ex}     Range - 0.0 to 1.0e8 )
                                                                               
  Length of preflash in seconds.
                                                                               
  This is only used if the user inputs that there is a prflash frame
  and that the preflash time cannot be found from the input image
  header.
                                                                               
}\sstsubsection{SCREEN = {\undersc}INTEGER(2) [HIDDEN] (Read)}{
  (Default - 1, size of image      \hspace{6ex} Range - 1 to large)

  Size of screen or window to open. 

  The default size is that of the image, unless the image is too large
  to fit on the screen, when the image will be binned down by an integer
  factor for display. The default size will then be this binned down size.

  It is 'hidden'. That is, it is not asked for and is assumed to be the
  deafult, unless set on the command line or before by the
  'LET UNCCD\_SCREEN=x,y' command. It is set automatically by the
  program, and should not be touched by the user.
                                                                               
}\sstsubsection{TIT = LITERAL (Read)}{
  (Default - see below)
                                                                               
  The Title to add to the output image. Default is the name in the
  image 'objname' descriptor.
                                                                               
                                                                               
}}}

\newpage
\section{Image Programmes}
\ajhsect{\arabic{section}}{IMAGE PROGRAMMES}
\label{se:progim}
\newpage

\ajhsect{\arabic{section}}{Image Programmes - \hspace*{0.2in} IMCUT}
 
\sstroutine{IMCUT}{Cut out, Bin, Flip an Area of an Image }{
 
\sstdescription{ 
                                                                               
  Copies one image to another, with the options of:-

\begin{list}{{-}}{}
\item Copying only a section of the input image
\item Binning that section down
\item Inverting the section in X and/or Y
\end{list}
                                                                               
}\sstdiytopic{Binning}{
  It can take rectangular groups of pixels (bins) in the input image
  and output them as a single pixel to the output image. This is
  known as 'binning'. The reduction of a group can be done either
  by taking the bottom left hand pixel of the group and outputting
  that value, or taking the mean of all the pixels in the group.
  If the average is taken, there is the choice of:-


\begin{list}{{-}}{}
\item Ignore any INVALID points in the bin
\item Set the output to INVALID
\end{list}
                                                                               
  If this binning is used, and the chosen area of the input image cannot
  be exactly sub-divided into an integral number of bins, then those
  pixels at the right and top edges of the chosen area that fall
  outside the binned area are ignored.
                                                                               
}\sstdiytopic{Inverting}{
                                                                               
  The inverting is done by defining the section with the start and
  stop locations inverted.
                                                                               
  Thus for example, if one wanted to take all the bottom half of
  an image of size NX by NY, and invert in X, one would define the
  section as:-
                                                                               
          (NX, 1) and (1, NY/2)
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{BIN = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,1   \hspace*{6ex}   Range - 1 to max size of image)
                                                                               
  The size of the groups of pixels that are to binned to make
  the output image. If the default is taken, no binning is done.
                                                                               
  If the sampling step in both X and Y is not one, then either the 1st
  (blh) pixel of the bin is output ('yes'), or the average of the bin
  is output ('no').
                                                                               
  If the average is taken, there is the option to either ignore any
  INVALID points in the bin, or to set the output to INVALID.
                                                                               
}\sstsubsection{IGNORE = LITERAL (Read)}{
  (Default - 'no'      \hspace*{6ex}      Choice - 'no:yes')
                                                                               
  In taking the average, ignore any INVALID points in the input bin
  ('yes'), or to set the output to INVALID ('no').
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the input image file.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                               
  The name of the new file containing the output image.
                                                                               
}\sstsubsection{SAMPLE = LITERAL (Read)}{
  (Default - 'yes'     \hspace*{6ex}       Choice - 'yes:no')
                                                                               
  If the binning step in both X and Y is not one, then either the 1st
  (blh) pixel of the bin is output ('yes'), or the average of the bin
  is output ('no').
                                                                               
  If the average is taken, there is the option to either ignore any
  INVALID points in the bin, or to set the output to INVALID.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title, or if null, 'Output from IMCUT'
    \hspace*{6ex}   Choice  - any)
                                                                               
  Title to add to output image
                                                                               
}\sstsubsection{XRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,input image X size    \hspace*{6ex}     Range - 1 to input image X size)
                                                                               
  X start and X end of the area of image to cut out and put in new image.
                                                                               
  If the X end is smaller than the X start, then the output image is
  inverted in X.
                                                                               
}\sstsubsection{YRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,input image Y size   \hspace*{6ex}      Range - 1 to input image Y size)
                                                                               
  Y start and Y end of the area of image to cut out and put in new image.
                                                                               
  If the Y end is smaller than the Y start, then the output image is
  inverted in Y.
                                                                               
                                                                               
}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} IMCUBE}
 
\sstroutine{IMCUBE}{ Cut 2-D plane from 3- or 4-D Cube }{
 
\sstdescription{ 
                                                                               
  This program cuts a 2-D plane out of a 2-, 3-, or 4-D cube.
                                                                               
  The types it can deal with are:-
                                        
   \begin{tabular}{|l|l|}\hline  
     Type       &       Name \\ \hline
     32-bit real &      Real \\
     32-bit integer &   Integer \\
     16-bit integer  &  Short \\ \hline
   \end{tabular}
                                                                               
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the input image.
                                                                               
}\sstsubsection{INTYPE = LITERAL (Read)}{
  (Default - 'real'  \hspace*{6ex}     Choice - 'real:integer:short')
                                                                               
  The type of the input image.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                               
  The name of the output image.
                                                                               
}\sstsubsection{PLANE3 = LITERAL (Read)}{
  (Default - 'xy'      \hspace*{6ex}      Choice - 'xy:xz:yz')
                                                                               
  The plane to cut out of a 3-D cube. The cube is considered
  to have axes XYZ.
                                                                               
}\sstsubsection{PLANE4 = LITERAL (Read)}{
  (Default - 'xy'        \hspace*{6ex}    Choice - 'xy:xz:xt:yz:yt:zt')
                                                                               
  The plane to cut out of a 4-D cube. The cube is considered
  to have axes XYZT.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title    Choice - any)
                                                                               
  The title to be attached as a header to the output image.
                                                                               
}\sstsubsection{XPLANE = {\undersc}INTEGER (Read)}{
  (Default - 1     \hspace*{6ex}     Range - 1 to size of X plane)
                                                                               
  The position, along the X direction, to position the plane
  to be cut out. The cube is either a 3-D one (XYZ), or a
  4-D one (XYZT).
                                                                               
}\sstsubsection{YPLANE = {\undersc}INTEGER (Read)}{
  (Default - 1      \hspace*{6ex}    Range - 1 to size of Y plane)
                                                                               
  The position, along the Y direction, to position the plane
  to be cut out. The cube is either a 3-D one (XYZ), or a
  4-D one (XYZT).
                                                                               
}\sstsubsection{ZPLANE = {\undersc}INTEGER (Read)}{
  (Default - 1      \hspace*{6ex}    Range - 1 to size of Z plane)
                                                                               
  The position, along the Z direction, to position the plane
  to be cut out. The cube is either a 3-D one (XYZ), or a
  4-D one (XYZT).
                                                                               
}\sstsubsection{TPLANE = {\undersc}INTEGER (Read)}{
  (Default - 1     \hspace*{6ex}     Range - 1 to size of T plane)
                                                                               
  The position, along the T direction, to position the plane
  to be cut out. The cube is a 4-D one (XYZT).
                                                                               
}}}

\ajhsect{\arabic{section}}{Image Programmes - \hspace*{0.2in} IMDES}
 
\sstroutine{IMDES}{Type out Image Descriptors }{
 
\sstdescription{ 
                                                                               
  Types out the descriptors of an image.
                                                                               
  It types the size; pixel value scale and zero; title.
                                                                               
  Then it asks whether you want all descriptors output or just specificied
  ones. If you want all, it outputs them. If you want specific ones, it
  asks for the name of a specific descriptor. You give it, and it types
  out the descriptors value. It then repeats asking for names until you
  reply with a null (' ' or <carriage return>).
                                                                               
  You can specify that the program looks at only one descriptor before
  exiting. This mode is chosen with the 'ALL=no' and 'ONLYONE=yes'
  setting of the parameters.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{ALL = LITERAL (Read)}{
  (Default - 'yes'   \hspace*{6ex}         Choice - 'yes:no')
                                                                               
  Do you want all the descriptors output, or just specified one or ones?
                                                                               
}\sstsubsection{IN = BDF (Read)}{
 (Default - null)                                           
                                    
  The name of the input image file.
                                                                               
}\sstsubsection{MORE = LITERAL (Read)}{
  (Default - 'yes'       \hspace*{6ex}       Choice - 'yes:no')
                                                                               
  Do you want any more output of these descriptors (if doing all of
  them)or of this descriptor (if doing single specific descriptors)?
                                                                               
}\sstsubsection{NAME = LITERAL (Read)}{
  (Default - ' '       \hspace*{6ex}        Choice - any)
                                                                               
  Name of descriptor you want to have its value typed out.
                                                                               
  If you reply with a null (' ' or <carriage return>), it ceases
  asking for descriptor names.
                                                                               
}\sstsubsection{ONLYONE = LITERAL (Read)}{
  (Default - 'no'     \hspace*{6ex}         Choice - 'yes:no')
                                                                               
  Do you want the program to look at only one descriptor before
  exiting?
                                                                               
  This option can only be chosen if the 'ALL=no' option has
  previously been chosen.
                                                                               
                                                                               
}}}

\ajhsect{\arabic{section}}{Image Programmes - \hspace*{0.2in} IMFITSIN}
 
\sstroutine{IMFITSIN}{Read FITS images off a Tape }{
 
\sstdescription{ 
                                                                               
  Takes FITS format images off a magnetic tape and loads them into
  disk images in the Starman .BDF format.
                                                                               
  A feature of this program is that the output files can be named
  automatically, enabling the user to set the program going and leave
  it until all the desired images are read off.
                                                                               
  As an option, the images can be displayed automatically as they are
  read off the tape.
                                                                               
  IMFITSIN can only deal with images. Tables and other FITS extensions
  will be ignored. To read these, a good way to go is to use the FIGARO
  programmes FITS and then STAROUT, or the KAPPA FITSIN and then NDF2BDF.
                                                                               
}\sstdiytopic{Image Output}{
  The images are output as 2-D images. There are two aspects to be
  considered in this.
                                                                               
{\hspace*{4ex} \bf If the input image is 3- or n-D}
                                                                               
  If the file images are 3- or n-D, then the sections are joined to
  make a 2-D image. The Y-plane will thus be (no of Z panes) larger
  than the individual images. (The individual images can later be cut
  out of the image using IMCUT.) Thus a 3-D image with 2 planes in the
  Z direction will be output as one image as:-
               
\setlength{\unitlength}{1mm}                                 
\begin{picture}(100,55)
\put(10,20){Z-plane 1}
\put(10,40){Z-plane 2}
\put(30,10){\framebox(20,20){\hspace*{1ex}}}
\put(30,30){\framebox(20,20){\hspace*{1ex}}}
\end{picture}
                      
\vspace*{-3mm}                                                         
  The images are output as `Short' (16-bit) Integer, `Integer' (32-bit
  Integer), or `Real' (32-bit real), depending on their format
  in the file. `Integer' and `Real' images should be transformed into
  the `Short' Starman standard format, using IMTYPE, before use by
  Starman programmes.
                                                                               
{\hspace*{4ex} \bf The input image is `GROUPED'}
                                                                               
  If the input image is grouped, then one output image will be made
  for each of the input images in the group. These will have the usual
  output name with `\_1', `\_2', `\_3', etc. appended to their names.

}\sstdiytopic{Automatic Mode}{
  There is a mode to automatically name and make the new output file
  for each input file as it is read off the tape.
                                                                               
  If you do not use this, then you have to give the name for each file
  as it is read off the tape.
                                                                               
  If you do, you can leave the program running alone, until it has
  read off all the desired files. It names the files by asking you
  for this general preffix, and the starting number for a numeric
  suffix. It then increases the suffix by one for each file read off.
                                                                               
  Thus if you have read off files (3,7-9,20), with the preffix
  of 'RUN', and the suffix number as '98', then the disk files made
  will have names:-

\hspace*{4ex}\begin{tabular}{|c|c|}\hline
       Number on tape   &    Name on disk \\ \hline
             3          &      RUN098 \\
             7          &      RUN099 \\
             8          &      RUN100 \\
             9          &      RUN101 \\
            20          &      RUN102 \\ \hline
\end{tabular}
                                                                               
  You will notice that the suffix is constrained as a three digit
  integer, with leading zeroes.
                                                                               
  The suffix can only be as large as 999. If it gets larger than
  that, then subsequent files all have the same suffix of '999'.
                                                                               
}\sstdiytopic{First File}{
  Often, the first file on a tape will be different to the rest.
  It sometimes contains a text file giving information about the tape
  and it can even not be in a proper FITS format.
                                                                               
  If you have trouble starting to read a tape, it might be because of
  a 'bad' first file. The remedy for this is to start reading at the
  second file. (This may actually be the first real data.)
                                                                               
}\sstdiytopic{ING Matters}{
  If the tape has been made at the ING group of telescopes at La Palma,
  then the non-standard FITS headers are dealt with in a particular
  way. If the 'SOURCE' parameter has been set to 'ING', then these
  are dealt with.
                                                                               
  The main manner the ING tapes are non-standard is that there are
  some headers that are in 'packets' of headers coming from different
  components of the telescope/instruments (e.g. 'OBSVATON' or 'DETCCD  ').
  These are written as headers with no names but with the contents having
  a starting name in them. Thus for example:-
                                                     
\hspace*{6ex}\begin{tabular}{lp{1in}p{2in}} 
        ING PACKTYPE=       & 'OBSVATON '     &   /Packet type \\
        ING PACKVERS=       &            2    &  /Packet Version Number \\
        ING PACKDATE=       & '91/06/21'      &   /Date of Packet Creation \\
            ..........      &    ....         &  .... \\
        ING RA\hspace{4em}= &      13.0758    & /RA of the source \\
             .........      &   .........     &   \\
        ING PACKEND         &                 &    \\
\end{tabular}
                                                                               
  This program processes these to give header names as:-
                                                                               
  (For the example where the PACKTYPE is 'OBSVATON')
                                                                               
\hspace*{6ex}\begin{tabular}{|l|p{1in}|p{2in}|}\hline  
      Input Start   &     Output Name &  Output Content\\ \hline
      ING PACKTYPE  &     none        &   none \\
      ING PACKVERS  &     OBSVVERS    &         2     /Packet Version Number \\
      ING PACKDATE  &     OBSVDATE    &   '91/06/21'  /Date of Packet Creation \\
            ....... & ..........      &  ..... \\
      ING RA        &     RA          &     13.0758   /RA of the source \\
            ....... & ..........      & ..... \\
      ING PACKEND   &     none        &    none \\ \hline
\end{tabular}
                                                                               
                                                                               
  The RGO has the following comments to make on their format (you
  will note that this Starman version of FITSIN does deal with
  these headers in its own way) :-
                                                                               
                                                                               
  "This FITS tape has a NEW  format. It is still a completely
   standard FITS tape but it contains new information about instrument
   setup and the layout of the FITS descriptors has been rationalised.
                                                                               
  In order to gain maximum benefit from the FITS descriptors on
  this tape, your home institute's FITS tape reading program will need
  modifying. The current Starlink FITSIN utility has the modifications
  and a listing of it is included in the header file of this tape,
  following the text of this note. The tape has the following overall
  format :-
                                                                               
  Header file \newline
  $<$ Tape Mark $>$ \newline
  Observation  1 \newline
  $<$ Tape Mark $>$ \newline
  $\mid$ \newline
  $\mid$ \newline
  $\mid$ \newline
  Observation   \newline
  $<$ Tape Mark $>$ \newline
  $<$ Tape Mark $>$
                                                                               
  Within the individual tape files, descriptors whose names are defined
  in the FITS standard are written in the form :-
                        
\begin{tabular}{ccp{0.5in}ccc}                                                       
  0     &   1 &       &           3       &   4  &   col \\
  1     &   0 &       &           0       &   1  &    \\
  name  &  =  &       &       value       &   /C &    \\
\end{tabular}
                                                                               
  Any descriptors whose names are not defined in the FITS standard are
  written in the form :-
                                                                               
\begin{tabular}{ccp{0.5in}ccc}                                                       
  0         &   1 &       &           3       &   4  &  col \\
  1         &   0 &       &           0       &   1  &      \\
  ING name  &  =  &  alue &               /C  &      &     \\
\end{tabular}
                                                                               
  In other words, the actual descriptor name is blank (the  standard
  permits this and states that in this case the rest of the descriptor
  is to be treated as a comment) followed by another blank, the
  character string "ING" (standing for "Isaac Newton Group", the source
  institute), another blank and then, starting in column 14, the
  non-standard descriptor name, value and comment.
                                                                               
  Your host institute's FITS tape reading program will need to
  recognise and handle such descriptors. Once these non-standard
  descriptors are handled the next stage is to split the descriptors
  into the different categories: those describing the observation, the
  AG box, the instrument, the detector, the telescope, the weather  etc.
  This is beyond the scope of this note and for further details please
  see La Palma Technical Note 30 and its references."

}\sstdiytopic{Hidden Parameters}{
  There is a parameter, 'BELL', which controls whether to sound a bell
  when asking for an output file name. It is 'hidden'. That is, it is
  not asked for and is assumed to be 'yes', unless set on the command
  line or before by the 'LET IMFITSIN\_BELL=no' command.
                                                                               
  There is also another hidden parameter, 'SCREEN', which is used if you
  are displaying the images as they are read in. This the size of the
  screen or window to use. It is set automatically by the program, and
  should not be touched by the user.
                                                                               
}\sstdiytopic{Bugs}{
  Any 'COMMENT' or 'HISTORY' headers in the files on the tape are not
  read properly. Only the last 'COMMENT' and/or the last 'HISTORY'
  card is noted.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{AUTO = LITERAL (Read)}{
  (Default - 'yes'   \hspace*{6ex}     Choice - 'yes:no')
                                                                               
  Do you want the program to automatically name and make the new
  output file for each input file as it is read off the tape?
                                                                               
  If you do not, then you have to give the name for each file as it
  is read off the tape.
                                                                               
  If you do, you can leave the program running alone, until it has
  read off all the desired files. It names the files by asking you
  for this general preffix, and the starting number for a numeric
  suffix. It then increases the suffix by one for each file read off.
                                                                               
  Thus if you have read off files (3,7-9,20), with the preffix
  of 'RUN', and the suffix number as '98', then the disk files made
  will have names:-
             
\begin{tabular}{|c|c|}\hline
       Number on tape    &   Name on disk \\ \hline
             3            &    RUN098 \\
             7            &    RUN099 \\
             8            &    RUN100 \\
             9            &    RUN101 \\
            20            &    RUN102 \\ \hline
\end{tabular}
                                                                               
  You will notice that the suffix is constrained as a three digit
  integer, with leading zeroes.
                                                                               
  The suffix can only be as large as 999. If it gets larger than
  that, then subsequent files all have the same suffix of '999'.
                                                                               
}\sstsubsection{BELL = LITERAL (Read)}{
  (Default - 'yes'   \hspace*{6ex}             Choice - 'yes:no')
                                                                               
  This is a 'hidden parameter'. That is, it is not asked for
  and is assumed to be 'yes', unless set on the command line or before by
  the 'LET IMFITSIN\_BELL=no' command.
                                                                               
  This controls whether to sound a bell when making a new output file
  (in the 'AUTO' mode), or when about to ask you for the name of the
  file. Its purpose is to either keep you in touch with what it is
  doing, or call your attention for the need for input.
                                                                               
}\sstsubsection{DISPLAY = LITERAL (Read)}{
  (Default - 'no'     \hspace*{6ex}           Choice - 'yes:no')
                                                                               
  Should the images be displayed on an image device as they are being
  read in?
                                                                               
}\sstsubsection{DSTYPE  = LITERAL (Read)}{
 (Default - `decw' \hspace{6ex}     Choice - `ikon:none:vws:decw')

  Type of display to be used:-

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Ikon    &    IKON image display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{FILES = LITERAL (Read)}{
 (Default - null  \hspace*{6ex}    Choice - see below)
                                                                               
 A character string specifying which files are to be read off the
 tape. (The files are specified by their position on the tape.;
 1,2,3,,,etc.)
                                                                               
 Single files and/or groups of files can be specified. Thus
 FILES=3,7-10,20 will read files 3,7,8,9,10,20.
                                                                               
 The program cannot rewind the tape, thus the files must be
 in increasing order.
                                                                               
 After the file have been read, you are asked (via the 'MORE' parameter)
 whether you want more files read off. If so, then you are asked
 for files again. This time the files must not only be in
 increasing order, but higher than any previously read file.
                                                                               
}\sstsubsection{IDINAME = LITERAL (Read)}{
 (Default - `ikon'      \hspace{6ex}       Choice - any)
    
   The local name defining the display device. The list of names
   call be seen in the file with the logical name `GNS\_IDINAMES'.
   Remember that the case of the letters matters.

  See your local guide to IDI image names.
                     
}\sstsubsection{IN = BDF (Read)}{
  (default - null)
                                                                               
  The name of the tape deck where the data tape is.
                                                                               
  It should already have been mounted as 'MOUNTED/FOREIGN', and be at
  the beginning of the tape.
                                                                               
}\sstsubsection{LABELLED = (Read)}{
  (Default - 'no'      \hspace*{6ex}         Choice - 'yes:no')
                                                                               
  This describes the way the files are separated on the tape.
                                                                               
  A 'non-labelled' tape ('no' ) has files that are separated by
  single tape marks, and a 'labelled' tape ('yes') has them separated
  by two marks.
                                                                               
}\sstsubsection{MORE = LITERAL (Read)}{
  (Default - 'yes'       \hspace*{6ex}        Choice - 'yes:no')
                                                                               
  After having read in a set of files, this asks you whether you
  want to read some more ('yes'), or quit the program ('no').
                                                                               
  If you respond 'yes', the program will ask you if you want
  the automatic file naming and making. If you do not, the program
  will ask for you for the names of the output files. If you do,
  then the program will ask you for the new preffix and starting
  suffix number, and make the new output files with those details.
                                                                               
}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the Starman programmes use all three, with
  the right-hand button being used mainly as the `exit' button. 

  With two buttons, then the third button is simulated by pressing 
  both of the buttons down, with the middle one being pressed slightly 
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will 
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                               
  The name of the new file containing the next output image.
                                                                               
  This is asked for repeatedly, each time a file is read of the tape,
  unless you have specified automatic output file making (via the
  'AUTO' parameter), when it is not asked for at all, but the output
  files made automatically.
                                                                               
  If the tape image is grouped, then the `OUTT' parameter is used.
                                                                               
}\sstsubsection{OUTT = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the new file containing the next output image.
                                                                               
  This is only asked for if the tape image is `grouped'.
                                                                               
  This is asked for repeatedly, each time a file is read of the tape,
  unless you have specified automatic output file making (via the
  'AUTO' parameter), when it is not asked for at all, but the output
  files made automatically.
                                                                               
  If the tape image is not grouped, then the `OUT' parameter is used.
                                                                               
}\sstsubsection{QUIET = LITERAL (Read)}{
  (Default - 'yes'        \hspace*{6ex}       Choice - 'yes:no')
                                                                               
  Controls whether all the descriptors of each image are put out
  on the terminal as the images are read in. 'yes' means they
  are not.
                                                                               
}\sstsubsection{PREFFIX = LITERAL (Read)}{
  (Default - null           Choice - any)
                                                                               
  A character string, giving the first part (the 'preffix') of the
  names of disk files made in the 'AUTO' mode.
                                                                               
  In this mode, you can leave the program running alone, until it has
  read off all the desired files. It names the files by asking you
  for this general preffix, and the starting number for a numeric
  suffix. It then increases the suffix by one for each file read off.
                                                                               
  Thus if you have read off files (3,7-9,20), with the preffix
  of 'RUN', and the suffix number as '98', then the disk files made
  will have names:-
                                                                               
\begin{tabular}{|c|c|}\hline
       Number on tape    &   Name on disk \\ \hline
             3            &    RUN098 \\
             7            &    RUN099 \\
             8            &    RUN100 \\
             9            &    RUN101 \\
            20            &    RUN102 \\ \hline
\end{tabular}
                                                                               
  You will notice that the suffix is constrained as a three digit
  integer, with leading zeroes.
                                                                               
  The suffix can only be as large as 999. If it gets larger than
  that, then subsequent files all have the same suffix of '999'.
                                                                               
}\sstsubsection{SCREEN = {\undersc}INTEGER(2) [HIDDEN] (Read)}{
  (Default - 1, size of image      \hspace{6ex} Range - 1 to large)

  Size of screen or window to open. 

  The default size is that of the image, unless the image is too large
  to fit on the screen, when the image will be binned down by an integer
  factor for display. The default size will then be this binned down size.

  It is 'hidden'. That is, it is not asked for and is assumed to be the
  deafult, unless set on the command line or before by the
  'LET IMFITSIN\_SCREEN=x,y' command. It is set automatically by the program,
  and should not be touched by the user.
                                                                               
}\sstsubsection{SOURCE = LITERAL (Read)}{
  (Default - 'standard'    \hspace*{6ex}           Choice - 'ing:standard')
                                                                               
  A character string identifying the name of the institute that
  the tape comes from. The choice is between the ING group of
  telescopes on La Palma, and all other places which are assumed
  to produce descriptors in the standard FITS way.
                                                                               
  This enables the program to deal with the ING mode of
  using descriptors. (See the higher-level help.)
                                                                               
}\sstsubsection{STATS = LITERAL (Read)}{
  (Default - 'no'         \hspace*{6ex}       Choice - 'yes:no')
                                                                               
  Calculate and output the mean, standard deviation, minimum and
  maximum of each image?
                                                                               
}\sstsubsection{SUFFIX = {\undersc}INTEGER (Read)}{
  (Default - 1             \hspace*{6ex}         Range - 1 to 999)
                                                                               
  An integer, giving the last part (the 'suffix') of the names of disk
  files made in the 'AUTO' mode.
                                                                               
  In this mode, you can leave the program running alone, until it has
  read off all the desired files. It names the files by asking you
  for a general preffix, and the starting number for this numeric
  suffix. It then increases the suffix by one for each file read off.
                                                                               
  Thus if you have read off files (3,7-9,20), with the preffix
  of 'RUN', and the suffix number as '98', then the disk files made
  will have names:-
                                                                               
\begin{tabular}{|c|c|}\hline
       Number on tape    &   Name on disk \\ \hline
             3            &    RUN098 \\
             7            &    RUN099 \\
             8            &    RUN100 \\
             9            &    RUN101 \\
            20            &    RUN102 \\ \hline
\end{tabular}
                                                                               
  You will notice that the suffix is constrained as a three digit
  integer, with leading zeroes.
                                                                               
  The suffix can only be as large as 999. If it gets larger than
  that, then subsequent files all have the same suffix of '999'.
                                                                               
}}}

\ajhsect{\arabic{section}}{Image Programmes - \hspace*{0.2in} IMFLASH}
 
\sstroutine{IMFLASH}{Display Image}{
 
\sstdescription{ 
                                                                               
  IMFLASH displays an image on an image display with a minimum
  of interaction with the user. It `flashes' an image up on the
  screen.
                                                                               
  The program calculates the `best' contrast to display the image
  at. This assumes that much of the image is sky with some noise.
  The display is -2/+5 std dev about the mean. This brings up
  faint features.
                                                                               
  If the image is too large to be displayed on the image, it is binned
  down (with square bins), so that it does fit into the display.
                                                                               
}\sstdiytopic{Hidden parameter}{
  There is a parameter, `SCREEN', which is used to set the size of the
  screen for the displayed image. It is set automatically by the
  program, and should not be touched by the user.
                                                                               
}\sstparameters{
                                 
\sstsubsection{DSTYPE  = LITERAL (Read)}{
 (Default - `decw'    \hspace{6ex}     Choice - `ikon:none:vws:decw')

  Type of display to be used:-

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Ikon    &    IKON image display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}
                                              
                                                                               
}\sstsubsection{ENOUGH = LITERAL (Read)}{
  (Default - `yes'     \hspace{6ex}      Choice - `yes:no')
                                                                               
  Have you had enough of looking at the image?
                                                                               
  If you have, then the program will exit, and if you are using a
  workstation the image will vaish from the screen.
                                                                               
}\sstsubsection{IDINAME = LITERAL (Read)}{
  (Default - `IKON'    Choice - any)
                                                                               
  Name of IDI image display device that image displays are to go to.
                                                                               
  See your local guide to IDI image names.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the input image.

}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the Starman programmes use all three, with
  the right-hand button being used mainly as the `exit' button. 

  With two buttons, then the third button is simulated by pressing 
  both of the buttons down, with the middle one being pressed slightly 
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will 
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{SCREEN = {\undersc}INTEGER(2) [HIDDEN] (Read)}{
  (Default - 1, size of image      \hspace{6ex} Range - 1 to large)

  Size of screen or window to open. 

  The default size is that of the image, unless the image is too large
  to fit on the screen, when the image will be binned down by an integer
  factor for display. The default size will then be this binned down size.

 (This is hidden from the user. The default is taken, unless it is changed
  before the programme is run, or on the programme command line.)
                                                                               
}}}

\ajhsect{\arabic{section}}{Image Programmes - \hspace*{0.2in} IMJOIN}
 
\sstroutine{IMJOIN}{Mosaic Several Images into One Image}{
 
\sstdescription{ 
                                                                               
 This program is used to merge several images into one new image.
                                                                               
 The key features are:-

\begin{list}{{-}}{}
\item The addition of each image is done in such a way that the
      each pixel in the output image has the `weighted' contribution
      from each input image.
                                                                               
\item The input images can be `transformed', that is given a
      displacement, rotation, and stretch in the XY plane.
                                                                               
\item For each image, the pixel values can have a zero level
      subtracted and can be scaled before being added into the output
      image.
\end{list}
                                                                               
 The program can, less usually, combine two `reference' images.
                                                                               
 The output can be an integer*2 image, or a real*4 `reference' image.
                                                                               
 The reference image can contain more information than the simple
 output image, and is accompanied by a `load' image, which means it
 can be input into IMJOIN again without loosing any information.
                                                                               
}\sstdiytopic{Method}{
 This program is intended for the purpose of making a large image from
 a number of images.
                                                                               
 The input images can be placed in a normal output image or as an
 output `reference' image. The reference image can either then be used
 as a normal image (but see the comment in the `Details' help section),
 or used as a further input to another run of IMJOIN.
                                                                               
{\hspace*{4ex} \bf A Simple Point}
                                                                               
 If the input images were simply added in, then when images overlapped
 the output pixels would have double inputs and be too high. This
 problem is solved by some simple arithmetic.
                                                                               
 It works by adding image(s) into a `reference' image.
                                                                               
 The reference image has an accompanying `load' image which records for
 each pixel how many input images have contributed to that pixel. Thus
 a new input pixel value gets added in to give the output value as:-
                                                                               
               
$$    OUT\_VAL =  \frac{OUT\_VAL.(Present~number~of~inputs) + IN\_VAL}{
                     Present~number~of~inputs + 1} $$
                                                                               
                                                                               
{\hspace*{4ex} \bf Scaling the Input Images}
                                                                               
 There is a further facility, in that the input images may have
 different `scales'. Thus if there are two images which have different
 exposure times, then simply adding them in together will result in
 mismatched pixels.
                                                                               
 This is solved by applying a `scale' to each input image.
                                                                               
 When the new image is added in, each pixel that gets a value from the
 new image is scaled by a factor. Each pixel is multiplied by this
 scale factor. Then at the end the output pixel is divided by the sum
 of the `scales'. Thus if the scaling were due, in fact, to different
 exposure times, the `scale' could be inversely proportional to the
 exposure times.
                                                                               
 Since the scale is multiplied into the pixel values, it is recommended
 that the longest exposure have a `scale' of 1.0, and the others in
 proportion. This avoids loosing accuracy when the output image (which
 is real) is later converted back to a short integer one.
                                                                               
 Thus a pixel, from an input image of the `SCALE' parameter of IN\_SCALE,
 with a pixel value of IN\_VAL will be added to a reference image pixel
 of scale SCALE\_VAL and value REF\_VAL so that the output pixel value
 will be:-
                                                                               
$$    OUT\_VAL = \frac{REF\_VAL.SCALE\_VAL + IN\_VAL}{SCALE\_REF + IN\_SCALE}$$
                                                                               
 and the output `scale' image will be:-
                                                                               
 $$   OUT\_SCALE = SCALE\_VAL + IN\_SCALE $$
                                                                               
                                                                               
{\hspace*{4ex} \bf Subtracting a Zero from the Images}
                                                                               
 There is a facility for subtracting a mean `zero' level from each input
 image before the process of scaling, transforming and inputting starts.
                                                                               
 This is useful when the input images have been taken under different
 conditions of sky brightness and each has an extra, uniform,
 contribution from the sky background. This level can be automatically
 estimated and subtracted from the image.
                                                                               
 This is not a good idea when there is large scale structure truly
 present in the imagea, as a mean level from this in each image will
 also be subtracted, leading to strange effects.
                                                                               
}\sstdiytopic{Pixel Interpolation}{
  As the transformation coefficents do not necessarily result in
  each pixel in an input image corresponding exactly to the pixel
  locations in the output image, it is necessary to interpolate
  between the input pixels to see what value to put into the
  output pixel.
                                                                               
  This interpolating from the grid of input image pixels onto the
  output image can be done in one of three ways:-

\begin{tabular}{|c|p{4in}|}\hline
  Method & Action \\ \hline                      
  NEAREST  &  Take the nearest input image pixel. \\
  LINEAR   &  Make a linear combination of the four input image
              pixels around the output image pixel. \\
  UNIFORM  &  Make a weighted mean of the nine adjacent input image
              pixels (linearly combined), so that the ouput image pixels
              have a constant noise value.  \\ \hline
\end{tabular}
                                                                               
  The default is LINEAR.
                                                                               
 The NEAREST method is the simplest, and actually no interpolation is
 done.
                                                                               
 All interpolation methods have the drawback that they will miss high
 and low points `between' the pixels. Thus if there is structure on a
 scale commensurate with the pixel sizes, there will tend to be a
 smoothing of the high and low points. Thus, an image with stars in it
 runs the risk that the star peaks will be smoothed down.
                                                                               
 A drawback with `LINEAR' is that an output pixel in the centre of four
 input pixels will be the mean of those, and thus have a lower noise
 than an output pixel on an input pixel, in which case it would only
 have the mean of that single pixel. Thus the provision of the `UNIFORM'
 mode.
                                                                               
}\sstdiytopic{Reference Image Adding}{
 It sometimes happens that one has run IMJOIN twice, and one wants to
 combine the two resultant `reference' and `load' images. This can be
 done.
                                                                               
 The combining is done assuming that the images are already exactly
 aligned. The output `reference' and `load' images are made, dealing
 with the `weights' in the proper manner.
                                                                               
}\sstdiytopic{Transformation}{
 The `transformation' of the input image pixel locations into the
 output images pixel locations is done with a linear transformation.
                                                                               
 Thus:-
                                                                               
$$     x1 = c1 + c2.x + c3.y $$
$$     y1 = c4 + c5.x + c6.y  $$
                                                                               
 where: (x,y) are the coordinates in the input image.
        (x1,y1) are the coordinates in the output `reference' image,
                                                                               
  The default is no translation, rotation or stretching:-
                                                                               
$$     x1 = 0.0 + 1.0*x + 0.0*y $$
$$     y2 = 0.0 + 0.0*x + 1.0*y $$
                                                                               
}\sstdiytopic{Details}{
 If an output `reference' image is made, this is a `real' image, then
 for further use in Starman, it is a good idea to use IMTYPE to
 convert it into a normal `integer*2' 16-bit image.
                                                                               
 The input reference, input load, output reference, and output load
 images are all real (32 bit). The input image, and the output image are
 integer*2.
                                                                               
 If there is no input reference image, then a default null one is
 assumed, with a default null load image.
                                                                               
 `Invalid' pixels in an input image are not transferred over to the
 corresponding pixel in the output image, unless that pixel has had no
 valid input data yet. If an output image pixel has had only `invalid'
 input image pixels, and then a new input image delivers a valid
 pixel value, that overwrites the `invalid' flag in the output pixel.
                                                                               
 Up to ten input images can be used. If it is desired to load more
 than ten, then run the program again.

}\sstdiytopic{Warnings}{
  This program can seem very slow or inoperative, because of the
  number and sizes of the files used/made. Also the size of the
  output files may be larger than you expect.
                                                                               
                                                                               
{\hspace*{4ex} \bf The Computer Setup}
                                                                               
 Because of the (possible) large size of the input and output files,
 your computer may find that it is working very inefficently on
 inputting and outputting these files.
                                                                               
 For different machines, this can be due to a number of causes. For
 VAX/VMS machines, things to consult your system manager on are:-

\begin{list}{{-}}{}
\item The size of the system page file
\item Your page file quota
\item The system Work Space 
\item Your WS quota and extend quota
\end{list}
                                                                               
{\hspace*{4ex} \bf   The Size of the Images}
                                                                               
 The input (if any) and output `Reference' and `Load' images are `Real'
 32 bit images, unlike the usual integer*2 16-bit images. The input
 images themselves are the usual integer*2 16-bit images. To use the
 output images further in Starman, use the program IMTYPE to convert
 to 16 bit images.
                                                                               
{\hspace*{4ex} \bf  The Execution Time}
                                                                               
 Because the reference image and load image are `Real*4' images, one
 is outputting (and perhaps inputting) data that is four times as large
 as one is used to. This, combined with the fact that the images are
 usually significantly larger than the input images, means that
 inputting and outputting them can take a surprisingly long time.
                                                                               
                                                                               
}\sstparameters{
                                                                               
 \sstsubsection{IN1 = BDF (Read)}{
 (Default - null)
                                                                               
 The name of the first input image.
                                                                               
 A null entry means that there are no more input images
                                                                               
 This must be an Integer*2 image.


}\sstsubsection{ }{
   {\large \bf This is repeated for IN2 to IN10}

   \vspace*{2mm}
                                                                               
}\sstsubsection{INLOAD = BDF (Read)}{
 (Default - null)
                                                                               
 The name of the input `load' image.
                                                                               
 This is the image which contains for each pixel the `weight' of
 the pixels values already added into the corresponding `reference'
 image  pixel.
                                                                               
 - This must be a `Real*4' image.

 - This is only asked for if a `reference' image has been input.

 - A null  response is invalid.
                                                                               
}\sstsubsection{INLOAD1 = BDF (Read)}{
 (Default - null)
                                                                               
 The name of the first input `load' image.
                                                                               
 This is the image which contains for each pixel the `weight' of
 the pixels values already added into the corresponding first
 `reference' image  pixel.
                                                                               
 - This must be a `Real*4' image.

 - A null  response is invalid.
                                                                               
}\sstsubsection{INLOAD2 = BDF (Read)}{
 (Default - null)
                                                                               
 The name of the second input `load' image.
                                                                               
 This is the image which contains for each pixel the `weight' of
 the pixels values already added into the corresponding second
 `reference' image  pixel.
                                                                               
 - This must be a `Real*4' image.

 - A null  response is invalid.
                                                                               
}\sstsubsection{INREF = BDF (Read)}{
 (Default - null)
                                                                               
 The name of the input `reference' image.
                                                                               
 A null response indicates that the  user says that one does
 not exist. If one does not exist, the program creates one with
 all pixels set at the `BLANK' parameter value.
                                                                               
 This must be a `Real*4' image.
                                                                               
}\sstsubsection{INREF1 = BDF (Read)}{
 (Default - null)
                                                                               
 The name of the first input `reference' image.
                                                                               
 - A null response is invalid.

 - This must be a `Real*4' image.
                                                                               
}\sstsubsection{INREF2 = BDF (Read)}{
  (Default - null)
                                                                               
 The name of the second input `reference' image.
                                                                               
 - A null response is invalid.
 - This must be a `Real*4' image.
                                                                               
}\sstsubsection{METHOD = LITERAL (Read)}{
  (Default - `'linear'     \hspace*{6ex}       Choices - `linear:nearest:uniform')
                                                                               
  This interpolating from the grid of input image pixels onto the
  output image can be done in one of three ways:-
                                                                               

\begin{tabular}{|c|p{4in}|}\hline
  Method & Action \\ \hline                      
  NEAREST  &  Take the nearest input image pixel. \\
  LINEAR   &  Make a linear combination of the four input image
              pixels around the output image pixel. \\
  UNIFORM  &  Make a weighted mean of the nine adjacent input image
              pixels (linearly combined), so that the ouput image pixels
              have a constant noise value.  \\ \hline
\end{tabular}
                                                                               
 For more information, see the `Pixel Interpolation' help at a higher
 level in the IMJOIN help.
                                                                               
}\sstsubsection{MODE = LITERAL (Read)}{
  (Default - `new'      \hspace*{6ex}      Choices - `new:reference')
                                                                               
 The program can do two things:-

   - The usual mosaicing in of new input images.

   - The less usual adding together of two `reference' images.
                                                                               
 The two modes are described in the higher levels of the IMJOIN help.
                                                                               
 The program is usally used in the `New' mode.
                                                                               
}\sstsubsection{OUT = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file to contain the output image. If this
  is null, then no output image will be made.
                                                                               
}\sstsubsection{OUTSCALE = {\undersc}REAL(2) (Read)}{
  (Default - input scale, zero      \hspace*{6ex}    Range - 2 real numbers in the
                                                range -1.0e20 to 1.0e20)
                                                                               
  The BSCALE and BZERO are descriptors of the output image.
                                                                               
  The `true value'' of a pixel = BSSCALE*`stored value' + BZERO
                                                                               
}\sstsubsection{OUTLOAD = BDF (Write)}{
  (Default - null)
                                                                               
  The name of the output reference `scale' image. This is only
  asked for if an output reference image is made.
                                                                               
  THIS WILL BE CREATED AS A `REAL*4' 32 BIT IMAGE.
                                                                               
}\sstsubsection{OUTREF = BDF (Write)}{
  (Default - null)
                                                                               
  The name of the output reference image. If this
  is null, then no output image will be made.
                                                                               
  THIS WILL BE CREATED AS A `REAL*4' 32 BIT IMAGE.
                                                                               
}\sstsubsection{SCALE1 = {\undersc}REAL (Read)}{
  (Default - 1.0            \hspace*{6ex}        Range - 0.0 to 1.0e8)
                                                                               
 The scale you want the first image to be put at. The image is
 multiplied by this before adding into the output (after
 subtracting any zero level).
                                                                               
 This could, for a series of images of different exposure times,
 be inversely proportional to the exposure times. Since the scale is
 multiplied into the pixel values, it is recommended that the longest
 exposure have a `scale' of 1.0, and the others in proportion. This
 avoids loosing accuracy when the output image (which is real) is
 later converted back to a short integer one.
                                                                               

}\sstsubsection{ }{
   {\large \bf This is repeated for SCALE2 to SCALE10}

   \vspace*{2mm}


}\sstsubsection{SIZE = {\undersc}INTEGER(2) (Read)}{
  (Default - 100,100 or largest needed          \hspace*{6ex} Range - 1 to 100000)
                                                                               
  If no reference image is input, then this is the size of
  the one to make. The default will be just large enough to take
  all the input images.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - null             \hspace*{6ex}       Choice - any)
                                                                               
  The title to add to the output image.
                                                                               
}\sstsubsection{TITLEL = LITERAL (Read)}{
  (Default - null            \hspace*{6ex}        Choice - any)
                                                                               
  The title to add to the output reference load image.
                                                                               
}\sstsubsection{TITLER = LITERAL (Read)}{
  (Default - null            \hspace*{6ex}        Choice - any)

  The title to add to the output reference image.
                                                                               
}\sstsubsection{XCOEFF1 = {\undersc}REAL(3) (Read)}{
  (Defaults - 0.0,1.0,0.0       \hspace*{6ex}    Range -1.0e8 to 1.0e8)
                                                                               
 The X transformation coefficents of the set to transform the
 first input image coordinates to the reference image. These
 are in the form:-
                                                                               
  $$   x1 = c1 + c2.x + c3.y $$
  $$   y1 = c4 + c5.x + c6.y $$
                                                                               
 where: (x,y) are the coordinates in the input image.
        (x1,y1) are the coordinates in the reference image,
                                                                               
  The default is no translation, rotation or stretching:-
                                                                               
$$     x1 = 0.0 + 1.0*x + 0.0*y $$
  $$   y2 = 0.0 + 0.0*x + 1.0*y $$


}\sstsubsection{ }{
   {\large \bf This is repeated for XCOEFF2 to XCOEFF10}

   \vspace*{2mm}
                                                                               
}\sstsubsection{YCOEFF1 = {\undersc}REAL(3) (Read)}{
  (Defaults - 0.0,0.0,1.0      \hspace*{6ex} Range -1.0e8 to 1.0e8)
                                                                               
 The Y transformation coefficents of the set to transform the
 first input image coordinates to the reference image. These
 are in the form:-
                                                                               
  $$   x1 = c1 + c2.x + c3.y $$
  $$   y1 = c4 + c5.x + c6.y $$
                                                                               
 where: (x,y) are the coordinates in the input image.
        (x1,y1) are the coordinates in the reference image,
                                                                               
  The default is no translation, rotation or stretching:-
                                                                               
  $$   x1 = 0.0 + 1.0*x + 0.0*y $$
  $$     y2 = 0.0 + 0.0*x + 1.0*y $$
                                                                               

}\sstsubsection{ }{
   {\large \bf This is repeated for YCOEFF2 to YCOEFF10}

   \vspace*{2mm}
                                                                               
                                                                               
}\sstsubsection{ZERO = LITERAL (Read)}{
  (Default - `no'      \hspace*{6ex}          Choice - `yes:no')
                                                                               
  Do you want a `zero' level removed from the input image before
  scaling and adding to the output image?
                                                                               
}}}

\ajhsect{\arabic{section}}{Image Programmes - \hspace*{0.2in} IMROTATE}
 
\sstroutine{IMROTATE}{Rotate an Image by  90, 180, or 270 Degrees}{
 
\sstdescription{ 
                                                                               
  Rotates an image anti-clockwise by 90, 180, or 270 degrees.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{DEGREES = LITERAL (Read)}{
  (Default - '90'  \hspace{6ex}    Choice - `90:180:270')
                                                                               
  Number of degrees anti-clockwise to rotate image.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
 (Default - null)
                                                                               
  The name of the input image file.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
 (Default - null)
                                                                              
  The name of the new file containing the output image.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title, or if null, 'Output from IMCUT'
   Choice  - any)
                                                                               
  Title to add to output image
                                                                               
                                                                               
}}}

\ajhsect{\arabic{section}}{Image Programmes - \hspace*{0.2in} IMSTAT}
 
\sstroutine{IMSTAT}{ Statistics of an Image Area  }{
 
\sstdescription{ 
                                                                               
  Calculates statistics of an area of the image
                                                                               
  Takes an input area of an image, and calculates the mean and
  standard deviation, minimum and maximum pixel values (with their
  locations), the number of valid and invalid pixels, and the sum
  of the valid pixel values.
                                                                               
  The results are typed out, and also put as parameters of the
  programme
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the input image file.
                                                                               
}\sstsubsection{MEAN = {\undersc}REAL (Write)}{
                                                                               
  Set by programme. The mean of the valid pixel values in the
  selected area.
                                                                               
}\sstsubsection{NBAD = {\undersc}INTEGER (Write)}{
                                                                               
  Set by programme. The number of invalid pixels in the selected area.
                                                                               
}\sstsubsection{NGOOD = {\undersc}INTEGER (Write)}{
                                                                               
  Set by programme. The number of valid pixels in the selected area.
                                                                               
}\sstsubsection{STDDEV = {\undersc}REAL (Write)}{
                                                                               
  Set by programme. The standard deviation of the valid pixel values in
  the selected area.
                                                                               
}\sstsubsection{SUM = {\undersc}REAL (Write)}{
                                                                               
  Set by programme. The sum of the values of the valid pixels in the
  selected area.
                                                                               
}\sstsubsection{XMAXLOC = {\undersc}INTEGER (Write)}{
                                                                               
  Set by programme. The X location of the pixel with the maximum value
  in the selected area.
                                                                               
}\sstsubsection{XMINLOC = {\undersc}INTEGER (Write)}{
                                                                               
  Set by programme. The X location of the pixel with the minimum value
  in the selected area.
                                                                               
}\sstsubsection{XRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,input image X size     Range - 1 to input image X size)
                                                                               
  X start and X end of the area of image to analyse
                                                                               
}\sstsubsection{YMAXLOC = {\undersc}INTEGER (Write)}{
                                                                               
  Set by programme. The Y location of the pixel with the maximum value
  in the selected area.
                                                                               
}\sstsubsection{YMINLOC ={\undersc}INTEGER (Write)}{
                                                                               
  Set by programme. The Y location of the pixel with the minimum value
  in the selected area.
                                                                               
}\sstsubsection{YRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,input image Y size     Range - 1 to input image Y size)
                                                                               
  Y start and Y end of the area of image to analyse
                                                                               
}}}

\ajhsect{\arabic{section}}{Image Programmes - \hspace*{0.2in} IMTYPE}
 
\sstroutine{IMTYPE}{Convert `Type' of Image}{
 
\sstdescription{ 
                                                                               
  This program converts an image of one type into one of
  another type.
                                                                               
  The types it can deal with are:-

\begin{tabular}{|c|c|}\hline
     Type            &  Name \\ \hline
     32-bit real     &  REAL \\
     32-bit integer  &  INTEGER \\ 
     16-bit integer  &  SHORT \\ \hline
\end{tabular}
                                                                               
 It deals with values above and below the range of permitted values
 in the output image, by truncating them at the edge of the permitted
 ranges. Permitted ranges:- INTEGER -2147483648 to 2147483647 and
 SHORT   -327678 to 32767
                                                                               
 For the conversion from Real to Integer or Short, and from Integer
 to Short, there is the
 possibility of overflow of the numbers, so they may be scaled
 by the formula
                                                                               
            `stored value' = (`true value'-BZ)/BS
                                                                               
 where the `stored value' is the one that must not overflow the
 output data format limits.
                                                                               
 It translates the `INVAL' parameter to and from real and integer.
                                                                               
 If an `INVAL' value lies outside the permitted output ranges, this
 is dealt with by putting it at the format pixel value limits.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{IN = BDF (Read)}{
 (Default - null)
                                                                
  The name of the input image.
                                                                               
}\sstsubsection{INTYPE = LITERAL (Read)}{
  (Default - `real' \hspace*{6ex}    Choice - 'real:integer:short')
                                                                               
  The type of the input image.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
 (Default - null)
                                                                               
  The name of the output image.
                                                                               
}\sstsubsection{OUTTYPE = LITERAL (Read)}{
  (Default - `short'   \hspace*{6ex}      Choice - `real:integer:short')
                                                                               
  The type of the output image.
                                                                               
}\sstsubsection{SCALE = {\undersc}REAL(2) (Read)}{
  (Default - the values of the input image     \hspace*{6ex}    Range - -1.0e20 to 1.0e20)
                                                                               
  The scale and zero to be applied to the output image.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title )
                                                                               
  The title to be attached as a header to the output image.
                                                                               
}}}

\ajhsect{\arabic{section}}{Image Programmes - \hspace*{0.2in} IMWRDES}
 
\sstroutine{IMWRDES}{Write Descriptors to Image}{
 
\sstdescription{ 
                                                                               
 Allows descriptor items to be overwritten with new information, or
 inserted if they were not present, into an image.
                                                                               
  If the `LOOP' parameter is not set (or set to `Yes'), then the
  program loops, asking for new descriptor names until a `null'
  response is input. If it is set to `No' (in the command line),
  then only one descriptor is asked for.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{LOOP = (Read)}{
  (Default - `yes'   \hspace*{6ex}     Choice - `yes:no')
                                                                               
  This is a hidden parameter. To set it to `no', you have to
  puit it into the command line.
                                                                               
  If `yes', then the program loops, asking for new descriptor names
  until a `null' response is input. If `no', then only one
  descriptor is asked for.
                                                                               
}\sstsubsection{IN = (Read)}{
  (Default - null)
                                                                               
  Name of file containing image
                                                                               
}\sstsubsection{NAME = (Read)}{
  (Default - null       \hspace*{6ex}        Choice - any)
                                                                               
  The name of the descriptor.
                                                                               
  A null response will end the program.
                                                                               
}\sstsubsection{VALUE = (Read)}{
  (Default - null     \hspace*{6ex}          Choice - any)
                                                                               
  A character string to give the `value' to insert into
  the descriptor.
                                                                               
}}}

\newpage
\section{Table Programmes}
\ajhsect{\arabic{section}}{TABLE PROGRAMMES}
\label{se:progtb}
\newpage


\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBCALC}
 
\sstroutine{TBCALC}{Calculate table elements}{
 
\sstdescription{ 
 This program allows arithmetic and mathematical functions to be
 applied to a number of input tables and constants by means of a
 FORTRAN-like expression which specifies the required functions. In
 addition to the standard FORTRAN facilities, a number of special
 functions are available (e.g. for adding noise).

}\sstdiytopic{Method}{
 For up to 20 columns of the output table, the user inputs a
 Fortran-like equation (through the parameters EQN1, EQN2, ...).
 These equations can contain references to:-

 \begin{list}{{-}}{}
   \item specified columns of specified tables (which must all have the
     same number of rows, but may have different numbers of columns)
   \item variables
   \item constants
   \item Fortran operators on these (e.g. `+', or `cos()', ... )
  \end{list}
                                                                               
 (For more details on the structure of these equations ) see
 the `equation' section.)
                                                                               
 For each specified output column, the relevant equation is
 analysed and the operations are performed. Each row of that output
 column contains the results of the equation, with the data for
 the input tables coming from the matching row of those input tables.
                                                                               
 More specifically, the equations are analysed to identify the names
 of tables and variables and to evaluate constants and are then
 converted into reverse-Polish notation. The tables and variables are
 prompted for in alphabetical order and the program then performs
 simple `stack-arithmetic' to evaluate the expression for each output
 table element.
                                                                               
 The output table can be made by:-

  \begin{list}{{-}}{}
   \item  Imposing the calculated columns on a `template' table - which
          must be one of the input tables.
   \item  Imposing the calculated columns on a `template' table - which
          must be one of the input tables - and zeroing all the other
          columns
   \item  Making a new table from scratch - whose total number of
          columns is user defined, and whose columns that are not
          calculated set to zero.
   \end{list}

 If a 'template' table is used, and any of the calculated columns
 are 'beyond' the end of the template, then the output is extended 
 to hold those, with any columns missed out set to zero.
                                                                       
 The size of the output table is:-
   
  \begin{list}{{-}}{}
  \item That of the `template' table, plus (optionally) some columns.
  \item Or has a user defined number of columns with the number of rows
        being the same as the number of rows in the input tables.
  \item Or, if there are no input tables, the number or columns and rows
        are user defined.
  \end{list}
                                                                               
}\sstdiytopic{Equations}{
 An arithmetic expression of up to 80 characters which gives the
 function to be evaluated for each output table element. The syntax
 is similar to Fortran (same operator precedence, etc.) but with the
 following differences:
               
 \begin{enumerate}  
 \item Input tables are represented by any of the variables TAn1, TBn2, ...
    to TZnm, where the `A', `B' etc., refer to the table and the `n1',
    `n2', .. etc., refer the column number in that table to use.
 \item Numerical parameters by any of the variables variables A to Z
 \item  Constants by any numerical Fortran constant (real or integer,
    including exponent if required).
 \item Arithmetic is performed as though all values were real, The actual
    calculations are performed in double precision, and the results
    translated back to reals.
 \item The standard Fortran functions are available and identified
    by their generic names, i.e. SQRT, EXP, LOG10, LOG, SIN, COS, TAN,
    ASIN, ACOS, ATAN, ATAN2, SINH, COSH, TANH, ABS, AINT, ANINT, MOD,
    SIGN, DIM, MIN and MAX. Note, however, that MIN and MAX may take only
    2 arguments.
 \item To avoid problems with the way the Starlink environment
    handles character parameters, the comma `,' must be replaced with
    the colon `:' for separating function arguments. Similarly, the
    division sign `\/' may be replaced by the percent sign `\%', although
    this latter substitution is not necessary when replying to a prompt
    at the terminal.
 \item There are three extra functions available:-

    \begin{tabular}{lp{4in}}
    CLIP(A,B,C) & This gives the value B so long as it lies in the
                 interval A to C (inclusive). Otherwise it gives a
                 zero result. It may be used to remove output values
                 outside a certain range (e.g. if a division operation
                 has resulted in very large output values). \\
    GAUSS(X)    & Gives gaussian noise with zero mean and standard
                 deviation X (the value returned is different at each
                 element and for each call of GAUSS). \\
    RAN(X)      & Gives uniform noise with a value between zero and X
                 (the value returned is different at each element and
                 for each call of RAN). \\
    \end{tabular}
  \end{enumerate}
                                                                               
  For example, an equation of the form:-
                                                                               
 $$        TA2*3.3+0.5+COS(TB1)+A   $$
                                                                               
  will fill each row of a specified output column with:-
                                                                               
 \hspace*{1.0em}( 3.3 times the element in that row of column 2 of input 
    table specifed by parameter `INA' ) \hspace*{\fill} \\
  + ( 0.5 ) \hspace*{\fill} \\
  + ( cosine of the element in that row of column 1 of input table 
    specifed by parameter `INB' ) 
   \hspace*{\fill} \\
  + ( the user defined value of the variable `A' ) \hspace*{\fill} 
                                                                               
}\sstdiytopic{Input}{
  Only tables and variables used in the expressions are prompted for and
  these are requested in alphabetical order, and only once each.
                                                                               
}\sstparameters{
\sstsubsection{CLEAR = LITERAL (Read)}{
  (Default - `no'  \hspace*{6em}    Choice - `yes:no')
                                                                               
  Are the columns of the output table that have not been set by
  the equations to be set to zeroes?
                                                                               
}\sstsubsection{NUMCOLS = {\undersc}INTEGER (Read)}{
  (Default - largest column number defined     \hspace*{6em}    
   Range - that to 999)
                                                                               
  The number of columns in the output table. If a template table is
  not being used, then this must be a user-defined value. This
  number must be at least as large as the largest column number
  defined for any of the equations.
                                                                               
}\sstsubsection{NUMROWS = {\undersc}INTEGER (Read)}{
  (Default - 1            \hspace*{6em}    Range - 1 to 100000)
                                                                               
  If there are no input tables, the user has the choice of how
  many rows there are in the output table. Then all the rows will
  have the same set of values for the columns. The names of the
  rows will be `\#1', `\#2', etc..
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                               
 The output table to contain the result.
                                                                               
 This contains the defined columns. There may be other columns. These
 other columns contain either the values from the input template table,
 or are full of zeroes if there was;- no input tables, no input
 template table, or the user decided to set those columns to zero.
                                                                               
 The size of the output table is:-

  \begin{list}{{-}}{}
  \item That of the `template' table, plus (optionally) some columns.
  \item Or has a user defined number of columns with the number of rows
        being the same as the number of rows in the input tables.
  \item Or, if there are no input tables, the number or columns and rows
        are user defined.
  \end{list}
                                                                               
  The names of the rows will either be those from the template table,
  or will be `\#1', `\#2', etc..
                                                                               
}\sstsubsection{SEED = {\undersc}INTEGER (Read)}{
  (Default - 1234567891     \hspace*{6em}    Range - 1200000001 to 1400000001)
                                                                               
  The seed number to be used in any random number generators.
  This is used in the `GAUSS()' and `RAN()' operators. These
  will provide the same pattern of numbers in the same
  seed number is input.
                                                                               
  It has to be a large positive odd number.
                                                                               
}\sstsubsection{TEMPLATE = LITERAL (Read)}{
  (Default - `none'    \hspace*{6em}    Choice - 
   `none:ta:tb:tc:td:te:tf:tg:th:ti:tj:tk:tl:tm:tn:to:tp:tq: \\
   \hspace*{\fill} tr:ts:tt:tu:tv:tw:tx:ty:tz')
                                                                               
  The parameter that defines the input table to be used as the
  template for the output table.
                                                                               
  If a template tables is used (selected from the `TA', etc. parameters
  that must come from those already used in the `EQN1', etc.,
  parameters), then the output table is a copy of the that template
  table, except for the new columns values from the equations (with
  the choice of zeroing all the other values).
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - title of input template table or `Output from Tbcalc'
     \hspace*{6em}    Choice - any )
                                                                               
  The title for the output table.
                                                                               
}\sstsubsection{COLUMN1 = {\undersc}INTEGER (Read)}{
  (Default - 1         \hspace*{6em}    Range - 0 to 999 )
                                                                               
  The column number in the output table that the results of the
  calculations from the first equation are to be put into.
                                                                               
  A response of zero indicates that no more columns are to be
  calculated.
                
}\sstsubsection{ }{
   {\large \bf This is repeated for COLUMN2 to COLUMN20 }

   \vspace*{2mm}
                                                                               
                                                                               
}\sstsubsection{EQN1 = LITERAL (Read)}{
  (Default - null         \hspace*{6em}    Choice - as defined below)
                                                                               
  The FORTRAN-style expression that gives the elements in the
  defined (by `Column1') column in the output table.
                                                                               
  Its style is given the `equation' section of this help.
                
}\sstsubsection{ }{
   {\large \bf This is repeated for EQN2 to EQN20 }

   \vspace*{2mm}
                                                                               
}\sstsubsection{HEAD1 = LITERAL (Read)}{
  (Default - see below          \hspace*{6em}      Choice - any)
                                                                               
  The (up to) 20 character string giving the `header' of the
  column for the first equation.
                                                                               
  The default will be that of the template table or just blanks
  if there is no template.
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for HEAD2 to HEAD20 }

   \vspace*{2mm}
                                                                               
}\sstsubsection{INA = BDF (Read)}{
 (Default - null)
                                                                               
 The input table corresponding to 'TA' to be used in the arithmetic
 expressions.
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for INB to INZ }

   \vspace*{2mm}
                                                                               
}\sstsubsection{A = {\undersc}REAL (Read)}{
  (Default - 0.0         \hspace*{6em}        Range -1.0e37 to 1.0e37)
                                                                               
  The value to be used in the expressions for the value of
  the variable 'A'.
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for B to Z }

   \vspace*{2mm}

}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBCHART}
 
\sstroutine{TBCHART}{Star Chart from Table of Positions, Magnitudes }{
 
\sstdescription{ 
                                                                               
 This plots out a realistic looking star map, with filled circles,
 bigger for brighter stars, at the positions of an input list of
 star positions and magnitudes. The star identifications may be put
 by the stars. Overlapping stars may be distinguished by having
 circles round all stars. If used, these circles may be removed
 (overwritten).
                                                                               
 The program is worked using a menu-driven approach. You choose
 various options from the menu. This menu can be driven through a
 'panel-button' type of display.
                                                                               
 With an interactive device, a cursor can be used to read out the
 cursor position and the details of the nearest star read out.
                                                                               
 The user has control of the ranges of star positions and magnitudes
 that are plotted out and the size of the area plotted. More than
 one input list may be plotted.
                                                                               
 In a star identifier, a `\#' as the 1st charcater is ignored, and a star
 identifier consisting solely of `\#' is not put out.
                                                                               
}\sstdiytopic{Menu}{
  This is the menu of options open to the user.
                                                                               
\begin{tabular}{|c|l|}\hline
   Option  &    Function \\ \hline
   Circle   &   Write a circle round each star \\
   Clear    &   Clear Display \\
   Close    &   Close Display \\
   Device   &   Open (new) display device \\
   Exit     &   Exit from program \\
   Gcursor  &   Get position and nearesy star with cursor \\
   Getdata  &   Open an input table \\
   Label    &   Plot the labels \\
   Lsize    &   Set the labels size \\
   Mrange   &   Change limits on table magnitude selection \\ 
   Mscale   &   Change magnitude plotting scale \\
   Panel    &   Toggle between keyboard and panel option input \\
   Plot     &   Plot the points \\
   Prange   &   Change limits on table position selection \\
   Psize    &   Change the plotting limits \\
   Uncircle &   Write over any circles round stars \\ \hline
\end{tabular}
                                                                               
}\sstdiytopic{Cursor Use}{                                                                               
   To input cursor positions, position cursor at desired point
   and press any key. End by locating cursor outside graph
                                                                               
}\sstparameters{
                                                                               

\sstsubsection{COMMAND = LITERAL (Read)}{
  (Default - `no'     \hspace{6ex}       Choice - `yes:no')

  This is used when using the `panel' instruction input. It has no
  function other than to permit use of the full help system by
  responding `?' or `??', and to permit use of the `dropping through'
  to the operating system by use of the `\$' symbol before a normal
  DCL instruction, e.g. `\$ DIRECTORY/SIZE'.

  After you have used the help, then just reply `no' with a `return'
  key entry.
                                                                               
}\sstsubsection{DEVLIMX = {\undersc}INTEGER(2) (Read)}{
  (Default - Min,max in table     \hspace*{6ex}       Range - -1.0e10 to 1.0e10)
                                                                               
  The X start and end of the area to be plotted.
                                                                               
}\sstsubsection{DEVLIMY =  {\undersc}INTEGER(2) (Read)}{
  (Default - Min,max in table   \hspace*{6ex}         Range - -1.0e10 to 1.0e10)
                                                                               
  The Y start and end of the area to be plotted.
                                                                               
}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question, 
  in a different way. A response here of `?' will bring up a listing 
  of all the possible names of graphics devices which are supported 
  on your machine, and you then input the appropriate name.
                                                                               
}\sstsubsection{IDINAME = LITERAL (Read)}{
 (Default - `ikon'      \hspace{6ex}       Choice - any)
    
   The local name defining the display device. The list of names
   call be seen in the file with the logical name `GNS\_IDINAMES'.
   Remember that the case of the letters matters.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (default - null)                                                                               
  The name of the file containing the input (position, magnitude)
  table.
                                                                               
}\sstsubsection{LSIZE =  {\undersc}REAL (Read)}{
  (Default - 1.0        \hspace*{6ex}             Range - 0.0 to 1.0e10)
                                                                               
  The size of the text to be used when plotting the stars
  identifiers. A size of 1.0 gives letters with heights of about
  1/100th of the plotted Y range.
                                                                               
}\sstsubsection{MMIN =  {\undersc}REAL (Read)}{
  (Default - Maximum in table   \hspace*{6ex}          Range - -1.0e10 to 1.0e10)
                                                                               
  The zero point in the scale for plotting the radii of the
  circles to represent a star. These circles have radii
  of:- (MMIN-mag)*MSCALE in terms of the plotted scale.
                                                                               
}\sstsubsection{MRANGE =  {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table   \hspace*{6ex}         Range - -1.0e10 to 1.0e10)
                                                                               
  The start and end of the range of magnitudes in the table
  that a star can have to be plotted.
                                                                               
}\sstsubsection{MSCALE =  {\undersc}REAL (Read)}{
  (Default - 1.0         \hspace*{6ex}     Range - -1.0e10 to 1.0e10)
                                                                               
  The 'SCALE' in the scale for plotting the radii of the
  circles to represent a star. These circles have radii
  of:- (MMIN-mag)*MSCALE in terms of the plotted scale.
                                                                               
}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the Starman programmes use all three, with
  the right-hand button being used mainly as the `exit' button. 

  With two buttons, then the third button is simulated by pressing 
  both of the buttons down, with the middle one being pressed slightly 
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will 
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - see below   \hspace*{6ex}             Choices - see below)
                                                                               
  This is the menu of options open to you.
                                                                               
\begin{tabular}{|c|l|}\hline
   Option  &    Function \\ \hline
   Circle   &   Write a circle round each star \\
   Clear    &   Clear Display \\
   Close    &   Close Display \\
   Device   &   Open (new) display device \\
   Exit     &   Exit from program \\
   Gcursor  &   Get position and nearesy star with cursor \\
   Getdata  &   Open an input table \\
   Label    &   Plot the labels \\
   Lsize    &   Set the labels size \\
   Mrange   &   Change limits on table magnitude selection \\ 
   Mscale   &   Change magnitude plotting scale \\
   Panel    &   Toggle between keyboard and panel option input \\
   Plot     &   Plot the points \\
   Prange   &   Change limits on table position selection \\
   Psize    &   Change the plotting limits \\
   Uncircle &   Write over any circles round stars \\ \hline
\end{tabular}
                                                                               
                                                                               
   To input cursor positions, position cursor at desired point
   and press any key. End by locating cursor outside graph
                        

}\sstsubsection{PDSTYPE = LITERAL (Read)}{
 (Default - `decw'      \hspace{6ex}    Choice - `none:vws:decw')

  Image display device to put windows-type `panel' of options
  up on.

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{XRANGE =  {\undersc}INTEGER(2) (Read)}{
  (Default - Min,max in table   \hspace*{6ex}         Range - -1.0e10 to 1.0e10)
                                                                               
  The X start and end of X range of positions in the table
  that a star can have to be plotted.
                                                                               
}\sstsubsection{YRANGE =  {\undersc}INTEGER(2) (Read)}{
  (Default - Min,max in table   \hspace*{6ex}         Range - -1.0e10 to 1.0e10)
                                                                               
  The Y start and end of Y range of positions in the table
  that a star can have to be plotted.
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBCOMPS}
 
\sstroutine{TBCOMPS}{ Find Companions to Stars }{
 
\sstdescription{ 
                                                                               
   This takes a table and finds positions in it which are within a
   given annulus of any other position in the table. Such positions are output
   to an output table.
                                                                               
   Optionally, it can output those positions which are NOT within these
   annulii.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{LIMITS = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0     \hspace*{6ex}       Range - 0.0 to 1.0e10)
                                                                               
  Annulus around every position which is either forbidden or
  necessary to output positions.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The file containing the input table
                                                                               
}\sstsubsection{OPTION = LITERAL (Read)}{
   (Default - 'within'     \hspace*{6ex}        Choice -  'within:not\_within')
                                                                               
   Find all positions within (within) or not within (not\_within)
   annulus round any other position.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                               
    The output file
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - `Output from TBCOMPS'   \hspace*{6ex}           Choice - any)

    The Title to be added to the output file
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBCOPDES}
 
\sstroutine{TBCOPDES}{ Copy Descriptors from one Table to Another }{
 
\sstdescription{ 
                                                                               
   This copies the descriptors of one table onto another.
   Optionally you can choose to overwrite or not descriptors that
   already occur in the output table. If you do overwrite, then
   you can choose to delete existing descriptors before overwriting.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{DELETE = LITERAL (Read)}{
   (Default = 'yes'     \hspace*{6ex}     Choice  -  'yes:no')
                                                                               
   Whether to delete all existing descriptors before overwriting.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The name of file with the table to get the descriptors from.
                                                                               
}\sstsubsection{OUT = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file with the table to put the descriptors to.
                                                                               
}\sstsubsection{OVER = LITERAL (Read)}{
   (Default = 'yes'  \hspace*{6ex}   Choice - 'yes:no')
                                                                               
   Whether to overwrite already existing descriptors.
                                                                               
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBCUT}
 
\sstroutine{TBCUT}{ Cut Parts Out of a Table to Make a New One }{
 
\sstdescription{ 
                                                                               
   This cuts out columns and rows of a table and ouputs those cut out
   rows and columns to a new table in a new file.
                                                                               
   You input up to 20 stretches of columns and up to 20 stretches
   of rows to cut out and save.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{COL1 = {\undersc}INTEGER(2) (Read)}{
  (Default - 0,all   \hspace*{6ex}      Range - 0 to no of columns)
                                                                               
   The 1st section of columns to cut out and save. Thus `1,2' would cut
   out and save the first two columns of the input table.
                                                                               
   If the first number is zero, then this entry is ignored
   and no more column sections are requested.

}\sstsubsection{ }{
   {\large \bf This is repeated for COL2 to COL20 }

   \vspace*{2mm}
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
   The name of the file containing the input table.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                               
   The name of the file to contain the output table.
                                                                               
}\sstsubsection{ROW1 = (Read)}{
  (Default - 0,all   \hspace*{6ex}      Range - 0 to no of rows)
                                                                               
   The 1st section of rows to cut out and save. Thus `1,2' would cut
   out and save the first two rows of the input table.
                                                                               
   If the first number is zero, then this entry is ignored
   and no more row sections are requested.
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for ROW2 to ROW20 }

   \vspace*{2mm}
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - `Output from TBCUT'  \hspace*{6ex}         Choice - any)
                                                                               
  The keyword to be added to the output file as a 'Title'.
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBJOIN}
 
\sstroutine{TBJOIN}{ Concatenate Tables }{
 
\sstdescription{ 
                                                                               
  This program allows up to nine tables to be concatenated.
                                                                               
  It allows you to shift the data in the files relative to each
  other before joining. Thus if you have:-

\setlength{\unitlength}{1mm}                                 
\begin{picture}(100,55)
\put(20,25){A}
\put(60,25){B}
\put(10,5){\framebox(30,45){\hspace*{1ex}}}
\put(50,5){\framebox(30,45){\hspace*{1ex}}}
\end{picture}

                                                                               
  you can join them
                                                                               
\setlength{\unitlength}{1mm}                                 
\begin{picture}(100,75)
\put(30,40){A}
\put(60,30){B}
\put(20,20){\framebox(30,45){\hspace*{1ex}}}
\put(40,10){\framebox(30,45){\hspace*{1ex}}}
\end{picture}
                                                                               
   They do not even have to overlap.
                                                                               
   The 2nd (and optionally ) later file is written on top of the 1st
   file data,identifiers, and headers deleting them. Parameters with no
   entry are put to 0.0.
                                                                               
   To simply add one file onto the end of another, use the default
   displacements.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{COLOFF2 = {\undersc}INTEGER (Read)}{
 (Default - 0    \hspace*{6ex}       Range - -1000000 to 1000000)
                                                                               
  The no of columns that the parameters in the 2nd file
  are to shifted along before the files are added.
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for COLOFF3 to COLOFF9 }

   \vspace*{2mm}
                                                                               
}\sstsubsection{IN1 = BDF (Read)}{
  (Default - null)
                                                                               
      The first input table

}\sstsubsection{IN2 = BDF (Read)}{
  (Default - null)
                                                                               
      The optional second input table
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for IN3 to IN9 }

   \vspace*{2mm}
                                                                               
}\sstsubsection{OUT = BDF (Read)}{
  (Default - null)
                                                                               
      The output table.
                                                                               
}\sstsubsection{ROWOFF2 = {\undersc}INTEGER (Read)}{
 (Default - see below    \hspace*{6ex}      Range - -1000000 to 1000000)
                                                                               
  The no of rows that the parameters in the 2nd file are to shifted
  up or down before the files are added.
                                                                               
  The default is that value which will add this table to the end
  of the previously input tables.
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for ROWOFF3 to ROWOFF9 }

   \vspace*{2mm}
                                                                               
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - That of 1st table or 'Output from TBJOIN'        \hspace*{6ex}    Choice - any)
                                                                               
      The title for the output list.
                                                                               
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBKEY}
 
\sstroutine{TBKEY}{ Input a Table from the Keyboard}{
 
\sstdescription{ 
                                                                               
  This programme inputs data for a table from the keyboard.

  The user inputs the following information on the keyboard:-

\begin{enumerate}
\item The number of columns the output table will have.
                                                                               
\item The lines (rows) of data, in the format:-
         r1,r2,r3,,,rn,name
                                                                               
     The `r1', `r2' ,,   are the input values. If less numbers than
     the number of columns is input, the later ones will be assigned
     the value zero. Up to 100 entries can be input in the line (up
     to the maximum set by the `NUMCOL' parameter).
                                                                               
     The `name' is the identifier for the row. If this is ommitted
     then the identifier will be "\#N', where `N' is the number of the
     row. The identifier can have up to 20 characters.
                                                                               
     The total length of the character string must be less than or
     equal to 256 characters.
                                                                               
\item A null entry signifying the end of inputting data.
                                                                               
\item The name of the file to output the table to.

\item A text string as the `title' to the table 

\item Text strings as `headers' for each column.
\end{enumerate}
                                                                               
   If more than 1000 lines are to be input, you must set the MAXROW
   parameter accordingly, before entering the program.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{DATA = LITERAL (Read)}{
  ( Default - null     \hspace*{6ex}  Choice - see below)
                                                                               
  A character string giving the data to be input, in the format:-
                                                                               
        \hspace*{\fill}  r1,r2,r3,,,rn,name \hspace*{\fill}
                                                                               
     The `r1', `r2' ,,   are the input values. If less numbers than
     the number of columns is input, the later ones will be assigned
     the value zero. Up to 100 entries can be input in the line (up
     to the maximum set by the `NUMCOL' parameter).
                                                                               
     The total length of the character string must be less than or
     equal to 256 characters.
                                                                               
     Where `name' is the identifier for the row. If this is ommitted
     then the identifier will be "\#N', where `N' is the number of the
     row. The identifier can have up to 20 characters.
                                                                               
  A null entry signifies the end of inputting data.
                                                                               
}\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - see below  \hspace*{6ex}  Choice - see below)
                                                                               
  The character string to act as header for the column. This can
  be up to 20 characters long. This is asked for each column.
                                                                               
  The defaults are:- 

\begin{tabular}{|c|l|}\hline
 Column Number & Default \\ \hline
     1 & `X' \\
     2 & `Y' \\
     3 & `MAGNITUDE' \\
  later ones & ` ' \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{NUMCOL = {\undersc}INTEGER (Read)}{
  (Default - 2     \hspace*{6ex}   Range - 1 to 100)
                                                                               
  The number of columns to input into the table. (The identifier
  does not count as a column.)
                                                                               
}\sstsubsection{MAXROW = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - 1000    \hspace*{6ex}   Range - 1 to 1000000)
                                                                               
  The maximum number of rows that can be input.

  This is a hidden parameter, and is not asked for. It can be set on the
  command line or by the `LET TBKEY\_MAXROW=xxx' Command, where `xxx' is
  the number of rows desired.
                                                                               
}\sstsubsection{OUT = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file to contain the output table.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - `Output from TBKEY'    \hspace*{6ex} Choice - any character string)
                                                                               
  A character string (up to 50 characters) to be added to the output
  file as its `title'.
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBLIST}
 
\sstroutine{TBLIST}{ Make a Text file of a Table }{
 
\sstdescription{ 
                                                                               
 Make a text (ASCII) version of a table. This can be typed out
 on the user's console, and can be output to an ASCII text file.
                                                                               
 There are four modes of formatting the output:-

\begin{tabular}{|c|p{4.5in}|}\hline
   Option   &   Output from each row \\ \hline
  'SHORT'   &  The name and the values of the first three columns. 
               The values are output in a 12 character floating format. \\
  'FULL'    &  The name (optionally), and all columns. The values are
               output in a 12 character floating format, with four
               values in each line of the output. \\
  'FIXFORM' &  The name (optionally) and up to 15 selected columns are
               output. The number of characters output in the names is
               defined. The values are outputwith each column having a
               fixed format of having so many places before the
               decimal point, and so many after. \\
  'FORM'    &  Up to 15 selected columns may be chosen from the table.
               These are output with (optionally) the name. The number
               of characters output in the names is defined. The values
               are output in a 12 character floating format, with four
               values in each line of the output. \\
  'HEADER'  &  Just puts out the standard header (see below). \\ \hline
\end{tabular}
                                                                               
  There is an option to precede the values by a standard header.
  This gives the title and the headers for the columns.
  This standard is useful, as TBLOAD can use it to input a similar
  (perhaps edited) text file. Its format is:-
                           
\begin{tabular}{|c|l|l|l|}\hline 
   No & Contents          & 1st ten characters   &   Contents \\ \hline
   1  & Title             & 'Title is: '         &   up to 50 characters \\
   2  & No of columns     & 'Columns = '         &   Integer \\
   3  & No of rows        & 'Rows =    '         &   Integer \\
   4  & 1st column header & 'HEAD001   '         &   up to 20 characters \\
   5  & 2nd column header & 'HEAD002   '         &   up to 20 characters \\
 ...  &   ....            &     ....            &    .... \\
   X  & No of descriptors &  'NumDes =  '        &    Integer \\
   Y  & 1st descriptor   &  name                 &   value \\
   Y  & 2nd descriptor   &  name                 &   value \\
 ...  &   ....            &     ....            &    .... \\ \hline
\end{tabular}
                                                                               
   There must be the same number of headers as there are columns.
                                                                               
   [The number of columns does not include the names.]
                                                                               
   The 'no of descriptors' line must be there. If there are no
   descriptors, then the number should be '0'.
                                                                               
   [The table size and headers are, strictly speaking, descriptors
    themselves, but they are not counted as such in this
    descriptor count. It is only concerned with other, incidental,
    descriptors.]
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - 'short'  \hspace*{6ex}     Choice - 'full:short:none')
                    
 The type of the text lines that precede the table contents lines in the 
 output.
                                                           
  The choice of types is:-

\begin{tabular}{|c|p{4.5in}|}\hline
   Choice  &  Contents of the Lines\\ \hline
   Full    &  A standard heading, which gives the size, the title, the
             headers for the columns, and the descriptors. \\
   Short   &  Just the title and the headers in a short form \\
   None    &  Nothing \\ \hline
\end{tabular}
                                                                               
  The standard heading is useful, as TBLOAD can use it to input a similar
  (perhaps edited) text file.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the input table
                                                                               
}\sstsubsection{MODE = LITERAL (Read)}{
  (Default - 'short'     \hspace*{6ex}        Choice - 'short:full:fixform:form')
                                                                               
 The mode of formatting the output.
                                                                               
 There are four modes of formatting the output. They are listed in the
 start of this section.
                                                                               
}\sstsubsection{NAFT1 = {\undersc}INTEGER (Read)}{
  (Default - 2         \hspace*{6ex}         Range - 0 to 100)
                                                                               
  The number of characters after the decimal point in the 1st output
  column.
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for NAFT2 to NAFT15 }

   \vspace*{2mm}
                                                                               
                                                                               
}\sstsubsection{NBEF1 = {\undersc}INTEGER (Read)}{
  (Default - 4     \hspace*{6ex}      Range - 0 to 100)
                                                                               
  The number of characters before the decimal point in the 1st output
  column.

}\sstsubsection{ }{
   {\large \bf This is repeated for NBEF2 to NBEF15 }

   \vspace*{2mm}
                                                                               
}\sstsubsection{NCOL1 = {\undersc}INTEGER (Read)}{
  (Default - next       \hspace*{6ex}      Range - 0 to no of columns in table)
                                                                               
  The number of the column in the table to be output in the 1st text
  column.
                                                                               
  If 0 is input, no more columns are asked for.
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for NCOL2 to NCOL15 }

   \vspace*{2mm}
                                                                               
}\sstsubsection{NUMNAME = {\undersc}INTEGER (Read)}{
  (Default - 12           \hspace*{6ex}        Range - 0 to 20)
                                                                               
  The number of characters of the name of each row to output.
                                                                               
  If 0 is chosen, then the name is not output.
                                                                               
}\sstsubsection{OUT = ASCII (Write)}{
  (Default - null     \hspace*{6ex}            Choice - see below)
                                                                               
  The name of the file containing the output ASCII file. This
  should have a descriptor, i.e. a simple choice would be
  'tblist.lis'. If the descriptor is omitted, then '.dat' is
  taken.
                                                                               
  If the default null response is made, then no file is output.
                                                                               
}\sstsubsection{TYPING = LITERAL (Read)}{
  (Default - 'yes'       \hspace*{6ex}             Choice - 'yes:no')
                                                                               
  Type out the output to the user's console?
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBLOAD}
 
\sstroutine{TBLOAD}{ Turn an ASCII File into a Table  }{
 
\sstdescription{ 
                                                                               
  This takes an ASCII text file, and loads the contents into a table.
                                                                               
  The input file may contain either just the numbers or both the names
  and numbers. In the first case, then default names \#1,\#2,,,\#n are
  put into the table. In the second case, the name should be the first
  entry in the line.
                                                                               
  The numbers for one row of the output table may take up more than one
  line in the input file. In this case, all the lines of the input file
  should be in the same format, that is a constant number of lines in
  the input file are put into each row of the output table. Also in this
  case, if names are being input, then the name for each row must occur
  only once in the set of input lines (at the beginnning of the first
  line).
                                                                               
  The numbers in a line in the input file must be separated by blanks
  and/or commas.
                                                                               
}\sstdiytopic{Headers}{
  The table title and headers may be input automatically, if they are
  put in a standard format at the start of the input file. This format
  is a series of lines with the first ten characters being a description
  and the remainder the values. The order of these lines is fixed. It
  is:-
                                                                               
                           
\begin{tabular}{|c|l|l|l|}\hline 
   No & Contents          & 1st ten characters   &   Contents \\ \hline
   1  & Title             & 'Title is: '         &   up to 50 characters \\
   2  & No of columns     & 'Columns = '         &   Integer \\
   3  & No of rows        & 'Rows =    '         &   Integer \\
   4  & 1st column header & 'HEAD001   '         &   up to 20 characters \\
   5  & 2nd column header & 'HEAD002   '         &   up to 20 characters \\
 ...  &   ....            &     ....            &    .... \\
   N  & No of descriptors &  'NumDes =  '        &    Integer \\
   N+1  & 1st descriptor   &  name                 &   value \\
   N+2  & 2nd descriptor   &  name                 &   value \\
 ...  &   ....            &     ....            &    .... \\ \hline
\end{tabular}

   There must be the same number of headers as there are columns.
                                                                               
   [The number of columns does not include the names.]
                                                                               
   The 'no ofdescriptors' line must be there. If there are no
   descriptors, then the number should be '0'.
                                                                               
   [The table size and headers are, strictly speaking, descriptors
    themselves, but they are not counted as such in this
    descriptor count. It is only concerned with other, incidental,
    descriptors.]
                                                                               
                                                                               
  If this standard format is not chosen, then the headers are input by
  hand, with the first 20 coming from individual program parameters, and
  any remaining input on a single program parameter.
                                                                               
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{HEAD = LITERAL (Read)}{
  (Default - ' '       \hspace*{6ex}          Choice - see below)
                                                                               
  The character string to put as the header of the next column.
  This may be up to 20 characters long
                                                                               
}\sstsubsection{HEAD001 = LITERAL (Read)}{
  (Default - ' '           \hspace*{6ex}      Choice - see below)
                                                                               
  The character string to put as the header of the 1st column.
  This may be up to 20 characters long
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for HEAD002 to HEAD020 }

   \vspace*{2mm}
                                                                               
                                                                               
}\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - 'no'         \hspace*{6ex}       Choice - 'yes:no')
                                                                               
  Does the input file start of with the standard header format
  information? If it does, then this format is as given
  in the start of this section.
                                                                               
                                                                               
   There must be the same number of headers as there are columns.
                                                                               
   [The number of columns does not include the names.]
                                                                               
   The 'no ofdescriptors' line must be there. If there are no
   descriptors, then the number should be '0'.
                                                                               
   [The table size and headers are, strictly speaking, descriptors
    themselves, but they are not counted as such in this
    descriptor count. It is only concerned with other, incidental,
    descriptors.]
                                                                               
}\sstsubsection{HIGNORE = {\undersc}INTEGER (Read)}{
  (Default - 0             \hspace*{6ex}       Range - 1 to 10000)
                                                                               
  As there is not the standard header start to the file, how many
  lines at the start of the file shall be ignored?
                    
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the input data.
                                                                               
}\sstsubsection{NAMES = LITERAL (Read)}{
  (Default - 'no'        \hspace*{6ex}        Choice - 'yes:no')
                                                                               
  Does the input file contain a name for each row of
  the output table?
                                                                               
}\sstsubsection{NLINES = {\undersc}INTEGER (Read)}{
  (Default - 1            \hspace*{6ex}       Range - 1 to 1000)
                                                                               
  The number of lines in the input file that the data, for
  each output table row, occupy.
                                                                               
}\sstsubsection{OUT = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file to contain the output table.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - ' '   \hspace*{6ex}    Choice - any)
                                                                               
  The title to put into the output table. This can be
  up to 50 characters long.
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBMATCH}
 
\sstroutine{TBMATCH}{ Finds Entries with The Same Names in Two Tables }{
 
\sstdescription{ 
                                                                               

   This takes two tables and makes two new ones which are copies 
   of the old ones, but only contain the entries which do (or 
   optionally do not) have names which occur in the other table.

   If the choice is to have entries which do occur in both tables,
   then there is the choice to have those entries occur in the
   output tables either in the same order, or in the order that
   they appeared in their input tables, If the same order is chosen,
   the order is that of occurence in the first table. If there are
   repeated entries with the same names, then only the last such
   occurence is copied over. If the original order is chosen
   however, then those entries occur in the output tables in the
   same order as they occur in their respective input tables and
   repeated entries of the same name are all copied over.

   If the choice is to have entries which do not occur in both
   tables, then those entries occur in the output tables in the
   same order as they occur in their respective input tables.
   Repeated entries of the same name are all copied over.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{IN1 = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file with the 1st input table.
                                                                               
}\sstsubsection{IN2 = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file with the 2nd input table.
                                                                               
}\sstsubsection{OPTION = LITERAL (Read)}{
   (Default - 'accept'        \hspace*{6ex}     Choice - 'accept:reject')
                                                                               
   Accept or reject stars who have names in common with the other table.
                                                                               
}\sstsubsection{OUT1 = BDF (Write)}{
  (Default - null)
                                                                               
   The name of the file for the 1st output table.
                                           
}\sstsubsection{SAME = LITERAL (Read)}{
  (Default - `yes' \hspace*{6ex} Choice - `yes:no')

  Are entries to be copied over in the same order (`yes'), or
  not (when they are copied in the order they occur in their
  repective input tables) (`no')?
                                    
}\sstsubsection{TITLE1 = LITERAL (Read)}{
  (Default - Input 1st table title or 'Output from TBMATCH'  \hspace*{6ex}
   Choice - any)
                                                                               
   The Title to be added to the 1st output file.
                                                                               
}\sstsubsection{OUT2 = BDF (Write)}{
  (Default - null)
                                                                               
   The name of the file for the 2nd output table.
                                                                               
}\sstsubsection{TITLE2 = LITERAL (Read)}{
  (Default - Input 2nd table title or 'Output from TBMATCH' \hspace*{6ex}
   Choice - any)
                                                                               
   The Title to be added to the 2nd output file.
                                                                               
}}}

\ajhsect{\arabic{section}}{General Programmes - \hspace*{0.2in} TBNMATCH}

\sstroutine{TBNMATCH}{ Put tables in the same order of names}{

\sstdescription{


  This takes up to 40 tables and reorders the occurence of their rows
  so that the output tables all have the row names in the
  same order. As some tables may not have rows with names that
  occur in other table(s), then dummy rows with zero entries are
  added and/or inserted into the output tables. Such rows are
  flagged with a user defined value set in a user defined column.

  If a table has more than one row with the same name, then of those
  rows, only the last such row is copied over.

  The order of the output rows will be that of the first table,
  then that of those rows in the second table which are not in
  the first table, then that of the rows in the third table that
  are not in the first two, and so on.

  Up to 40 tables may be input.

}\sstparameters{

\sstsubsection{FLAGCOL = {\undersc}INTEGER (Read)}{
  (Default - 3    \hspace*{6ex}      Range - 1 to smallest number of columns in
                                     input tables)

  Column in output tables to put a flag value into to indicate a 
  missing entry. The other entries in that row will be set at zero.
                                                                               
}\sstsubsection{FLAGVAL = {\undersc}REAL (Read)}{
  (Default - 50.0          \hspace*{6ex} Range - -1.0e20 to 1.0e20)
                                                                               
  Value to put in `flag' column to indicate a missing entry.
  The other entries in that row will be set at zero.
                                                                               
}\sstsubsection{IN1 = LITERAL (Read)}{
  (Default - null)
                                                                               
 The input file containing the 1st table.
                                                                               

}\sstsubsection{ }{
   {\large \bf This is repeated for IN2 to IN40}

   \vspace*{2mm}

                                                                               
}\sstsubsection{MAXIMUM = LITERAL (Read)}{
  (Default - 10000    \hspace*{6ex} Range - 1 to 1000000)
                                                                               
  Maximum number of rows allowed to occur in output tables.
  (This is limitedfor the sake of efficiency in the computing.)
                                                                               
}\sstsubsection{OUT1 = LITERAL (Write)}{
  (Default - null)
                                                                               
 The output file containing the reordered (and possibly extended)
 version of the corresponding input table.
                
}\sstsubsection{ }{
   {\large \bf This is repeated for OUT2 to OUT40}

   \vspace*{2mm}
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
 (Default - Input file title or `Output from Tbnmatch'     \hspace*{6ex}  Choice - any)
                                                                               
 The Title to be inserted in the Output file.
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBPLOT}
 
\sstroutine{TBPLOT}{Plot Graph or Histogram from a Table }{
 
\sstdescription{ 
                                                                               
 This plots out a graph or a histogram from the contents of a table.
                                                                               
 The graph can be isolated dots, or a line.
                                                                               
 The program is worked using a menu-driven approach. You choose
 various options from the menu. This menu can be driven through a
 `panel-button' type of display.
                                                                               
 With an interactive device, a cursor can be used to read out the
 cursor position and the details of the nearest star read out.
                                                                               
                                                                               
}\sstdiytopic{Menu}{
  This is the menu of options open to the user.

\begin{tabular}{|c|p{4.5in}|}\hline
   Option   &   Function \\ \hline
   Aspect   &   Toggle between graph having axes on the same scale
                and axes being independantly scaled \\
   Clear    &   Clear Display \\
   Close    &   Close Display \\
   Device   &   Open (new) display device \\
   Exit     &   Exit from program \\
   Gcursor  &   Get position and nearesy star with cursor \\
   Getdata  &   Open an input table \\
   Histogram &  Plot a histogram \\
   Line      &  Plot data as line \\
   Panel     &  Toggle between keyboard and panel option input \\
   Points    &  Plot data as points \\
   Prange    &  Change limits on table position selection \\
   Psize     &  Change the plotting limits \\ \hline
\end{tabular}
                                                                               
}\sstdiytopic{Cursor Use}{
   To input cursor positions, position cursor at desired point
   and press any key on the keyboard, or maybe press any
   button on the cursor. End by locating cursor outside graph
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{COMMAND = LITERAL (Read)}{
  (Default - `no'       \hspace*{6ex}     Choice - `yes:no')
                                                                               
  This is used when using the `panel' instruction input. It has no
  function other than to permit use of the full help system by
  responding `?' or `??', and to permit use of the `dropping through'
  to the operating system by use of the `\$' symbol before a normal
  DCL instruction, e.g. `\$ DIRECTORY/SIZE'.
                                                                               
  After you have used the help, then just reply `no' with a `return'
  key entry.
                                                                               
}\sstsubsection{DEVLIMX = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table    \hspace*{6ex}        Range - -1.0e20 to 1.0e20)
                                                                               
  The X values of the ends of the plotted graph.
                                                                               
}\sstsubsection{DEVLIMY = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table    \hspace*{6ex}        Range - -1.0e20 to 1.0e20)
                                                                               
  The Y values of the ends of the plotted graph.
                                                                               
}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question, 
  in a different way. A response here of `?' will bring up a listing 
  of all the possible names of graphics devices which are supported 
  on your machine, and you then input the appropriate name.
                                                                               
}\sstsubsection{HRANGE = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table   \hspace*{6ex}   Range - -1.0e20 to 1.0e20)
                                                                               
  The lower and upper limits of data to be put into histogram.
                                                                               
}\sstsubsection{IDINAME = LITERAL (Read)}{
 (Default - `ikon'      \hspace{6ex}       Choice - any)
    
   The local name defining the display device. The list of names
   call be seen in the file with the logical name `GNS\_IDINAMES'.
   Remember that the case of the letters matters.
                                                                               
}\sstsubsection{IN1 = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the first input table.
                                                                               
}\sstsubsection{IN2 = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the second input table.
                                                                               
}\sstsubsection{LSTYLE = {\undersc}INTEGER (Read)}{
  (Default - 1       \hspace*{6ex} Range - 1 to 5)
                                                                               
  Code for style line is to be plotted.

\begin{tabular}{|c|l|}\hline
  Number  Style \\ \hline
    1  &   Full line \\
    2  &   Long dashes \\
    3  &   Dash-dot-dash \\
    4  &   Dotted \\
    5  &   Dash-dot-dot \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{NCOL1 = {\undersc}INTEGER (Read)}{
  (Default - 1    \hspace*{6ex}     Range - 1 to no of columns)
                                                                               
  Column in first table to take data from.
                                                                               
}\sstsubsection{NCOL2 = {\undersc}INTEGER (Read)}{
  (Default - 1      \hspace*{6ex}   Range - 1 to no of columns)
                                                                               
  Column in second table to take data from.
                                                                               
}\sstsubsection{NBIN = {\undersc}INTEGER (Read)}{
  (Default - last chosen, first=40        \hspace*{6ex} Range - 1 to 200)
                                                                               
  No of bins in histogram.
                                                                               
}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the Starman programmes use all three, with
  the right-hand button being used mainly as the `exit' button. 

  With two buttons, then the third button is simulated by pressing 
  both of the buttons down, with the middle one being pressed slightly 
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will 
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - see below     \hspace*{6ex}         Choices - see below)
                                                                               
  This is the menu of options open to the user.

  (The list is given at the start of this section.)
                                                                               
   To input cursor positions, position cursor at desired point
   and press any key on the keyboard, or maybe press any
   button on the cursor. End by locating cursor outside graph
                                         

}\sstsubsection{PDSTYPE = LITERAL (Read)}{
 (Default - `decw'      \hspace{6ex}    Choice - `none:vws:decw')

  Image display device to put windows-type `panel' of options
  up on.

\begin{tabular}{|l|l|}\hline
  Choice   &    Display \\ \hline
   None    &    Do not use display \\
   Vws     &    DEC Vaxstation VWS display \\
   Decw    &    DEC Vaxstation DecWindows display \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{SYMBOL = {\undersc}INTEGER (Read)}{
  (Default - 9       \hspace*{6ex}           Range - 0 to 31)
                                                                               
  Code for style points to be plotted as. The full explanation
  of the symbols is given in the PGPLOT manual.
                                                                               
}\sstsubsection{XRANGE = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table    \hspace*{6ex}        Range - -1.0e20 to 1.0e20)
                                                                               
  The X start and end of X range of positions in the table
  that a star can have to be plotted.
                                                                               
}\sstsubsection{YRANGE = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table      \hspace*{6ex}   Range - -1.0e20 to 1.0e20)
                                                                               
  The Y start and end of Y range of positions in the table
  that a star can have to be plotted.
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBPMATCH}
 
\sstroutine{TBPMATCH}{ Match XY Positions in Two Tables }{
 
\sstdescription{ 
                                                                               
   This takes two tables lists and makes two new ones which are copies of
   the old ones, but only contain the rows which match in X,Y position
   (within an input tolerance).
                                                                               
   The new file entries are in the same order as order they occur in
   the 1st file, but of course there may be rows missing if a match
   fails for that row.
                                                                               
   If the 2nd file has more than one star near enough to the position
   of the star in the 1st to qualify, then selection is done on the
   basis of the option chosen
                                                                               
\begin{tabular}{|l|p{4.5in}|}\hline
     Option   &  Function \\ \hline
     Alldup   &   All such stars - each star as often as it appears \\
     Allnodup &   All such stars - each star only once \\
     Largest  &   Only the star with the largest value in NUMCOL \\
     Nearest  &   Only the nearest star \\
     Smallest &   Only the star with the smallest value in NUMCOL \\ \hline
\end{tabular}
                                                                               
   The position of an entry is taken as X from the first column
   and Y from the second column in the table.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{IN1 = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the 1st input table
                                                                               
}\sstsubsection{IN2 = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the 2nd input table
                                                                               
}\sstsubsection{MISMATCH = {\undersc}REAL (Read)}{
   (Default - 1.0  \hspace*{6ex}     Range - 0.0 to 1.0e20)
                                                                               
    Distance two stars can be apart and still be regarded as matching
    in X,Y position.
                                                                               
}\sstsubsection{METHOD = LITERAL (Read)}{
    (Default - 'nearest'   \hspace*{6ex}        Choice -
                            'alldup:allnodup: nearest:largest:smallest')
                                                                               
   If the 2nd file has more than one star near enough to the position
   of the star in the 1st to qualify, then selection is done on the
   basis of the option chosen
                             
   The list is given at the start of this section.                                                  
                                                                               
}\sstsubsection{NUMCOL = {\undersc}INTEGER (Read)}{
    (Default - 1     \hspace*{6ex}       Range - 1 to number of columns)
                                                                               
   If any duplicity is to be resolved by parameter value (see 'Method')
   then this is the table column to get the value from.
                                                                               
}\sstsubsection{OPTION = LITERAL (Read)}{
   (Default - 'close'    \hspace*{6ex}            Choice - 'close:far')
                                                                               
   Find all stars in one table that are close to those in another table,
   or find those stars that are far from all the stars in the other table?
                                                                               
}\sstsubsection{OUT1 = BDF (Write)}{
  (Default - null)
                                                                               
   The name of the file to contain the 1st output table
                                                                               
}\sstsubsection{OUT2 = BDF (Write)}{
  (Default - null)
                                                                               
   The name of the file to contain the 2nd output table
                                                                               
}\sstsubsection{TITLE1 = LITERAL (Read)}{
  (Default - First input table title or 'Output from TBPMATCH'   \hspace*{6ex}     
   Choice - any)
                                                                               
   The Title to be added to the first output file.
                                                                               
}\sstsubsection{TITLE2 = LITERAL (Read)}{
  (Default - Second input table title or 'Output from TBPMATCH'  \hspace*{6ex}     
   Choice - any)
                                                                               
   The Title to be added to the 2nd output file.
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBRENUM}
 
\sstroutine{TBRENUM}{ Renumbers Names in a Table }{
 
\sstdescription{ 
                                                                               
   It takes a table and outputs an identical one, except the
   identifiers are labelled \#1,\#2,,,\#n.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
    The input file
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                               
    The output file
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - Input table title or 'Output from TBRENUM'    \hspace*{6ex} Choice - any)
                                                                               
    The Title to be added to the output file
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBSHEET}
 
\sstroutine{TBSHEET}{ Spread-Sheet for the Tables }{
 
\sstdescription{ 
                                                                               
 TBSHEET is a spread-sheet program for the Starman tables.
                                                                               
 An input table (or part of it) is displayed as a grid on your graphics
 screen. You may perform various inspections, changes, and
 manipulations on the table. Part of these are the ability to add up to
 200 columns and up to 2000 rows to the table. The resultant table may
 be output to file.
                                                                               
 The format of the displayed screen is to some extent under the control
 of the user.
                                                                               
 The input table may be omitted. In this case a table of a size defined
 by the user, containing zeroes is set up for starting with.
                                                                               
 The display of the spread sheet uses the `PGPLOT' graphics
 sub-routines, so you will need a terminal capable of graphics display,
 capable of writing `black' areas, for which a PGPLOT driver exists.
                                                                               
}\sstdiytopic{Cursor Use}{
 Place the cursor on the desired location and press any key
 on the keyboard, or maybe use the cursor button.
                                                                               
}\sstdiytopic{Description of Screen}{
 When the table is displayed, the screen shows the table itself
 and a number of other things.
                                                                               
 To the left of the table, there are the row numbers and the names
 attached to each row.
                                                                               
 Above the table, there are the column numbers and the headers attached
 to each row.
                                                                               
 To the left and above the table, there is the program `prompts', which
 indicate the current state of the program.
                                                                               
 Along the top of the screen, there are the `option' boxes which the
 user points to undertake an action.
                                                                               
}\sstdiytopic{Menu}{
 Numbers in the table are changed by clicking on them, and then
 using the keyboard to replace the values. The same goes for the
 row names and the column headers. For the other options, place
 the cursor on the desired option in the menu panel displayed above
 the table, and press a key on the keyboard or maybe use the
 cursor button.
                                                                               
 Menu of options available:-

\begin{tabular}{|l|p{4.5in}|}\hline
 Name      &    Function \\ \hline
 Add Cols  &    Add columns to the table. A column (or columns)
                is added to the data, located after the
                column picked by the cursor. (See below for
                data entry.) \\
 Add Rows   &   Add rows to the table. A row (or rows)
                is added to the data, located after the
                row picked by the cursor. (See below for
                data entry.) \\
 Calculate   &  Make the entries in a column from a FORTRAN-like 
                equation. \\
 Command     &  Issue a DCL command as a sub-process. \\
 Delete Col  &  Delete a column, picked by the cursor \\
 Delete Cols &  Delete a number of contiguous columns, defined
                by user input \\
 Delete Row  &  Delete a row, picked by the cursor \\
 Delete Rows &  Delete a number of contiguous rows, defined
                by user input \\
 Down        &  Move the displayed table so that the number
                of the row displayed at the top increases
                by one. \\
 Down 10     &  Move the displayed table so that the number
                of the row displayed at the top increases
                by ten. \\
 Exit        &  Exit from the programme. \\
 Format      &  Change the format and colour of the display. \\
 Help        &  Type out this help information. \\
 Insert Cols &  Add columns to the table. A column (or columns)
                is added to the data, located before the
                column picked by the cursor. (See below for
                data entry.) \\
 Insert Rows &  Add rows to the table. A row (or rows)
                is added to the data, located before the
                row picked by the cursor. )See below for
                data entry.) \\ 
 Left        &  Move the displayed table so that the number
                of the column displayed at the left increases
                by one. \\
 Left 10     &  Move the displayed table so that the number
                of the column displayed at the left increases
                by ten. \\
 Position    &  Change the column/row shown at the top left
                of the display to that demanded. \\
 Renumber    &  Load the names of all the rows with numbers
                in the format \#n, where n is the number of
                the row. \\
 Right       &  Move the displayed table so that the number
                of the column displayed at the left decreases
                by one. \\
 Right 10    &   Move the displayed table so that the number
                of the column displayed at the left decreases
                by ten. \\
 Sort Down   &  Sort the rows of the table by looking at the
                values of entries in a column (picked by the
                the cursor), and sorting so these are in
                descending order. \\
 Sort Up     &  Sort the rows of the table by looking at the
                values of entries in a column (picked by the
                the cursor), and sorting so these are in
                ascending order. \\
 Store       &  Store the present table in an output file \\
 Title      &   Change the title of the table \\
 Undo       &   Undo the last deletion or weed, if no sub-
                sequent changes have been made in the table. \\
 Up         &   Move the displayed table so that the number
                of the row displayed at the top decreases
                by one. \\
 Up 10      &   Move the displayed table so that the number
                of the row displayed at the top decreases
                by ten. \\
 Weed       &   Delete rows of the table by looking at the
                values of entries in a column (picked by the
                the cursor), and seeing if they lie within
                (or without) a chosen range. \\ \hline
\end{tabular}
                                                                               
}\sstsubsection{Column/Row Data Entry}{
 Entering data for columns or rows is done by typing in
 values for the entries in the column/row, and an entry for
 the header/name, separated by commas. If you do not enter
 all the values, the rest are given the value of zero and
 the header/names is given the value \#n where n is the number
 of the column/row. You are then asked for the values for the
 next column/row to be entered. A completely null response
 ends the inputting of data.
                                                                               
}\sstdiytopic{Program Prompts}{
 In using the program, you may occaisionly be wondering if it is waiting
 for input from you. It actually tells you what it is doing, with a
 display to the top left of the table:-
                                                                               
\begin{tabular}{|l|l|p{3.5in}|}\hline
   Displayed        &       Colour &   Action desired of user \\ \hline
   `Waiting (Option)' &     Red    &   Place cursor on Option box, press
                                      any key or maybe cursor button \\
   `Waiting (Position)' &   Red     &  Place cursor on Option box, press
                                      any key or maybe cursor button \\
   `Waiting (Keyboard)'  &  Red     &  Input data via keyboard \\
   `Working'             &  Green   &  Wait until program asks you \\ \hline
\end{tabular}
                                                                               
}\sstdiytopic{Use}{
  The user starts the programs, inputs the input file name (or null),
  and inputs the display type and whether it is monochrome or not.
  The programs then puts up the table on the screen.
                                                                               
  The user then chooses to replace a value or row name or column
  header by clicking on them, or chooses one of the options. The option
  choice is done by placing the cursor on an `option' box and pressing
  any key on the keyboard, or maybe cursor button. Then the program
  performs that option (which may involve further user input either
  from the cursor or from the keyboard - the `prompt' message will
  indicate this).
                                                                               
  This process is then repeated, until the user chooses to exit.
                                                                               

}\sstdiytopic{Calculations}{

 There is an option when using this programme to perform arithmetic 
 and mathematical functions to be applied to the values of column(s) in
 the table ( and to, optionally, a number of input tables) and 
 constants by means of a FORTRAN-like expression which specifies the 
 required functions. The results are then loaded into the desired 
 column of the working table.

 In addition to the standard FORTRAN facilities, a number of special
 functions are available (e.g. for adding noise).

  {\bf \large General}

 The user inputs a Fortran-like equation (through the parameter
 EQUATION).

 These equations can contain references to:-

  \begin{list}{{-}}{}
   \item specified columns of specified tables (which must all have the
        same number of rows, but mayhave different numbers of columns)
        The table presently in the spread-sheet can be refered to.
   \item variables
   \item constants
   \item Fortran operators on these (e.g. '+', or 'cos()', ... )
   \end{list}

 (For more details on the structure of these equations ) see below.

 The equation is then analysed and the operations are performed. 
 Each row of the output column column contains the results of the 
 equation, with the data for the input tables coming from the matching 
 row of those input tables.

 More specifically, the equation is analysed to identify the names
 of tables and variables and to evaluate constants and are then
 converted into reverse-Polish notation. The tables and variables are
 prompted for in alphabetical order and the program then performs
 simple 'stack-arithmetic' to evaluate the expression for each output
 table element.

 {\bf \large The Equation}

 An arithmetic expression of up to 80 characters which gives the
 function to be evaluated for each output table element. The syntax 
 is similar to Fortran (same operator precedence, etc.) but with the
 following differences: 

 \begin{enumerate}
 \item Input tables are represented by any of the variables TAn1, TBn2, ...
    to TZnm, where the 'A', 'B' etc., refer to the table and the 'n1',
    'n2', .. etc., refer the column number in that table to use.
    The table presently in the spread sheet is refered to as 'TA'.
 \item Numerical parameters by any of the variables variables A to Z
 \item Constants by any numerical Fortran constant (real or integer,
    including exponent if required). 
 \item Arithmetic is performed as though all values were real, The actual
    calculations are performed in double precision, and the results
    translated back to reals.
 \item The standard Fortran functions are available and identified
    by their generic names, i.e. SQRT, EXP, LOG10, LOG, SIN, COS, TAN,
    ASIN, ACOS, ATAN, ATAN2, SINH, COSH, TANH, ABS, AINT, ANINT, MOD,
    SIGN, DIM, MIN and MAX. Note, however, that MIN and MAX may take only
    2 arguments. 
 \item To avoid problems with the way the Starlink environment
    handles character parameters, the comma ',' must be replaced with
    the colon ':' for separating function arguments. Similarly, the
    division sign '\/' may be replaced by the percent sign '\%', although
    this latter substitution is not necessary when replying to a prompt
    at the terminal. 
 \item There are three extra funstions available:-

    \begin{tabular}{lp{4in}}
    CLIP(A,B,C) & This gives the value B so long as it lies in the
                 interval A to C (inclusive). Otherwise it gives a
                 zero result. It may be used to remove output values 
                 outside a certain range (e.g. if a division operation 
                 has resulted in very large output values). \\
    GAUSS(X)   &  Gives gaussian noise with zero mean and standard 
                 deviation X (the value returned is different at each 
                 element and for each call of GAUSS). \\
    RAN(X)     &  Gives uniform noise with a value between zero and X
                 (the value returned is different at each element and 
                 for each call of RAN). \\
    \end{tabular}

   \end{enumerate}
  For example, an equation of the form:-

  $$        TA2*3.3+0.5+COS(TB1)+A $$

  will fill each row of a specified output column with:-

\hspace*{1.0em}    ( 3.3 times the element in that row of column 2 of the present
        table ) \hspace*{\fill} \\
  + ( 0.5 )  \hspace*{\fill} \\
  + ( cosine of the element in that row of column 1 of the input table 
        specified through parameter 'INB' )   \hspace*{\fill} \\
  + ( the user defined value of the variable 'A' ) \hspace*{\fill} \\

  {\bf \large Input}

  Only tables and variables used in the expressions are prompted for and
  these are requested in alphabetical order, and only once each.
  The table refered to as 'TA' is the table presently in the spread
  sheet, and is thus not asked for.

}\sstparameters{
                                                                               
\sstsubsection{A = {\undersc}REAL (Read)}{
  (Default - 0.0         \hspace*{6em}        Range -1.0e37 to 1.0e37)
                                                                               
  The value to be used in the expressions for the value of
  the variable 'A',  in the `calculations' option.
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for B to Z }

   \vspace*{2mm}

}\sstsubsection{CHNAMES = {\undersc}INTEGER (Read)}{
  (Default - present value (starting value=10)   \hspace*{6ex} Range - 2 to 20)
                                                                               
  The number of characters of the row names to display.
                                                                               
}\sstsubsection{COLNUM = {\undersc}INTEGER (Read)}{
  (Default - present value (starting value=4)    \hspace*{6ex} Range - 2 to 100)
                                                                               
  The number of columns to display on the screen.
                                                                               
  The number of rows displayed is automatically adjusted to fill the
  screen.
                                                                               
  Clearly, the more columns shown, the smaller the character size.
                                                                               
}\sstsubsection{COLOURS = {\undersc}INTEGER(5) (Read)}{
  (Default - present value (starting value = `2,1,3,4,5')   \hspace*{6ex} 
   Range - 5 integers with values between 1 and 10)
                                                                               
  The colour to give to each of five elements of the screen.

\begin{tabular}{|l|l|l|}\hline
  Number &  Element          &   Default \\ \hline
    1    &  Background       &   White \\
    2    &  Numbers/names/   &   Black \\
         &  table grid       &          \\
    3    &  Prompt - waiting &   Red \\
    4    &  Prompt - working &   Green \\
    5    &  Options box grid &   Blue \\ \hline
\end{tabular}
                                                                               
  The colours that can be given instead to these are:-

\begin{tabular}{cccccc}
   Number  &  1    & 2       &  3     &   4    &   5 \\
   Colour  & Black & White   & Red    & Green  & Blue \\
           &   6   &  7      &    8   &    9   &     10 \\
           & Cyan  & Magenta & Yellow & Orange & Grn/Ylw \\
\end{tabular}
                                                                               
  (If the screen is monochrome, then the background is displayed
  as white and the rest as black.)
                                                                               
}\sstsubsection{COMMAND = LITERAL (Read)}{
  (Default - `no'       \hspace*{6ex}      \hspace*{6ex}  Choice - `yes:no')
                                                                               
  This is used when using the `panel' instruction input. It has no
  function other than to permit use of the full help system by
  responding `?' or `??', and to permit use of the `dropping through'
  to the operating system by use of the `\$' symbol before a normal
  DCL instruction, e.g. `\$ DIRECTORY/SIZE'.
                                                                               
  After you have used the help, then just reply `no' with a `return'
  key entry.
                                                                               
}\sstsubsection{DATA = LITERAL (Read)}{
  (Default - null      \hspace*{6ex}     Choice - any)
                                                                               
  A character string giving the data to input to a column or row.
  These are numbers (in the form (e.g.) 123 or -12.34 or -1.2e4),
  and maybe a name, separated by commas or spaces. There should
  be as many numbers as are needed to fill the column or row. If
  there are more, then the first numbers filling up the table
  are taken, and the next entry is taken as the column header or
  row name. If there are fewer, then the remaining numbers are
  filled up with zeroes. If there is no name at the end of the
  entry, then the column header/row name is taken as `\#n' where
  n is the number of the column/row.
                                                                               
  The name must be no more than 20 characters long
                                                                               
  Numbers in a bad form, (e.g. 12j34) are taken as 0.0.
                                                                               
  Thus for a table row entry for row number five, where there are
  three columns, the character strings below would give the following
  input:-

\begin{tabular}{|l|l|l|c|c|}\hline
                    & \multicolumn{4}{c|}{Stored}  \\ \cline{2-5}
    Input           &  Column1  &  Column2 &  Column3  &  Name \\ \hline
    1,2.1,-1.2e3     &    1.0    &   2.0     &  -1200.0  &  \#5 \\
    1,2,3,fred       &    1.0    &   2.0     &     3.0   &  fred \\
    1,2              &    1.0    &   2.0     &     0.0   &  \#5 \\
    1,2,3,4,fred     &    1.0    &   2.0     &     3.0   &  4 \\
    1,2j2,3          &    1.0    &   0.0     &     3.0   &  \#5 \\ \hline
\end{tabular}
                
                                                                               
}\sstsubsection{EQUATION = LITERAL (Read)}{
  (Default - null         \hspace*{6em}    Choice - as defined below)
                                                                               
  The FORTRAN-style expression that gives the elements to be loaded into the
  desired column in the working table,  in the `calculations' option.
                                                                               
  Its style is given the `equation' section of this section.
                
                                                               
}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question, 
  in a different way. A response here of `?' will bring up a listing 
  of all the possible names of graphics devices which are supported 
  on your machine, and you then input the appropriate name.
                                                                               
}\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - present value    \hspace*{6ex}        Choice - any)
                                                                               
  The character string to replace the current column header with.
                                                                               
  This must be no longer than 20 characters long.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the input table, or a new input table.
                                                                               
}\sstsubsection{INB = BDF (Read)}{
 (Default - null)
                                                                               
 The input table corresponding to 'TB' to be used in the arithmetic
 expressions in the `calculations' option.
                                                                               
}\sstsubsection{ }{
   {\large \bf This is repeated for INC to INZ }

   \vspace*{2mm}

}\sstsubsection{LIMITS = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0     \hspace*{6ex}        Range - 2 real numbers in the
                                      range -1.0e20 to 1.0e20)
                                                                               
  If the value of a table entry (in the specified column) in a row
  lies within this range of values, then the row will either be
  accepted or rejected. (The choice of accept/reject is made with
  the `weedopt' parameter after this parameter.)
                                                                               
}\sstsubsection{MONO = LITERAL (Read)}{
  (Default - `no'      \hspace*{6ex}        Choice - `yes:no')
                                                                               
  Is the display screen for the table, a monochrome display or not?
  (If it is a colour display, then the display can be made a little
   clearer than for a monochrome display.)
                                                                               
}\sstsubsection{MORE = LITERAL (Read)}{
  (Default - `yes'     \hspace*{6ex}        Choice - `yes:no')
                                                                               
  Do you want more of the help displayed or not?
                                                                               
}\sstsubsection{NAME = LITERAL (Read)}{
  (Default - present value   \hspace*{6ex}         Choice - any)
                                                                               
  The character string to replace the current row name with.
                                                                               
  This must be no longer than 20 characters long.
                                                                               
}\sstsubsection{NUMCOLS = {\undersc}INTEGER(2) (Read)}{
  (Default - 0,end of current table      \hspace*{6ex} Range - 2 integers between 0 and
                                                 end of cureent table)
                                                                               
  The range of columns to delete.
                                                                               
  If either of the limits is `0', then no deletion takes place.
                                                                               
}\sstsubsection{NUMROWS = {\undersc}INTEGER(2) (Read)}{
  (Default - 0,end of current table      \hspace*{6ex} Range - 2 integers between 0 and
                                                 end of cureent table)
                                                                               
  The range of rows to delete.
                                                                               
  If either of the limits is `0', then no deletion takes place.
                                                                               
}\sstsubsection{OK = LITERAL (Read)}{
  (Default - `no'    \hspace*{6ex}        Choice - `yes:no')
                                                                               
  In choosing to exit from the program without having previously
  stored the table since the last change, you will loose all the
  changes made to the table since the start (or since you last
  stored the then current state of the table).
                                                                               
  If you want this, then answering `yes' will result in the
  program finishing. If on the other hand you do want to store the
  current state of the table, then answer `no' (the default) and you
  will get back to the option choice. You can then store the table
  and then exit.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                               
  The name of the file to contain the output table.
                                                                               
}\sstsubsection{POSITION = {\undersc}INTEGER (Read)}{
  (Default - present position     \hspace*{6ex}        Range - 1 to max of num of
                                                 columns and rows)
                                                                               
  The column position and row position of the table entry displayed
  at the top left hand of the display.
                                                                               
  This positions the display so that the specified entry is at the
  top left of the display.
                                                                               

}\sstsubsection{SEED = {\undersc}INTEGER (Read)}{
  (Default - 1234567891     \hspace*{6em}    Range - 1200000001 to 1400000001)
                                                                               
  The seed number to be used in any random number generators.
  This is used in the `GAUSS()' and `RAN()' operators. These
  will provide the same pattern of numbers in the same
  seed number is input. This is used  in the `calculations' option.
                                                                               
  It has to be a large positive odd number.

}\sstsubsection{SIZE = {\undersc}INTEGER(2) (Read)}{
  (Default - 2,100     \hspace*{6ex}           Choice - 2 integers each between
                                        1 and 10000)
                                                                               
  As there is no input table, a blank one is made. This parameter
  defines the size of the table - the number of columns and the
  numbers of rows. The table will have zeroes in it and the `\#n'
  format entries for the names and headers.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - the title of the input table   \hspace*{6ex}    Choice - any)
                                                                               
  The title to give to the present table. This is a
  character string, less than 50 characters long.
                                                                               
}\sstsubsection{VALUE = {\undersc}REAL (Read)}{
  (Default - present value    \hspace*{6ex}        Range - -1.0e20 to 1.0e20)
                                                                               
  The value to replace the current table entry value with.
                                                                               
}\sstsubsection{WEEDOPT = LITERAL (Read)}{
  (Default - `accept'     \hspace*{6ex}        Choice - `accept:reject')
                                                                               
  Do you want to accept or reject those rows whose entries
  in the specificed column lie within the limits specified?

                                                                               

}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBSORT}
 
\sstroutine{TBSORT}{ Sort a Table }{
 
\sstdescription{ 
                                                                               
   This takes a table and makes a new one with identical entries,
   but sorted on the values in a user defined column, either in
   ascending or descending order.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The file containing the input table
                                                                               
}\sstsubsection{NUMCOL = {\undersc}INTEGER (Read)}{
  (Default - 1      \hspace*{6ex}      Range - 1 to last column)
                                                                               
  The  number of the column to do the sorting on.
                                                                               
}\sstsubsection{OPTION = LITERAL (Read)}{
   (Default - 'ascending'    \hspace*{6ex}      Choice -  'ascending:descending')
                                                                               
   Wether to sort into ascending or descending order.
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                               
    The output file
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input table title or 'Output from Tbsort'   \hspace*{6ex}      Choice - any)
                                                                               
    The Title to be added to the output file
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBSTAT}
 
\sstroutine{ TBSTAT}{ Statistics of Column(s) in Table(s) }{
 
\sstdescription{ 
                                                                               
  Calculate some statistics of one or two columns of data in table(s).
                                                                               
  The input of the second table is optional.
                                                                               
  It calculates for each column ( mean, std dev, std dev of mean )
                                                                               
  If there are two columns it calculates the regression line
  fit of one on the other, and the correlation.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{IN1 = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the first input table.
                                                                               
}\sstsubsection{IN2 = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the second input table.
                                                                               
}\sstsubsection{NCOL1 = {\undersc}INTEGER (Read)}{
  (Default - 1  \hspace*{6ex}   Range - 1 to no of columns)
                                                                               
  Column in first table to take data from.
                                                                               
}\sstsubsection{NCOL2 = {\undersc}INTEGER (Read)}{
  (Default - 1     \hspace*{6ex}     Range - 1 to no of columns)
                                                                               
  Column in second table to take data from.
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBTRAN{\undersc}APPLY}
 
\sstroutine{TBTRAN{\undersc}APPLY}{ Apply Position Transformations to Table }{
 
\sstdescription{ 
                                                                               
   This takes a table and makes a new one with identical entries,
   but with the positions transformed through a transformation matrix.
                                                                               
   The entries in columns 1 and 2 are taken as `$X$', `$Y$'. The output table
   then has values `$X_1$', `$Y_1$' with:-
                                                                               
    $$    X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$
                                                                               
    $$    Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y  $$

  With the `X~coefficents', $c_x(1)$, $c_x(2)$X, $c_x(3)$ and the 
  `Y~coefficents', $c_y(1)$, $c_y(2)$X, $c_y(3)$, being input by the user.

}\sstparameters{
                                                                               
\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The file containing the input table
                                                                               
}\sstsubsection{OUT = BDF (Write)}{
  (Default - null)
                                                                               
  The file containing the output table
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - Input table title or `Output from TBTRAN{\undersc}APPLY' \hspace*{6ex}
   Choice - any)
                                                                               
    The Title to be added to the output file
                                                                               
}\sstsubsection{XCOEFF = {\undersc}REAL(3) (Read)}{
  (Default - 0.0,0.0,0.0       \hspace*{6ex}     Range - -1.0e20 to 1.0e20)
                                                                               
  The three coefficents for the X transfomation.
                                                                               
    $$    X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$
                                                                               
}\sstsubsection{YCOEFF = {\undersc}REAL(3) (Read)}{
  (Default - 0.0,0.0,0.0       \hspace*{6ex}     Range - -1.0e20 to 1.0e20)
                                                                               
  The three coefficents for the Y transfomation.
                                                                               
    $$    Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y  $$
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBTRAN\hspace{-0.1em}{\undersc}LOAD}
 
\sstroutine{TBTRAN\hspace{-0.1em}{\undersc}LOAD}{ 
Turn `Magn,Rotn,Shift' to Position Transformation}{
 
\sstdescription{ 
                                                                               
   This calculates the transformation coefficents between two
   coordinate systems, converting from 'shift, rotation, and
   magnification' to a 'transformation matrix' of the form:-
                                                                               
    $$    X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$
                                                                               
    $$    Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y  $$
                                                                               
                                                                               
    The input parameters are fed in, and the six transformation
    coefficents are calculated.
                                                                               
    The input parameters are:-

\begin{list}{{-}}{}
\item The present centre of the coordinate system
\item The magnification to apply to the coordinate system
\item The rotation in degrees to apply to the coordinate system
\item The new centre of the coordinate system
\end{list}
                                                                               
  The results are typed out, and also put into the program paramters.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{MAGNIFY = {\undersc}REAL (Read)}{
  (Default - 1.0        \hspace*{6ex}      Range - 0.0 to 1.0e20)
                                                                               
  The magnification to apply.
                                                                               
}\sstsubsection{NEWCEN =  {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0      \hspace*{6ex}     Range - -1.0e20 to 1.0e20)
                                                                               
  The new centre of the system.
                                                                               
}\sstsubsection{OLDCEN =  {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0      \hspace*{6ex}      Range - -1.0e20 to 1.0e20)
                                                                               
  The old centre of the system
                                                                               
}\sstsubsection{ROTATE =  {\undersc}REAL (Read)}{
  (Default - 0.0     \hspace*{6ex}  Range - -1.0e20 to 1.0e20)
                                                                               
  The rotation (in degrees) to apply to the system.
                                                                               
}\sstsubsection{XCOEFF =  {\undersc}REAL(3) (Write)}{
  (This is an output parameter)
                                                                               
  The three output cofficents for the X system
                                                                               
    $$    X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$
                                                                               
}\sstsubsection{YCOEFF =  {\undersc}REAL(3) (Write)}{
  (This is an output parameter)
                                                                               
  The three output cofficents for the Y system
                                                                               
    $$    Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y  $$
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBTRAN{\hspace{-0.1em}}{\undersc}MAKE}
 
\sstroutine{TBTRAN{\hspace{-0.1em}}{\undersc}MAKE}{ Calculate Posn Transforms Between Two Tables}{
 
\sstdescription{ 
                                                                               
   This takes two tables (whose entries in columns 1 and 2 are XY
   positions of at least some same points) and calculates the
   transformation between the coordinate systems of the two tables.
                                                                               
   The coordinates in the first table are taken as `$X$', `$Y$', and those
   in the second are taken as `$X_1$', `$Y_1$', and the transformation is:-
                                                                               
    $$ Calculated \hspace{3ex}   X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$
                                                                               
    $$    Calculated \hspace{3ex}   Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y  $$
                                                                               
                                                                               
   The coefficients are calculated so as to minimise the errors
   between 'calculated positions in the second table' and
   'actual positions in the second tables'. Points which are too
   discordant are dropped from the calculation of the transformation.
                                                                               
   Four types of transformation may be calculated:-

\begin{tabular}{|c|l|}\hline
   Number   &   Type \\ \hline
     1       &  Shift only  (cx2=1,cx3=0,cy2=0,cy3=1) \\
     2      &   Shift and rotation \\ 
     3      &   Shift, rotation and magnification \\ 
     4      &   Full (=Shift, rotation, magnification and stretch) \\ \hline
\end{tabular}                                                                               
                                                                               
  The input tables may either be taken as consisting of matching pairs,
  or the program can look for rows with the same names to treat as the
  matching pairs.
                                                                               
  The results are typed out, and also put into the programme paramters.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{IN1 = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the 1st input table
                                                                               
}\sstsubsection{IN2 = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the file containing the 2nd input table
                                                                               
}\sstsubsection{NAMES = LITERAL (Read)}{
  (Default - 'no'    \hspace*{6ex}             Choice - 'yes:no')
                                                                               
  Match up pairs of points in the 1st and 2nd tables by looking
  for rows with the same names? If not, then assume entries
  are the same order in the two tables.
                                                                               
}\sstsubsection{SIGLIM = {\undersc}REAL (Read)}{
  (Default - 2.5      \hspace*{6ex}    Range - 0.0 to 1.0e20)
                                                                               
  When calculating the transformations, discordant points are
  rejected if their calculated positions in the 2nd table lie
  more than 'SIGLIM' times the standard deviation away from the
  2nd table positions.
                                                                               
}\sstsubsection{TRTYPE = {\undersc}INTEGER (Read)}{
  (Default - 4   \hspace*{6ex}   Range - 1 to 4)
                                                                               
  The type of transformation to be calculated.
                                                                               
\begin{tabular}{|c|l|}\hline
   Number   &   Type \\ \hline
     1       &  Shift only  (cx2=1,cx3=0,cy2=0,cy3=1) \\
     2      &   Shift and rotation \\ 
     3      &   Shift, rotation and magnification \\ 
     4      &   Full (=Shift, rotation, magnification and stretch) \\ \hline
\end{tabular}                                                                               
                                                                               
}\sstsubsection{XCOEFF = {\undersc}REAL(3) (Write)}{
  (This is an output parameter)
                                                                               
  The three output cofficents for the X system
                                                                               
    $$ Calculated \hspace{3ex}   X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$
                                                                               
                                                                               
}\sstsubsection{YCOEFF = {\undersc}REAL(3) (Write)}{
  (This is an output parameter)
                                                                               
  The three output cofficents for the Y system
                                                                               
    $$    Calculated \hspace{3ex}   Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y  $$
                                                                               
}}}

\ajhsect{\arabic{section}}{ Table Programmes - \hspace*{0.2in} TBVALUE}
 
\sstroutine{TBVALUE}{Output an element of a Table }{
 
\sstdescription{ 
  This takes the value of a single element in an input table, and types
  out that value and also puts it out as a parameter of the programme.
                                                                               
  The column the element is taken from may be defined either from the
  number of the column or from the column's header.
                                                                               
  The row the element is taken from may be defined either from the
  number of the row or from the row's name.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{COLUMN = {\undersc}INTEGER (Read)}{
  (Default - 1  \hspace*{6em}         Range - 1 to number of columns in table)
                                                                               
  The number of the desired column.
                                                                               
}\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - ' '        \hspace*{6em}       Choice - any)
                                                                               
  The (up to) 20 character string of the header of the desired
  column.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
    The input file containing the input table.
                                                                               
}\sstsubsection{NAME = LITERAL (Read)}{
  (Default - ' '       \hspace*{6em}        Choice - any)
                                                                               
  The (up to) 20 character string of the name of the desired row.
                                                                               
}\sstsubsection{ROW = {\undersc}INTEGER (Read)}{
  (Default - 1        \hspace*{6em}          Range - 1 to number of rows in table)
                                                                               
  The number of the desired row.
                                                                               
}\sstsubsection{USEHEAD = LITERAL (Read)}{
  (Default - 'no'     \hspace*{6em}      Choice - 'yes:no')
                                                                               
  Define the column desired from its header ('yes'), or from the
  the number of the column ('no')?
                                                                               
}\sstsubsection{USENAME = LITERAL (Read)}{
  (Default - 'no'    \hspace*{6em}       Choice - 'yes:no')
                                                                               
  Define the row desired from its name ('yes'), or from the
  the number of the row ('no')?
                                                                               
}\sstsubsection{VALUE = {\undersc}REAL (Write)}{
  (Output parameter)
                                                                               
  The value of the table element is put out into this programme
  parameter.
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBWEED}
 
\sstroutine{TBWEED}{ Weed a Table }{
 
\sstdescription{ 
                                                                               
  This makes a new table which is a copy of an old table, but
  with only those rows whose values in user defined columns lie in
  (or optionally outside) user assigned ranges are copied over.
                                                                               
  Up to ten columns can be tested. The repeated asking for columns
  is stopped by responding '0' to the request for column number.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  The name of the input file containing the input table.
                                                                               
}\sstsubsection{LIMS1 = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0  \hspace*{6ex}        Range - -1.0e20,1.0e20)
                                                                               
   The lower and upper limits to the acceptable values for the entries
   in this column.
                        
}\sstsubsection{LIMS2 = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0      \hspace*{6ex}     Range - -1.0e20,1.0e20)
                                                                               
   The lower and upper limits to the acceptable values for the entries
   in this column.
                                                                               
   If 0 is input, then this column input is ignored, and no more
   are asked for.

}\sstsubsection{ }{
   {\large \bf This is repeated for LIMS3 to LIMS10 }

   \vspace*{2mm}
                                                                               
}\sstsubsection{NCOL1 = {\undersc}INTEGER (Read)}{
  (Default - 1       \hspace*{6ex}     Range - 0, no of columns)
                                                                               
  The number of the first column whose values are to be tested.
                                                                               
   If 0 is input, then this column input is ignored, and no more
   are asked for.
                                                                               
}\sstsubsection{NCOL2 = {\undersc}INTEGER (Read)}{
  (Default - 2             \hspace*{6ex}     Range - 0, no of columns)
                                                                               
  The number of the second column whose values are to be tested.
                                                                               
   If 0 is input, then this column input is ignored, and no more
   are asked for.

}\sstsubsection{ }{
   {\large \bf This is repeated for NCOL3 to NCOL10 }

   \vspace*{2mm}
                                                                               
}\sstsubsection{OPTION = LITERAL (Read)}{
   (Default - 'accept'     \hspace*{6ex}   Choice - 'accept:reject')
                                                                               
   Accept or reject entries whose column values falls in the
   given ranges.
                                                                               
}\sstsubsection{OUT = BDF (Read)}{
  (Default - null)
                                                                               
    The name of the output file to contain the output table.
                                                                               
}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - Input table title or 'Output from TBWEED'       \hspace*{6ex}   Choice - any)
                                                                               
    The Title to be added to the output file
                                                                               
}}}

\ajhsect{\arabic{section}}{Table Programmes - \hspace*{0.2in} TBWRDES}
 
\sstroutine{TBWRDES}{ Write Descriptors to a Table }{
 
\sstdescription{ 
                                                                               
 Allows the descriptors of a table to be overwritten with new
 information, or to be inserted if they were not present,
                                                                               
  If the 'LOOP' parameter is not set (or set to 'yes'), then the
  program loops, asking for new descriptor names until a 'null'
  response is input. If it is set to 'no' (in the command line),
  then only one descriptor is asked for.
                                                                               
}\sstparameters{
                                                                               
\sstsubsection{LOOP = LITERAL (Read)}{
  (Default - 'yes'   \hspace*{6ex}     Choice - 'yes:no')
                                                                               
  This is a hidden parameter. To set it to 'no', you have to
  puit it into the command line.
                                                                               
  If 'Yes', then the program loops, asking for new descriptor names
  until a 'null' response is input. If 'no', then only one
  descriptor is asked for.
                                                                               
}\sstsubsection{IN = BDF (Read)}{
  (Default - null)
                                                                               
  Name of file containing table
                                                                               
}\sstsubsection{NAME = LITERAL (Read)}{
  (Default - null    \hspace*{6ex}       Choice - any)
                                                                               
  The name of the descriptor.
                                                                               
  A null response will end the program.
                                                                               
}\sstsubsection{VALUE = LITERAL (Read)}{
  (Default - null   \hspace*{6ex}        Choice - any)
                                                                               
  A character string to give the 'value' to insert into
  the descriptor.
                                                                               
}}}

\end{document}
