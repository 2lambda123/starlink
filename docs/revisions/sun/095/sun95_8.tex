\documentstyle[11pt]{article}
\pagestyle{myheadings}

%------------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocnumber}    {95.8}
\newcommand{\stardocauthors}   {Malcolm J. Currie}
\newcommand{\stardocdate}      {1992 August 18}
\newcommand{\stardoctitle}     {KAPPA --- Kernel Application Package}
%------------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\renewcommand{\_}{{\tt\char'137}}     % re-centres the underscore
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}
\setlength{\unitlength}{1mm}

%------------------------------------------------------------------------------
% Add any \newcommand or \newenvironment commands here

% degrees symbol
\newcommand{\dgs}{\hbox{$^\circ$}} 
% centre an asterisk
\newcommand{\lsk}{\raisebox{-0.4ex}{\rm *}}
% A kind of list item, like description, but with an easily adjustable
% item separation.
\newcommand{\menuitem}[2]
  {{\bf #1}: \addtolength{\baselineskip}{-0.4ex}
  \parbox[t]{128mm}{#2} \addtolength{\baselineskip}{0.4ex} \\ \hspace{-5pt}}
% an environment for references
\newenvironment{refs}{\goodbreak
                      \vspace{3ex}
                      \begin{list}{}{\setlength{\topsep}{0mm}
                                     \setlength{\partopsep}{0mm}
                                     \setlength{\itemsep}{0mm}
                                     \setlength{\parsep}{0mm}
                                     \setlength{\leftmargin}{1.5em}
                                     \setlength{\itemindent}{-\leftmargin}
                                     \setlength{\labelsep}{0mm}
                                     \setlength{\labelwidth}{0mm}}
                    }{\end{list}}

% SST definitions
% ---------------

%+
%  Name:
%     LAYOUT.TEX

%  Purpose:
%     Define Latex commands for laying out documentation produced by PROLAT.

%  Language:
%     Latex

%  Type of Module:
%     Data file for use by the PROLAT application.

%  Description:
%     This file defines Latex commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by Latex. The
%     contents of this file should be included in the source presented to
%     Latex in front of any output from PROLAT. By default, this is done
%     automatically by PROLAT.

%  Notes:
%     The definitions in this file should be included explicitly in any file
%     which requires them. The \include directive should not be used, as it
%     may not then be possible to process the resulting document with Latex
%     at a later date if changes to this definitions file become necessary.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}

%  Define a \tt font of the required size.
\font\ssttt=cmtt10 scaled 1095

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.45pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the output results parameters section (for an application).
\newcommand{\sstresparameters}[1]{
   \item[Results Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the graphics style parameters section (for an application).
\newcommand{\sstgraphparameters}[1]{
   \item[Graphics-style Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{\item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[1]{\item[{\ssttt #1}] \mbox{} \\}

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  End of LAYOUT.TEX layout definitions.
%.

% End of SST definitions
% ----------------------

%    Starlink definitions for \LaTeX\ macros used in MAN output
%
%  Description:
%    As much as possible of the output from the MAN automatic manual generator
%    uses calls to user-alterable macros rather than direct calls to built-in
%    \LaTeX\ macros. This file is a version of the MAN default definitions for
%    these macros modified for Starlink preferences.
%
%  Language:
%    \LaTeX
%
%  Support:
%    William Lupton, {AAO}
%    Alan Chipperfield (RAL)
%-
%  History:
%    16-Nov-88 - WFL - Add definitions to permit hyphenation to work on
%		 words containing special characters and in teletype fonts.
%    27-Feb-89 - AJC - Redefine \manroutine
%                      Added \manheadstyle
%                      Switch order of argument descriptors
%    07-Mar-89 - AJC - Narrower box for parameter description
%                      Remove Intro section and other unused bits
%
% permit hyphenation when in teletype font (support 9,10,11,12 point only -
% could extend), define lccodes for special characters so that the hyphen-
% ation algorithm is not switched off. Define underscore character to be
% explicit underscore rather than lots of kerns etc.

\typeout{Starlink MAN macros. Released 27th February 1989}

\hyphenchar\nintt=`-\hyphenchar\tentt=`-\hyphenchar\elvtt=`-\hyphenchar\twltt=`-

\lccode`_=`_\lccode`$=`$

%    Macros used in the .TEX_SUMMARY file
%
%  Description:
%    There is a command to introduce a new section (mansection) and a list-like
%    environment (mansectionroutines) that handles the list of routines in the
%    current section. In addition a mansectionitem command can be used instead
%    of the item command to introduce a new routine in the current section.
%-

\newcommand {\mansection}[2]{\subsection{#1 --- #2}}

\newenvironment {mansectionroutines}{\begin{description}\begin{description}}%
{\end{description}\end{description}}

\newcommand {\mansectionitem}[1]{\item [#1:] \mbox{}}

%    Macros used in the .TEX_DESCR file
%
%  Description:
%    There is a command to introduce a new routine (manroutine) and a list-like
%    environment (manroutinedescription) that handles the list of paragraphs
%    describing the current routine. In addition a manroutineitem command can
%    be used instead of the item command to introduce a new paragraph for the
%    current routine.
%
%    Two-column tables (the ones that can occur anywhere and which are
%    triggered by "=>" as the second token on a line) are bracketed by a
%    new environment (mantwocolumntable). Other sorts of table are introduced
%    by relevant  environments (manparametertable, manfunctiontable and
%    manvaluetable). The definitions of these environments call various other
%    user-alterable commands, thus allowing considerable user control over such
%    tables... (to be filled in when the commands have been written)
%-

\newcommand {\manrule}{\rule{\textwidth}{0.5mm}}

%\newcommand {\manroutine}[2]{\subsection{#1 --- #2}}
\newlength{\speccaption}
\newlength{\specname}
\newcommand{\manroutine}[2]{\goodbreak
                          \rule{\textwidth}{0.5mm}  % draw thick line
                          \settowidth{\specname}{{\Large {\bf #1}}}
                        % left and right box width is text width plus gap
                          \addtolength{\specname}{4ex}
                        % caption width is width of page less the two names
                        % less than empirical fudge factor
                          \setlength{\speccaption}{\textwidth}
                          \addtolength{\speccaption}{-2.0\specname}
                          \addtolength{\speccaption}{-4.45pt}
                        % move text up the page because \flushleft environ-
                        % ment creates a paragraph
                          \vspace{-7mm}
                          \newline
                          \parbox[t]{\specname}{\flushleft{\Large {\bf #1}}}
                          \parbox[t]{\speccaption}{\flushleft{\Large #2}}
                          \parbox[t]{\specname}{\flushright{\Large {\bf #1}}}
                          }

\newenvironment {manroutinedescription}{\begin{description}}{\end{description}}

\newcommand {\manroutineitem}[2]{\item [#1:] #2\mbox{}}


% parameter tables

\newcommand {\manparametercols}{lllp{90mm}}

\newcommand {\manparameterorder}[3]{#2 & #3 & #1 &}

\newcommand {\manparametertop}{}

\newcommand {\manparameterblank}{\gdef\manparameterzhl{}\gdef\manparameterzss{}}

\newcommand {\manparameterbottom}{}

\newenvironment {manparametertable}{\gdef\manparameterzss{}%
\gdef\manparameterzhl{}\hspace*{\fill}\vspace*{-\partopsep}\begin{trivlist}%
\item[]\begin{tabular}{\manparametercols}\manparametertop}{\manparameterbottom%
\end{tabular}\end{trivlist}}

\newcommand {\manparameterentry}[3]{\manparameterzss\gdef\manparameterzss{\\}%
\gdef\manparameterzhl{\hline}\manparameterorder{#1}{#2}{#3}}


% list environments

\newenvironment {manenumerate}{\begin{enumerate}}{\end{enumerate}}

\newcommand {\manenumerateitem}[1]{\item [#1]}

\newenvironment {manitemize}{\begin{itemize}}{\end{itemize}}

\newcommand {\manitemizeitem}{\item}

\newenvironment {mandescription}{\begin{description}\begin{description}}%
{\end{description}\end{description}}

\newcommand {\mandescriptionitem}[1]{\item [#1]}

\newcommand {\mantt}{\tt}

% manheadstyle for Starlink
\newcommand {\manheadstyle}{}

\catcode`\_=12

%------------------------------------------------------------------------------

\begin{document}
\thispagestyle{empty}
SCIENCE \& ENGINEERING RESEARCH COUNCIL \hfill \stardocname\\
RUTHERFORD APPLETON LABORATORY\\
{\large\bf Starlink Project\\}
{\large\bf \stardoccategory\ \stardocnumber}
\begin{flushright}
\stardocauthors\\
\stardocdate
\end{flushright}
\vspace{-4mm}
\rule{\textwidth}{0.5mm}
\vspace{5mm}
\begin{center}
{\Large\bf \stardoctitle}
\end{center}
\vspace{5mm}

\setlength{\parskip}{0mm} \tableofcontents
\setlength{\parskip}{\medskipamount} \markright{\stardocname} \newpage 

\section{Introduction}

The {\bf K}ernel {\bf AP}plication {\bf PA}ckage uses the NDF data
format, and comprises {\em general-purpose applications}, particularly
for image processing and data visualisation.  It provides applications
that integrate with specialised packages such as {\small PHOTOM},
{\small PISA}, {\small CCDPACK}, {\small SPECDRE} and
{\small Figaro}.\footnote{If you desire further details of the r\^{o}le
of KAPPA please consult Appendix~\ref{ap:role}.}
On {\small VMS} systems {\small KAPPA} is available as {\small DCL}
commands to activate individual applications, and as a monolith from the
{\small ADAM} command language, {\small ICL}. On {\small UNIX},
specifically {\small SunOS} and {\small Ultrix}, {\small KAPPA} is a
monolith, but it is invoked from the operating system. 

{\small KAPPA} handles bad pixels, and processes quality and variance
information within NDFs (SUN/33 and Section~\ref{se:datastr}).  Although
oriented to image processing, many applications will work on NDFs of
arbitrary dimension.  Many applications handle all non-complex data
types directly, for efficient memory and disk usage.  Those that do not
will usually undergo automatic data conversion to produce the desired
result.  {\small KAPPA}'s graphics are device independent.  X-windows
and overlays are supported.

Currently, {\small KAPPA} has about 140 commands in total, and provides
the following facilities for data processing:
\begin{itemize}
\item Up-to-date FITS readers that generate NDFs and ASCII tables.
\item Generation of test data, and NDF creation from ASCII files.
\item Setting NDF components.
\item Arithmetic including a powerful application that handles
expressions.
\item Pixel and region editing, including polygons and circles; and
re-flagging of bad pixels by value or by median filtering.
\item Configuration change: flip, rotate, shift, subset, change
dimensionality.
\item Forming image mosaics; normalisation of NDF pairs.
\item Compression and expansion of images.
\item Filtering: box, Gaussian, and median smoothing; very efficient
Fourier transform, maximum-entropy deconvolution.
\item Two-dimensional-surface fitting.
\item Statistics including ordered statistics, histogram; pixel-by-pixel
statistics over a sequence of images.
\item Inspection of image values.
\item Centroids of features, particularly stars; stellar PSF fitting.
\item Detail enhancement via histogram equalisation, Laplacian
convolution, edge enhancement via a shadow effect, thresholding.
\end{itemize}

There are also many applications for data visualisation:
\begin{itemize}
\item Use of the graphics database, AGI, to pass information about
pictures between applications.  Facilities for the creation, labelling,
selection of pictures, and obtaining world and data co-ordinate
information from them.
\item Image and greyscale plots with a selection
of scaling modes and many options such as axes.
\item Creation, selection, saving and manipulation of colour tables and
palettes (for axes, annotation, coloured markers and borders). 
\item Snapshot of an image display to hardcopy.
\item Blinking and visibility of image-display planes.
\item Line graphics: contouring, including overlay; columnar and
hidden-line plots of images; histogram; line plots of 1-d arrays, and
multiple-line plot of images; slices through an image.  There is some
control of the appearance of plots.
\end{itemize} 

{\small KAPPA} is continuing to be developed and additional
applications, particularly for image processing, will be added in
subsequent releases.\footnote{If you wish to influence the priority
given to certain new applications, or have suggestions for new ones or
enhancements to existing ones please contact the author.  The Vaxnotes
conference IPESIG\_NOTICES will periodically contain news of plans and
work in progress, particularly in the minutes of IPESIG meetings.} It
also receives a high level of support. 

Unfortunately, it's not all good news.  For historical reasons, not all
{\small KAPPA} applications that should operate on NDFs do so, though
{\em all\/} will handle most {\em primitive\/} and {\em simple\/} NDFs
correctly (those where the data array is an array of numbers at the top
or second level of the hierarchical structure). A conversion process is underway
to transform the remaining to use the NDF-access interface (SUN/33). See
Appendix~\ref{ap:full} for details of which applications use the NDF.
Until the conversion is complete the documentation will unfortunately
either contain `if's and `but's or incorrect generalisations.  This is
why {\small KAPPA} has yet to reach version 1.0.

The documentation concentrates on the description of the {\small VMS}
version.  The differences for {\small UNIX} are minor and are described
in Appendix~\ref{ap:unixdif}.  This document is arranged as follows. 
First are two annotated {\small KAPPA} sessions to give you a quick
summary of basic usage.  The main text follows, which amplifies the
points sketched in the demonstrations, and describes other functionality
and modes of use illustrated with further examples.  Finally, there are
extensive appendices, including a classified list of commands and
detailed descriptions of each command. 

\section{Demonstrations}
\label{se:demo}
So the facilities summarised in the introduction sound appealing.  Now
you want to know how to access them, but the thick manual looks
daunting. Actually, most of this manual comprises descriptions of each
application. The best way to learn the basics is to try some example
sessions.

Login to a terminal where you can see an available {\em Ikon\/} image
display. Then enter the commands following the prompts shown below. The
{\tt \$} is the familiar {\small DCL} prompt string, which you don't
type. As we go along there will be commentary explaining what is
happening and why. You may need increased quotas, so it is a good idea
to ask your friendly site manager to ensure your's are adequate for
{\small KAPPA}.  Let's begin. 

\subsection{From DCL}

\small
\begin{verbatim}
     $ KAPPA
\end{verbatim}
\normalsize

This defines {\small DCL} symbols for each {\small KAPPA} command,
includes the help information, and shows the version number. It need
only be issued once per login session.  Regular {\small KAPPA} users
might wish to add this to their {\tt LOGIN.COM}.  Thus you will see

\small
\begin{verbatim}

      --    Initialised for KAPPA    --
      --  Version 0.8-4, 1992 August --

      Type HELP KAPPA or KAPHELP for KAPPA help

\end{verbatim}
\normalsize

Let's run a {\small KAPPA} application.  CADD adds a scalar constant to
an NDF file to make a new NDF file (usually called an {\em NDF\/} for
short.)  In this case ten is added to the pixels in {\tt
ADAM\_EXAMPLES:IMAGE.SDF} to create {\tt TEST.SDF} in the current
directory. 

\small
\begin{verbatim}
     $ CADD ADAM_EXAMPLES:IMAGE 10 TEST
\end{verbatim}
\normalsize

There are three {\em parameters\/} qualifying the CADD command: the names
of the input and output NDFs and the constant.  Notice that these
parameters are separated by spaces.  Most applications have a few of
these positional parameters, usually the most commonly used. Parameter
values on the command line are not subsequently prompted for by the
application.  Also you see that the NDF file extensions are not given.

Next we run the statistics application.  Here we have not given
any parameters.  In this case the application will ask for the
values of any parameters it needs.

\small
\begin{verbatim}
     $ STATS
\end{verbatim}
\normalsize

The only parameter required is called NDF, and STATS prompts us for it.

\small
\begin{verbatim}
     NDF - Data structure to analyse /@TEST/ >
\end{verbatim}
\normalsize

In this example, STATS wants to know for which NDF we require
statistical data.  The text between the {\tt //} delimiters is the
suggested default for the parameter.  By pressing the carriage
return we accept this default as the parameter's value.
Here the suggested default is the name of the NDF
created by CADD.  (Ignore the {\tt @} for the moment---it just tells
the application that it is a file.)
{\small KAPPA} remembers the last NDF used or created, and uses it
for the suggested default to save typing.  Since TEST is the NDF
whose statistics we want we just hit the return key. Again we exclude the
{\tt .SDF} extension.  Here is the output from STATS.

\small
\begin{verbatim}

        Pixel statistics for the NDF structure DISK$SCRATCH:[MJC]TEST

           Title                     : KAPPA - Cadd
           NDF array analysed        : DATA

              Pixel sum              : 9145718
              Pixel mean             : 139.5526
              Standard deviation     : 49.39742
              Minimum pixel value    : 10
                 At pixel            : (215, 35)
                 Co-ordinate         : (214.5, 34.5)
              Maximum pixel value    : 256.2927
                 At pixel            : (89, 47)
                 Co-ordinate         : (88.5, 46.5)
              Total number of pixels : 65536
              Number of pixels used  : 65536 (100.0%)

\end{verbatim}
\normalsize

Of course, in your case the current directory will not be
{\tt DISK\$SCRATCH:[MJC]}.
The NDF title {\tt KAPPA - Cadd} was written into TEST by the
CADD command.  The parameter for nominating the title was defaulted
to this value.  Had we wished TEST to have another title, say
``Horsehead Nebula'', we would have appended {\tt "Horsehead Nebula"}
to the command line.  Notice the quotation marks because the title
includes a space.  Thus to alter defaulted parameters you give their
values on the command line.  Defaulted parameters exist to prevent a
long series of prompts where reasonable values can be defined, and hence
save time. (However, there is a way of being prompted for all parameters
of a command should you wish.)

NDFs may contain three standard arrays---the data array, the data
variance and quality.  STATS can calculate statistics for any of
these.  By default, STATS uses the data array, as indicated here.

Next we wish to smooth our data.  GAUSS performs a Gaussian smooth
of neighbouring pixels.

\small
\begin{verbatim}
     $ GAUSS
\end{verbatim}
\normalsize

Again we are prompted with the same suggested default, since we
have not created any new NDFs within STATS.  Say we don't want to
smooth that NDF, but the original one.  We just enter the name of the
NDF at the prompt.  Notice that we don't need the {\tt @}
prefix, since parameter IN expects a file.  One occasion where you
would need it is when the filename is a number, {\it e.g.}\ if your
NDF was called 234 you must enter @234, otherwise {\small ADAM} will
think you are giving the integer 234.

\small
\begin{verbatim}
     IN - Input NDF /@TEST/ > ADAM_EXAMPLES:IMAGE
\end{verbatim}
\normalsize

The description of parameter FWHM is too brief for us to select a value.
So we obtain some help on this parameter, and then GAUSS reprompts
for a value.  The smoothed NDF is written to the NDF called TESTSM
in the current directory.

\small
\begin{verbatim}
     FWHM - Gaussian PSF full-width at half-maximum /5/ > ?

     GAUSS

       Parameters

         FWHM

           FWHM = _REAL (Read)
              Full-width at half-maximum of the Gaussian PSF to be used in
              smoothing the image. A value between 0.1 and 100.0 should be
              given. Note that unless a non-default value is specified for
              the BOX parameter, the time taken to perform the smoothing
              will increase in approximate proportion to the value of FWHM.
                                                           
     FWHM - Gaussian PSF full-width at half-maximum /5/ >
     OUT - Output NDF > TESTSM
\end{verbatim}
\normalsize

Next we want to look at the result of our image processing.  First thing
to do is to select an image display.  The IKON becomes the current
image display and remains so until the next IDSET command.

\small
\begin{verbatim}
     $ IDSET IKON
\end{verbatim}
\normalsize

Now we actually display it on the Ikon.   Some applications have
many parameters, and it would be impractical to have to specify all
those preceding the ones we wanted to alter.  The solution is specify
the parameter by keyword.  Here we have requested that the scaling of
the data values to colour indices within the image display uses the
current percentile range.  Note that you may abbreviate the options
of a menu, such as offered by parameter MODE, to any unambiguous
string.

\small
\begin{verbatim}
     $ DISPLAY MODE=PE \
     Data will be scaled from 72.5357 to 239.1492.
\end{verbatim}
\normalsize

You should see an image of the ubiquitous Horsehead Nebula on the screen.

The backslash is a very useful feature.  It tells an application to
accept all the suggested defaults. In this case DISPLAY uses the current
NDF and scales between the current percentile limits---10 and 90.

Next we want to make the image colourful.  There are a number of
predefined lookup tables, or you may create and modify
your own.  Here we've given the Ikon a spectrum-like colour table. 

\small
\begin{verbatim}
     $ LUTSPEC
\end{verbatim}
\normalsize

Finally, we decide that we don't like the appearance and we want to
try the effect of `rotating' the colour table.  LUTROT tells you
what to do.

\small
\begin{verbatim}
     $ LUTROT
     Move Ikon mouse to rotate the colour table.
     Push left hand button to reset the colour table.
     Push right hand button to end the rotation of the colour table.
\end{verbatim}
\normalsize

If now you move the mouse from left to right, the colours will move too.
Press the right-hand button when you have finished.

During the above example, you may have noticed a pause each time you
issued a command.  There is a way of preventing them.  Read on.

\subsection{From ICL}
{\small ICL} is the standard command language designed for use with
{\small ADAM} applications, like {\small KAPPA}.  The main advantages
for the {\small KAPPA} user is that only one executable need be loaded,
and therefore it is faster than using {\small DCL} when you want to invoke
more than two or three commands; there is a wide selection of intrinsic
functions and floating-point arithmetic; and results may be passed
between applications via {\small ICL} variables.  However, in these two
demonstrations the command languages are interchangeable.

Let's start the second example.

\small
\begin{verbatim}
     $ ADAM KAPPA
\end{verbatim}
\normalsize

This starts {\small ICL}.  System, local and user-defined {\small ICL}
login files are invoked.  Here there is only a system login procedure
which sets up help on {\small ADAM} packages, and commands for setting
up definitions for those packages.  One of those commands is {\tt
KAPPA}; it is analogous to the KAPPA command from {\small DCL}.
We can either enter it after receiving the {\small ICL} prompt,
or, as here, following the ADAM command.

You should see something like the following.

\small
\begin{verbatim}
     Interactive Command Language   -   Version 1.5-6

       - Type HELP package_name for help on specific Starlink packages
       -   or HELP PACKAGES for a list of all Starlink packages
       - Type HELP [command] for help on ICL and its commands

     Help key KAPPA redefined.

     --    Initialised for KAPPA    --
     --  Version 0.8-4, 1992 August --

     Type HELP KAPPA or KAPHELP for KAPPA help

\end{verbatim}
\normalsize

Now we run an application, ADD, that adds the pixels in
{\tt ADAM\_EXAMPLES:IMAGE.SDF} to those in {\tt KAPPA\_DIR:CCDFRAMEC.SDF}.
Although these images have different dimensions, the intersection is
made.

\small
\begin{verbatim}
     ICL> add adam_examples:image kappa_dir:ccdframec
\end{verbatim}
\normalsize

After the first {\small KAPPA} command is issued you'll see an arcane
message like this.

\small
\begin{verbatim}
     Loading KAPPA_DIR:KAPPA into 1336KAPPA
\end{verbatim}
\normalsize

It just tells you that {\small KAPPA} is being loaded.  After a pause of
10--40 seconds, depending on the power of your computer, the application
will execute.\footnote{The reason why it takes so long is due to the
loading VMS shareable libraries.} However, subsequent applications will be
fired instantaneously.

Since we did not give the name of the destination NDF that will hold the
co-added NDFs, ADD prompts for it.  Notice that file names and
literal parameters are case insensitive.

\small
\begin{verbatim}
     OUT - Output NDF > demo1
\end{verbatim}
\normalsize

\small
\begin{verbatim}
     ICL> NDFTRACE \
\end{verbatim}
\normalsize

This shows that the {\tt DEMO1} NDF has the same dimensions as the
smaller of the two NDFs.

We were going to display the image on the current image display, but
then changed our minds.  A {\tt !!} in response to a prompt aborts an
application.

\small
\begin{verbatim}
     ICL> display demo1
     MODE - Method to define the scaling limits /'PERCENTILES'/ > !!
      demo1
     ADAMERR   %PAR, Parameter request aborted
\end{verbatim}
\normalsize

We make the Ikon the current graphics device.  Like the IDSET command
we saw earlier this selection remains until we next issue a GDSET
command.  It persists between {\small DCL} and {\small ICL} sessions.
If you wish to see the current values of these {\em global} parameters
use the GLOBALS command.  There are examples later.

\small
\begin{verbatim}
     ICL> GDSET IKON
\end{verbatim}
\normalsize

{\small KAPPA} uses the graphics database, which records the positions
and extents of graphs and images, collectively called pictures.

\small
\begin{verbatim}
     ICL> PICDEF MODE=A XPIC=2 YPIC=1 PREFIX=C
\end{verbatim}
\normalsize

This instruction divides the display surface into two equally sized
pictures, side by side.  They are labelled C1 and C2 in the database.
Picture C1 is the current picture, in which future pictures are drawn,
unless we select a new current picture.

Thus in picture C1 we display an image of Comet West around which we
draw a yellow border.  The backslash causes the current scaling method
to be used.

\small
\begin{verbatim}
     ICL> DISPLAY COMWEST BORDER BCOLOUR=Yell \
     !! Error searching for file DISK$SCRATCH:[MJC]COMWEST.SDF; - RMS-E-FNF,
     !     file not found.
     !  HDS_OPEN: Error opening an HDS container file.
     !  NDF_ASSOC: Unable to associate an NDF structure with the 'IN' parameter.
\end{verbatim}
\normalsize

DISPLAY could not find the a {\tt COMWEST.SDF} in the current directory.
So there is an error message and we are prompted.  This time we remember
to add the logical name.

\small
\begin{verbatim}
     IN - NDF to be displayed /@COMWEST_BAS/ > KAPPA_DIR:COMWEST
     Data will be scaled from 20.33679 to 230.7239.
\end{verbatim}
\normalsize
An image of Comet West should be visible to the left of the screen.

SHADOW creates an image that appears like a bas-relief.  We've called
the resulting NDF COMWEST\_BAS.  The backslash causes the current NDF
to be the input NDF for SHADOW.

\small
\begin{verbatim}
     ICL> SHADOW OUTPIC=COMWEST_BAS \
     Title = KAPPA - Sqorst
\end{verbatim}
\normalsize

We select the right-hand picture created earlier.

\small
\begin{verbatim}
     ICL> PICSEL C2
\end{verbatim}
\normalsize

As above we display the current NDF, the bas-relief image, with a yellow
border on the right of the raw comet image.

\small
\begin{verbatim}
     ICL> DISPLAY BORDER BCOLOUR=Yell \
     Data will be scaled from -8.322052 to 13.87538.
\end{verbatim}
\normalsize

The relief looks best with a greyscale colour table.  Note that this
does not affect the colour of the border.  LUTGREY is a procedure
which calls a more-general application.  Since it is the first
procedure we've invoked there is a short pause while all the {\small
KAPPA} procedures are compiled and loaded.

\small
\begin{verbatim}
     ICL> LUTGREY
     Loading procedure file KAPPA_DIR:KAPPA_PROC.ICL
\end{verbatim}
\normalsize

Next we decide to make a hard copy of the bas-relief image.  GREYPLOT
does this and adds a key of grey levels and their corresponding values.
The chosen device is POSTSCRIPT\_L; this overrides the Ikon for the
duration of GREYPLOT.  If you don't have this device, try CANON\_L.
We scale between the limits reported earlier.

\small
\begin{verbatim}
     ICL> GREYPLOT DEVICE=POSTSCRIPT_L
     IN - NDF to be displayed /@COMWEST_BAS/ >
     KEY - Do you want a key of the grey levels and a title ? /TRUE/ >
     MODE - Method to define the scaling limits /'SCALE'/ >
     BLACK - Value to be black in the plot? /187.5625/ > 13.88
     WHITE - Value to be white in the plot? /-183.453125/ > -8.32
\end{verbatim}
\normalsize

GREYPLOT does not send your plot to the printer, since this is hardware
and node dependent.  Therefore, you must issue a {\small DCL} command
from {\small ICL} to perform this action.  That's not difficult---just
insert a dollar before the {\small DCL} command.  There is a slight
pause while the subprocess is created.  Subsequent {\small DCL} commands
will be obeyed immediately. 

\small
\begin{verbatim}
     ICL> $ PRINT/QUEUE=SYS_PS/FORM=POST/PASSALL GKS_72.PS
     Creating DCL subprocess
\end{verbatim}
\normalsize

{\small DCL} symbols may also be used, so if {\tt DC} equates to
{\tt DELETE/CONFIRM}, we could remove any unwanted HDS files.  If you
don't have this symbol, as is likely, then you will receive the
appropriate error message from {\small DCL}.

\small
\begin{verbatim}
     ICL> $ DC *.SDF;*
\end{verbatim}
\normalsize

That's the end of the second demonstration.  Of course, these
introductions have only scratched the surface of what {\small KAPPA} can
do for you.  You should look at Appendix~\ref{ap:classified} to search
for the desired function, and then find more details in
Appendix~\ref{ap:full}.

If you get stuck or something untoward happens, there is a {\tt Hints}
help topic.

\newpage
\section{Getting started}

\subsection{Quotas}
You may need increased quotas to run {\small ADAM} applications and
{\small KAPPA} in particular.  See Appendix~\ref{ap:quotas} for details.
You can check your quotas from {\small DCL} via

\small
\begin{verbatim}
     $ SHOW PROCESS/QUOTA
\end{verbatim}
\normalsize
Note that the {\tt \$} is the standard VMS prompt which you do not type.
If any additional quotas are required see your generous computer
manager. The most likely candidates requiring enlarged quotas are PGFLQUOTA
(paging file quota) and PRCLM (maximum number of subprocesses).

\subsection{Running KAPPA}
{\small KAPPA} comes in two forms.  One is a monolith that is activated
within the {\small ADAM} command language---{\small ICL}.  The other
comprises individual applications and is run from {\small DCL}.  The
monolith has the advantage that after the initial pause while it loads,
all its constituent applications are available immediately.  There is no
pause while each new application is fired up.  This is fine when you
wish to run several applications and/or the same application several
times. However, for single tasks it may be more convenient to run from
{\small DCL}.  You may simply prefer the familiar {\small DCL} to
{\small ICL}, though {\small DCL} commands, including editing, are
accessible from {\small ICL} via a {\tt \$} prefix. This is not the
vehicle to expound the intrinsic merits of the two
command languages, but where there are differences affecting {\small
KAPPA}, they'll be indicated. The choice is yours.

To run {\small KAPPA} from {\small DCL} just enter the command

\small
\begin{verbatim}
     $ KAPPA
\end{verbatim}
\normalsize
This executes a procedure setting up symbols for {\small KAPPA}'s command
names, and defines some logical names to make help information available.
Then you'll be able to mix {\small KAPPA} commands with the familiar
{\small DCL} ones.

To run the {\small KAPPA} monolith is almost the same except you must be
within the {\small ADAM} command language.  This requires just one extra
command, namely

\small
\begin{verbatim}
     $ ADAM
\end{verbatim}
\normalsize
You will see any messages produced by system and user procedures, followed
by the {\tt ICL>} prompt. Again there is a procedure for making the
commands known to the command language, and not unexpectedly, it too is

\small
\begin{verbatim}
     ICL> KAPPA
\end{verbatim}
\normalsize
Then you are ready to go.  Not too painful, was it?  In either case
you'll see message from KAPPA telling you which version is ready for
use.

So what do you get for your trouble?  Appendix~\ref{ap:summary} lists
in alphabetical order the 130-odd commands and their functions, and
Appendix~\ref{ap:classified} is a classified list of the same commands.
Many examples are given in subsequent sections.

\subsection{Issuing Commands}
To run an application you then can just give its name---you will be
prompted for any required parameters. Alternatively, you may enter
parameter values on the command line specified by position or by
keyword.  More on this in Section~\ref{se:param}.

Commands are interpreted in a case-independent way.
They may be abbreviated provided they are unambiguous strings with
at least four characters.  Commands shorter than five characters,
therefore, cannot be shortened. So

\small
\begin{verbatim}
     ICL> CREF
     ICL> CREFR
     ICL> CreFra
     ICL> CREFRAM
\end{verbatim}
\normalsize
would all run CREFRAME. Whereas

\small
\begin{verbatim}
     ICL> FITS
     ICL> FITSI
\end{verbatim}
\normalsize
would be ambiguous, since there are several commands beginning
{\tt FITS}, and two starting {\tt FITSI}, namely FITSIN and FITSIMP.

Note if other packages are active there may be command-name clashes, {\it
e.g.}\ ROTATE is in {\small FIGARO} and {\small KAPPA}.  Issuing such a
command will run that command in the package last activated.  You can
ensure receiving the {\small KAPPA} help by inserting a {\tt KAP\_}
prefix before the command name.  For example,

\small
\begin{verbatim}
      $ KAP_ROTATE
\end{verbatim}
\normalsize
will execute {\small KAPPA}'s ROTATE application. \medskip

{\large {\bf Since the {\normalsize{\bf KAPPA}} commands are the same in both
{\normalsize{\bf DCL}} and {\normalsize{\bf ICL}}, the {\tt \$} and {\tt ICL>} prompts in the
examples and description below are interchangeable unless noted
otherwise.}}

\subsection{Obtaining Help}
\subsubsection{Entering the Help System}
An introduction is given in the KAPPA topic via

\small
\begin{verbatim}
     ICL> HELP KAPPA
\end{verbatim}
\normalsize
The behaviour is different for {\small DCL} and {\small ICL} because
of a restriction imposed by VMS help libraries that is circumvented
in {\small ICL}.  From {\small ICL}, {\tt HELP KAPPA} puts you into the
top level of the help library.  Type {\tt ?} to get a list of
help topics.  These are mostly the commands for running
applications, but they also include global information on matters such
as parameters, data structures and selecting a graphics device.

\small
\begin{verbatim}
     ICL> HELP PACKAGES KAPPA
\end{verbatim}
\normalsize
gives a summary of purpose of the package. (This is part of an index
of {\small ADAM} packages.)

Whereas from {\small DCL}

\small
\begin{verbatim}
     $ HELP KAPPA
\end{verbatim}
\normalsize
combines the two help items described above.  Note this locates you at
the second level of the help hierarchy because the highest is {\tt
"Help"}, not {\tt "KAPPA"}; you'll have to hit a carriage return
({\tt <CR>}) to climb a level to see the list of help on commands and
general information.

Since the existing {\small ICL} help system has some drawbacks and
because of the different behaviour from the command languages, a simple
help system that was written prior to {\small ICL} is still available;
to operate it use the command {\tt KAPHELP} instead of {\tt HELP}.  It
accesses a portable {\small KAPPA} help library with constiuents
virtually identical to those read by the {\tt HELP} command.
The system responds by introducing {\small KAPPA}'s help library,
followed by a list of topics for which help is available, followed by
the prompt {\tt Topic?}. 

 If you have commenced running an application you can still access the
help library at prompts for parameters.  It is primarily there to
provide information about the parameter being prompted. See
Section~\ref{se:parhelp} for details.

\subsubsection{Navigating Help Hierarchies} All the help systems may be
navigated in the normal ways for a VMS help library, except that from
{\small ICL} {\tt HELP} does not recognise all the navigation commands,
and {\tt KAPHELP} permits other abbreviations. For those not familiar
with VMS help libraries the topic {\tt Using\_help} has details. You can
exit from the help by typing {\tt CTRL/Z} (that is, pressing the CONTROL
and Z keys simultaneously) in response to any prompt (except from
{\small ICL} where it must be a {\tt subtopic?} or {\tt topic?} prompt).
 A series of carriage returns has the same effect. 

\subsubsection{Help on KAPPA commands}
Help on an individual {\small KAPPA} application is simply achieved by
entering {\tt HELP} followed by the command name, for example:

\small
\begin{verbatim}
     $ HELP CENTROID
\end{verbatim}
\normalsize
will give the description and usage of the CENTROID command.  There
are subtopics which contain details of the parameters, including defaults, and
valid ranges; examples; notes expanding on the description;
implementation status; and occasionally timing.
For example,

\small
\begin{verbatim}
     ICL> HELP HIST PARAM INPIC
\end{verbatim}
\normalsize
gives details of parameter {\tt INPIC} in all applications prefixed by
{\tt HIST}.

The instruction

\small
\begin{verbatim}
     ICL> HELP CLASSIFIED
\end{verbatim}
\normalsize
displays a list of subject areas as subtopics.  Each subtopic lists and
gives the function of each {\small KAPPA} application in that classification.
There is also an alphabetic list which can be obtained directly via
the command

\small
\begin{verbatim}
     ICL> HELP SUMMARY
\end{verbatim}
\normalsize

At the next release it is expected that all the above help systems will
be standardised via the fast and more-flexible {\small HELP} package
(SUN/124), as used by {\tt KAPHELP}.  These confusing differences
should disappear and help from {\small DCL} or {\small ICL}, {\tt HELP}
or {\tt KAPHELP} will behave identically. More documentation, including a
cookbook and beginners guide are planned for later versions. 

\subsubsection{Command clashes}
Note if other packages are active, there may be duplicated commands,
{\it e.g.}\ GAUSS is in {\small FIGARO} and {\small KAPPA}.  Help on
the most recently activated will be given.  From {\small ICL} you can ensure
receiving the {\small KAPPA} help by inserting a {\tt KAP\_} prefix
before the command name.  For example,

\small
\begin{verbatim}
     ICL> HELP KAP_GAUSS
\end{verbatim}
\normalsize
will describe {\small KAPPA}'s GAUSS application.  From {\small DCL}
go via {\tt \$ HELP KAPPA} then select the GAUSS topic.

\subsection{Exiting an Application}
In normal circumstances when you've finished using {\small KAPPA}
nothing need be done from {\small DCL}, but to end an {\small ICL}
session, enter the {\tt EXIT} command to return to {\small DCL}.

What if you've done something wrong, like entering the wrong value
for a parameter?  If there are further prompts you can enter the
abort code {\tt !!} to exit the application.  This is recommended
even from {\small DCL} because certain files like the graphics
database may become corrupted if you use the crude {\tt CTRL/Y}.
If, however, processing of the data has begun in the application
{\tt CNTL/C} should be hit.  From {\small ICL} this ought to return
you to a prompt, but the processing will continue.  Then you can stop
the running process via

\small
\begin{verbatim}
     ICL> KILL KAPPA_DIR:KAPPA
\end{verbatim}
\normalsize
{\small KAPPA} will be loaded again once you enter a {\small KAPPA}
command. If several attempts with {\tt CTRL/C} fail to return you to an
{\small ICL} prompt then it's time for the heavy artillery---{\tt
CTRL/Y}.  Once back to {\small DCL} enter {\tt CONTINUE} to return to
{\small ICL} where you left off, and then kill the process as described
above.

\section{Parameters}
\label{se:param}
{\small KAPPA} is a command-driven package.  Commands have
{\em parameters\/} by which you can qualify their behaviour.
Parameters are obtained in response to prompts or supplied on a
command line.

For convenience, the main aspects of the {\small ADAM} parameter system
as seen by a user of {\small KAPPA} are described below.  Though note
that most of what follows is applicable to any {\small ADAM}
application.

\subsection{Defaults}
\label{se:defaults}
Command-line values are used mostly for those parameters
that are normally defaulted by the application.   Defaulted parameters
enable applications to have many options, say for controlling the appearance
of some graphical output, without making routine operations tedious because
of a large number of prompts. The values of normally defaulted
parameters are given in Appendix~\ref{ap:full}. You can also find them
by obtaining online help on a specific parameter.  They are enclosed
in square brackets at the end of the parameter description.

\small
\begin{verbatim}
     ICL> HELP MEDIAN PARAM *
\end{verbatim}
\normalsize
gives details of all parameters in application MEDIAN. NDF applications
show the defaults at the end of each parameter description enclosed in
square brackets---the same as in Appendix~\ref{ap:full}.\footnote{
IMAGE-format applications have their parameter help arranged
differently. For each parameter there is a line that begins {\tt vpath}
which tells ADAM from where it should try to obtain a value or values
for that parameter. If it does not begin 'PROMPT' the parameter will be
defaulted.  A vpath of 'DEFAULT' indicates that the parameter will take
the value given by the default field; a vpath of 'DYNAMIC' means that
the application has computed a suitable default, usually depending on
the values of other parameters or the dimensions of your data array.} If
you want to override one of these defaults, then you must specify the
parameter's value on the command line.

When you are prompted you will usually be given a suggested default value in
{\tt / /} delimiters.  You can choose to accept the default by pressing
carriage return.  For example, 64 is the suggested value below.

\small
\begin{verbatim}
     XDIM - x dimension of output array /64/ >
\end{verbatim}
\normalsize
Alternatively, enter a different value

\small
\begin{verbatim}
     XDIM - x dimension of output array /64/ > 109
\end{verbatim}
\normalsize
to override the default.
Some defaults begin with an {\tt @}.

\small
\begin{verbatim}
     INPIC - Input image /@starfield/ >
\end{verbatim}
\normalsize
These are associated with files (ASCII, HDS) and devices (graphics,
tape). If you want to override the default given, you do not have to
prefix your value with an {\tt @}, {\it e.g.}

\small
\begin{verbatim}
     DEVICE - Name of display device /@IKON/ > ARGS1
\end{verbatim}
\normalsize
There are rare cases when the syntax is ambiguous, and it is then that you
need to include the {\tt @}.  Section~\ref{se:parstring} describes
when the {\tt @} is needed.

The default value can be edited to save typing by first pressing the
{\tt <TAB>} key. The editor behaves like the {\small DCL} command-line
editor. Defaults may change as data are processed by {\small KAPPA}.
Often the current (last) value of the parameter will be substituted, or
a dynamic value is suggested depending on the values of other
parameters. Here is an example comprising a loop within an application.

\small
\begin{verbatim}
     INPIC - Image to be inspected /@HORSEHEAD/ >
     Title = KAPPA - Gauss
     Array is 109 by 64 pixels
     CHOICE - Peep, Examine or List /'P'/ >

     XCEN - x centre pixel index of 7x7 box /55/ > 60
     YCEN - y centre pixel index of 7x7 box /32/ > 28
        .              .               .              .
        .              .               .              .
        .              .               .              .
     ANOTHER - Another inspection ? /YES/ >
     CHOICE - Peep, Examine or List /'P'/ >

     XCEN - x centre co-ordinate of 7x7 box /60/ > 66
     YCEN - y centre co-ordinate of 7x7 box /28/ >
\end{verbatim}
\normalsize
and so on. 
Notice that the current values of the centres are the suggested values
at the second pair of prompts.
Current values of KAPPA parameters are stored in the HDS file
{\tt ADAM\_USER:KAPPA.SDF}, and so they persist between {\small KAPPA} sessions.
This file should not be deleted unless {\small KAPPA} parameters are to
be completely reset.

\subsection{Globals}
{\small KAPPA} stores a number of global parameters that are used as
defaults to reduce typing in response to prompts. Global means that they are
shared between applications.  The most common is the last IMAGE structure
or NDF written or accessed.  In the example above, this was
{\tt HORSEHEAD.SDF}.  If you just press {\tt <CR>} to the prompt, the global
value is unchanged. Only when you modify the parameter and the
application completes without error is the
global value updated, and so becomes the suggested default value for the
next prompt for an NDF or IMAGE structure. 

All global parameters are stored in HDS file {\tt ADAM\_USER:GLOBAL.SDF}.
The full list is:
\newline\newline
\begin{tabular}{@{\hspace{5ex}}l@{~~ --- ~~}l}
{\tt GLOBAL.COORD\_SYSTEM}    & Current co-ordinate system.\\
{\tt GLOBAL.DATA\_ARRAY}      & Last IMAGE file or NDF accessed or written.\\
{\tt GLOBAL.GRAPHICS\_DEVICE} & Last GKS workstation used.\\
{\tt GLOBAL.IMAGE\_DISPLAY}   & Last image display (base) used.\\
{\tt GLOBAL.IMAGE\_OVERLAY}   & Last image-display overlay used.\\
{\tt GLOBAL.INTERACTIONMODE}  & Current interaction mode. \\
{\tt GLOBAL.LUT}              & Last lookup table file accessed or written. \\
\end{tabular}
\newline\newline
{\small KAPPA} uses the last DATA\_ARRAY written or accessed as the
suggested default value for the next prompt for an IMAGE or NDF
structure.  The same applies to the current lookup table.  However, the
remaining, including the three graphics global parameters are
defaulted---you will not be prompted.  Details of how to control these
parameters are given in the relevant sections
later---Section~\ref{se:selgradev} for the graphics devices,
Section~\ref{se:interaction} for the interaction mode, and
Section~\ref{se:co-ordsystem} for the co-ordinate systems.

The values of of all global parameters may be inspected via the
{\tt GLOBALS} command.

\small
\begin{verbatim}
     ICL> GLOBALS
     The current IMAGE file or NDF is     : @SYS$SCRATCH:CCDPIC
     The current graphics device is       : @graphon
     The current image-display device is  : @IKON
     The current image-display overlay is : <undefined>
     The current lookup table file is     : @KAPPA_DIR:SPECTRUM_LUT
     The current co-ordinate system is    : WORLD
     The current interaction mode is      : <undefined>
\end{verbatim}
\normalsize
In the above example no interaction mode is defined.  The next time
you call an application which uses the interaction mode you
would be prompted for a value.   Likewise for the image-display
overlay. (Under normal circumstances you will not
have to enter the {\tt @} prefix yourself.)  

\subsection{Strings}
\label{se:parstring}
Notice that the apostrophes around strings given in response to prompts
for a character parameter can be omitted. However, on the command
line quotes or double quotes are needed if the string contains spaces,
otherwise the second and subsequent words could be treated as
separate positional parameters.
To indicate that the parameter should come from a
data-structure object, prefix the name with an {\tt @} to tell {\small ADAM}
that it is a file name, and not a literal value.

\small
\begin{verbatim}
     PLTITL - Plot title /' '/ @ADAM_USER:GALAXY.MYTITLE
\end{verbatim}
\normalsize
In this example PLTITL has the value of object MYTITLE in {\tt GALAXY.SDF}.
If the {\tt @} were omitted PLTITL would be
{\tt 'ADAM\_USER:KAPPA.CONTOUR.PLTITL'}.  You will need the {\tt @}
prefix if your file name is a number.
Note that the file extension should not be included when giving the
name of an HDS data file. Otherwise HDS will look for an object
called SDF within the file.

Responses to prompts are case insensitive.

\subsection{Arrays}
If a parameter requires an array of values, the series
should be in brackets separated by commas or spaces.  For example,

\small
\begin{verbatim}
     PERCENTILES - List of percentiles > [25,95.5,75]
\end{verbatim}
\normalsize
would input three values: 25, 95.5 and 75 into the real parameter
PERCENTILES.  If the application is expecting an exact number of values
you will be reprompted, either for all the values if you give too many,
or the remaining values if you supply too few.  There is one exception
where you can omit the brackets---a fairly common one---and that is in
response to a prompt for a one-dimensional array as above.

\subsection{Abort and Null}
Responding to a prompt with a null value {\tt !} will not necessarily
cause the application to abort, but it can force a suitable default to
be used, where this is the most-sensible action. A further use in KAPPA
is when an optional file may be created, such as a lookup table; a {\tt !}
entered in response to the prompt for the filename means that no file is
to be output. {\small KAPPA} often uses null as a default for many
optional files. In some applications, {\it e.g.}\ CRELUT, a null ends an
interactive loop.

Responding to a prompt with an abort request {\tt !!} will abort the
application.  This process includes the various tidying operations
such as the unmapping and closing of files.  Any other method of
stopping an application prematurely can leave files mapped or corrupted.

\subsection{Help}
\label{se:parhelp}
To get help about a parameter enter {\tt ?}.  Usually, this will give
access to the help-library
information for that parameter, for example,

\small
\begin{verbatim}
     BOX - Smoothing box size /3,3/ > ?

     BLOCK

       Parameters

         BOX(2) = _INTEGER (Read)
            The X and Y sizes (in pixels) of the rectangular box to be
            applied to smooth the image. If only a single value is given,
            then it will be duplicated so that a square filter is used.
            The values given will be rounded up to positive odd integers
            if necessary.

     BOX - Smoothing box size /3,3/ >
\end{verbatim}
\normalsize
and then immediately reprompt you for the parameter.  There are
occasions when information about the parameter is insufficient; you
may require to examine the examples or the description of related
parameters.  This can be achieved via entering {\tt ??} to the prompt.
You can then delve anywhere in the help information.  When you exit the help
system you're reprompted for the parameter.

For the old, IMAGE-format, applications the {\tt ?} does not enter
the help system, and so the help is limited to an unsatisfactory and
miserly 120 characters:

\small
\begin{verbatim}
     DIRN - Direction of ramping > ?
       1 = L-R : 2 = R-L : 3 = B-T : 4 = T-B, where L is left, R is right, B is bott
     om and T is top
     DIRN - Direction of ramping >
\end{verbatim}
\normalsize
{\small ADAM} does not break the text between words
to start a new line.  Fortunately, this form of parameter help is
being phased out of {\small KAPPA}.

\subsection{Menus}
Some {\small KAPPA} parameters are menus from which you select an option.
You do not have to enter the full option string, but merely a string
that selects a choice unambiguously.  In many cases this can be as
little as a single character.  Here is an example:

\small
\begin{verbatim}
     OPTION - Which option is required ?' /'REGION'/ > ?
       Help, Region, Save, Device, Value, Peep, List, Statistics, Histogram, Slice, XYcur or Exit.
\end{verbatim}
\normalsize
where a {\tt P} would be sufficient to select the {\tt Peep} option, but at least
two characters would be needed if you wanted {\tt Save} or {\tt Slice}
or {\tt Statistics}.

Some parameters permit a mixture---a choice from a menu, or a
numerical value within a range.  The options are described in full
in the help system and Appendix~\ref{ap:full}.

\subsection{Logical names}
From {\small DCL}, ordinary process logical names may be used as normal.
However, logical names to be used by applications (including
{\small KAPPA}) from within {\small ICL} must be defined with the /JOB
qualifier. Thus if your NDF data files are stored in IMAGEDIR
alias {\tt DISK\$USER1:[XYZ.IRCAM.IMAGES]}

\small
\begin{verbatim}
    $ DEFINE/JOB IMAGEDIR DISK$USER1:[XYZ.IRCAM.IMAGES]
\end{verbatim}
\normalsize
will enable you to respond to a prompt thus

\small
\begin{verbatim}
     IN - Input image /@starfield/ > imagedir:ngc1365
\end{verbatim}
\normalsize
Regrettably, at present {\small ICL} cannot change default directories
for {\small KAPPA}.  The DEFAULT command only applies to {\small ICL}
and the {\small DCL} process.  Therefore, if you need to access files in
several directories with the minimum of typing, you should define some
job logical names as described above.  If you require many then you will
need your JTQUOTA increased.  See your site manager if you run into
difficulties.  It is advisable to set default to the directory
containing your data files before entering {\small ICL}.

\subsection{Specifying Parameter Values on Command Lines}
\label{se:cmdlindef}
Parameters may be assigned values on the command line. This is useful
for running {\small KAPPA} in batch mode and in procedures, and for
specifying the values of parameters that would otherwise be defaulted. A
command-line parameter will prevent prompting for that parameter unless
there is an error with the given value, say giving an alphabetic
character string where a floating-point value is demanded.

There are two ways in which parameter values may be given on the
command line: by keyword and by position. The two forms may be
mixed with care. The parser looks for positional parameters then
keywords, so you can have some positional values followed by keyword
values.  See some of the examples presented in Appendix~\ref{ap:full}.

Keywords may appear in any order.
Here is an example of command-line defaults using keywords:

\small
\begin{verbatim}
     ICL> PICDEF CURRENT FRACTION=0.4
\end{verbatim}
\normalsize
~FRACTION is a real parameter.  CURRENT is a logical parameter; by giving
just its name it is given the value {\tt TRUE}. {\tt CURRENT=T} would
have the same effect.  To obtain a false value for a logical parameter
you add a {\tt NO} prefix to keyword, for example,

\small
\begin{verbatim}
     ICL> PICDEF NOCURRENT
\end{verbatim}
\normalsize
would be equivalent to {\tt CURRENT=F}.

Alternatively, you can specify command-line values by position:

\small
\begin{verbatim}
     $ ADD HISIMAGE HERIMAGE THEIRIMAGE
\end{verbatim}
\normalsize
The application adds the two NDFs {\tt HISIMAGE.SDF} and
{\tt HERIMAGE.SDF} to form a new NDF in file {\tt THEIRIMAGE.SDF}.  Note
trailing parameters may missed---TITLE in the above example---but
intermediate ones may not.  Some applications have many parameters and
it would be tedious not only to enter all the intermediate values
between the ones you want to define, but also to remember them all. The
position of a parameter can be found in the {\tt Usage} heading in
Appendix~\ref{ap:full} or the help for the application.\footnote{In
IMAGE-format applications look in the help topic of the same name at the
level beneath the topic {\tt Parameters} in a given application.}

Another consideration is that some parameters do not have defined positions
because they are normally defaulted. Thus the keyword technique is
recommended for most parameters.  See Section~\ref{se:custom} if you
want to abbreviate some command strings to reduce typing.

Sometimes specifiying a parameter on the command line induces different
behaviour, usually to inhibit a loop for procedures, or to eliminate
unnecessary processing.
For instance,

\small
\begin{verbatim}
     $ CENTROID INIT=[51,42] MODE=I \
\end{verbatim}
\normalsize
will determine the centroid near the point (51,42) and then it exits,
whereas without the INIT value you would be re-prompted for a further
initial position; and

\small
\begin{verbatim}
     $ DISPLAY GALAXY MODE=SC HIGH=3000 LOW=1000
\end{verbatim}
\normalsize
prevents the calculation of the extreme values of the NDF called
GALAXY that are normally given as suggested defaults for HIGH and LOW,
because HIGH and LOW are already known.

\subsection{Special Keywords: ACCEPT, PROMPT, RESET}
\label{se:iclkey}
Another way in which prompts and default values can be controlled is
by use of the keywords ACCEPT, PROMPT and RESET.

The RESET keyword causes the default value of all parameters (apart
from those already specified before it on the command line) to be
set to the original values specified by the application or its interface
file.  In other words global and current values are ignored.

The PROMPT keyword forces a prompt to appear for every application
parameter.  This can be useful if you cannot remember the name of
a defaulted parameter or there would be too much to type on the
command line.  However, it may prove tedious for certain {\small KAPPA}
applications that have tens of parameters, most of which you normally
never see.  You can abort if it becomes too boring.

The ACCEPT keyword forces the parameter system to accept the
{\em suggested\/} default values for every application parameter.  In
other words, those parameters which would normally be prompted with
a value between `/ /' delimiters take the value between those
delimiters, {\it e.g.}\ XDIM we saw in Section~\ref{se:defaults}
would take the value {\tt 64}.  Parameters that are normally defaulted
behave as normal.  The ACCEPT keyword needs to be used
with care because not every parameter has a default, and therefore must
be given on the command line for the application to work properly. For
example, CREFRAME must have a value specified for parameter OUTPIC, the
name of the output data object. If we run the application like this:

\small
\begin{verbatim}
     ICL> creframe accept
\end{verbatim}
\normalsize
it would fail in the sense that it would still have to prompt for a
value---it does not know where to write the output IMAGE
data file.  However, if we run CREFRAME like this

\small
\begin{verbatim}
     ICL> creframe outpic=stars accept
\end{verbatim}
\normalsize
it would generate an output image using default values for all the
parameters except OUTPIC, and write the output to file STARS.SDF.
Another point to be wary of is that some applications have loops,
{\it e.g.}\ CHPIX, LUTABLE, STATS2D, and if you use the ACCEPT keyword
it will only operate the first time the application gets a parameter
value.

Sometimes the keyword ACCEPT can be used without any parameter value
specifications on the command line.
For example we could follow the above command by the command:

\small
\begin{verbatim}
     $ look accept
\end{verbatim}
\normalsize
and the central 7$\times$7 array of the image created by CREFRAME would be
displayed on your terminal without any parameter values being prompted.
The symbol `\verb+\+' has the same effect as ACCEPT when used on the
command line, thus:

\small
\begin{verbatim}
     $ look \
\end{verbatim}
\normalsize
would have the same effect as the previous example---and is quicker
to type.

How do you find out which parameters have suggested defaults, as opposed
to those that are normally defaulted?  Well, a good rule of thumb is
that parameters for output files (images, lookup tables and ASCII) will
not have a default, but the remainder will.  There are some exceptions,
such as where null is the default for optional files.  Consulting the
description of the parameters should give the suggested defaults, where
appropriate.\footnote{This information is not given in the old-style
(IMAGE-format) documentation.  There you can look at the
interface information in the KAPPA help library given for each
parameter, or the interface file itself ({\tt KAPPA\_DIR:KAPPA.IFL}).
If a parameter is given a suggested default it will have a line
beginning {\tt ppath} or a {\tt default} line.}  If you want to use
ACCEPT for an automatic procedure or batch job you could do some tests
to find which parameters get prompted and then put them on the command
line in your procedure. 

\section{Selecting a Graphics Device}
\label{se:selgradev}
As you saw earlier there are global parameters for the graphics devices:
\begin{description}
\item [Graphics Device] --- The device used for line graphics.
\item [Image Display] --- The device used for displaying images, but this
does not exclude the possibility of line graphics, such as axes, when
they are associated with the image.  The image-display device should
be capable of showing at least 24 colours or grey levels simultaneously,
and more for certain applications.
\item [Image-display Overlay] --- The device used for overlays on the image
display.  Again there is a restriction there should be at least 16
colours, except for X-windows overlays since these only have a single
colour.
\end{description}
The purpose of these global parameters is ostensibly to prevent
unnecessary prompting. However, there is an ulterior motive as well. 
The selection of devices outside of the graphics applications enables
us to perform other necessary actions just once. 

There are commands for selecting each type of device: GDSET,
IDSET and OVSET for the graphics device, image display and
overlay respectively.  For example,

\small
\begin{verbatim}
     ICL> IDSET XWINDOWS
     $ GDSET GRAPHON
\end{verbatim}
\normalsize
A selection remains in force until you change it via another
device-selecting command, or delete the globals file.  The current
choices can be inspected via the GLOBALS command.   If the
global parameter is undefined you will be prompted for the
device if an application requires it.

You can override the global parameter for the duration of a single
application by specifying it by keyword (normally {\tt DEVICE=}), or in
some applications, by position.  Here is an example.

\small
\begin{verbatim}
     ICL> CONTOUR DEVICE=GRAPHON
\end{verbatim}
\normalsize

Note that applications with optional graphics, {\it e.g.}\ NORMALIZE,
will prompt for the graphics device, so you can enter null, {\tt !} if
graphics aren't required.  The global value appears as the suggested
default, so there is little extra typing. A prompt is made because
{\small ADAM} treats a {\tt !} literally when it appears on the command
line rather than null, and from {\small DCL}, characters following the
{\tt !} would be treated as comments.

\subsection{X-windows}
Here seems a good point to mention X-windows, as it is a special case
that can require a little preparation before you select a device.

{\small KAPPA} graphics commands use {\small GWM} indirectly to manage
windows, for example to permit a window to persist between separate
applications, or to be shared by GKS and IDI applications. If you do not
create the window before running {\small KAPPA}, the first graphics
application to open an X-windows device will create the window, using
certain defaults.  The defaults control amongst others the foreground
and background colours, the number of colour indices, the size and
location of the window. These defaults may be altered with an X-defaults
file, or a window created with the {\small GWM} {\bf xmake} command. See
SUN/130 for details of {\small GWM} and how to change your X-defaults
file. 

{\small GWM} also enables a single-colour overlay to be made, though
it halves the number of available colour indices.  If you want to
INSPECT or CONTOVER to use an X-windows overlay, you must ensure
that you have made the window with the {\bf -overlay} qualifier to
{\bf xmake}, or changed your X-defaults file.

The following set up is a reasonable compromise, as it maximises
the number of colour indices for the image-display window (xwindows),
has an overlay (xoverlay), and a line-graphics window (x2windows).
In the defaults file there are the following lines

\small
\begin{verbatim}
     Gwm*xwindows*colours:         80
     Gwm*xwindows*overlay:         True
     Gwm*xwindows*ovcolour:        Yellow
     Gwm*x2windows*colours:        20
\end{verbatim}
\normalsize

The following tells {\small KAPPA} that these are the current devices.

\small
\begin{verbatim}
     $ IDSET XWINDOWS
     $ GDSET X2WINDOWS
     $ OVSET XOVERLAY
\end{verbatim}
\normalsize
\bigskip

For an X-windows overlay, INSPECT in the cursor mode uses dashed lines
instead of colour, for example when indicating the position of a region
or slice.  Similarly for CONTOVER when pen rotation is selected.

\newpage
\section{Data structures}
\label{se:datastr}
In an ideal world you would not need to know how your data are stored.
It would be transparent. (The trendies call it object orientation.) 
However, for historical reasons there are numerous data formats in
Starlink software, and at the moment {\small KAPPA} is no exception in
that it has two formats. 

{\small KAPPA} is in a state of transition.  It is moving from the
historical and flawed IMAGE structure, to the official standard data
format for Starlink {\small ADAM} applications---the NDF (Extensible
$N$-dimensional Data Format).  Both formats, though, use HDS, and have
file extension {\tt .SDF}.  The NDF is more detailed and has been
carefully designed to facilitate processing by both general applications
like {\small KAPPA} and specialist packages.  It contains an
$n$-dimensional data array that can store most astronomical data such as
spectra, images and spectral-line data cubes. The NDF may also contain
information like a title, axis labels and units, error and quality
arrays.  There are also places in the NDF, called {\em extensions}, to
store any ancillary data associated with the data array, even other
NDFs.

The two formats and the meaning of their components are described in
Appendices~\ref{ap:NDFformat} and \ref{ap:IMAGEformat}.   Suffice to say
here that the IMAGE format is more or less a degenerate form of the NDF,
and so both formats can be used in parallel thoroughout {\small KAPPA};
those applications using the IMAGE format will have restricted
functionality, for example limited axis and quality processing, and an
inability to handle NDF sections (Section~\ref{se:ndfsect}).

Both formats permit arrays to seven dimensions, but some
applications only handle two-dimen\-sional data arrays and others just
one-dimensional data.  The data and variance arrays are not constrained
to a single data type. Valid types are the HDS numeric primitive types, see
Appendix~\ref{ap:HDStypes}.

Many applications are generic, that is they can work on all or some of
these data types directly.  This makes these applications faster, since
there is no need to make a copy of the data converted to the type
supported by the application.  If an application is not generic it only
processes {\_REAL} data.   Look in the {\tt Implementation Status} in
the help or the reference manual.  If none is given you can assume that
processing will occur in \_REAL.

In {\small KAPPA} the elements of the data array
are often called {\em pixels}, even if the NDF is not two dimensional.

You can look at a summary of the NDF or IMAGE structure using the
command NDFTRACE. {\small TRACE} (SUN/102) can be used to look at
array values and extensions.

\subsection{Bad pixels}
Bad pixels are flagged with the standard values (see Section~5 of
SUN/39), which for \_REAL is the most-negative value possible.
In the NDF applications, quality information is automatically
processed.  To control of the effect of the quality array use SETBB.
`Invalid' is a synonym for `bad' in some applications.

\newpage
\section{Graphics Database}
\label{se:agitate}
Have you ever faced the problem that you would like an application to know
about graphics drawn by some other programme?  For instance, you display an
image of the sky, then later you want to obtain the co-ordinates of the
stars within the image via the cursor.  There are two main approaches to
achieve this functionality. The first is to duplicate the display code in
the cursor application.  This is wasteful and inflexible.  The second is to
store information about {\em pictures\/} in a database that can be accessed
by graphics programmes.  A picture's position and extent are added to the
database immediately after the plot is created. Those of you who have used
{\small ASPIC} may be familiar with the ARGS database. Its basic concepts
are now incorporated in AGI ({\it c.f.}\ SUN/48), but AGI can store
information about plots on any graphics device.

AGI also stores a {\em name\/} and a {\em comment\/} for each picture. Optionally,
a {\em label\/} may be added. `Name' is something of a misnomer---`type'
would give a clearer indication of its purpose.  In the same way `label'
would have been called `name', but for the fact that `name' was in use.
Confused? Don't worry. It will become clear in a moment.

Currently, the name can take one of four values: {\tt 'BASE'} or {\tt
'FRAME'} or {\tt 'DATA'} or {\tt 'KEY'}. {\tt 'BASE'} is reserved for
the base picture; this is the picture that extends over the whole of the
plotting area. {\tt 'DATA'} indicates that the picture contains a
representation of data in a graphical form, {\it e.g.}\ a greyscale, an
histogram. {\tt 'KEY'} is used for keys---there's a surprise. {\tt
'FRAME'} usually contains a collection of data pictures. For instance in
a contour plot, the data picture is the area where contours may
potentially be drawn; whereas the frame picture comprises the annotated
axes and labels, the key, and data area. The comment is a one-line
description of the picture. At present in {\small KAPPA} the comment is
just {\tt 'KAPPA\_<application>'} where {\tt <application>} is the name
of the application that created the picture. However, in later versions
of {\small KAPPA} commentary will probably be under your control via a
parameter in each graphics application, and that defaults to the
application name as above.  What you can control now is the label. Label
is a name you assign to a picture for easy reference and selection.

All {\small KAPPA} graphics applications use AGI, where new plots are
being drawn or co-ordinates are required. The best way to demonstrate
{\small KAPPA} and AGI in harness is to give some illustrated examples.

\subsection{AGI and KAPPA in action}
Assuming that {\small KAPPA} is loaded and the graphics
device---an Ikon in the following examples---is available.
First of all we make the Ikon the current graphics device and image
display, and the Ikon overlay the image-display overlay (as described
in Section~\ref{se:selgradev}). These will remain in force until changed.
The following commands would not be necessary if the global parameters
already had these values.

\small
\begin{verbatim}
     ICL> GDSET IKON
     ICL> IDSET IKON
     ICL> OVSET IKON_OVERLAY
\end{verbatim}
\normalsize
Next we shall clear the Ikon, and purge the database of Ikon and
Ikon-overlay pictures.  Note it does not clear the overlay, just the
database entries, because AGI knows that the two graphics devices use
the same screen, but GKS does not.  The same applies to an ARGS and its
overlay.

\small
\begin{verbatim}
     ICL> GDCLEAR
\end{verbatim}
\normalsize

One picture remains in the database---the base---because AGI must
always have a current picture into which further plots are drawn.

Next we display a CCD frame scaled between defined limits.  (The file
used in this demonstration can be found in {\tt KAPPA\_DIR:CCDFRAMEC}).
Details of the displayed image are recorded in the graphics database, but
the current picture continues to be the base.  In other words the current
picture on input is the current picture on output.  This is standard
practice in {\small KAPPA}.  The only exceptions are applications that
manage the database rather than plotting data.\footnote{An uncontrolled
exit from an application, {\it e.g.}\ {\tt CTRL/Y} may leave the database
in an  abnormal state.} If this rule was not enacted pictures would become
progressively smaller vanishing into the distance, since new pictures
cannot be drawn outside the current picture.  DISPLAY, in keeping with
other graphics applications, does not write a label.  We'll see later
how to annotate a picture with a label.

\begin{figure}[hbt]
\caption{DISPLAYed CCD image as seen on the Ikon except that it is the
negative of what you would actually see.  This was done for clarity in
high-contrast reproduction.  Yes it {\em could\/} be worse!}
\label{fi:agi1}
\vspace{4.4in}
\end{figure}

\small
\begin{verbatim}
     ICL> DISPLAY KAPPA_DIR:CCDFRAMEC CENTRE=[390,300]
     MODE - Method to define scaling limits /'FLASH'/ > SC
     LOW - Low value for display /2250/ > 2300
     HIGH - High value for display /30790.99/ > 4700
\end{verbatim}
\normalsize
Unlike the earlier example where the image was plotted in the centre of the
screen, here it is shifted down and to the left (see Figure~{\ref{fi:agi1}).
{\tt CENTRE=[390,300]} means position the pixel (390,300) in the array
at the centre of the current picture. As you can see the pixel can lie
outside the bounds of the array. By default DISPLAY places the
central pixel at the centre of the current picture.  When the current
picture is the base, this location is therefore at the centre of the
screen as we have here.

To illustrate this point and introduce a new application we shall plot
the same data array in a picture at the top right of the screen
(Figure~\ref{fi:agi2}).
\begin{figure}[hbt]
\caption{CCD image DISPLAYed in the top-right quarter of the base picture.}
\label{fi:agi2}
\vspace{4.4in}
\end{figure}

\small
\begin{verbatim}
     ICL> PICDEF MODE=TR
     ICL> DISPLAY
     IN - NDF to be displayed /@KAPPA_DIR:CCDFRAMEC/ >
     MODE - Method to define scaling limits /'SCALE'/ >
     LOW - Low value for display /2250/ > 2300
     HIGH - High value for display /30790.99/ > 4700
\end{verbatim}
\normalsize
PICDEF creates a new frame picture in the database.  It is half the linear
size of the base picture. The picture is empty, but it still becomes the
new current picture. Therefore when DISPLAY comes along and puts the
image in the centre of the current picture it plots in the top-right
corner of the screen.  You will also notice that the magnification is
correspondingly reduced by a factor of two, from 1.55 to 0.775.  DISPLAY
has two parameters that control the $x$ and $y$ magnifications, but
these default to the give the largest magnification that displays the
image without clipping or distortion.  Now we can exceed the default
magnifications to produce an enlarged portion of the image
within the current picture.  Only the part of the magnified image that
is located within the current picture will be visible; there is no
spillage into other pictures (Figure~\ref{fi:agi3}).

\small
\begin{verbatim}
     ICL> DISPLAY XMAGN=2.5 YMAGN=2.5
     IN - NDF to be displayed /@KAPPA_DIR:CCDFRAMEC/ >
     MODE - Method to define scaling limits /'SCALE'/ >
     LOW - Low value for display /2250/ > 2300
     HIGH - High value for display /30790.99/ > 4700
\end{verbatim}
\normalsize
\begin{figure}[htb]
\caption{Magnified portion of the CCD image to the top right.}
\label{fi:agi3}
\vspace{4.4in}
\end{figure}
Before we plot any more pictures we can give the current picture---still
the frame created by PICDEF---a label.

\small
\begin{verbatim}
     ICL> PICLABEL ERIC
\end{verbatim}
\normalsize
If we move to or create a new current picture, and then want to return
to ERIC all we have to enter is

\small
\begin{verbatim}
     ICL> PICSEL ERIC
\end{verbatim}
\normalsize

The graphics database is not restricted to images.  To show this we shall
draw a contour plot in the bottom-right corner of the base picture.  The new
picture has the aspect ratio of the base picture.  Its dimension is
measured as a fraction of the linear size of the base picture, which is
controlled by the parameter {\tt FRACTION}. The current picture is not
cleared before plotting so you can see through the contour plot to the
galaxy image behind (Figure~\ref{fi:agi4}).  The {\tt NOOUTLINE}
prevents an outline from being drawn around the picture.

\small
\begin{verbatim}
     ICL> PICDEF MODE=BR FRACTION=0.65 NOOUTLINE
     ICL> TURBOCONT NOCLEAR LBOUND=[51,141] UBOUND=[250,330] PLTITL="AGI demonstration"
     IN - NDF to be contoured /@KAPPA_DIR:CCDFRAMEC/ >
     MODE - Method for selecting contour heights /'FREE'/ > AR
     NCONT - Give the number of contour heights /6/ > 5
     Contour heights used:
     2478.022,   2560,958,   2697.029,   3042.488,   4050.937.
\end{verbatim}
\normalsize
\begin{figure}[htb]
\caption{Contour plot added to bottom-right.}
\label{fi:agi4}
\vspace{4.4in}
\end{figure}
The PICDEF command can also be used to define new pictures with any
aspect ratio either by defining explicit limits ({\tt MODE=XY}) or
by using the cursor ({\tt MODE=CURSOR})---the default.  Also, you may
constrain the new picture to lie within the current picture with
parameter {\tt CURRENT}. In this case the fractional size and aspect ratio
relate to the current picture.

\small
\begin{verbatim}
     ICL> PICDEF CURRENT
     To select a point press the left button on the mouse or trackerball.
     To exit press the right button.
     Use the cursor to select 2 distinct points.
\end{verbatim}
\normalsize
If you try to select a point outside the current picture you will be told
and the cursor position is reset.

\small
\begin{verbatim}
     Point lies outside the allowed region.
     Co-ordinates are ( 0.5160462, 1.0269577E-02 ) and ( 0.8908858, 0.6046214 )
\end{verbatim}
\normalsize
Notice there is an outline of the region selected, as it is drawn
by default.

Now draw a greyscale plot and its key within the region.
The extent of the new current picture can be seen in silhouette against
the earlier pictures (Figure~\ref{fi:agi5}).

\small
\begin{verbatim}
     ICL> greyplot pltitl="AGI demonstration"
     IN - NDF to be displayed /@KAPPA_DIR:CCDFRAMEC/ >
     Dimensions are ( 319, 503 )
     KEY - Do you want a key of the grey levels and a title ? /TRUE/ >
     MODE - Method to define scaling limits /'SCALE'/ >
     BLACK - Value to be black in the plot? /30790.99/ > 4700
     WHITE - Value to be white in the plot? /2250/ > 2300
\end{verbatim}
\normalsize
\begin{figure}[ht]
\caption{Greyplot added within the region of contour picture defined by
PICDEF's cursor.}
\label{fi:agi5}
\vspace{4.4in}
\end{figure}
PICDEF has one further mode---Array.  This enables you to create an
$n\times m$ grid of new frame pictures.  It also has a mechanism for
labelling all the pictures, so you can easily switch between the
elements of the picture array.  You might use the following command in
an {\small ICL} procedure to display a series of up to twelve spectra.

\small
\begin{verbatim}
     ICL> PICDEF MODE=A PREFIX=SPEC XPIC=3 YPIC=4
\end{verbatim}
\normalsize
The bottom-left picture would be labelled SPEC1 and the rest are
numbered in sequence from left to right to SPEC12---the top-right
picture.  You'd call PICSEL to select each picture in turn via
the {\small ICL} SNAME function (see Section~\ref{se:ICLproc}).

You can see that montages of pictures can rapidly be built.
Occasionally, you will want some earlier picture to become the current
picture. As we've seen labelled picture can be recalled via PICSEL, but
not all pictures will be labelled, especially ones with named {\tt
'DATA'}, because of the rule that applications must not change the
current picture.  The alternative way to select a new current picture
is via the command CURSOR.  It displays a cursor. Move the cursor
to lie on top of the picture you require and hit the escape/exit button
(the right-hand one) on the mouse. Generally, this will be fine, but you can
have cases where one plot is still visible through a transparent plot drawn
subsequently. If the later picture extends entirely over the image you
require, CURSOR will not let you access it.  The moral is ``be careful when
arranging your pictures''. A picture may only be partially obscured, so by
moving the cursor around and hitting the left-hand button you can
often find a portion that is topmost.  CURSOR reports the name, comment
and the label (if it there is one) of the picture in which the cursor is
located to assist you. It is usually quite obvious where pictures begin
and end, so in practice it is easier than described here.  There is
another way of accessing `obscured' pictures---PICLIST.  Besides listing
all the pictures with a specified name for the current graphics device,
PICLIST offers a means of making any of the listed pictures the current
picture.

If you do get lost or forget what and where the current picture is,
the GDSTATE command will come to your rescue.  You can even plot an
outline with the OUTLINE keyword if you can't visualise the device
co-ordinates. The current picture does not have a label.  If it did
this too would be listed by GDSTATE.

\small
\begin{verbatim}
     ICL> GDSTATE
 
     Status of the IKON image_display graphics device...
        Physical device: IKON_DEFAULT
 
        The current picture is a FRAME picture.
        Comment: KAPPA_PICDEF
        World co-ordinates:
                    X = 0.5160462 to 0.8908858
                    Y = 1.0269577E-02 to 0.6046214
        Normalised device co-ordinates:
                    X = 0.3930821 to 0.6786044
                    Y = 7.822529E-03 to 0.4605515
 
\end{verbatim}
\normalsize

Let us select the first picture that we displayed (the image to the
bottom left).  Having done so we can then inspect some of the data
in that picture.  INSPECT looks for the topmost data picture within
the current picture.  This may be the current picture itself. Using
the database entries it knows the position and extent of the picture,
and so when you come to place the cursor on a point its pixel co-ordinates
can be evaluated.  Notice that AGI remembers the name of the source
data array and so you need not re-enter it here.  If you want to inspect
another NDF of the same dimensions you can override the NDF stored
in AGI by specifying the NDF you want on the command line.  Sometimes
you might obtain the wrong array; see Section~\ref{se:probpage} on what
to do.  In the example below a slice through the CCD frame is plotted on
the overlay plane (Figure~\ref{fi:agi6}).

\begin{figure}[htb]
\caption{A slice through the image drawn on the overlay plane.}
\label{fi:agi6}
\vspace{4.4in}
\end{figure}

\small
\begin{verbatim}
     ICL> cursor
     To select a point press the left button on the mouse or trackerball.
     To exit press the right button.
      X = 183.4733, Y = 264.575 in KAPPA_DISPLAY ( DATA )
     ICL> inspect
     Current picture has name: DATA, comment: KAPPA_DISPLAY
     Using DISK$STAR:[KAPPA]CCDFRAMEC as the input NDF.
     GDEVICE - Graphics device is to be used for line plots /@ikon/ > ikon_overlay
     OPTION - Option required /'Region'/ > SL
     Co-ordinates are ( 150, 175 ) and ( 211, 318 )
     Type the null character, !, if the slice is not to be saved.
     SLNAME - Name of file to save slice /@SLICE/ > !
     OPTION - Option required /'Region'/ > E
\end{verbatim}
\normalsize
A word of warning about the device for GDEVICE.  Don't use the base
plane of the image display, in this case {\tt IKON}.  Otherwise
your underlying images will be erased when a line plot is drawn.
The current-graphics-device scheme breaks down here.  Both
options: no default or occasionally a harmful default,
are undesirable.  Anyway you've been warned!

Using the same picture we can now demonstrate the contour-overlay
application, CONTOVER.  The data array we have employed so far is
smoothed with GAUSS; a subset is obtained from it (omitting the first
ten columns and twenty lines) by PICK2D; and then all values outside a circle
centred at pixel (160,230), radius 70 pixels are set to zero via OUTSET
to make {\tt \mbox{CCDCIRCLE.SDF}}. See Figure~\ref{fi:agi7}.  The plot is made
to the current overlay device defined by OVSET, namely {\tt
IKON\_OVERLAY}. Currently, only pixel offsets may be used, but
eventually complicated transformations will be possible, say for
overlaying a radio map on the infra-red image of a source.
Note that CONTOVER reports the name of the NDF used for the underlying
image, so if for some reason it is not the one you intended, just abort
({\tt !!}) at the prompt for parameter OFFSET.  (You can check what
the reference object will be via the PICIN command.)

\begin{figure}[htb]
\caption{Contour overlay of a different data array on top of the original CCD
image.}
\label{fi:agi7}
\vspace{4.4in}
\end{figure}

\small
\begin{verbatim}
     ICL> contover
     NDF - Image to be contoured /@KAPPA_DIR:CCDFRAMEC/ > ccdcircle
     Current picture has name: DATA, comment: KAPPA_DISPLAY
        Reference data object: DISK$STAR:[KAPPA]CCDFRAMEC.
     OFFSET - x-y displacement in pixels /0,0/ > 10 20
     MODE - Method for selecting contour heights /'Free'/ >
     HEIGHTS - Give the heights of the contours > [2400,2500,2650,2900,3300,3900]
\end{verbatim}
\normalsize

Application CURSOR has a dual role. It also provides a means of
determining the co-ordinates of points in pictures selected with the
cursor. Again only the topmost picture at a given cursor location is
accessible.  Each time the left-hand button is pressed the co-ordinates
of the position in the topmost picture at that point is presented.
This is the dynamic mode ({\tt 'DYNAMIC'}).  The other options let you
obtain co-ordinates in the reference frames of the current picture
({\tt 'CURRENT'}) or anchored ({\tt 'ANCHOR'}) to the picture at the first
cursor position selected.

\small
\begin{verbatim}
     ICL> CURSOR
     To select a point press the left button on the mouse or trackerball.
     To exit press the right button.
      X = 245.6915, Y = 400.4704 in KAPPA_GREYPLOT ( DATA )
      X = 0.8398062, Y = 1.04369 in KAPPA_GREYPLOT ( FRAME )
      X = 239.562, Y = 279.4127 in KAPPA_CONTOUR ( DATA )
      X = 241.1404, Y = 298.2021
      X = 255.3456, Y = 293.2284
      X = 153.5614, Y = 236.91 in KAPPA_DISPLAY ( DATA ), label = ERIC.
      X = 3.2948352E-02, Y = 0.5845106 in KAPPA_CONTOUR ( FRAME )
      X = 0.5291266, Y = 1.805826 in KAPPA_GREYPLOT ( FRAME )
      X = 0.7304244, Y = 0.9760387 in KAPPA_CONTOUR ( FRAME )
      X = -7.8452587E-02, Y = 0.838221 in KAPPA_CONTOUR ( KEY )
      X = 0.7147477, Y = 0.5338036
      X = 0.7361856, Y = 0.5252284
\end{verbatim}
\normalsize
If you don't want to affect the graphics database, but still obtain
co-ordinates of features in an image, try the {\tt XYcur} option in
INSPECT.  It also marks the points selected. 

The contents of the graphics database are ephemeral.  Therefore you
should regularly purge the database entries via GDCLEAR (or optionally
via IDCLEAR for the current image display), and delete the database file
{\tt ADAM\_USER:AGI\_<node>.SDF}, where you substitute your system's
node name for {\tt <node>}), {\it e.g.}\ {\tt ADAM\_USER:AGI\_RLSTAR.SDF}.
A new database is created when you run an AGI application if none
exists.  AGI will purge the database for a device if the graph window
has changed size, or if you switch between portrait and landscape
formats for a printer device. 

\section{Co-ordinate Systems}
\label{se:co-ordsystem}

{\small KAPPA} uses a number of co-ordinate systems; this section
describes them, and how to select one.  NDFTRACE reports the bounds
of an NDF in these various co-ordinate systems. 

\subsection{Pixel Indices}

The elements in an NDF's array can be addressed by their
$n$-dimensional integer pixel indices.  The first or {\em origin\/}
pixel in an NDF need not have pixel index equal to one in each
dimension, though it usually will.  An NDF can have an arbitrary
origin.  By adjusting the origins of NDFs with SETORIGIN you may
combine the NDFs differently.  For example, ADD adds two NDFs where
they overlap. The overlap is defined in terms of pixel indices. 
Thus only those pixels with the same pixel index in both NDFs will
be added.  The resultant NDF is the addition in the intersection of
the two input NDFs. 

If you wish to select rectangular sections of pixels within an NDF
indices are fine and precise.  Since they are integer quantities,
these indices cannot represent a continuous co-ordinate system,
although the information stored in an NDF will almost always require
that positions within it be describable to sub-pixel accuracy.  For
example, when CENTROID determines the position of a star in a
2-dimensional image it will inevitably give rise to a non-integer
result, for which a continuous ($x$-$y$) co-ordinate system is required.

\subsection{Pixel Co-ordinates}
\label{se:pixelco-ordinates}

There are a number of ways in which a continuous co-ordinate system
can be defined for a regular array of pixels. In the absence of
other information, the Starlink convention is to use a {\em pixel
co-ordinate system\/} in which a pixel with indices ($i,j$) has its
centre at the position

\begin{quote}
\begin{center}
($i-\frac{1}{2},j-\frac{1}{2}$)
\end{center}
\end{quote}

and is taken to be one unit in extent in each dimension.
Pixel (1,1) would therefore be centred at the position (0.5,0.5) and would
have its `lower' and `upper' corners located at positions (0.0,0.0) and
(1.0,1.0) respectively, as follows

\begin{quote}
\begin{center}

\setlength{\unitlength}{1.0mm}
\begin{picture}(15,25)(0,-7.5)

\thicklines
\put(0,0){\line(1,0){10}}
\put(10,0){\line(0,1){10}}
\put(10,10){\line(-1,0){10}}
\put(0,10){\line(0,-1){10}}
\put(5,5){\circle*{0.7}}

\thinlines
\put(0,-4){\vector(0,1){3}}
\put(0,-5){\makebox(0,0)[tr]{(0.0,0.0)}}
\put(10,14){\vector(0,-1){3}}
\put(10,15){(1.0,1.0)}
\put(14,5){\vector(-1,0){8}}
\put(15,5){\makebox(0,0)[l]{(0.5,0.5)}}

\end{picture}
\end{center}
\end{quote}

This makes it possible to refer to fractional pixel positions---in
this case within a 2-dimensional array, although the principle can
obviously be extended to other numbers of dimensions. 

\subsection{Data Co-ordinates}
\label{se:dataco-ordinates}

The pixel co-ordinate system described above defines how to convert pixel
indices into a set of continuous co-ordinates and therefore introduces a
co-ordinate {\em axis\/} which runs along each dimension of the NDF, as
follows

\begin{quote}
\begin{center}

\setlength{\unitlength}{0.65mm}
\begin{picture}(70,57)(-10,-7)

\multiput(10,10)(0,3){11}{\line(1,0){45}}
\multiput(10,10)(3,0){16}{\line(0,1){30}}
\put(32.5,43){\makebox(0,0)[b]{\scriptsize NDF Pixel Array}}

\thicklines
\put(0,0){\vector(1,0){60}}
\put(25,-5){\bf Axis 1}
\put(0,0){\vector(0,1){45}}
\put(0,48){\makebox(0,0)[b]{\bf Axis 2}}

\end{picture}
\end{center}
\end{quote}

The use of the pixel size to determine the units of these axes is rather
restrictive, however, and in practice we may want to use more realistic
physical units. This would allow a spectrum to be calibrated in
wavelength, for instance, or the output from a plate-measuring machine
to be related to axes calibrated in microns.   In {\small KAPPA}
these are called {\em Data\/} co-ordinates.

The NDF's {\em axis\/} components are designed to hold the extra information
needed to define more useful co-ordinate systems, so that realistic axes can
be associated with a NDF, along with {\em labels\/} and {\em units\/} for
these axes.

\subsection{Selecting a Co-ordinate System}
The pixel co-ordinate system is the default choice, and although it is
intended to be used only in the absence of other information,
{\small KAPPA} offers you a choice of co-ordinate system, even if
your NDF has physical co-ordinates in its axis centres.

There is a global parameter---the current co-ordinate system---that
may be {\tt WORLD} or {\tt DATA}.  It is set by a parameter called
COSYS in each application that processes data co-ordinates. For
instance,

\small
\begin{verbatim}
     $ DISPLAY COSYS=W AXES \
     $ CENTROID
\end{verbatim}
\normalsize
makes the axes about the displayed image and the centroid positions in
the following task appear in pixel co-ordinates, regardless of whether
there are axes present or not.

Conversely,

\small
\begin{verbatim}
     $ DISPLAY COSYS=D AXES \
     $ CENTROID
\end{verbatim}
\normalsize
makes the axes about the displayed image and the centroid positions
appear in data co-ordinates, {\em provided there are axes present.}
Of course, the axes may just have a pixel co-ordinate system.

If the global parameter is undefined, applications will adopt 
a suitable default, depending on the application.  All default to
{\tt "Data"} except CENTROID, PSF, and ZAPLIN.

As we discovered earlier, when you draw a plot or an image, the
graphics database records the co-ordinate extents of the picture.
What was not said explicitly was which co-ordinate system.  Looking
at the output from GDSTATE and CURSOR shows that the database
deals in world co-ordinates.
Graphics packages like GKS require co-ordinates to be linear
and increase from left to right and bottom to top.  This is
not necessarily the case for physical axes.  So are we going
to lose our co-ordinate system between applications?  No\ldots
well almost certainly not.
{\small KAPPA} strives to find a linear transformation between
your data co-ordinates and pixel co-ordinates, or a logarithmic
one in some cases.  If it succeeds the transformation is stored
in the database.  Thus if you plot a spectrum with wavelength
along the abscissa, you can then use CURSOR to identify lines.

\small
\begin{verbatim}
     $ LINPLOT ADAM_EXAMPLES:SPECTRUM COSYS=D \
     $ CURSOR
     Type a 1 or a space to select a point.
     Type . to exit.
     X=3934.254, Y=196.118 in KAPPA_LINPLOT( DATA )
     X=3969.148, Y=196.118 in KAPPA_LINPLOT( DATA )
\end{verbatim}
\normalsize
The $x$ co-ordinates are the wavelengths in {\AA}ngstroms of the Calcium
II H and K lines.

If the global parameter is undefined you will be prompted for
a co-ordinate as required.

\section{Interaction Mode}
\label{se:interaction}
We have seen the different co-ordinate systems {\small KAPPA} uses.
Now we address how the applications obtain co-ordinate information
itself.  Applications that require co-ordinates are being modified to
permit a variety of mechanisms for obtaining those
co-ordinates.\footnote{Those converted so far are CENTROID, INSPECT and
ZAPLIN.} The possibilities are as follows.
\begin{description}
\item [Cursor] --- This mode utilises the cursor of the current graphics
device.  For this to work the array must already be displayed as an
image, or a contour plot, or line plot (provided the application handles
1-dimensional data), and the picture is stored in the graphics database.
\item [Interface] --- This mode obtains co-ordinates from
the parameter system, usually in response to prompting.
\item [File] --- In this mode the application reads an ASCII file
containing a list of co-ordinates in free format, one object per record.
There may be commentary lines in the file beginning with {\tt \#} or
{\tt !}.  The format and syntax of the files are {\it ad hoc}, and are
described in the application documentation.\footnote{A standard and
far-more powerful syntax for defining co-ordinates and regions within
arrays has been designed.}
\end{description}

Applications that permit these options have a parameter, called
MODE, by which you can control how positional data are to be acquired.
It would be tedious to have to specify a mode for each application,
therefore {\small KAPPA} has a global parameter---the interaction
mode---to which each applications's interaction-mode parameter is
defaulted.  The global value remains in force until you change it by
assigning an application's interaction mode on the command line.
The following examples shows the effect of the global parameter.
For compactness GLOBALS will merely show the interaction mode.

First we display an image on the Ikon.

\small
\begin{verbatim}
     ICL> gdset ikon
     ICL> idset ikon
     ICL> display kappa_dir:ccdframec mode=pe \
     Data will be scaled from 2366.001 to 2614.864.
     ICL> globals
     The current interaction mode is      : <undefined>
\end{verbatim}
\normalsize
Now we obtain the centroids of a couple of stellar/galaxian images via
each of the interaction modes.  First in cursor mode.  Note that
CENTROID obtains the name of the input NDF from the graphics database
in this mode.  If you need to preview which NDF is going to be selected
use the PICIN command.

\small
\begin{verbatim}
     ICL> centroid mode=c
     Current picture has name: DATA, comment: KAPPA_DISPLAY.
     Using DISK$STAR:[KAPPA]CCDFRAMEC as the input NDF.
     
     To select a point press the left button on the mouse or trackerball.
     To exit press the right button.
     Use the cursor to select one point.
 
     Input guess position was     86.23534, 295.0848
     Output centroid position is  86.41057, 295.1141
 
     Use the cursor to select one point.
 
     Input guess position was     73.32529, 318.9757
     Output centroid position is  72.76437, 318.9484
 
     Use the cursor to select one point.
\end{verbatim}
\normalsize
If we look at the global parameters again, indeed we see that it has
become cursor mode.  To show that it is global we can run INSPECT.
Yes a cursor appears rather than a prompt for the pixel value.

\small
\begin{verbatim}
     ICL> globals
     The current interaction mode is      : CURSOR
     ICL> inspect
     Current picture has name: DATA, comment: KAPPA_DISPLAY.
     Using DISK$STAR:[KAPPA]CCDFRAMEC as the input NDF.
     GDEVICE - Graphics device to be used for line plots /@ikonov/ >
     OPTION - Option required /'Region'/ > VA
 
        VALUE of image at 59, 294 is 2753.928
       
        VALUE of image at 149, 311 is 3727.465
 
     OPTION - Option required /'Region'/ > ex
\end{verbatim}
\normalsize
Now we'll see the effect of changing the mode parameter. Note that
unless it is undefined or the application does not support the current
mode, you must change the mode on the command line.  First we shall
prompt for the co-ordinates.  A null ends the loop.

\small
\begin{verbatim}
     ICL> centroid mode=i
     NDF - Array to be analysed /@disk$star:[kappa]ccdframec/ >
     INIT - Guess at co-ordinates of star-like feature /108.8,403.5/ > 86,295

     Input guess position was     86, 295
     Output centroid position is  86.41057, 295.1141
     
     INIT - Guess at co-ordinates of star-like feature /86,295/ > 73.3,319
 
     Input guess position was     73.3, 319
     Output centroid position is  72.76437, 318.9484
 
     INIT - Guess at co-ordinates of star-like feature /73.3,319/ > !
\end{verbatim}
\normalsize
Finally, we can create an ASCII file called {\tt STARLIST.DAT} and run
CENTROID in file mode.  

\small
\begin{verbatim}
     ICL> $ ed starlist.dat
     Creating DCL subprocess
     86 295
     73 320
     ICL> centroid mode=f
     COIN - File of initial positions /@CENTROID.LIS/ > starlist
     NDF - Array to be analysed /@kappa_dir:ccdframec/ >
 
     Input guess position was     86, 295
     Output centroid position is  86.41057, 295.1141
 
     Input guess position was     73, 320
     Output centroid position is  72.76437, 318.9484
\end{verbatim}
\normalsize
Such co-ordinate files can also be created interactively with images by
CURSOR or the XYcur mode of INSPECT.

\section{NDF Sections}
\label{se:ndfsect} 

You will frequently want to examine or process only a portion of your
dataset, be it to focus on a given object in an image, or a single
spectrum between nominated wavelengths, or a plane of a cube. You could
use MANIC or PICK2D in some circumstances to make a new NDF containing
the required data, but this would be inconvenient as you will need more
disc space, and to invent and remember a new filename. In addition,
these particular applications currently do not fully support the NDF,
and so you could lose axis information, for example.  You will be
pleased to learn that there is a succinct and powerful alternative that
obviates the need to create a new file---the NDF section.  The
application just processes a `rectangular' subset, or section, of the
NDF that you nominate.  Certainly, it requires you to learn a little
syntax, but after you use it a few times it will seem cheap at the price
for the advantages it offers.  Please note however, that sections cannot
be given to an IMAGE-format application. 

An NDF section is defined by specifying the bounds of the portion of
the NDF to be processed immediately following the name of the NDF.
You can do this in any place where an NDF name alone would suffice,
for example, on the command line or in response to a prompt or as a
default in an interface file.  The syntax is a series of subscripts
within parentheses and may be given in several ways. Here is a simple
example. 

\small
\begin{verbatim}
     $ STATS CLUSTER(101:200,51:150)
\end{verbatim}
\normalsize

This would derive statistics of a 100$\times$100-pixel region starting
at pixel indices (101,51) in the NDF called CLUSTER.  Alternatively,
ranges of axis co-ordinates may be given instead of pixel indices.
Besides giving lower and upper bounds as above, you may specify
a centre and extent.  Sections are not limited to subsets---supersets
are allowed.  See the paragraphs below for more details of these
features.

If you {\em do} want to make a new NDF from a portion of an existing one,
you should use the command NDFCOPY.  An NDF's shape may be changed
{\it in situ\/} by SETBOUND.

\subsection{Specifying Lower and Upper Bounds}

The subscript expression appended to an NDF name to specify a section
may be given in several ways. One possible method (corresponding with
the example above) is to give the lower and upper bounds in each
dimension, as follows

\small
\begin{quote}
\begin{center}
{\tt NAME( a:b, c:d, ... )}
\end{center}
\end{quote}
\normalsize

where `{\tt a:b}', `{\tt c:d}', ({\it etc.}) specify the lower and upper
bounds. The bounds specified need not necessarily lie within the actual
bounds of the NDF, because {\em bad\/} pixels will be supplied in the
usual way, if required, to pad out the NDF's array components whenever
they are accessed. However, none of the lower bounds should exceed the
corresponding upper bound. 

Omitting any of the bounds from the subscript expression will cause the
appropriate (lower or upper) bound of the NDF to be used instead. If you
also omit the separating `:', then the lower and upper bounds of the
section will both be set to the same value, so that a single pixel will
be selected for that dimension. Omitting the bounds entirely for a
dimension (but still retaining the comma) will cause the entire extent
of that dimension to be used. Thus, 

\small
\begin{quote}
\begin{center}
{\tt IMAGE(,64)}
\end{center}
\end{quote}
\normalsize

could be used to specify row 64 of a 2-dimensional image, while

\small
\begin{quote}
\begin{center}
{\tt CUBE( 1, 257:, 100 )}
\end{center}
\end{quote}
\normalsize

would specify column 1, pixels 257 onwards, selected from plane number
100 of a 3-dimensional `data cube', forming a one-dimensional section.

\subsection{Specifying Centre and Extent}

An alternative form for the subscript expression involves specifying the
centre and extent of the region required along each dimension, as
follows

\small
\begin{quote}
\begin{center}
{\tt NAME( p}$\sim${\tt q, r}$\sim${\tt s, ... )}
\end{center}
\end{quote}
\normalsize

where `{\tt p}$\sim${\tt q}', `{\tt r}$\sim${\tt s}', ({\it etc.})
specify the centre and extent. Thus, 

\small
\begin{quote}
\begin{center}
{\tt NAME(100}$\sim${\tt 11,200}$\sim${\tt 5)}
\end{center}
\end{quote}
\normalsize

would refer to an 11$\times$5-pixel region of an image centred on pixel
(100,~200).

If the value before the delimiting `$\sim$' is omitted, it will default
to the index of the central pixel in that dimension (rounded downwards
if there are an even number of pixels). If the value following the
`$\sim$' is omitted, it will default to the number of pixels in that
dimension. Thus, 

\small
\begin{quote}
\begin{center}
{\tt IMAGE( }$\sim${\tt 100, }$\sim${\tt 100)}
\end{center}
\end{quote}
\normalsize

could be used to refer to a 100$\times$100-pixel region located
centrally within an image, while 

\small
\begin{quote}
\begin{center}
{\tt IMAGE( 10}$\sim${\tt , 20}$\sim$ {\tt )}
\end{center}
\end{quote}
\normalsize

would specify a section which is the same size as the original image, but
displaced so that it is centred on pixel (10,~20).

\subsection{Using Axis Co-ordinates to Specify Sections}
\label{se:axissections}

A further variation is that numerical values in subscript expressions
may be specified either as integers, in which case they refer to pixel
indices, or as floating-point numbers,\footnote{Here, a floating-point
number is one containing a decimal point and/or an exponent. Double
precision arithmetic is used to process these values, but either double-
or single-precision notation may be used when supplying them.} in which
case they refer to {\em axis\/} (or {\em data}) co-ordinates (for a
description of {\em data\/} co-ordinates, see
Section~\ref{se:dataco-ordinates}). Both linear and non-linear {\em
axis\/} co-ordinates are supported, the values supplied being
automatically converted into the corresponding pixel indices before use.
For instance

\small
\begin{quote}
\begin{center}
{\tt SPECTRUM(6500.0:7250.0)}
\end{center}
\end{quote}
\normalsize

could be used to select the appropriate region of a spectrum calibrated
in {\AA}ngstroms, while

\small
\begin{quote}
\begin{center}
{\tt SPECTRUM(6000.0}$\sim${\tt 500.0)}
\end{center}
\end{quote}
\normalsize

would select a region of the spectrum approximately from 5750 to 
6250.0~{\AA}ngstroms (the exact extent depending the values of the
axis co-ordinates), and

\small
\begin{quote}
\begin{center}
{\tt SPECTRUM(5500.0}$\sim${\tt 21)}
\end{center}
\end{quote}
\normalsize

would select a 21-pixel-wide region of the spectrum centred on
5500~{\AA}ngstroms.

Command NDFTRACE will show whether or not an NDF has axis co-ordinates, and 
if so, it reports their extents.

\subsection{Changing Dimensionality}

The number of dimensions given when specifying an NDF section need not
necessarily correspond with the actual number of NDF dimensions,
although usually it will do so. 

If you specify fewer dimensions than there are NDF dimensions, then
any unspecified bounds will be set to (1:1) for the purposes of
identifying the pixels to which the section should refer. Conversely, if
extra dimensions are given, then the shape of the NDF will be padded
with extra bounds set to (1:1) in order to match the number of
dimensions. In all cases, the resulting section will have the number of
dimensions you have actually specified, the padding serving only to
identify the pixels to which the section should refer. 

In {\small KAPPA} there are a number of applications that can only
handle a fixed number of dimensions ({\it e.g.}\ DISPLAY, LINPLOT).
NDF sections permit such applications to have wider applicability
since they can operate on full NDFs of arbitrary dimensionality.

\subsection{Mixing Bounds Expressions}

In the last example (in Section~\ref{se:axissections}) both {\em axis\/}
co-ordinates and pixel indices were mixed in the same subscript
expression. In fact, any of the features described earlier may be
combined when specifying an NDF section, the only restriction being that
when the shape of the resulting section is expressed in pixel indices,
the lower bound must not exceed the upper bound in any dimension. Thus,
all the following might be used as valid specifications for NDF
sections 

\small
\begin{quote}
\begin{center}
\begin{tabular}{l}
{\tt NDF(3.7)}\\
{\tt NDF(,5:)}\\
{\tt NDF(-77:13.8,,4)}\\
{\tt NDF(66}$\sim${\tt 9,4:17)}\\
{\tt NDF(}$\sim${\tt 5,6}$\sim${\tt )}\\
{\tt NDF(}$\sim${\tt ,:)}\\
{\tt NDF(5500.0}$\sim${\tt 150,)}\\
{\tt NDF(3.0}$\sim${\tt 1.5,-78.06D-3:13.0545,,,,)}\\
\end{tabular}
\end{center}
\end{quote}
\normalsize

Many other combinations are obviously possible.

\section{Image-display Interface in KAPPA}

{\small KAPPA} has started to utilise IDI (Image-display Interface) for
interactions with images.  However, GKS is still called to display
images. IDI is much faster for some interactions, such as manipulating
the colour table, and provides functionality that is excluded from GKS,
such as pan and zoom.

So far the only implementations available are for the Digisolve Ikon and
X-windows.  The latter uses the GWM (SUN/130) window manager so that IDI
and GKS applications can share a window.  There is little likelihood of
an ARGS implementation appearing, since the ARGS is now thoroughly
obsolete.  For convenience two applications that are hardwired for both
Ikon and ARGS (IDRESET and IDPAN) are retained.  IDRESET is needed in
addition to the {\small ASPIC} routine because it also purges the
graphics database. 

Not all IDI functionality is available in the Starlink implementations. 
Some of these are apparent when comparing certain {\small KAPPA}
applications run on X-windows as opposed to the Ikon.  For instance,
there is no blinking capability on X-windows.  IDUNZOOM is ineffective,
since once a window is panned and/or zoomed, the original data are lost
due to a limitation of the Graphics Window Manager.  The same applies if
you run IDINVISIBLE; IDVISIBLE is unable to restore the window.  This is
actually not serious since images cannot be displayed on the X-windows
overlay.  You will probably want IDINVISIBLE to erase only the overlay
plane of an X-window.

\section{Image-Display Colour Table and Palette}
\label{se:coltab}
An image display has a colour table\footnote{Sometimes called the
video lookup table.} which converts integer values
in the display's memory into the colours that you see on the monitor.
There are usually somewhere between 64 and 256 entries or {\em indices\/}
in the colour table that are numbered consecutively increasing from 0.
For example, if there were 256 colour indices then you would be able
display 256 different colours simultaneously; and when you display an
image your data values would be scaled to map onto the integer range of
the colour indices, 0--255.

In many systems the full colour table is used.  This has the
disadvantage that if you want to annotate images with captions or axes,
plot coloured borders about images, plot graphs {\it etc.}\, yet
simultaneously display
images with certain colour tables, there may be conflict of interests.
For instance, a linear greyscale colour table's first few colour indices
will be almost black.  By default, these same indices, particularly
index 1, are used by GKS/SGS for line graphics, thus
any plots will be invisible.  If you reset colour index 1 to white, the
appearance of your image alters.   Whenever you alter the colour table
to enhance the look of your image, it will affect the line graphics.

To circumvent this dilemma, {\small KAPPA} reserves a portion of the
colour table, called the {\em palette}, that is
unaffected by changes to the rest of the colour table. It is shown
schematically below.  The palette contain 16 indices.  $N$ is the total
number of indices.  In {\small KAPPA} the remainder of colour indices
is called the {\em colour table}.

\begin{center}
\begin{picture}(136,28)
% Thick outline.
\thicklines

% Draw the palette outline.  0.3 fudge to make lines match!
\put(2,15){\framebox(32,7.7){}}

% Draw the colour-table outline broken with dots to indicate an
% arbitrary length and so three frameboxes cannot be drawn.
\put(34,15){\line(1,0){50}}
\put(34,23){\line(1,0){50}}
\multiput(84.8,15)(2,0){4}{{\huge .}}
\multiput(84.8,22.4)(2,0){4}{{\huge .}}
\put(94,15){\line(1,0){40}}
\put(94,23){\line(1,0){40}}
\put(134,15){\line(0,1){8}}

% Switch to thin lines to mark the individual colour indices.
\thinlines

% Mark the colour indices as vertical lines.
\multiput(4,15)(2,0){15}{\line(0,1){8}}
\multiput(36,15)(2,0){25}{\line(0,1){8}}
\multiput(94,15)(2,0){20}{\line(0,1){8}}

% Label the colour indices.
\put(2,24){0}
\put(30,24){15}
\put(34,24){16}
\put(131,24){$N\!\!-\!\!1$}

% Make braces to indicate the two parts.
\put(18,10){\makebox(0,0)[c]{$\underbrace{\rule{31mm}{0mm}}$}}
\put(84,10){\makebox(0,0)[c]{$\underbrace{\rule{99mm}{0mm}}$}}

% Write the captions
\put(2,4){\makebox[32mm][c]{{\large Palette}}}
\put(34,4){\makebox[100mm][c]{{\large Colour Table}}}
\end{picture}
\end{center}

\subsection{Lookup Tables}
In order to distinguish between the set of colours in the physical image
display (the colour table) and some external table of colours, the latter
is called a {\em lookup table}. Lookup tables comprise a series of
red, green and blue (RGB) intensities, each normalised to 1.0; they may
be stored in NDFs---indeed some are provided with {\small KAPPA}---or
be coded within applications.

A lookup table may be transferred into the display's colour table.
However, the number of indices in the colour table is usually not the
same as the number of colours in the lookup table and so a simple
substitution is not possible.  Therefore, {\small KAPPA} squeezes
or stretches the lookup table to make it fit in the available number of
colour-table indices.  Normally, linear interpolation between adjacent
lookup-table entries defines the resultant colour, though you can select
a nearest-neighbour algorithm.  The latter is suited to lookup tables
with sharp boundaries between contrasting colours, {\it e.g.}\ a series of
coloured blocks, and the former to smoothly varying lookup tables where
there are no obvious discontinuities, {\it e.g.}\ spectrum-like.

Let's have a few examples.

\small
\begin{verbatim}
     $ LUTHEAT
     $ LUTRAMPS
     $ LUTREAD PASTEL
     $ LUTABLE LI EX SAWTOOTH NN
     $ LUTSAVE PIRATED
\end{verbatim}
\normalsize
LUTHEAT loads the standard `heat' lookup table into the colour table
using linear interpolation, whilst LUTRAMPS loads the standard
coloured ramps using the nearest neighbours in the lookup table.
LUTREAD reads the lookup table stored in the DATA\_ARRAY of the NDF
called PASTEL and maps it onto the colour table via linear interpolation.
In the fourth example the lookup table in NDF SAWTOOTH is mapped onto the
colour table via a linear nearest-neighbour method. {\tt EX} tells
LUTABLE to read an external file.  In the final example LUTSAVE saves
the current colour table into a lookup table NDF.  LUTSAVE is quite
useful as you can steal other people's attractive colour tables that
they've carelessly left in the display's memory! It does not matter
should the display not have a palette, since

\small
\begin{verbatim}
     ICL> LUTSAVE PIRATED FULL
\end{verbatim}
\normalsize
will save the full set of colour indices to the NDF.

\subsection{Manipulating Colour Tables}
{\small KAPPA} provides a number of commands for adjusting a colour
table.  LUTFLIP, LUTHILITE, LUTROT, LUTTWEAK are all IDI-based. Remember
that only the colour table will be flipped; highlighted; rotated; stretched,
or squashed, and/or have its origin moved.
Thus during flipping, colour index 16 will swap with $N-1$, 17
with $N-2$ {\it etc.}\ TWEAK is slow and clunky because the inherent
device-independence and generality of GKS, which it calls, prevents it
from taking full advantage of the capabilities of the hardware. However,
TWEAK does have the advantage of working on VWS windows and ARGS
devices.  CRELUT uses an enlarged palette to modify a lookup table.

\subsection{Creating Lookup Tables}
You can start from scratch via CRELUT, or make an ASCII file of the
RGB intensities and use TRANDAT to create the NDF, or manipulate the colour
table and then save it in a lookup-table NDF.  If you choose the second
option remember that all RGB intensities must lie in the range 0.0--1.0,
where 1.0 is the maximum intensity; and that equal red, green, and
blue intensities yields a shade of grey.
So for example if you want a six equal blocks of red, blue, yellow,
pink, sienna and turquoise you could create the ASCII file {\tt COL6.DAT}
with contents

\small
\begin{verbatim}
     # Red, blue, yellow, pink, sienna, and turquoise LUT
     1.0 0.0 0.0
     0.0 0.0 1.0
     1.0 1.0 0.0
     0.9 0.56 0.56
     0.56 0.42 0.14
     0.68 0.92 0.92
\end{verbatim}
\normalsize
and then run TRANDAT to make the NDF called COLLUT6.

\small
\begin{verbatim}
     $ TRANDAT COL6 COLLUT6 AUTO
\end{verbatim}
\normalsize

CRELUT has a number of stages that cannot be expressed via the
examples in the reference manual, so here is a walk through with
commentary.  It would be a good idea to find an image display and
repeat the example yourself. CRELUT asks for an initial lookup table.
Since we don't have one we enter {\tt !}; this results in a greyscale
being loaded in the colour table.  Next we nominate an image for which
we want to tailor the lookup table.  In order to display it and to
compute an histogram we must also provide scaling limits. The chosen
limits encompass most data values.

\small
\begin{verbatim}
     ICL> crelut
     INLUT - NDF containing input lookup table /@KAPPA_DIR:SPECTRUM_LUT/ > !
     NDF - Image to be displayed /@KAPPA_DIR:CCDFRAMEC/ >
     LOW - Low value for image scaling /2250/ >
     HIGH - High value for image scaling /30790.990234375/ > 3000
\end{verbatim}
\normalsize
The image appears in grey above the histogram of values between 2250 and
3000.  Notice that the histogram shows the appearance of data values
given along the data-value axis, currently just grey intensities.  Had
we entered {\tt !} to parameter NDF, a ramp would appear rather than the
histogram. Below the histogram are two rows of 16 enumerated colours and
grey levels.  The bottom line is the standard palette, as would be given
by command PALDEF, and an adjustable upper line. To manipulate the
colour table (and hence generate a new lookup table) we select palette
colours and data-value ranges.  First we want to add some colours of our
own to the palette.

We first add a named colour, sienna, to the palette, followed by a pale
yellow given as RGB intensities.  We try Violetred, but don't like it
so the previous grey value is restored.  Orchid is paler than Violetred
and more like what we want.  A null ends the loop.  Note that once you
have completed this section you cannot add more colours to the palette.
The current RGB is given so minor adjustments can be made.  Also you
don't have to add palette colours in numerical order.

\small
\begin{verbatim}
     Now you may add to the predefined palette. Numbers 16 to 31, are available.
     Type ! to complete the modifications.
     PALNUM - Number of the palette entry to be modified /16/ >
     The current RGB is 0,0,0.
     COLOUR - New palette colour > sienna
     OK - Accept this colour (Y/N)? /NO/ > y
     PALNUM - Number of the palette entry to be modified /17/ >
     The current RGB is 6.666667E-02,6.666667E-02,6.666667E-02.
     COLOUR - New palette colour > 1.0,1.0,0.3
     OK - Accept this colour (Y/N)? /NO/ > y
     PALNUM - Number of the palette entry to be modified /18/ >
     The current RGB is 0.1333333,0.1333333,0.1333333.
     COLOUR - New palette colour > violetred
     OK - Accept this colour (Y/N)? /NO/ >
     PALNUM - Number of the palette entry to be modified /18/ >
     The current RGB is 0.1333333,0.1333333,0.1333333.
     OUR - New palette colour > orchid
     OK - Accept this colour (Y/N)? /NO/ > y
     PALNUM - Number of the palette entry to be modified /19/ > !
\end{verbatim}
\normalsize
Now we change the colour table.  Notice the appearance of the histogram
alters.  Between 2300 and 2380 the colour smoothly varies from blue to
orchid. (We tried a narrower range but did not like it.)  Next a
block of sienna represents values in the range 2375--2400.  Notice that
the order of the colours matters, {\it c.f.}\ the 2500--2600 range
where 2500 appears pale yellow and 2600 is red.  A null ends the
manipulation.

\small
\begin{verbatim}
     Now you may interactively change the lookup table (LUT). You give ranges of
     data values (that map to LUT pens) to be assigned colours obtained
     by interpolation of pairs of numbered colours selected from the palette.
     Type ! to complete the creation of the LUT.

     VALRANGE - Data-value range to be assigned colours > 2300,2350
     COLRANGE - Select one or two colours from the palette > 4,18

     VALRANGE - Data-value range to be assigned colours > 2300,2380
     COLRANGE - Select one or two colours from the palette > 4,18
 
     VALRANGE - Data-value range to be assigned colours > 2375,2400
     COLRANGE - Select one or two colours from the palette > 16
 
     VALRANGE - Data-value range to be assigned colours > 2900,3000
     COLRANGE - Select one or two colours from the palette > 6
 
     VALRANGE - Data-value range to be assigned colours > 2500,2600
     COLRANGE - Select one or two colours from the palette > 17,2
 
     VALRANGE - Data-value range to be assigned colours > !
\end{verbatim}
\normalsize
Finally, we save the lookup table in an NDF called YUK, but not the palette.
The original palette is restored.

\small
\begin{verbatim}
     Type the null character, !, if the created LUT is not to be saved.
     OUTLUT - NDF to save the lookup table > YUK
     OUTPAL - NDF to save the palette /!/ >
\end{verbatim}
\normalsize

\subsection{Palette}
There are four commands for controlling the palette, all beginning
PAL. If you inherit the image display after a non-{\small KAPPA}
user or after a device reset, you will probably have to reset the
palette.  You can do this either by loading the default palette---black,
white, the primary then secondary colours, and eight equally spaced
grey levels---with the command PALDEF; or load a palette you've created
yourself via PALREAD.  You modify the palette by changing individual
colours within it using PALENTRY. The colour specification can be a
named colour (see Appendix~\ref{ap:colset} for a list), or RGB
intensities. For example,

\small
\begin{verbatim}
     $ PALE 1 Skyblue
     $ PALE 14 [1.0,1.0,0.3]
\end{verbatim}
\normalsize
would make palette index 1 sky blue and index 14 a pale yellow.  Once
you have a palette you like, save it in an NDF with PALSAVE.  IDSTATE
reports the current palette colours by name, picking the nearest named
colour from the standard colour set given in Appendix~\ref{ap:colset}.

The palette has limited {\em direct\/} use in {\small KAPPA} so far, but
it is expected to grow as more applications support different colouring of
the components of a plot.  One example, is in DISPLAY where you can
have a coloured border for effect (as seen on television news programmes).
The colour of the border is selected from the palette or the nearest
colour in the palette is used.

Indirectly, the appearance of existing plots may be changed.  Palette
entry 0 is the background colour, and entries 1--5 correspond to SGS pens
or PGPLOT colour indices of the same number.  By choosing a palette
colour equal to the background colour, features may be `erased'.

Note that the X-windows overlay only has one colour, and so do not have
a palette.

\section{Getting Data into KAPPA}
{\small KAPPA} utilises general data structures within an HDS container
file, type {\tt .SDF}. In the examples so far, processing was performed
on data in this format generated from within {\small KAPPA}. Generally,
you will already have data in formats other than that used by {\small
KAPPA}, particularly in the Interim BDF and Figaro DST formats. To convert
a BDF or a DST to an SDF for {\small KAPPA} run the utilities {\small
BDF2NDF} or {\small DST2NDF} respectively in the {\small CONVERT}
package ({\it c.f.}~SUN/55).\footnote{STARIN (SUN/96) will be removed
from the SSC once {\small KAPPA} is NDF compliant.} There is also
TRANDAT, which will read an ASCII file of data values, or co-ordinates
and data values into an NDF.  There is also ASCIN in the {\small 
SPECDRE} package (SUN/140).  You may have a FITS tape or disc file.
FITSIN will read, amongst others, simple FITS files including blocked or
group format and floating-point data from tape.  FITSDIN is its
counterpart for disc files.

Let's see the FITS readers in action.  First we mount the tape foreign
in the normal way.  We ask for the second file on the tape, and the
headers are displayed so we can decide whether this is the file we
want.  It is so we supply a name of an NDF to receive the FITS file.
If it wasn't we would enter {\tt !} to the OUT prompt.  The FMTCNV
parameter asks whether the data are to be converted to \_REAL,
using the FITS keywords BSCALE and BZERO, if present.  If you are
wondering why there is {\tt (1)} after the file number, that's present
because FITS files can have sub-files, stored as FITS extensions.

\small
\begin{verbatim}
     $ MOUNT/FOR MUC0:
     $ FITSIN
     MT - Tape deck /@muc0/ >
     The tape is currently positioned at file 1.
     FILES - Give a list of the numbers of the files to be processed > 2
     File # 2(1)  Descriptors follow:
     SIMPLE  =                    T
     BITPIX  =                   16
     NAXIS   =                    2
     NAXIS1  =                  400
     NAXIS2  =                  590
     DATE    = '03/07/88'                    /Date tape file created
     ORIGIN  = 'ING     '                    /Tape writing institution
     OBSERVER= 'CL      '                    /Name of the Observer
     TELESCOP= 'JKT     '                    /Name of the Telescope
     INSTRUME= 'AGBX    '                    /Instrument configuration
     OBJECT  = 'SYS:ARCCL.002'               /Name of the Object
     BSCALE  =                  1.0          /Multiplier for pixel values
     BZERO   =                  0.0          /Offset for pixel values
     BUNIT   = 'ADU     '                    /Physical units of data array
     BLANK   =                    0          /Value indicating undefined pixel
                 :                :                :
                 :                :                :
                 :                :                :
     END
     FMTCNV - Convert data? /NO/ >
     OUT - Output image > ff1
     Completed processing of tape file 2 to ff1.
     MORE - Any more files? /NO/ >
\end{verbatim}\
\normalsize
We can trace the structure to reveal the 2-byte integer CCD image.

\small
\begin{verbatim}
     $ trace ff1
     FF1  <NDF>
 
        DATA_ARRAY(400,590)  <_WORD>   216,204,220,221,202,222,220,206,218,221,
                                       ... 216,218,218,204,221,218,219,222,221,218
        TITLE          <_CHAR*13>      'SYS:ARCCL.002'
        UNITS          <_CHAR*3>       'ADU'
        MORE           <EXT>           {structure}
           FITS(84)       <_CHAR*80>      'SIMPLE  =                    T','BI...'
                                          ... '   ...','         ING PACKEND','END'
   
     End of Trace.
\end{verbatim}
\normalsize
If you have many FITS files to read there is a quick method for
extracting all files or a selection.  In automatic mode the output files
are generated without manual intervention and the headers aren't reported
for efficiency.  Should you want to see the headers, write them to an ASCII
file via the LOGFILE parameter. The cost of automation is a restriction
on the names of the output files, but if you have over a hundred files
on a tape are you really going to name them individually?

\small
\begin{verbatim}
     $ fitsin auto
     MT - Tape deck /@muc0/ >
     FMTCNV - Convert data? /NO/ > y
     PREFIX - Prefix for the NDF file names? /'FITS'/ > JKT
     FILES - Give a list of the numbers of the files to be processed > [4-6,8]
     Completed processing of tape file 4 to JKT4.
     Completed processing of tape file 5 to JKT5.
     Completed processing of tape file 6 to JKT6.
     Completed processing of tape file 8 to JKT8.
     MORE - Any more files? /NO/ >
\end{verbatim}
\normalsize
Officially, there is no such thing as disc FITS.  However, for a number
of years {\it ad hoc}\ implementations have existed.  FITSDIN will
handle files with fixed-length records, and semi-arbitrary length.  So
files mangled during network transfer, which have 512-byte records
rather than the customary 2880, may be read.  FITSDIN will accept
a list of files with wild cards. In the example a floating-point
file is read (BITPIX=$-$32) and so FMTCNV is not required.

\small
\begin{verbatim}
     ICL> fitsdin *.fits

        2 files to be processed...
 
     Processing file number 1: DISK$SCRATCH:[MJC]GR.FITS;2.
     File # DISK$SCRATCH:[MJC]GR.FITS;2(1)  Descriptors follow:
     SIMPLE  =                    T / Standard FITS format
     BITPIX  =                  -32 / No. of bits per pixel
     NAXIS   =                    2 / No. of axes in image
     NAXIS1  =                  512 / No. of pixels
     NAXIS2  =                  256 / No. of pixels
     EXTEND  =                    T / FITS extension may be present
     BLOCKED =                    T / FITS file may be blocked
     
     BUNIT   = 'none given      '   / Units of data values
     
     CRPIX1  =   1.000000000000E+00 / Reference pixel
     CRVAL1  =   0.000000000000E+00 / Coordinate at reference pixel
     CDELT1  =   1.000000000000E+00 / Coordinate increment per pixel
     CTYPE1  = '                '   / Units of coordinate
     CRPIX2  =   1.000000000000E+00 / Reference pixel
     CRVAL2  =   0.000000000000E+00 / Coordinate at reference pixel
     CDELT2  =   1.000000000000E+00 / Coordinate increment per pixel
     CTYPE2  = '                '   / Units of coordinate
 
     ORIGIN  = 'ESO-MIDAS'          / Written by MIDAS
     OBJECT  = 'artificial image'   / MIDAS desc.: IDENT(1)
             :                :                :
             :                :                :
             :                :                :
     HISTORY  ESO-DESCRIPTORS END     ................
     
     END
     OUT - Output image > GR
     Completed processing of disk file DISK$SCRATCH:[MJC]GR.FITS;2 to GR.
     File has illegal-length blocks (512). Blocks should be a multiple (1--10) of the
     FITS record length of 2880 bytes.
     Processing file number 2: DISK$SCRATCH:[MJC]INDEF.FITS;1.
     File # DISK$SCRATCH:[CUR.KAPPA.SCRATCH]INDEF.FITS;1(1)  Descriptors follow:
     SIMPLE  =                    T  /  FITS STANDARD
     BITPIX  =                   32  /  FITS BITS/PIXEL
     NAXIS   =                    2  /  NUMBER OF AXES
     NAXIS1  =                  256  /
     NAXIS2  =                   20  /
     BSCALE  =      3.7252940008E28  /  REAL = TAPE*BSCALE + BZERO
     BZERO   =      7.9999999471E37  /
     OBJECT  = 'JUNK[1/1]'  /
     ORIGIN  = 'KPNO-IRAF'  /
             :                :                :
             :                :                :
             :                :                :
     END
     OUT - Output image > IRAF
     Completed processing of disk file DISK$SCRATCH:[MJC]INDEF.FITS;1 to IRAF.
\end{verbatim}
\normalsize
NDFTRACE shows that the object name is written to the NDF's
title, that axes derived from the FITS headers are present,
and that GR is a \_REAL NDF.

\small
\begin{verbatim}
     ICL> ndftrace gr
 
        NDF structure DISK$SCRATCH:[MJC]GR:
           Title:  artificial image
           Units:  none given
 
        Shape:
           No. of dimensions:  2
           Dimension size(s):  512 x 256
           Pixel bounds     :  1:512, 1:256
           Total pixels     :  131072
 
        Axes:
           Axis 1:
              Label : Axis 1
              Units : pixel
              Extent: -0.5 to 511.5
 
           Axis 2:
              Label : Axis 2
              Units : pixel
              Extent: -0.5 to 255.5
 
        Data Component:
           Type        :  _REAL
           Storage form:  PRIMITIVE
           Bad pixels may be present
 
        Extensions:
              FITS             <_CHAR*80>
 
\end{verbatim}
\normalsize
Both FITSIN and FITSDIN write the FITS headers into a FITS extension
within your NDF.  The extension is a literal copy of all the 80-character
`card images' in order. These can be inspected or written to a file via
the command FITSLIST.  Ancillary data within the FITS extension may
be extracted from the character format into numeric data objects in
other extensions via FITSIMP.  FITSIMP will even handle hierarchical
keywords and those much-loved ING packets from La Palma.

\section{Procedures}
Applications from {\small KAPPA} and other packages can be combined
in procedures to customise and automate data processing. In addition to
giving literal values to application parameters, you can include {\small
ICL} variables or {\small DCL} symbols on the command line, whose values
are substituted at run time. In addition from {\small ICL} it possible to
write parameter data into variables and hence pass them to another
application. Since {\small DCL} is familiar and well documented,
here we shall concentrate on {\small ICL}.

\subsection{ICL}
\label{se:ICLproc}
You should consult the {\sl ICL Users' Guide} for details about writing
{\small ICL} syntax, procedures, and functions, but you're a busy
researcher\ldots  For a quick overview the {\em two-page\/} summary on
``Writing ICL command files and procedures'' in SUN/101 is recommended
reading. Here we'll just show some example procedures that can be
adapted and cover points not mentioned in SUN/101.

Let's start with something simple.  You want to `flash' a series of
images, each with a yellow border.  First you write the following
procedure called FLASH.  It has one argument INPIC, that passes the name of
the NDF you want to display.  When you substitute an {\small ICL}
variable for a parameter value you enclose it in parentheses.  The lines
beginning with {\tt \{ } are comments.

\small
\begin{verbatim}
     PROC FLASH INPIC
     {
     { Procedure for displaying an image without scaling and a yellow border.
     {
        DISPLAY IN=(INPIC) MODE=FL BORDER BCOLOUR=Yellow
     END PROC
\end{verbatim}
\normalsize
To make {\small ICL} recognise your procedure you must `load' it.  The
command

\small
\begin{verbatim}
     ICL> LOAD FLASH
\end{verbatim}
\normalsize
will load the file {\tt FLASH.ICL}.
Thereafter in the {\small ICL} session you can invoke FLASH for many
NDFs. The following will display the NDFs called GORDON and FLOOD
side-by-side.

\small
\begin{verbatim}
     ICL> PICDEF MODE=A PREFIX=F XPIC=2 YPIC=1
     ICL> FLASH GORDON
     ICL> PICSEL F2
     ICL> FLASH FLOOD
\end{verbatim}
\normalsize
It would be tedious to have to load lots of individual procedures, but
you don't. If you have related procedures that you regularly require
they can be concatenated into a single file which you load.  Better
still is to add definitions for each of the procedures in your
{\small ICL} login file.
Suppose you have three procedures: FLASH, PICGREY in file
{\tt MY\_DIR:DISPLAY_PROC.ICL}, and FILTER in {\tt MY\_DIR:IMPROC.ICL}.
In your {\tt LOGIN.ICL} you could add the following

\small
\begin{verbatim}
     defproc  flash     my_dir:display_proc.icl
     defproc  sfilt     my_dir:improc.icl filter
     defproc  picgr(ey) my_dir:display_proc.icl
\end{verbatim}
\normalsize
which defines three commands that will be available each time you
use {\small ICL}: FLASH which will run your FLASH
procedure, PICGREY to execute the PICGREY procedure, and SFILT which
runs the FILTER procedure.  In addition PICGREY can be abbreviated
to PICGR or PICGRE.  So now you can load and run your procedure.
Let's have some more example procedures.

Suppose you have a series of commands to run on a number of files.  You
could create a procedure to perform all the stages of the processing,
deleting the intermediate files that it creates.

\small
\begin{verbatim}
     PROC UNSHARPMASK NDFIN CLIP NDFOUT

     { Clip the image to remove the cores of stars and galaxies above
     { a nominated threshold.
        THRESH (NDFIN) TMP1 THRHI=(CLIP) NEWHI=(CLIP) \

     { Apply a couple of block smoothings with boxsizes of 5 and 13
     { pixels.  Delete the temporary files as we go along.
        BLOCK TMP1 TMP2 BOX=5
        $ DELETE TMP1.SDF;0
        BLOCK TMP2 TMP3 BOX=13
        $ DELETE TMP2.SDF;0

     { Multiply the smoothed image by a scalar.
        CMULT TMP3 0.8 TMP4
        $ DELETE TMP3.SDF;0

     { Subtract the smoothed and renormalised image from the input image.
     { The effect is highlight the fine detail, but still retain some of
     { low-frequency features.
        SUB (NDFIN) TMP4 (NDFOUT)
        $ DELETE TMP4.SDF;0
     END PROC
\end{verbatim}
\normalsize
A common use of procedures is likely to be duplicate processing
for several files.  Here is an example procedure that does that.  It uses
some intrinsic functions which look just like Fortran.

\small
\begin{verbatim}
     PROC MULTISTAT

     { Prompt for the number of NDFs to analyse.  Ensure that it is positive.
        INPUTI Number of frames:  (NUM)
        NUM = MAX( 1, NUM )

     { Find the number of characters required to format the number as
     { a string using a couple of ICL functions.
        NC = INT( LOG10( I ) ) + 1

     { Loop NUM times.
        LOOP FOR I=1 TO (NUM)

     { Generate the name of the NDF to be analysed via the ICL function
     { SNAME.
          FILE = '@' & SNAME('REDX',I,NC)

     { Form the statistics of the image.
          STATS NDF=(FILE)
        END LOOP
     END PROC
\end{verbatim}
\normalsize
If NUM is set to 10, the above procedure obtains the statistics of the
images named REDX1, REDX2, \dots REDX10. The {\small
ICL} variable FILE is in parentheses because its value is to be
substituted into parameter NDF. There is a piece of syntax to note which
often catches people out. Filenames passed via {\small ICL} variables,
such as FILE in the above example, must be preceded by an {\tt @}.

Here is another example, which could be used to flat field a series of
CCD frames.  Instead of executing a specific number of files, the
user can enter an arbitrary sequence of NDFs.  When processing is
completed a !! is entered rather than an NDF name, and that exits the
loop.  Note the {\tt \~{}} continuation character. (It's not
required but it's included for pedagogical reasons.)
\pagebreak[3]

\small
\begin{verbatim}
     PROC FLATFIELD

     { Obtain the name of the flat-field NDF.  If it does not have a
     { leading @ insert one.
        INPUT "Which flat field frame?: " (FF)
        IF SUBSTR( FF, 1, 1 ) <> '@'
           FF = '@' & (FF)
        END IF

     { Loop until there are no further NDFs to flat field.
        MOREDATA = TRUE
        LOOP WHILE MOREDATA

     { Obtain the frame to flat field.  Assume that it will not have
     { an @ prefix. Generate a title for the flattened frame.
           INPUT "Enter frame to flat field (!! to exit): " (IMAGE)
           MOREDATA = IMAGE <> '!!'
           IF MOREDATA
              TITLE = 'Flat field of ' & (IMAGE)
              IMAGE = '@' & (IMAGE)

     { Generate the name of the flattened NDF.
              IMAGEOUT = (IMAGE) & 'F'
              PRINT Writing to (IMAGEOUT) 

     { Divide the image by the flat field.
              DIV IN1=(IMAGE) IN2=(FF) OUT=(IMAGEOUT) ~
                TITLE= (TITLE)
           ENDIF
        END LOOP
     END PROC
\end{verbatim}
\normalsize
Some {\small KAPPA} applications, particularly the statistical ones,
produce output parameters which can be passed between applications via
{\small ICL} variables. Here is an example to draw a
perspective histogram centred about a star in a nominated data array
from only the star's approximate position. The region about the star is
stored in an output NDF file. Note in a procedure meant to be used in
earnest there would be checks that input and output names begin with an
{\tt @}.

\small
\begin{verbatim}
     PROC COLSTAR FILE,X,Y,SIZE,OUTFILE

     {+
     {  Arguments:
     {     FILE = FILENAME (Given)
     {        Input NDF containing one or more star images.
     {     X = REAL (Given)
     {        The approximate x position of the star.
     {     Y = REAL (Given)
     {        The approximate y position of the star.
     {     SIZE = REAL (Given)
     {        The half-width of the region about the star's centroid to be
     {        plotted and saved in the output file.
     {     OUTFILE = FILENAME (Given)
     {        Output primitive NDF of 2*%SIZE+1 pixels square (unless
     {        constrained by the size of the data array or because the location
     {        of the star is near an edge of the data array.
     {-

     { Search for the star in a 21x21 pixel box.  The centroid of the
     { star is stored in the ICL variables XC and YC.
        CENTROID NDF=(FILE) XINIT=(X) YINIT=(Y) XCEN=(XC) YCEN=(YC) ~
          MODE=INTERFACE SEARCH=21 MAXSHIFT=14

     { Convert the co-ordinates to pixel indices.
        IX = NINT( XC + 0.5 )
        IY = NINT( YC + 0.5 )

     { Find the upper and lower bounds of the data array to plot. Note
     { this assumes no origin information in stored in the data file.
        XL = MAX( 1, IX - SIZE )
        YL = MAX( 1, IY - SIZE )
        XU = MAX( 1, IX + SIZE )
        YU = MAX( 1, IY + SIZE )

     { Create a new IMAGE file centred on the star.

        PICK2D INPIC=(FILE) OUTPIC=(OUTFILE) XSTART=(XL) YSTART=(YL) ~
           XFINISH=(XU) YFINISH=(YU)

     { Draw a perspective histogram around the star on the current
     { graphics device.
        COLUMNAR NDF=(OUTFILE)

     { Exit if an error occurred, such as not being to find a star
     { near the supplied position, or being unable to make the plot.
        EXCEPTION ADAMERR
           PRINT Unable to find or plot the star.
        END EXCEPTION
     END PROC
\end{verbatim}
\normalsize

Here is another that creates a fancy display of an image with axes and
a key showing data values.  Note the need to give an expression
combining the $x$-$y$ bounds of the key to the LBOUND and UBOUND
parameter arrays.

\small
\begin{verbatim}
     PROC FANCYLOOK NDF

     { Clear the current window.
        GDCLEAR CURRENT

     { Set the background and annotation colours.
        PALENTRY 0 Sienna
        PALENTRY 1 Yellow

     { Find the extent of the current picture and aspect ratio.
        GDSTATE NCX1=(FX1) NCX2=(FX2) NCY1=(FY1) NCY2=(FY2) NOREPORT
        ASP = ( FX2 - FX1 ) / ( FY2 - FY1 )

     { Display the image with axes using the most-ornate fount.
        DISPLAY (NDF) MODE=PE AXES FONT=NCAR COSYS=D SCALOW=(LOW) SCAHIGH=(HIGH) \

     { Find the extent of the image picture.
        PICIN NCX1=(DX1) NCX2=(DX2) NCY1=(DY1) NCY2=(DY2) NOREPORT

     { Determine the widths of the borders.
        XL = DX1 - FX1
        XR = FX2 - DX2
        YB = DY1 - FY1
        YT = FY2 - DY2

     { Only plot a key if there is room. 
        IF MAX( XL, XR, YB, YT ) > 0.0

     { Determine which side has most room for the key, and derive the
     { the location of the key. First, see if the key is vertical.
           IF MAX( XL, XR ) >= MAX( YB, YT )
              WIDTH = MIN( 0.25 * MAX( XL, XR ), 0.2 * ( DX2 - DX1 ) )
              HEIGHT = MIN( 8.0 * WIDTH, 0.7 * ( DY2 - DY1 ) * ASP )

     { Allow more room to the left for the ordinate-axis labelling.
              IF XL > XR
                 XK1 = DX1 - 2.3 * WIDTH
                 XK2 = DX1 - 1.3 * WIDTH
              ELSE
                 XK1 = DX2 + 0.5 * WIDTH
                 XK2 = DX2 + 1.5 * WIDTH
              ENDIF
              YK1 = 0.5 * ASP * ( DY2 + DY1 ) - 0.5 * HEIGHT
              YK2 = YK1 + HEIGHT
           ELSE

      { Deal with horizontal key.
              WIDTH = MIN( 0.3 * MAX( YB, YT ), 0.9 * ( DY2 - DY1 ) * ASP )
              HEIGHT = MIN( 8.0 * WIDTH, 0.7 * ( DX2 - DX1 ) )
              IF YB > YT
                 YK1 = DY1 - 1.2 * WIDTH
                 YK2 = DY1 - 0.2 * WIDTH
              ELSE
                 YK1 = DY2 + 0.2 * WIDTH
                 YK2 = DY2 + 1.2 * WIDTH
              ENDIF
              XK1 = 0.5 * ( DX2 + DX1 - HEIGHT )
              XK2 = XK1 + HEIGHT
           ENDIF

     { Draw the key to fit within the current picture annotating with 
     { the scaling used in DISPLAY.
           LUTVIEW LOW=(LOW) HIGH=(HIGH) LBOUND=[ (XK1&','&YK1)] ~
             UBOUND=[ (XK2&','&YK2)] MODE=XY
        ENDIF
     END PROC
\end{verbatim}
\normalsize

\subsection{DCL}
The VMS document {\sl Guide to Using Command Procedures} explains
how to write {\small DCL} procedures in some detail and has many
examples. Here the only matter to elucidate is how to use symbols with
{\small KAPPA} applications.  The answer is ``business as usual''.  Thus
in a procedure you might have the following fragment to evaluate
the effect of block averaging on the NDF called {\tt TEST}.  Created are
four NDFs---{\tt SMOOTH3}, {\tt SMOOTH5}, {\tt SMOOTH7}, and
{\tt SMOOTH9}---that are versions of {\tt TEST} following smoothing with
boxsizes of 3, 5, 7, and 9 pixels respectively.  Each smoothed NDF
is displayed.  Notice the single quotes which tell {\small DCL} to
substitute the value of the symbol.

\small
\begin{verbatim}
     $ BOX = 3
     $ PREFIX = "SMOOTH"
     $ LOOP:
     $    OUTFILE = 'PREFIX''BOX'
     $    BLOCK TEST 'OUTFILE' 'BOX'
     $    DISPLAY 'OUTFILE' \
     $    INQUIRE CONTLOOP "Ready to continue?"
     $    BOX = BOX + 2
     $    IF BOX .LT. 10 GOTO LOOP
     $!
     $ END:
\end{verbatim}
\normalsize
Be careful when dealing with strings that have spaces, which must be in
quotes with an additional leading apostrophe, otherwise the second and
subsequent words may be treated as positional parameters.  This is
normal {\small DCL} syntax for symbol substitution within strings.  For
example,

\small
\begin{verbatim}
     $ CAPTION = "WFPC PSF"
     $ HIDE ABERRATION PLTITL="''CAPTION'"
\end{verbatim}
\normalsize
will draw a hidden-line plot of the NDF called {\tt ABERRATION} with the
title {\tt "WFPC PSF"}.

\section{Problems Problems}
\label{se:probpage}
\subsection{Errors}
A detailed list of error codes and their meanings is not available.
{\small KAPPA} produces descriptive contextual error messages, which are
usually straightforward to comprehend.  Some of these originate in
the underlying infrastructure software, though there are still some
of systems yet to do that.  These are being corrected, and so
imprecise error reports should soon be a thing of the past. Error
messages from {\small KAPPA} begin with the name of the application reporting
the error. The routine may have detected the error, or it has
something to say about the context of the error. 

The remainer of the section describes some difficulties you may encounter
and how to overcome them.  Please suggest additions to this compilation.

\subsection{ICL KAPPA fails to load}
If it takes more than a minute to load {\small KAPPA}
it is likely that for some reason {\small KAPPA} will not load.
Unfortunately, after a couple of minutes you just receive a ``failed
to load'' error message, but it does not say why.  This problem
is usually because you
don't have sufficient disk or process quotas.  To determine the error
you need to run KAPPA from {\small DCL} thus

\small
\begin{verbatim}
     $ RUN KAPPA_DIR:KAPPA
\end{verbatim}
\normalsize
which will quickly elicit a more-revealing error most of the time.
Rarely, you see ``Requested action name is not defined'' when doing
this.  This means that {\small KAPPA} has loaded but it cannot find
a command to run. In effect you are just under some quota that
gets exceeded when you run {\small ICL} as well.

\subsection{Unable to Obtain Work space}
Error messages like ``Unable to create a work array'' may puzzle you.
They are accompanied by additional error messages that usually pinpoint
the reason for the failure of the application to complete.
Many applications require temporary or work space to
perform their calculations.  This space is stored in an HDS file within
directory HDS\_SCRATCH and most likely is charged to your disk quota.
(If you have not redefined this logical name, this will point to your
current directory.)
So one cause for the message is insufficient disk quota available to
store the work space container file or to extend it.  A second reason
for the message is that your computer cannot provide sufficient
virtual memory to map the workspace.  In this case you can try to
persuade your local system manager to increase your username's paging
file quota, and if necessary, the system parameter VIRTUALPAGECNT, which
must be at least as large as the paging file quota.
If you cannot accommodate your large datasets this way,
you should fragment your data array, and process the pieces separately.
After receiving this error message in an {\small ICL} session you may need
to delete the scratch file by hand.  The file is called {\tt
Txxxxxxxx.SDF}, where {\tt xxxxxxxx} is your process identifier.
A normal exit from {\small ICL} will delete the work-space
container file.  If you redefine HDS\_SCRATCH to a scratch area it
must have the /JOB qualifier, {\it e.g.}\

\small
\begin{verbatim}
     $ DEFINE/JOB HDS_SCRATCH DISK$SCRATCH:[JRL]
\end{verbatim}
\normalsize
when using the {\small KAPPA} monolith.

From {\small DCL} a process logical name is adequate, and the scratch
file should be deleted after each application completes.

\subsection{Application automatically picks up the wrong NDF}
Some applications read the name of the NDF used to create a plot or
image from the graphics database in order to save typing.  Once in a
while you'll say ``that's not the one I wanted''.  This is because AGI finds
the last {\tt 'DATA'} picture situated within the current picture.
Abort the application via {\tt !!}, then use CURSOR or PICLIST to select
the required {\tt 'FRAME'} picture enclosing the {\tt 'DATA'} picture,
or even select the latter directly.  You can override the AGI NDF also
by specifying the required NDF on the command line, provided it has
pixels whose indices lies within the world co-ordinates of the {\tt
'DATA'} picture.  Thus

\small
\begin{verbatim}
     $ INSPECT MYNDF
\end{verbatim}
\normalsize
will inspect the NDF called MYNDF.  The command PICIN will
show the last DATA picture and its associated NDF.

\subsection{Unable to Store a Picture in the Graphics Database}
You may receive an error message, which says failed to store
such-and-such picture in the graphics database.  For some reason the
database was corrupted due to reasons external to {\small KAPPA}.  Don't
worry, usually your plot will have appeared, and to fix the problem run
GDCLEAR/IDCLEAR or delete the database file ({\tt AGI_USER:AGI_<node>.SDF},
where you substitute your system's node name for {\tt <node>}).
You will need to redraw the last plot if you still require it, say for
interaction.

\subsection{Line graphics are Invisible on an Image Display}
The reason for invisible line graphics on your image display
is because it is drawn in black or a dark grey.  Most likely is that
some person has been using other software on your image display or that
is has been reset.  PALDEF will set up the default colours for the
palette, and so most line graphics will then appear in white. 
Alternatively,

\small
\begin{verbatim}
     $ PALENTRY 1 WHITE
\end{verbatim}
\normalsize
will normally suffice.

\subsection{Store for Dynamic Defaults is Full}
If you receive this error message when running the {\small KAPPA} monolith
from {\small ICL} you will have to kill the {\small KAPPA} process as
follows

\small
\begin{verbatim}
     ICL> KILL KAPPA_DIR:KAPPA
\end{verbatim}
\normalsize
{\small KAPPA} will be loaded again once you enter a {\small KAPPA}
command.  This problem occurs because {\small KAPPA} is big and can
exceed some of the parameter-system buffers if you run many
applications.  This will be fixed in a future release of {\small ADAM}. 

\subsection{Error Obtaining a Locator to a Slice of an HDS array}
If the above error appears from DAT\_SLICE and you are (re)prompted
for an NDF, the most likely cause is that you have asked an IMAGE
application to process an NDF section.  Use NDFCOPY to make a
subset before running the application in question, or process the
whole NDF.

\section{Custom KAPPA}
\label{se:custom}

KAPPA applications can be modified to suit your particular requirements.
Since this document is not a programmer's guide, instructions are not
given here.  Programmers should contact the author for details until a
Programmer's Guide appears, though SUN/101 is a good summary of
{\small ADAM} libraries and programming.

All the source files can be found in KAPPA\_DIR.  These include
source and interface-file text libraries:
\begin{description}
\item [KAPPA.TLB] --- The application source.
\item [KAPGEN.TLB] --- The general subroutine source.
\item [KAPSUB.TLB] --- The specific subroutine source.
\item [KAPPA\_IFL.TLB] --- The interface-file source.
\end{description}
    
The building procedures situated in KAPPA\_BUILD\_DIR perform the
following tasks:
\begin{description}
\item [KAPPADEV.COM] --- Sets up necessary symbols and logical
names needed for building KAPPA.  It should be activated first.
\item [MAKE\_KAPPA\_ATASKS.COM] --- Builds one or all individual KAPPA
applications for DCL, including the interface file.
\item [MAKE\_KAPPA.COM]  --- Makes the monolith for ICL usage.
\item [MAKE\_KAPPA\_IFL.COM] --- Makes the monolith interface file.
\end{description}

An experienced {\small ADAM} programmer should be able modify {\small
KAPPA} without additional documentation. 

If you want to use {\small KAPPA} subroutines for your own application
here are words of warning: {\em the code is likely to undergo major
alterations for Version 1.0, {\em e.g.}\ subroutine names and argument
lists}.  One tailoring option is to create a single modified
application, or A-task.

If you don't like {\small KAPPA}'s parameter defaults, or its choice of
what parameters get prompted and what get defaulted, then you can copy
the interface file ({\tt KAPPA\_DIR:KAPPA.IFL}) to your work directory
and make the required modifications, and then recompile it.  Then when
you run {\small KAPPA} from that directory, your version of the
interface file is accessed, and not the released one.  Of course, once
you have done this the documentation in Appendix~\ref{ap:full} will no
longer be correct.  See SUN/115 on the meanings and possible values of
the fieldnames, and how to recompile the interface file. 

There is an easier method of tailoring {\small KAPPA} to your
requirements. If you frequently use certain commands, especially those
with a long list of keywords and fixed values, you can define some
{\small DCL} or {\small ICL} symbols for the commands.  Like {\small
DCL}'s {\tt LOGIN.COM}, {\small ICL} has a {\em login file}. (See SSN/64
for full details.)  If you add symbols to this file, each time you
activate {\small ICL} these abbreviations will be available to you
without further typing. What you should do is to create a {\tt
LOGIN.ICL} in a convenient directory, and put the following definition
in your {\small DCL} {\tt LOGIN.COM} file: 

\small
\begin{verbatim}
     $ DEFINE ICL_LOGIN DISK$USER:[XYZ.ABC]LOGIN.ICL
\end{verbatim}
\normalsize
where {\tt DISK\$USER:[XYZ.ABC]} needs to be replaced by the actual
directory used.  It is possible to have several {\small ICL} login
files, each for different work in different directories.  Now to
abbreviate a command you put a DEFSTRING entry into the {\small ICL}
login file. For example,

\small
\begin{verbatim}
     DEFSTRING MYC{ON} TURBOCONT CLEAR=F PENROT MODE=AU NCONT=7
\end{verbatim}
\normalsize
defines {\tt MYC} or {\tt MYCO} or {\tt MYCON} to run TURBOCONT without
clearing the screen, with pen rotation and seven equally spaced contour heights.
The symbols are not limited to {\small KAPPA}.  Indeed they can include
shorthands for {\small DCL} commands.  For example,

\small
\begin{verbatim}
     DEFSTRING DSD $DIRECTORY/SIZE/DATE
\end{verbatim}
\normalsize

would make DSD produce a directory listing with file sizes and
creation dates.

You can check what the current login files are as follows.

\small
\begin{verbatim}
     $ SHOW LOGICAL ICL_LOGIN*
\end{verbatim}
\normalsize

For DCL usage similar definitions can be made with symbols. For
example, 
 
\small
\begin{verbatim}
     $ MYC*ON:=='TURBOCONT' CLEAR=F PENROT MODE=AU NCONT=7
\end{verbatim}
\normalsize
 
is the equivalent of the DEFSTRING above.

\section{Acknowledgements}

Rodney Warren-Smith, David Berry, and Wei Gong wrote {\small KAPPA}
applications.  Rodney Warren-Smith has also converted some applications
to use the NDF library. The original {\small KAPPA} was derived from
Mark McCaughrean's {\small RAPI2D} and Ken Hartley's ASPIC {\small
Kernel}.  Thanks also to Rodney Warren-Smith for permitting this
document to include a few modified pages of his SUN/33 on NDF sections
and co-ordinate systems. 

\newpage
\appendix
\begin{small}
\section{An Alphabetical Summary of KAPPA Commands}
\label{ap:summary}
\menuitem{ADD}{
 Adds two NDF data structures.}
\menuitem{APERADD}{
 Derives statistics of pixels within a specified circle of a 2-d data array.}
\menuitem{BLINK}{
 Blinks two planes of an image display.}
\menuitem{BLOCK}{
 Smooths a 2-dimensional image using a square or rectangular box filter.}
\menuitem{CADD}{
 Adds a scalar to an NDF data structure.}
\menuitem{CDIV}{
 Divides an NDF by a scalar.}
\menuitem{CENTROID}{
 Finds the centroids of star-like features in an NDF.}
\menuitem{CHPIX}{
 Replaces the values of selected pixels in a 2-d data array
 with user-specified values.}
\menuitem{CLEANER}{
 Removes defects from a substantially flat 2-d NDF.}
\menuitem{CMULT}{
 Multiplies an NDF by a scalar.}
\menuitem{COLUMNAR}{
 Draws a perspective-histogram representatation of a 2-d NDF.}
\menuitem{COMPADD}{
 Reduces the size of a 2-d data array by adding neighbouring pixels.}
\menuitem{COMPAVE}{
 Reduces the size of a 2-d data array by averaging neighbouring pixels.}
\menuitem{COMPICK}{
 Reduces the size of a 2-d data array by picking every {$n^{\rm th}$} pixel.}
\vspace{0.8ex}
\menuitem{COMPRESS}{
 Reduces the size of a 2-d data array by averaging
 neighbouring pixels by different amounts in {$x$} and {$y$}.}
\menuitem{CONTOUR}{
 Contours a 2-d NDF.}
\menuitem{CONTOVER}{
 Contours a 2-d NDF overlaid on an image displayed previously.}
\menuitem{CREFRAME}{
 Generate a test 2-d data array from a selection of several types.}
\menuitem{CRELUT}{
 Creates or manipulates an image-display lookup table using a palette.}
\menuitem{CSUB}{
 Subtracts a scalar from an NDF data structure.}
\vspace{0.8ex}
\menuitem{CURSOR}{
 Reports the co-ordinates of points selected using the
 cursor and selects the current picture.}
\menuitem{DISPLAY}{
 Displays a 2-d NDF.}
\menuitem{DIV}{
 Divides one NDF data structure by another.}
\menuitem{ERASE}{
 Erases an HDS object.}
\menuitem{EXP10}{
 Takes the base-10 exponential of each pixel of a data array.}
\menuitem{EXPE}{
 Takes the exponential of each pixel of a data array (base $e$).}
\menuitem{EXPON}{
 Takes the exponential of each pixel of a data array (specified base).}
\menuitem{FITSDIN}{
 Reads a FITS disk file composed of simple, group or table files.}
\menuitem{FITSIMP}{
 Imports FITS information into an NDF extension.}
\menuitem{FITSIN}{
 Reads a FITS tape composed of simple, group or table files.}
\menuitem{FITSLIST}{
 Lists the FITS extension of an NDF.}
\menuitem{FLIP}{
 Reverses an NDF's pixels along a specified dimension.}
\menuitem{FOURIER}{
 Performs forward and reverse Fourier transforms on 2-d NDFs.}
\menuitem{GAUSS}{
 Smooths a 2-dimensional image using a symmetrical Gaussian filter.}
\menuitem{GDCLEAR}{
 Clears a graphics device and purges its database entries.}
\menuitem{GDNAMES}{
 Shows which graphics devices are available.}
\menuitem{GDSET}{
 Selects a current graphics device.}
\menuitem{GDSTATE}{
 Shows the current status of a graphics device.}
\menuitem{GLITCH}{
 Replaces bad pixels in a 2-d data array with the local median.}
\menuitem{GLOBALS}{
 Displays the values of the {\small KAPPA} global parameters.}
\menuitem{GREYPLOT}{
 Produces a greyscale plot of a 2-d NDF.}
\menuitem{HIDE}{
 Draws a perspective plot of a two-dimensional NDF.}
\menuitem{HISTAT}{
 Generates an histogram of a 2-d data array to compute statistics.}
\menuitem{HISTEQ}{
 Performs an histogram equalisation on a 2-d data array.}
\menuitem{HISTOGRAM}{
 Derives histograms of sub-arrays within a 2-d data array.}
\menuitem{IDCLEAR}{
 Clears an image display and purges its database entries.}
\menuitem{IDINVISIBLE}{
 Makes memory planes of an image-display device invisible.}
\menuitem{IDPAN}{
 Pans and zooms an {\mantt{ARGS}} or an {\mantt{IKON}}.}
\menuitem{IDPAZO}{
 Pans and zooms an image-display device.}
\menuitem{IDRESET}{
 Performs a hardware reset of an {\tt ARGS} or an {\tt IKON}.}
\menuitem{IDSET}{
 Selects a current image-display device.}
\menuitem{IDSTATE}{
 Shows the current status of an image display.}
\menuitem{IDUNZOOM}{
 Unzooms and re-centres an image-display device.}
\menuitem{IDVISIBLE}{
 Makes all the memory planes of an image-display device visible.}
\menuitem{INSPECT}{
 Inspects a 2-d NDF in a variety of ways.}
\menuitem{KAPHELP}{
 Gives help about {\small KAPPA}.}
\menuitem{LAPLACE}{
 Performs a Laplacian convolution as an edge detector in a 2-d data array.}
\menuitem{LINPLOT}{
 Draws a line plot of 1-d NDF's data values against their axis
 co-ordinates.}
\menuitem{LOG10}{
 Takes the base-10 logarithm of each pixel of a data array.}
\menuitem{LOGAR}{
 Takes the logarithm of each pixel of a data array (specified base).}
\menuitem{LOGE}{
 Takes the natural logarithm of each pixel of a data array.}
\menuitem{LOOK}{
 Outputs the values of a sub-array of a 2-d data array to the
 screen or an ASCII file.}
\menuitem{LUTABLE}{
 Manipulates an image-display colour table.}
\menuitem{LUTBGYRW}{
 Loads the {\it BGYRW}\ lookup table.}
\menuitem{LUTCOL}{
 Loads the standard colour lookup table.}
\menuitem{LUTCONT}{
 Loads a lookup table to give the display the appearance of a contour plot.}
\menuitem{LUTFC}{
 Loads the standard false-colour lookup table.}
\menuitem{LUTFLIP}{
 Flips the colour table of an image-display device.}
\menuitem{LUTGREY}{
 Loads the standard greyscale lookup table.}
\menuitem{LUTHEAT}{
 Loads the {\it heat}\ lookup table.}
\menuitem{LUTHILITE}{
 Highlights a colour table of an image-display device.}
\menuitem{LUTIKON}{
 Loads the {\it Ikon}\ lookup table.}
\menuitem{LUTNEG}{
 Loads a negative greyscale lookup table.}
\menuitem{LUTRAMPS}{
 Loads the coloured-ramps lookup table.}
\menuitem{LUTREAD}{
 Loads an image-display lookup table from an NDF.}
\menuitem{LUTROT}{
 Rotates the colour table of an image-display device.}
\menuitem{LUTSAVE}{
 Saves the current colour table of an image-display device in an NDF.}
\menuitem{LUTSPEC}{
 Loads a spectrum-like lookup table.}
\menuitem{LUTTWEAK}{
 Tweaks a colour table of an image display.}
\menuitem{LUTVIEW}{
 Draws a colour-table key.}
\menuitem{LUTZEBRA}{
 Loads a pseudo-contour lookup table.}
\menuitem{MANIC}{
 Converts all or part of a data array from one dimensionality to another.}
\menuitem{MATHS}{
 Evaluates mathematical expressions applied to NDF data structures.}
\menuitem{MEDIAN}{
 Smooths a 2-d data array using a 2-d weighted median filter.}
\menuitem{MEM2D}{
 Performs a Maximum-Entropy deconvolution of a 2-d NDF.}
\menuitem{MLINPLOT}{
 Draws a multi-line plot of a 2-d NDF's data values against their axis
 co-ordinates.}
\menuitem{MOSAIC}{
 Merges several non-congruent 2-d data arrays into one output data array.}
\menuitem{MSTATS}{
 Does cumulative statistics on a 2-d sub-array over a sequence of
 2-d data arrays.}
\menuitem{MULT}{
 Multiplies two NDF data structures.}
\menuitem{NATIVE}{
 Converts an HDS object to native machine data representation.}
\menuitem{NDFCOPY}{
 Copies an NDF (or NDF section) to a new location.}
\menuitem{NDFTRACE}{
 Displays the attributes of an NDF data structure.}
\menuitem{NOMAGIC}{
 Replaces all occurrences of magic-value pixels in a data array by a
 user-defined value.}
\menuitem{NORMALIZE}{
 Normalizes one NDF to a similar NDF by calculating a scale and zero
 difference.}
\vspace{0.8ex}
\menuitem{NUMB}{
 Counts the number of elements of a data array with values
 greater than a specified value.}
\vspace{0.8ex}
\menuitem{NUMBA}{
 Counts the number of elements of a data array with absolute
 values greater than a specified value.}
\menuitem{OUTSET}{
 Sets pixels outside a specified circle in a 2-d data array
 to a specified value.}
\menuitem{OVSET}{
 Selects a current image-display overlay.}
\menuitem{PALDEF}{
 Loads the default palette to a colour table.}
\menuitem{PALENTRY}{
 Enters a colour into an image display's palette.}
\menuitem{PALREAD}{
 Fills the palette of a colour table from an NDF.}
\menuitem{PALSAVE}{
 Saves the current palette of a colour table to an NDF.}
\menuitem{PICDEF}{
 Defines a new graphics-database picture or an array of pictures.}
\menuitem{PICIN}{
 Finds the attributes of a picture interior to the current picture.}
\menuitem{PICK2D}{
 Creates a new 2-d data array from a subset of another.}
\menuitem{PICLABEL}{
 Labels the current graphics-database picture.}
\menuitem{PICLIST}{
 Lists the pictures in the graphics database for a device.}
\menuitem{PICSEL}{
 Selects a graphics-database picture by its label.}
\menuitem{PIXDUPE}{
 Expands a 2-d data array by pixel duplication.}
\menuitem{POW}{
 Takes the specified power of each pixel of a data array.}
\vspace{0.8ex}
\menuitem{PSF}{
 Determines the parameters of a model star profile by
 fitting star images in a 2-dimensional NDF.}
\vspace{0.8ex}
\menuitem{QUILT}{
 Generates a mosaic from equally sized 2-d data arrays,
 optionally specified from an ASCII file.}
\menuitem{ROTATE}{
 Rotates a 2-d data array through any angle.}
\menuitem{SEGMENT}{
 Copies polygonal segments from one 2-d data array to another.}
\menuitem{SETBB}{
 Sets a new value for the quality bad-bits mask of an NDF.}
\menuitem{SETBAD}{
 Sets new bad-pixel flag values for an NDF.}
\menuitem{SETBOUND}{
 Sets new bounds for an NDF.}
\menuitem{SETLABEL}{
 Sets a new label for an NDF data structure.}
\menuitem{SETMAGIC}{
 Replaces all occurrences of pixels of a given value in a
 data array by the magic value.}
\menuitem{SETORIGIN}{
 Sets a new pixel origin for an NDF.}
\menuitem{SETTITLE}{
 Sets a new title for an NDF data structure.}
\menuitem{SETTYPE}{
 Sets a new numeric type for the data and variance components of an NDF.}
\menuitem{SETUNITS}{
 Sets a new units value for an NDF data structure.}
\menuitem{SETVAR}{
 Sets new values for the variance component of an NDF data structure.}
\menuitem{SHADOW}{
 Enhances edges in a 2-d data array using a shadow effect.}
\menuitem{SHIFT}{
 Realigns a 2-d data array via an {$x$}-{$y$} shift.}
\menuitem{SNAPSHOT}{
 Dumps an image-display memory to a graphics hardcopy and
 optionally to an NDF.}
\menuitem{SQORST}{
 Squashes or stretches a 2-d data array in either or both axes.}
\menuitem{STATS}{
 Computes simple statistics for an NDF's pixels.}
\menuitem{STATS2D}{
 Computes simple statistics for a 2-d data array.}
\menuitem{SUB}{
 Subtracts one NDF data structure from another.}
\menuitem{SURFIT}{
 Fits a polynomial or spline surface to 2-d data array.}
\smallskip
\menuitem{THRESH}{
 Creates a thresholded version of a data array (new values
 for pixels outside defined thresholds are specified).}
\smallskip
\menuitem{THRESH0}{
 Creates a thresholded version of a data array (every value
 outside the defined thresholds is set to zero).}
\menuitem{TRANDAT}{
 Converts free-format data into an NDF.}
\menuitem{TRIG}{
 Performs a trigonometric transformation on a data array.}
\menuitem{TURBOCONT}{
 Contours a 2-d NDF quickly.}
\menuitem{TWEAK}{
 Interactively adjusts a colour table.}
\menuitem{ZAPLIN}{
 Replaces regions in a 2-d NDF by bad values or by linear
 interpolation.}

\newpage
\section{Classified KAPPA commands}
\label{ap:classified}

{\small KAPPA} applications may be classified in terms of their
functions as follows:

\begin{description}

\item [I/O] ---
\begin{description}
\item [Image generation and input]:
\begin {description}
\item [CREFRAME]:
 Generates a test 2-d data array from a selection of several types.
\item [FITSDIN]:
 Reads a FITS disk file composed of simple, group or table files.
\item [FITSIMP]:
 Imports FITS information into an NDF extension.
\item [FITSIN]:
 Reads a FITS tape composed of simple, group or table files.
\item [TRANDAT]:
 Converts free-format data into an NDF.
\end {description}
\end {description}

\item [DISPLAY] ---
\begin{description}
\item [Detail enhancement] :
\begin{description}
\item [HISTEQ]:
 Performs an histogram equalisation on a 2-d data array.
\item [LAPLACE]:
 Performs a Laplacian convolution as an edge detector in a 2-d data array.
\item [SHADOW]:
 Enhances edges in a 2-d data array using a shadow effect.
\item [THRESH]:
 Creates a thresholded version of a data array (new values for pixels outside
 defined thresholds are specified).
\item [THRESH0]:
 Creates a thresholded version of a data array (every value outside the defined
 thresholds is set to zero).
\end{description}
\item [Display control] :
\begin{description}
\item [BLINK]:
 Blinks two planes of an image display.
\item [CURSOR]:
 Reports the co-ordinates of points selected using the cursor and selects
 the current picture.
\item [GDCLEAR]:
 Clears a graphics device and purges its database entries.
\item [GDSTATE]:
 Shows the current status of a graphics device.
\item [IDCLEAR]:
 Clears an image display and purges its database entries.
\item [IDINVISIBLE]:
 Makes memory planes of an image-display device invisible.
\item [IDPAN]:
 Pans and zooms an {\tt ARGS} or an {\tt IKON}.
\item [IDPAZO]:
 Pans and zooms an image-display device.
\item [IDRESET]:
 Performs a hardware reset of an {\tt ARGS} or an {\tt IKON}.
\item [IDSTATE]:
 Shows the current status of an image display.
\item [IDUNZOOM]:
 Unzooms and re-centres an image-display device.
\item [IDVISIBLE]:
 Makes all the memory planes of an image-display device visible.
\item [PICDEF]:
 Defines a new graphics-database picture or an array of pictures.
\item [PICIN]:
 Finds the attributes of a picture interior to the current picture.
\item [PICLABEL]:
 Labels the current graphics-database picture.
\item [PICLIST]:
 Lists the pictures in the graphics database for a device.
\item [PICSEL]:
 Selects a graphics-database picture by its label.
\end{description}
\item [Device selection] :
\begin{description}
\item [GDNAMES]:
 Shows which graphics devices are available.
\item [GDSET]:
 Selects a current graphics device.
\item [IDSET]:
 Selects a current image-display device.
\item [OVSET]:
 Selects a current image-display overlay.
\end{description}
\newpage
\item [Lookup/Colour tables] :
\begin{description}
\item [CRELUT]:
 Creates or manipulates an image-display lookup table using a palette.
\item [LUTABLE]:
 Manipulates an image-display colour table.
\item [LUTBGYRW]:
 Loads the {\it BGYRW}\ lookup table.
\item [LUTCOL]:
 Loads the standard colour lookup table.
\item [LUTCONT]:
 Loads a lookup table to give the display the appearance of a contour plot.
\item [LUTFC]:
 Loads the standard false-colour lookup table.
\item [LUTFLIP]:
 Flips the colour table of an image-display device.
\item [LUTGREY]:
 Loads the standard greyscale lookup table.
\item [LUTHEAT]:
 Loads the {\it heat}\ lookup table.
\item [LUTHILITE]:
 Highlights a colour table of an image-display device.
\item [LUTIKON]:
 Loads the {\it Ikon}\ lookup table.
\item [LUTNEG]:
 Loads a negative greyscale lookup table.
\item [LUTRAMPS]:
 Loads the coloured-ramps lookup table.
\item [LUTREAD]:
 Loads an image-display lookup table from an NDF.
\item [LUTROT]:
 Rotates the colour table of animage-display device.
\item [LUTSAVE]:
 Saves the current colour table of an image-display device in an NDF.
\item [LUTSPEC]:
 Loads a spectrum-like lookup table.
\item [LUTTWEAK]:
 Tweaks a colour table of an image display.
\item [LUTVIEW]:
 Draws a colour-table key.
\item [LUTZEBRA]:
 Loads a pseudo-contour lookup table.
\item [TWEAK]:
 Interactively adjusts a colour table.
\end{description}
\item [Output] :
\begin{description}
\item [COLUMNAR]:
 Draws a perspective-histogram representatation of a 2-d NDF.
\item [CONTOUR]:
 Contours a 2-d NDF.
\item [CONTOVER]:
 Contours a 2-d data array overlaid on an image displayed previously.
\item [DISPLAY]:
 Displays a 2-d NDF.
\item [GREYPLOT]:
 Produces a greyscale plot of a 2-d NDF.
\item [HIDE]:
 Draws a perspective plot of a two-dimensional NDF.
\item [INSPECT]:
 Inspects a 2-d NDF in a variety of ways.
\item [LINPLOT]:
 Draws a line plot of 1-d NDF's data values against their axis
 co-ordinates.
\item [LOOK]:
 Outputs the values of a sub-array of a 2-d data array to the screen or an
 ASCII file.
\item [MLINPLOT]:
 Draws a multi-line plot of a 2-d NDF's data values against their axis
 co-ordinates.
\item [SNAPSHOT]:
 Dumps an image-display memory to a graphics hardcopy and
 optionally to an NDF.
\item [TURBOCONT]:
 Contours a 2-d NDF quickly.
\end{description}
\item [Palette]:
\begin{description}
\item [PALDEF]:
 Loads the default palette to a colour table.
\item [PALENTRY]:
 Enters a colour into an image display's palette.
\item [PALREAD]:
 Fills the palette of a colour table from an NDF.
\item [PALSAVE]:
 Saves the current palette of a colour table to an NDF.
\end{description}
\end{description}

\item [MANIPULATION] ---
\begin {description}
\item [Arithmetic]:
\begin {description}
\item [ADD]:
 Adds two NDF data structures.
\item [CADD]:
 Adds a scalar to an NDF data structure.
\item [SUB]:
 Subtracts one NDF data structure from another.
\item [CSUB]:
 Subtracts a scalar from an NDF data structure.
\item [MULT]:
 Multiplies two NDF data structures.
\item [CMULT]:
 Multiplies an NDF by a scalar.
\item [DIV]:
 Divides one NDF data structure by another.
\item [CDIV]:
 Divides an NDF by a scalar.
\item [EXP10]:
 Takes the base-10 exponential of each pixel of a data array.
\item [EXPE]:
 Takes the exponential of each pixel of a data array (base $e$).
\item [EXPON]:
 Takes the exponential of each pixel of a data array (specified base).
\item [POW]:
 Takes the specified power of each pixel of a data array.
\item [LOG10]:
 Takes the base-10 logarithm of each pixel of a data array.
\item [LOGAR]:
 Takes the logarithm of each pixel of a data array (specified base).
\item [LOGE]:
 Takes the natural logarithm of each pixel of a data array.
\item [MATHS]:
 Evaluates mathematical expressions applied to NDF data structures.
\item [TRIG]:
 Performs a trigonometric transformation on a data array.
\end {description}
\item [Pixel editing]:
\begin{description}
\item [CHPIX]:
 Replaces the values of selected pixels in a 2-d data array with user-specified
 values.
\item [GLITCH]:
 Replaces bad pixels in a 2-d data array with the local median.
\item [NOMAGIC]:
 Replaces all occurrences of magic-value pixels in a data array by a
 user-defined value.
\item [OUTSET]:
 Sets pixels outside a specified circle in a 2-d data array to a specified
 value.
\item [SEGMENT]:
 Copies polygonal segments from one 2-d data array to another.
\item [SETMAGIC]:
 Replaces all occurrences of pixels of a given value in a
 data array by the magic value.
\item [ZAPLIN]:
 Replaces regions in a 2-d NDF by bad values or by linear
 interpolation.
\end{description}
\item [Configuration change]:
\begin{description}
\item [FLIP]:
 Reverses an NDF's pixels along a specified dimension.
\item [INSPECT]:
 Inspects a 2-d NDF in a variety of ways.
\item [MANIC]:
 Converts all or part of a data array from one dimensionality to another.
\item [NDFCOPY]:
 Copies an NDF (or NDF section) to a new location.
\item [PICK2D]:
 Creates a new 2-d data array from a subset of another.
\item [ROTATE]:
 Rotates a 2-d data array through any angle.
\item [SETBOUND]:
 Sets new bounds for an NDF.
\item [SHIFT]:
 Realigns a 2-d data array via an $x$-$y$ shift.
\end{description}
\item [Combination]:
\begin{description}
\item [MOSAIC]:
 Merges several non-congruent 2-d data arrays into one output data array.
\item [NORMALIZE]:
 Normalizes one NDF to a similar NDF by calculating a
 scale and zero difference.
\item [QUILT]:
 Generates a mosaic from equally sized 2-d data arrays, optionally specified
 from an ASCII file.
\end{description}
\item [Compression and Expansion] :
\begin {description}
\item [COMPADD]:
 Reduces the size of a 2-d data array by adding neighbouring pixels.
\item [COMPAVE]:
 Reduces the size of a 2-d data array by averaging neighbouring pixels.
\item [COMPICK]:
 Reduces the size of a 2-d data array by picking every $n^{\rm th}$ pixel.
\item [COMPRESS]:
 Reduces the size of a 2-d data array by averaging neighbouring pixels by
 different amounts in $x$ and $y$.
\item [PIXDUPE]:
 Expands a 2-d data array by pixel duplication.
\item [SQORST]:
 Squashes or stretches a 2-d data array in either or both axes.
\end {description}
\item [Filtering]:
\begin{description}
\item [BLOCK]:
 Smooths a 2-dimensional image using a square or rectangular box filter.
\item [FOURIER]:
 Performs forward and reverse Fourier transforms on 2-d NDFs.
\item [GAUSS]:
 Smooths a 2-dimensional image using a symmetrical Gaussian filter.
\item [MEDIAN]:
 Smooths a 2-d data array using a 2-d weighted median filter.
\item [MEM2D]:
 Performs a Maximum-Entropy deconvolution of a 2-d NDF.
\item [SURFIT]:
 Fits a polynomial or spline surface to 2-d data array.
\end {description}
\item [NDF and HDS components]:
\begin{description}
\item [ERASE]:
 Erases an HDS object.
\item [NATIVE]:
 Converts an HDS object to native machine data representation.
\item [NDFCOPY]:
 Copies an NDF (or NDF section) to a new location.
\item [SETBAD]:
 Sets new bad-pixel flag values for an NDF.
\item [SETBB]:
 Sets a new value for the quality bad-bits mask of an NDF.
\item [SETBOUND]:
 Sets new bounds for an NDF.
\item [SETLABEL]:
 Sets a new label for an NDF data structure.
\item [SETORIGIN]:
 Sets a new pixel origin for an NDF.
\item [SETTITLE]:
 Sets a new title for an NDF data structure.
\item [SETTYPE]:
 Sets a new numeric type for the data and variance components of an NDF.
\item [SETUNITS]:
 Sets a new units value for an NDF data structure.
\item [SETVAR]:
 Sets new values for the variance component of an NDF data structure.
\end{description}
\end {description}

\item [ANALYSIS] ---
\begin{description}
\item [Statistics]:
\begin{description}
\item [APERADD]:
 Derives statistics of pixels within a specified circle of a 2-d data array.
\item [HISTAT]:
 Generates an histogram of a 2-d data array to compute statistics.
\item [HISTOGRAM]:
 Derives histograms of sub-arrays within a 2-d data array.
\item [INSPECT]:
 Inspects a 2-d NDF in a variety of ways.
\item [MSTATS]:
 Does cumulative statistics on a 2-d sub-array over a sequence of 2-d data
 arrays.
\item [NUMB]:
 Counts the elements of an array with values greater than a specified value.
\item [NUMBA]:
 Counts the elements of an array with absolute values greater than specified.
\item [STATS]:
 Computes simple statistics for an NDF's pixels.
\item [STATS2D]:
 Computes simple statistics for a 2-d data array.
\end{description}
\item [Other]:
\begin{description}
\item [CENTROID]:
 Finds the centroids of star-like features in an NDF.
\item [NORMALIZE]:
 Normalizes one NDF to a similar NDF by calculating a
 scale and zero difference.
\item [PSF]:
 Determines the parameters of a model star profile by
 fitting star images in a 2-dimensional NDF.
\item [SURFIT]:
 Fits a polynomial or spline surface to 2-d data array.
\end {description}
\end {description}

\item [INQUIRIES and STATUS] ---
\begin {description}
\begin {description}
\item [GLOBALS]:
 Displays the values of the {\small KAPPA} global parameters.
\item [FITSLIST]:
 Lists the FITS extension of an NDF.
\item [NDFTRACE]:
 Displays the attributes of an NDF data structure.
\end {description}
\end {description}

\item [MISCELLANEOUS] ---
\begin {description}
\begin {description}
\item [KAPHELP]:
 Gives help about {\small KAPPA}.
\end {description}
\end {description}
\end {description}
\end{small}

\section{Quotas to run KAPPA}
\label{ap:quotas}
To run {\small KAPPA} the {\small ADAM} process quotas plus some extra paging file quota
are required, namely \mbox{}
\begin{tabular}[c]{lrlr}
\\
\hspace{4ex} CPU limit: & Infinite & \hspace{4ex} Direct I/O limit: & 18\\
\hspace{4ex} Buffered I/O byte count quota: & 65000 & \hspace{4ex} Buffered I/O limit: & 18\\
\hspace{4ex} Timer queue entry quota: & 9 & \hspace{4ex} Open file quota: & 50\\
\hspace{4ex} Paging file quota: & 40000 & \hspace{4ex} Subprocess quota: & 10\\
\hspace{4ex} Default page fault cluster: & 32 & \hspace{4ex} AST limit: & 23\\
\hspace{4ex} Enqueue quota: & 30 & \hspace{4ex} Shared file limit: & 0\\
\hspace{4ex} Max detached processes: & 0 & \hspace{4ex} Max active jobs: & 0\\
\hspace{4ex} JTQUOTA: & 3072 & & \\
\end{tabular}

The paging file quota is quite generous for {\small ICL} {\small KAPPA},
and it permits all applications to be run from DCL, even MEM2D which
requires 18000 pages excluding {\small ADAM}. Currently, {\small KAPPA}
itself requires 4360 pages of virtual memory. The additional quota
permits other {\small ADAM} applications to be run from {\small ICL}
alongside {\small KAPPA}, including the large {\small Figaro}. A quota
of about 30000 should suffice for the {\small KAPPA} monolith and a
couple of applications.

\newpage
\section{Specifications of KAPPA applications}
\label{ap:full}
\subsection{Explanatory Notes}
For historical reasons, in this Appendix there are two formats---the
first, exemplified by ADD, is the new layout indicating that this is
one of the applications converted to use the NDF. An example of the old
style is CHPIX. Applications in this format use the moribund IMAGE
format. 

\begin{description}
\item [NDF layout]
In this layout the specification of parameters has the following format. 

\begin{verbatim}
     name  =  type (access)
        description
\end{verbatim}
This format also includes a {\em Usage\/} entry.  This shows how the
application is invoked from the command line.   It lists the positional
parameters in order followed by any prompted keyword parameters using 
a {\mbox ``KEYWORD=?''} syntax.  Defaulted
keyword parameters do not appear.  Positional parameters
that are normally defaulted are indicated by being enclosed in square
brackets.   Keyword ({\it i.e.}\ not positional) parameters are needed 
where the number of parameters are large, and usually occur because
they depend on the value of another parameter.  These are denoted
by a curly brace; the parameters on each line are related, and 
each line is mutually exclusive.  An example should clarify.
\bigskip

{\ssttt \hspace*{1.0em}
        CONTOUR NDF [COMP] MODE NCONT [KEY] [DEVICE] [SMOOTHING]
        \newline\hspace*{2.5em}
        $\left\{ {\begin{tabular}{l}
                    FIRSTCNT=? STEPCNT=? \\
                    HEIGHTS=?
                   \end{tabular} }
        \right.$
        \newline\hspace*{2.9em}
        \makebox[0mm][c]{\small mode}
}
\bigskip

NDF, COMP, MODE, NCONT, KEY, DEVICE, and SMOOTHING are all positional
parameters.  Only NDF, MODE, and NCONT would be prompted if not given
on the command line. The remaining parameters depend on the value of
MODE.  If the mode is to nominate a list of contour heights, HEIGHTS
will be needed (MODE~=~{\tt Free}); alternatively, if the mode requires a
start height and spacing between contours FIRSTCNT and STEPCNT should be
specified (MODE~=~{\tt Linear} or {\tt Magnitude}). Note that there are
other modes which do not require additional information, and hence no
more parameters. 

There is also an {\em Examples\/} section.  This shows how to run the
application from the command line.  More often you'll enter the
command name and just some of the parameters, and be prompted for
the rest.

\item [IMAGE layout]
In this layout the specification of parameters has the following format
\begin{verbatim}
    name    type    access    description
\end{verbatim}
\end{description}
\medskip

The following notes apply to both layouts.

Some parameters will only be used when another parameter has a certain
value or mode. These are indicated by the name of the mode in
parentheses at the end of the parameter description, but before any
default, {\it e.g.}\ parameter DEVICE in CENTROID is only
relevant when parameter MODE is {\tt "CURSOR"}.

{\mantt \%name} means the value of parameter {\it name}.

The description entry has a notation scheme to indicate 
normally defaulted parameters, {\it i.e.}\ those for which there will
be no prompt.
For such parameters a matching pair of square brackets ({\mantt []})
terminates the description.  The content between the brackets mean
\begin{description}
\item[{\mantt []}]
Empty brackets means that the default is created dynamically
by the application, and may depend on the values of other parameters.
Therefore, the default cannot be given explicitly.
\item[{\mantt [,]}]
As above, but there are two default values that are created dynamically.
\item[{\mantt [}{\rm default}{\mantt ]}]
Occasionally, a description of the default is given in normal type,
{\it e.g.}\ the size of the plotting region in a graphics application,
where the exact default values depend on the device chosen. 
\item[{\mantt [default]}]
If the brackets contain a value in teletype-fount, this is the explicit
default value.
\end{description}

\newpage
\sstroutine{
   ADD
}{
   Adds two NDF data structures
}{
   \sstdescription{
      The routine adds two NDF data structures pixel-by-pixel to produce
      a new NDF.
   }
   \sstusage{
      ADD IN1 IN2 OUT
   }
   \sstparameters{
      \sstsubsection{
         IN1 = NDF (Read)
      }{
         First NDF to be added.
      }
      \sstsubsection{
         IN2 = NDF (Read)
      }{
         Second NDF to be added.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Output NDF to contain the sum of the two input NDFs.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Value for the title of the output NDF. A null value will cause
         the title of the NDF supplied for parameter IN1 to be used
         instead. {\tt ['KAPPA - Add']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         ADD A B C
      }{
         This adds the NDF called B to the NDF called A, to make the
         NDF called C.  C has title {\tt "KAPPA - Add"}.
      }
      \sstexamplesubsection{
         ADD OUT=C IN1=A IN2=B TITLE="Co-added image"
      }{
         This adds the NDF called B to the NDF called A, to make the
         NDF called C.  C has the title {\tt "Co-added image"}.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the two input NDFs have different pixel-index bounds, then
         they will be trimmed to match before being added. An error will
         result if they have no pixels in common.

         \sstitem
         This routine correctly processes the AXIS, DATA, QUALITY,
         LABEL, TITLE and VARIANCE components of an NDF data structure and
         propagates all extensions. Bad pixels and all non-complex numeric
         data types can be handled.

         \sstitem
         The HISTORY component is simply propagated without change, if
         present.

         \sstitem
         Units processing is not supported at present and therefore the
         the UNITS component is not propagated.
      }
   }
}

\manroutine {{\manheadstyle{APERADD}}}{ Derives statistics of pixels within a
  specified circle of a 2-d data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes an input 2-d data array in an {\mantt{IMAGE}} structure
  and bins up all the pixels that lie within specified circles to
  either increase the signal-to-noise over that region, or to
  simulate a circular-aperture measurement of the image.

  The following are displayed the noise on the intensity of the
  pixels before binning, the integrated value over the aperture, and
  the calculated mean level and reduced noise after binning.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  APERADD

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{LOGFILE}} }{{\mantt{FILENAME}}}
  Name of the ASCII file to record the statistics. If null,
  there will be no logging. {\mantt [!]}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}} }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing data array to be processed.
\manparameterentry {{\mantt{READ}} }{{\mantt{XCEN}} }{{\mantt{\_REAL}}}
  {$x$} co-ordinate of the circle centre.
\manparameterentry {{\mantt{READ}} }{{\mantt{YCEN}} }{{\mantt{\_REAL}}}
  {$y$} co-ordinate of the circle centre.
\manparameterentry {{\mantt{READ}} }{{\mantt{DIAM}} }{{\mantt{\_REAL}}}
  Diameter of the circle in pixels.
\manparameterentry {{\mantt{READ}} }{{\mantt{AGAIN}} }{{\mantt{\_LOGICAL}}}
  If true then another aperture can be chosen.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{NUMPIX}} }{{\mantt{\_INTEGER}}}
  The number of pixels within the aperture.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{TOTAL}} }{{\mantt{\_REAL}}}
  The total of the pixel values within the aperture.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MEAN}} }{{\mantt{\_REAL}}}
  The mean of the pixel values within the aperture.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{SIGMA}} }{{\mantt{\_REAL}}}
  The standard deviation of the pixel values within the aperture.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{NOISE}} }{{\mantt{\_REAL}}}
  The standard deviation of the pixel values within the aperture after
  binning.
\end{manparametertable}
\manroutineitem {Deficiencies }{}
  The circle centre must lie somewhere on the array, which is
  by far the most likely option, but it not totally general.

\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

 
\sstroutine{
   BLINK
}{
   Blinks two planes of an image display
}{
   \sstdescription{
      Two planes of an IDI-supported image display, such as the Ikon,
      are blinked.  The speed of blinking is controlled by the mouse
      or trackerball buttons.

      For an Ikon the base and overlay planes are used.  It is not
      possible to move the two planes independently due to a limitation
      of the Ikon hardware.  Pressing the left button of the mouse
      increases the speed of blinking, the centre button reduces the
      frequency, and the right-hand button stops the oscillation. It
      may be necessary to move the mouse for the stop operation to
      work.
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device to be blinked.  The
         name of the base-plane device should be given.
         {\tt [}Current image display{\tt ]}
      }
      \sstsubsection{
         PERIOD = \_REAL (Read)
      }{
         The initial frequency of blinking in seconds, {\it i.e.}\ the time
         between the display planes being alternated rather than the
         time to complete a full cycle.  If you blink too fast the
         effect can be chaotic.  {\tt [0.4]}
      }
      \sstsubsection{
         PLANES = \_INTEGER (Read)
      }{
         The two memory planes to be blinked.  0 is the base, and
         positive integers in sequence are overlays. For an Ikon the
         planes must be 0 and 1.  {\tt [0,1]}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         ARGS and X-windows are not supported.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         Data should be displayed on the two planes prior to running
            this application.
      }
   }
   \sstdiytopic{
      Side Effects
   }{
      \sstitemlist{

         \sstitem
         At the end the displayed planes may not be the same as on
            input. On completion of the blinking both memories are visible.
      }
   }
}
 
\sstroutine{
   BLOCK
}{
   Smooths a 2-dimensional image using a square or rectangular box
   filter
}{
   \sstdescription{
      This application applies a square or rectangular box filter to a
      2-dimensional image so as to smooth it. It provides one of the
      fastest methods of smoothing an image and is often useful as a
      general-purpose smoothing algorithm when the exact form of the
      smoothing point-spread function is not important.  The image is
      held in an NDF data structure.
   }
   \sstusage{
      BLOCK IN OUT BOX
   }
   \sstparameters{
      \sstsubsection{
         BOX(2) = \_INTEGER (Read)
      }{
         The $x$ and $y$ sizes (in pixels) of the rectangular box to be
         applied to smooth the image. If only a single value is given,
         then it will be duplicated so that a square filter is used.
         The values given will be rounded up to positive odd integers
         if necessary.
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         The input NDF containing the 2-dimensional image to which
         box smoothing is to be applied.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         The output NDF which is to contain the smoothed image.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Value for the title of the output NDF. A null value will cause
         the title of the input NDF to be used. {\tt ['KAPPA - Block']}
      }
      \sstsubsection{
         WLIM = \_REAL (Read)
      }{
         If the input image contains bad pixels, then this parameter
         may be used to determine the number of good pixels which must
         be present within the smoothing box before a valid output
         pixel is generated.  It can be used, for example, to prevent
         output pixels from being generated in regions where there are
         relatively few good pixels to contribute to the smoothed
         result.

         By default, a null ({\tt !}) value is used for WLIM, which causes
         the pattern of bad pixels to be propagated from the input
         image to the output image unchanged. In this case, smoothed
         output values are only calculated for those pixels which are
         not bad in the input image.

         If a numerical value is given for WLIM, then it specifies the
         minimum fraction of good pixels which must be present in the
         smoothing box in order to generate a good output pixel.  If
         this specified minimum fraction of good input pixels is not
         present, then a bad output pixel will result, otherwise a
         smoothed output value will be calculated.  The value of this
         parameter should lie between 0.0 and 1.0 (the actual number
         used will be rounded up if necessary to correspond to at least
         1 pixel). {\tt [!]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         BLOCK A B 9
      }{
         Smooths the 2-dimensional image held in the NDF structure A,
         writing the result into the structure B. The smoothing box is
         9 pixels square.  If any pixels in the input image are bad,
         then the corresponding pixels in the output image will also be
         bad.
      }
      \sstexamplesubsection{
         BLOCK IN=IMAGE1 OUT=IMAGE2 BOX=[5,7]
      }{
         Smooths the 2-dimensional image held in the NDF structure
         IMAGE1 using a rectangular box of size 5$\times$7 pixels.  The
         smoothed image is written to the structure IMAGE2.
      }
      \sstexamplesubsection{
         BLOCK ETACAR ETACARS BOX=[7,1] WLIM=0.6
      }{
         Smooths the specified image data using a rectangular box 7$\times$1
         pixels in size. Smoothed output values are generated only if
         at least 60\% of the pixels in the smoothing box are good,
         otherwise the affected output pixel is bad.
      }
   }
   \sstdiytopic{
      Timing
   }{
      The execution time is approximately proportional to the number of
      pixels in the image to be smoothed and is largely independent of
      the smoothing box size. This makes the routine particularly
      suitable for applying heavy smoothing to an image.  Execution
      time will be approximately doubled if a variance array is present
      in the input NDF.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         This routine correctly processes the AXIS, DATA, QUALITY,
         LABEL, TITLE, VARIANCE and UNITS components of the input NDF.
         Processing of bad pixels and all non-complex numeric types is
         supported.  Arithmetic is performed using single precision
         floating point, or double precision if appropriate.

         \sstitem
         The HISTORY component is simply propagated without change, if
         present.
      }
   }
}

\sstroutine{
   CADD
}{
   Adds a scalar to an NDF data structure
}{
   \sstdescription{
      The routine adds a scalar ({\it i.e.}\ constant) value to each pixel of
      an NDF's data array to produce a new NDF data structure.
   }
   \sstusage{
      CADD IN SCALAR OUT
   }
   \sstparameters{
      \sstsubsection{
         IN = NDF (Read)
      }{
         Input NDF data structure, to which the value is to be added.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Output NDF data structure.
      }
      \sstsubsection{
         SCALAR = \_DOUBLE (Read)
      }{
         The value to be added to the NDF's data array.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Value for the title of the output NDF. A null value will cause
         the title of the NDF supplied for parameter IN to be used
         instead. {\tt ['KAPPA - Cadd']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CADD A 10 B
      }{
         This adds ten to the NDF called A, to make the NDF called B.
         B has title {\tt "KAPPA - Cadd"}.
      }
      \sstexamplesubsection{
         CADD TITLE="HD123456" OUT=B IN=A SCALAR=17.3
      }{
         This adds 17.3 to the NDF called A, to make the NDF called B.
         B has the title {\tt "HD123456"}.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine correctly processes the AXIS, DATA, QUALITY,
         LABEL, TITLE, UNITS and VARIANCE components of an NDF data
         structure and propagates all extensions. Bad pixels and all
         non-complex numeric data types can be handled.

         \sstitem
         The HISTORY component is simply propagated without change, if
         present.
      }
   }
}

\sstroutine{
   CDIV
}{
   Divides an NDF by a scalar
}{
   \sstdescription{
      This application divides each pixel of an NDF by a scalar
      (constant) value to produce a new NDF.
   }
   \sstusage{
      CDIV IN SCALAR OUT
   }
   \newpage
   \sstparameters{
      \sstsubsection{
         IN = NDF (Read)
      }{
         Input NDF structure whose pixels are to be divided by a
         scalar.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Output NDF structure.
      }
      \sstsubsection{
         SCALAR = \_DOUBLE (Read)
      }{
         The value by which the NDF's pixels are to be divided.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         A title for the output NDF. A null value will cause the title
         of the NDF supplied for parameter IN to be used instead.
         {\tt ['KAPPA - Cdiv']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CDIV A 100.0 B
      }{
         Divides all the pixels in the NDF called A by the constant
         value 100.0 to produce a new NDF called B.
      }
      \sstexamplesubsection{
         CDIV IN=DATA1 OUT=DATA2 SCALAR=-38
      }{
         Divides all the pixels in the NDF called DATA1 by $-$38 to give
         DATA2.
      }
   }
   \sstimplementationstatus{
      This routine correctly processes the AXIS, DATA, QUALITY, LABEL,
      TITLE, UNITS and VARIANCE components of an NDF and propagates all
      extensions. Bad pixels and all non-complex numeric types can be
      handled. Arithmetic is carried out using the appropriate
      floating-point type, but the numeric type of the input pixels is
      preserved in the output NDF.
   }
}
 
 
 
\sstroutine{
   CENTROID
}{
   Finds the centroids of star-like features in an NDF
}{
   \sstdescription{
      This routine takes a NDF and returns the co-ordinates of the
      centroids of features in its data array given approximate initial
      co-ordinates.  A feature is a set of connected pixels which are
      above or below the surrounding background region. For example, a
      feature could be a star or galaxy on the sky.  The centroid is
      obtained iteractively from computing marginal profiles in a
      search region about the initial position, and subtracting the
      background. The loop is repeated up to a maximum number of
      iterations, though it normally terminates when a desired accuracy
      has been achieved.  Typically, for stars better than 0.1 pixel
      is readily attainable, but the accuracy is affected by noise,
      non-Gaussian and overlapping features.  The error in the centroid
      position may be estimated by a Monte-Carlo method using the
      data variance to generate realisations of the data about the
      feature.  Each realisation is processed identically to the actual
      data, and statistics are formed to derive the standard deviations.

      Co-ordinates may either be in pixels or in data co-ordinates.
      Three methods are available for obtaining the initial positions.

      \begin{enumerate}
      \item From the parameter system, usually in response to prompting.
      \item By a placing a graphics cursor of a nominated device on the
         feature.  To do this the data array must already be
         displayed as an image, or a contour or line plot, and the
         picture stored in the graphics database.
      \item By reading an ASCII file containing a list of co-ordinates
         in free format, one object per record.  There may be
         commentary lines in the file beginning with '{\tt \#}' or
         '{\tt !}'.
      \end{enumerate}

      In the first two modes the application loops asking for new
      feature co-ordinates until told to quit or encounters an error.
      Features within NDFs of dimension 1 to 7 may be located, except
      in the second method, where the graphics interface limits
      constrain the NDF to be one- or two-dimensional---the most common
      cases.

      The results may optionally be written to a log file that includes
      details of the input parameters.  This is intended for the human
      reader.  If the centroid positions are to be fed into another
      application requiring a list of co-ordinates, {\it e.g.}\ for photometry,
      a co-ordinate list file may also be written.
   }
   \sstusage{
      CENTROID NDF [MODE] INIT [SEARCH] [MAXITER] [MAXSHIFT] [TOLER]
   }
   \sstparameters{
      \sstsubsection{
         CERROR = \_LOGICAL (Read)
      }{
         If true errors in the centroid position will be calculated.
         The input NDF must contain the data's variance in order
         to compute errors. {\tt [FALSE]}
      }
      \sstsubsection{
         COIN =  FILENAME (Read)
      }{
         Name of the ASCII file containing the initial co-ordinates
         of star-like images.   The co-ordinates should be arranged
         in free-format columns $x$ then $y$ then $z$ {\it etc.}\, one record per
         image.  The file may contain comment lines with the first
         character \# or !.  (XYlist mode)
      }
      \sstsubsection{
         COOUT =  FILENAME (Read)
      }{
         Name of the ASCII file to contain the centroid co-ordinates
         of the star-like images.  It is a co-ordinate file which can
         be used by other applications, and contains the position of
         one object per record.  If COOUT is null, {\tt !}, no output
         co-ordinate file will be created. {\tt [!]}
      }
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either
         {\tt "WORLD"} or {\tt "DATA"}.  If COSYS = {\tt "DATA"} the
         input co-ordinates and the
         centroids are to be expressed in data co-ordinates, otherwise
         pixel (world) co-ordinates are used.  The data values are
         converted to and from pixel indices via the NDF's axis values;
         if there is no axis information within the NDF, world
         co-ordinates are then used, except in Cursor mode where the
         transformation, if present, is taken from the last DATA
         picture in the graphics database.  If COSYS = {\tt "WORLD"} pixel
         co-ordinates are used throughout.  {\tt [}Current co-ordinate
         system{\tt ]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics device whose the cursor is used to select the
         images for which centroids are to be calculated. (Cursor
         mode) {\tt [}Current graphics device{\tt ]}
      }
      \sstsubsection{
         INIT()  = \_DOUBLE (Read)
      }{
         Guess co-ordinates of the feature to be centroided.  The
         co-ordinates must lie within the bounds of the NDF.  If
         the initial co-ordinates are supplied on the command line
         only one centroid will be found; otherwise the application
         will ask for further guesses, which may be terminated by
         supplying the null value ({\tt !}). (Interface mode)
      }
      \sstsubsection{
         LOGFILE  =  FILENAME (Read)
      }{
         Name of the ASCII file to log the results.  If null, there
         will be no logging.  Note this is intended for the human reader
         and is not intended for passing to other applications. {\tt [!]}
      }
      \sstsubsection{
         MARK = \_LOGICAL (Read)
      }{
         If true the point selected by the cursor will be marked by a
         cross. (Cursor mode) {\tt [FALSE]}
      }
      \sstsubsection{
         MAXITER  =  \_INTEGER (Read)
      }{
         Maximum number of iterations to be used in the search.  It must
         be in the range 1--9.  The dynamic default is 3. {\tt [9]}
      }
      \sstsubsection{
         MAXSHIFT()  =  \_REAL (Read)
      }{
         Maximum shift in each dimension allowed between the guess and
         output positions in pixels.  Each must lie in the range
         0.0--26.0.  If only a single value is given, then it will be
         duplicated to all dimensions. The dynamic default is half of
         SEARCH $+$ 1. {\tt [9.0]}
      }
      \sstsubsection{
         MODE  =  LITERAL (Read)
      }{
         The mode in which the initial co-ordinates are to be obtained.
         {\tt "Interface"} means from the parameter system, {\tt "Cursor"}
         enables selection by graphics cursor, and {\tt "File"} reads
         them from an ASCII file. {\tt [}Current interaction mode{\tt ]}
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         The NDF structure containing the data array to be analysed.
      }
      \sstsubsection{
         NSIM =  \_INTEGER (Read)
      }{
         The number of simulations or realisations using the variance
         information in order to estimate the error in the centroid
         position.  The uncertainty in the centroid error decreases
         as one over the square root of NSIM. The range of acceptable
         values is 3--10000. {\tt [100]}
      }
      \sstsubsection{
         POSITIVE  =  \_LOGICAL (Read)
      }{
         True if array features are positive above the background.
         {\tt [TRUE]}
      }
      \sstsubsection{
         SEARCH()  =  \_INTEGER (Read)
      }{
         Size in pixels of the search box to be used. If only a single
         value is given, then it will be duplicated to all dimensions
         so that a square, cube or hypercube region is searched.
         Each value must be odd and lie in the range 3--51.  {\tt [9]}
      }
      \sstsubsection{
         TOLER  =  \_REAL (Read)
      }{
         Accuracy in pixels required in centroiding.  Iterations will
         stop when the shift between successive centroid positions
         is less than the accuracy.  The accuracy must lie in the range
         0.0--2.0. {\tt [0.05]}
      }
   }
   \sstresparameters{
      \sstsubsection{
         CENTRE()  = \_DOUBLE (Write)
      }{
         Co-ordinates of the centroid of the feature.  Note
         that only the last centroid is recorded in this parameter.
      }
      \sstsubsection{
         XCEN  =  \_DOUBLE (Write)
      }{
         $x$ co-ordinate of the centroid of the star-like feature.  Note
         that only the last centroid is recorded in this parameter.
         This provided in addition to CENTRE for convenience until ICL
         permits arrays.
      }
      \sstsubsection{
         YCEN  =  \_DOUBLE (Write)
      }{
         $y$ co-ordinate of the centroid of the star-like feature.  Note
         that only the last centroid is recorded in this parameter.
         This provided in addition to CENTRE for convenience until ICL
         permits arrays.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CENTROID CLUSTER CU
      }{
         This finds the centroids in the NDF called CLUSTER via the
         graphics cursor on the current graphics device.
      }
      \sstexamplesubsection{
         CENTROID CLUSTER CU SEARCH=21
      }{
         This finds the centroids in the NDF called CLUSTER via the
         graphics cursor on the current graphics device.  The search
         box for the centroid is 21 pixels in each dimension.
      }
      \sstexamplesubsection{
         CENTROID CLUSTER I [21.7,5007.1] COSYS=D
      }{
         This finds the centroid of the object in the 2-d NDF called
         CLUSTER around the data co-ordinate (21.7,5007.1).
      }
      \sstexamplesubsection{
         CENTROID ARP244(6,,) I [40,30] COSYS=W TOLER=0.01
      }{
         This finds the 2-d centroid of the feature near pixel
         (6,40,30) in the 3-d NDF called ARP244 via the graphics cursor
         on the current graphics device.  The centroid must be found to
         0.01 pixels.
      }
      \sstexamplesubsection{
         CENTROID CLUSTER I [40,30] COSYS=W XCEN=(XP) YCEN=(YP)
      }{
         This finds the centroid of the object in the 2-d NDF called
         CLUSTER around the pixel co-ordinate (40.0,30.0).  The
         centroid co-ordinates are written to ICL variables XP and YP
         for use in other applications.
      }
      \sstexamplesubsection{
         CENTROID CLUSTER MODE=XY COIN=OBJECTS.DAT LOGFILE=CENTROIDS.LOG
      }{
         This finds the centroids in the NDF called CLUSTER.  The
         initial positions are given in the ASCII file OBJECTS.DAT in
         the current co-ordinate system.  A log of the input parameter
         values, initial and centroid positions is written to the ASCII
         file CENTROIDS.LOG.
      }
      \sstexamplesubsection{
         CENTROID CLUSTER MODE=XY COIN=OBJECTS.DAT COOUT=CENTRES.DAT
      }{
         As above, except there is no logfile; instead a co-ordinate
         file called CENTRES.DAT is generated.
      }
      \sstexamplesubsection{
         CENTROID CLUSTER I [40,30] COSYS=W NOPOSITIVE
      }{
         This finds the centroid of the object in the 2-d NDF called
         CLUSTER around the pixel co-ordinate (40.0,30.0).  The feature
         must have values below that of the surrounding background.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The processing of bad pixels and all non-complex numeric types
         is supported.

         \sstitem
         Data co-ordinates are processed in double precision.  When data
         co-ordinates are being used, and the cursor mode is selected or
         the NDF contains axis information, the results appear in double
         precision.  Double precision arithmetic is needed to prevent
         a loss of precision for certain co-ordinate transformations stored
         within the graphics database or for double-precision axis centres.

         \sstitem
         The format of the logfile is different for 2-d from other
         dimensions for historical reasons.  The 2-d has a tabular layout
         with headings.  Logging awaits a proper table system to make this
         consistent.
      }
   }
}

\manroutine {{\manheadstyle{CHPIX}}}{ Replaces the values of selected pixels
  in a 2-d data array with user-specified values.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  The 2-d data array in the input {\mantt{IMAGE}} structure is copied to the
  output {\mantt{IMAGE}} structure.  Selected pixels in the output array are
  replaced by new, user-specified values within a loop, until the
  user terminates processing.

\manroutineitem {Invocation }{}
  CHPIX

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the data array to be modified.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the modified version of
  the data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Chpix']}
\manparameterentry {{\mantt{READ}} }{{\mantt{XCOORD}} }{{\mantt{\_INTEGER}}}
  {$x$} pixel index of a pixel to be replaced.
\manparameterentry {{\mantt{READ}} }{{\mantt{YCOORD}} }{{\mantt{\_INTEGER}}}
  {$y$} pixel index of a pixel to be replaced.
\manparameterentry {{\mantt{READ}} }{{\mantt{NEWVAL}} }{{\mantt{\_REAL}}}
  Value to replace old value in modified pixel.
\manparameterentry {{\mantt{READ}} }{{\mantt{AGAIN}}  }{{\mantt{\_LOGICAL}}}
  Whether or not user is prompted for another pixel.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\sstroutine{
   CLEANER
}{
   Removes defects from a substantially flat 2-d NDF
}{
   \sstdescription{
      This application cleans a 2-d NDF by removing defects smaller
      than a specified size.  The defects are flagged with the bad
      value. The defects are found by looking for pixels that deviate
      from the image's smoothed version by more than a user-defined
      number of standard deviations from the local mean, and that lie
      within a specified range of values.  Therefore, the image must be
      substantially flat.  The data variances provide the local noise
      estimate for the threshold, but if these are not available a
      variance for the whole of the image is derived from the mean
      squared deviations of the original and smoothed images.  The
      smoothed version of the image is obtained by block averaging over
      a rectangular box.  An iterative process progressively removes
      the outliers from the image.
   }
   \sstusage{
      CLEANER IN OUT CLIP BOX [THRESH] [WLIM] [ILEVEL]
   }
   \sstparameters{
      \sstsubsection{
         BOX( 2 ) = \_INTEGER (Read)
      }{
         The $x$ and $y$ sizes (in pixels) of the rectangular box to be
         applied to smooth the image. If only a single value is given,
         then it will be duplicated so that a square filter is used.
         The values given will be rounded up to positive odd integers
         if necessary.
      }
      \sstsubsection{
         CLIP( ) = \_REAL (Read)
      }{
         The number of standard deviations for the rejection threshold
         of each iteration.  Pixels that deviate from their counterpart
         in the smoothed image by more than CLIP times the noise are
         made bad.  The number of values given specifies the number of
         iterations.  Values should lie in the range 0.5--100.  Up to
         one hundred values may be given.  {\tt [3.0, 3.0, 3.0]}
      }
      \sstsubsection{
         ILEVEL = \_INTEGER (Read)
      }{
         The interactive level of the routine.  When it is greater or
         equal to two, the application will report the intermediate
         results after each iteration during processing. It should lie
         between 1 and 3. {\tt [2]}
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         The 2-d NDF containing input image to be cleaned.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         The NDF to contain the cleaned image.
      }
      \sstsubsection{
         THRESH( 2 ) = \_DOUBLE (Read)
      }{
         The range between which data values must lie if cleaning is to
         occur.  Thus it is possible to clean the background without
         removing the cores of images by a judicious choice of these
         thresholds.  If null, {\tt !}, is given, then there is no limit on
         the data range. {\tt [!]}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         The title of the output NDF.  A null ({\tt !}) value means using the
         title of the input NDF. {\tt ['KAPPA - Cleaner']}
      }
      \sstsubsection{
         WLIM = \_REAL (Read)
      }{
         If the input image contains bad pixels, then this parameter
         may be used to determine the number of good pixels which must
         be present within the smoothing box before a valid output
         pixel is generated.  It can be used, for example, to prevent
         output pixels from being generated in regions where there are
         relatively few good pixels to contribute to the smoothed
         result.

         By default, a null ({\tt !}) value is used for WLIM, which causes
         the pattern of bad pixels to be propagated from the input
         image to the output image unchanged. In this case, smoothed
         output values are only calculated for those pixels which are
         not bad in the input image.

         If a numerical value is given for WLIM, then it specifies the
         minimum fraction of good pixels which must be present in the
         smoothing box in order to generate a good output pixel.  If
         this specified minimum fraction of good input pixels is not
         present, then a bad output pixel will result, otherwise a
         smoothed output value will be calculated.  The value of this
         parameter should lie between 0.0 and 1.0 (the actual number
         used will be rounded up if necessary to correspond to at least
         1 pixel). {\tt [!]}
      }
   }
   \newpage
   \sstresparameters{
      \sstsubsection{
         SIGMA = \_DOUBLE (Write)
      }{
         The estimation of the RMS noise per pixel of the output image.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CLEANER DIRTY CLEAN $\backslash$
      }{
         The 2-d NDF called DIRTY is filtered such that pixels that
         deviate by more than three standard deviations from DIRTY's
         smoothed version are rejected.  Three iterations are performed.
         Each pixel in the smoothed image is the average of the
         neighbouring nine pixels. The filtered NDF is called CLEAN.
      }
      \sstexamplesubsection{
         CLEANER OUT=CLEAN IN=DIRTY THRESH=[-100,200]
      }{
         As above except only those pixels whose values lie between
         $-$100 and 200 can be cleaned.
      }
      \sstexamplesubsection{
         CLEANER POXY DAZED [2.5,2.8] [5,5]
      }{
         The 2-d NDF called POXY is filtered such that pixels that
         deviate by more than 2.5 then 2.8 standard deviations from
         POXY's smoothed version are rejected.  The smoothing is an
         average of a 5-by-5-pixel neighbourhood.
         The filtered NDF is called DAZED.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         This routine can process only 2-dimensional images.

         \sstitem
         This routine correctly processes the AXIS, DATA, QUALITY,
         LABEL, TITLE, VARIANCE and UNITS components of the input NDF.
         Processing of bad pixels and all non-complex numeric types is
         supported.  Arithmetic is performed using single-precision
         floating point, or double precision if appropriate.

         \sstitem
         The HISTORY component is simply propagated without change, if
         present.
      }
   }
}

\sstroutine{
   CMULT
}{
   Multiplies an NDF by a scalar
}{
   \sstdescription{
      This application multiplies each pixel of an NDF by a scalar
      (constant) value to produce a new NDF.
   }
   \sstusage{
      CMULT IN SCALAR OUT
   }
   \sstparameters{
      \sstsubsection{
         IN = NDF (Read)
      }{
         Input NDF structure whose pixels are to be multiplied by a
         scalar.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Output NDF structure.
      }
      \sstsubsection{
         SCALAR = \_DOUBLE (Read)
      }{
         The value by which the NDF's pixels are to be multiplied.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         A title for the output NDF. A null value will cause the title
         of the NDF supplied for parameter IN to be used instead.
         {\tt ['KAPPA - Cmult']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CMULT A 12.5 B
      }{
         Multiplies all the pixels in the NDF called A by the constant
         value 12.5 to produce a new NDF called B.
      }
      \sstexamplesubsection{
         CMULT IN=RAWDATA OUT=NEWDATA SCALAR=-19
      }{
         Multiplies all the pixels in the NDF called RAWDATA by $-$19 to
         give NEWDATA.
      }
   }
   \sstimplementationstatus{
      This routine correctly processes the AXIS, DATA, QUALITY, LABEL,
      TITLE, UNITS and VARIANCE components of an NDF and propagates all
      extensions. Bad pixels and all non-complex numeric types can be
      handled. Arithmetic is carried out using the appropriate
      floating-point type, but the numeric type of the input pixels is
      preserved in the output NDF.
   }
}

\sstroutine{
   COLUMNAR
}{
   Draws a perspective-histogram representatation of a 2-d NDF
}{
   \sstdescription{
      This application represents a 2-d NDF in the form of a 3-d
      histogram perspective view on the current graphics device.  The
      image may be part or whole of the data, variance or quality
      array.  It may be compressed in both dimensions to reduce noise
      and/or reduce the plotting time.  The image size is limited to
      100-by-100 pixels.  If the image is larger than this size it can
      be compressed so that it fits (the default), or clipped to plot
      no more than 100 pixels in either direction.

      Any viewing angle above the surface may be specified.  The axes
      may be labelled but not enumerated.  The plot is situated within
      the current graphics-database picture.
   }
   \sstusage{
      COLUMNAR NDF [COMP] [ELEVATION] [ORIENT] [BLOCK] [DISTANCE] [RANGE]
         [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         BLOCK = \_INTEGER (Read)
      }{
         The blocking factor used to average the image in both
         dimensions before it is plotted.  At least two pixels should
         remain in each dimension after blocking.  The value of the
         blocking is contrained between 1 and the smallest factor that
         would give two pixels in either direction.  A value of one
         will be the dynamic default when there is no need to compress,
         {\it i.e.}\ the image is less than 100-by-100 pixels. 
         {\tt [}The smallest value such that the image can fit within
         the 100-by-100 pixel constraint{\tt ]}
      }
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         True if the graphics device is to be cleared before display
         of the array. {\tt [TRUE]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be {\tt "Data"},
         {\tt "Quality"} or {\tt "Variance"}. {\tt ["Data"]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device. {\tt [}Current graphics device{\tt ]}
      }
      \sstsubsection{
         DISTANCE = \_DOUBLE (Read)
      }{
         The distance of the viewing point from the centre of the
         plotted grid in pixels.  If a non-perspective plot is required
         the distance should much larger than dimensions of the image,
         typically greater than 100 times.  If the distance is too
         small to generate a meaningful plot, a view from the zenith
         ({\it i.e.}\ 90-degree elevation) is produced. {\tt [}Five
         times the sum of the two dimensions of the image to be plotted
         divided by the absolute cosine of the angle of elevation{\tt ]}
      }
      \sstsubsection{
         ELEVATION = \_DOUBLE (Read)
      }{
         The angle of elevation of the viewer above the horizontal
         base plane in degrees. This must lie between 0 and 180. {\tt [30.]}
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         NDF structure containing the 2-d image to be displayed in a
         3-d perspective histogram.
      }
      \sstsubsection{
         ORIENT = \_DOUBLE (Read)
      }{
         The rotation of the vertical axis through the centre of the
         grid, in a clockwise direction, in degrees.  At zero degrees
         the $y$ axis of the image runs parallel with the $x$ axis of the
         display surface, and vice versa.  An example: for a rotation
         of 45 degrees and elevation angle is less than 90 degrees the
         furthest point is the lower bound, the $x$ axis goes to the left
         and the $y$ to the right, and the nearest point is the upper
         bound.  {\tt [45.]}
      }
      \sstsubsection{
         PXSIZE = \_REAL (Read)
      }{
         The length ($x$ axis) of the plot in metres. {\tt [}Maximum that can
         fit in the current picture whilst preserving square pixels{\tt ]}
      }
      \sstsubsection{
         PYSIZE = \_REAL (Read)
      }{
         The length ($y$ axis) of the plot in metres. {\tt [}Maximum that can
         fit in the current picture whilst preserving square pixels{\tt ]}
      }
      \sstsubsection{
         RANGE( 2 ) = \_DOUBLE (Read)
      }{
         The limits of the vertical range of data values in the surface
         plot, and may be given in either order.  This parameter can be
         useful for plotting a number of histograms at the same vertical
         point.  A null range or equal limits causes the plot to be scaled
         between the minimum and maximum values within the image.  Pixels
         with values above the upper limit are truncated to the upper limit,
         and those below the lower limit are set to that limit. {\tt [!]}
      }
      \sstsubsection{
         RESOLUTION = \_REAL (Read)
      }{
         The resolution factor. The actual plotting resolution is this
         times the $x$ and $y$ theoretical resolutions in world
         co-ordinates. In GKS whether or not a given `lamp' is
         illuminated or pen position is marked with ink cannot be
         determined, so a factor of unity is too small for the most
         efficient processing.  It must lie between 2.0 and 10.0. {\tt [2.0]}
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB  =  LITERAL (Read)
      }{
         Label for the plot abscissa.  Only the first 50 characters will
         be plotted.  If axis information is present the suggested
         default is the NDF's axis label followed by the units, in
         parentheses.  If an error occurs obtaining the label the
         suggested default is {\tt "X"}. {\tt []}
      }
      \sstsubsection{
         ORDLAB  =  LITERAL (Read)
      }{
         Label for the plot ordinate.  Only the first 50 characters will
         be plotted.   If axis information is present the suggested
         default is the NDF's axis label followed by the units, in
         parentheses.  If an error occurs obtaining the label the
         suggested default is {\tt "Y"}.  {\tt []}
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of the plot.  Up to about 30 characters can be
         accommodated.  If an error occurs obtaining the title, it is
         defaulted to {\tt "Perspective Plot"}.
         {\tt [}The NDF's title{\tt ]}
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the axes and annotations in the plot, where
         1.0 is the normal thickness. Currently, this is only available
         on a few devices.  It must take a value in the range 0.5--5.0.
         {\tt [1.0]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         COLUMNAR MYFILE
      }{
         Draws a perspective histogram of the data array in the NDF
         called MYFILE on the current graphics device.  If MYFILE has
         more than 100 pixels in either $x$ and $y$ it will be compressed.
         All other settings are defaulted.
      }
      \sstexamplesubsection{
         COLUMNAR MYFILE V
      }{
         Draws a perspective histogram of the variance array in the NDF
         called MYFILE on the current graphics device.  If MYFILE has
         more than 100 pixels in either $x$ and $y$ it will be compressed.
         All other settings are defaulted.
      }
      \sstexamplesubsection{
         COLUMNAR MYFILE(10:73,16:55)
      }{
         Draws a perspective histogram of part of the data array in the
         NDF called MYFILE on the current graphics device.  The part
         lies between pixel (10,16) and (73,55), {\it i.e.}\ 64 pixels in 
         $x$ and 40 in $y$.  All other settings are defaulted, so there is no
         compression.
      }
      \sstexamplesubsection{
         COLUMNAR MYFILE(10:73,3,16:55) BLOCK=2
      }{
         Draws a perspective histogram of part of the data array cube
         in the NDF called MYFILE on the current graphics device.  The
         part lies in the plane with $y$ index 3 between pixel (10,3,16)
         and (73,3,55), {\it i.e.}\ 64 pixels in $x$ and 40 in $z$, but it is
         compressed to 32-by-20 pixels for plotting.
      }
      \sstexamplesubsection{
         COLUMNAR NDF=MYFILE COMP=V ABSLAB=R.A. ORDLAB=Dec. PLTITL=Variance
      }{
         Draws a perspective histogram  of the variance array in the
         NDF called MYFILE on the current graphics device.  If MYFILE
         has more than 100 pixels in either $x$ and $y$ it will be
         compressed.  The axis labels are {\tt "R.A."} and {\tt "Dec."} rather
         than {\tt "X"} and {\tt "Y"}, and the title is {\tt "Variance"}.
      }
      \sstexamplesubsection{
         COLUMNAR NDF=MYFILE ELEVATION=60 ORIENT=135 RANGE=[100,500]
      }{
         Draws a perspective histogram of the data array in the NDF
         called MYFILE on the current graphics device.  If MYFILE has
         more than 100 pixels in either $x$ and $y$ it will be compressed.
         The orientation angle is adjusted by 90 degrees clockwise from
         the default; and the viewing angle is twice the default, thus
         appearing to been observed from nearer the zenith.  The plot
         is scaled so the highest peak is 500 and the base is at 100.
         All other settings are defaulted.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application stores a number of pictures in the graphics
         database in the following order: a FRAME of the specified size
         containing the title, and plot; and a DATA picture, which is
         currently stored with world co-ordinates of a unit square for the
         plot itself.  The NDF associated with the plot is stored by
         reference with the DATA picture.  On exit the current database
         picture for the chosen device reverts to the input picture.

         \sstitem
         For certain shaped images, particularly highly oblong ones,
         there may be no compression factor that enables the whole of
         the image to be plotted.  The application plots as much as it can
         in these circumstances.
      }
   }
   \sstdiytopic{
      Timing
   }{
      On slow graphics devices the timing is approximately proportional
      to the number of pixels to plot after blocking, plus a second
      small term depending on the original image size.  However, on fast
      graphics devices the latter term becomes more important, and
      blocking may increase the elapsed time slightly.  If there are bad
      pixels present the elapse time will increase, but this is hardly
      noticeable on slow devices.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Only real data can be processed directly.  Other data types
         will undergo a type conversion before the perspective plot is
         drawn.

         \sstitem
         Magic-value bad pixels cannot be plotted so should the image
         contain any, they are removed first by median filtering of the
         eight neighbouring pixels; if any remain they are set to the
         minimum value within the image.  If other bad-removal strategies
         are required these must be performed before calling this
         application.

         \sstitem
         This application calls a NAG routine.  Since this must have a
         double-precision data array free from magic-value pixels, extra
         processing and data copying is required more than doubling the
         time required by a bespoke subroutine.
      }
   }
}

\manroutine {{\manheadstyle{COMPADD}}}{ Reduces the size of a 2-d data array
  by adding neighbouring pixels.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes a 2-d data array in an input {\mantt{IMAGE}} structure
  and reduces it in size by adding together square neighbourhoods
  containing a specified number of pixels from the input array,
  each neighbourhood forming one new pixel in the output data array.
  The output data array is stored in a new {\mantt{IMAGE}} structure. If a
  given box contains more than a prescribed fraction of bad pixels,
  the resultant pixel is bad.  The magic-value method is used for
  processing bad data.

\manroutineitem {Invocation }{}
  COMPADD

\newpage
\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the data array to be reduced in
  size.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing modified, smaller version
  of the array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Compadd']}
\manparameterentry {{\mantt{READ}} }{{\mantt{COMPRESS}} }{{\mantt{\_INTEGER}}}
  Linear compression factor to be used to create the new data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMVAL}} }{{\mantt{\_INTEGER}}}
  Minimum number of valid pixels to be used to compute a valid
  output pixel. \mbox{\mantt [\%COMPRESS]}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{COMPAVE}}}{ Reduces the size of a 2-d data array
  by averaging neighbouring pixels.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes a 2-d data array in an input {\mantt{IMAGE}} structure
  and reduces it in size by averaging square neighbourhoods
  containing a specified number of pixels from the input array,
  each neighbourhood forming one new pixel in the output data array.
  The output data array is stored in a new {\mantt{IMAGE}} structure. If a
  given box contains more than a prescribed fraction of bad pixels,
  the resultant pixel is bad.  The magic-value method is used for
  processing bad data.

\manroutineitem {Invocation }{}
  COMPAVE

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the data array to be reduced in
  size.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing modified, smaller version
  of the array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Compave']}
\manparameterentry {{\mantt{READ}} }{{\mantt{COMPRESS}} }{{\mantt{\_INTEGER}}}
  Linear compression factor to be used to create the new data
  array.
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMVAL}} }{{\mantt{\_INTEGER}}}
  Minimum number of valid pixels to be used to compute a valid
  output pixel. \mbox{\mantt [\%COMPRESS]}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{COMPICK}}}{ Reduces the size of a 2-d data array
  by picking every {$n^{\rm th}$} pixel.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes a 2-d data array in an input {\mantt{IMAGE}} structure
  and reduces it in size by defining a series of boxes in the input
  array, and picking one pixel from that box to become a new pixel
  in the output data array. The output data array is stored in a
  new {\mantt{IMAGE}} structure.

\manroutineitem {Invocation }{}
  COMPICK

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the data array to be reduced in
  size.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure to contain modified, smaller version of the
  data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Compick']}
\manparameterentry {{\mantt{READ}} }{{\mantt{COMPRESS}} }{{\mantt{\_INTEGER}}}
  Linear compression factor to be used to create the new array,
  {\it i.e.}\ {$n$}.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{COMPRESS}}}{ Reduces the size of a 2-d data array
  by averaging neighbouring pixels by different amounts in {$x$} and {$y$}.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes a 2-d data array in an input {\mantt{IMAGE}} structure
  and reduces it in size by averaging rectangular neighbourhoods
  containing a specified number of pixels from the input array,
  each neighbourhood forming one new pixel in the output data array.
  The integer compression factor may be different for the {$x$} and {$y$}
  dimensions. The output data array is stored in a new {\mantt{IMAGE}}
  structure. If a given box contains more than a prescribed fraction
  of bad pixels, the resultant pixel is bad.  The magic-value method
  is used for processing bad data.

\manroutineitem {Invocation }{}
  COMPRESS

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the data array to be reduced in
  size.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing modified, smaller version
  of the array.
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Compress']}
\manparameterentry {{\mantt{READ}} }{{\mantt{XCMPRS}} }{{\mantt{\_INTEGER}}}
  Linear compression factor to be used in {$x$} dimension.
\manparameterentry {{\mantt{READ}} }{{\mantt{YCMPRS}} }{{\mantt{\_INTEGER}}}
  Linear compression factor to be used in {$y$} dimension.
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMVAL}} }{{\mantt{\_INTEGER}}}
  Minimum number of valid pixels to be used to compute a valid
  output pixel. \mbox{\mantt [MAX(\%XCMPRS,\%YCMPRS)]}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

 
 
\sstroutine{
   CONTOUR
}{
   Contours a 2-d NDF
}{
   \sstdescription{
      This application contours an image of a 2-d NDF on the current
      graphics device.  The image may be part or whole of the data
      array, but also the variance or quality can be shown.  The plot
      is situated within the current graphics-database picture.

      The contour plot resides within optional, annotated and enumerated
      axes.  An optional, but recommended, key may be drawn to the
      right of the contour plot.  It reports the NDF's units if there
      are any, and only contour heights actually plotted are included.
      There are five methods for selecting contours.

      The contouring algorithm has a choice of single-pixel
      or sub-pixel resolution.  The former does not give smooth
      contours, but this makes the processing much faster.  The latter
      draws smooth contours to the resolution of the graphics
      workstation. The curve drawing between pixels may be achieved by
      one of two methods: Butland's or McConalogue's.
   }
   \sstusage{
      CONTOUR NDF [COMP] MODE NCONT [KEY] [DEVICE] [SMOOTHING]
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                    FIRSTCNT=? STEPCNT=? \\
                    HEIGHTS=?
                   \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small mode}
   }
   \sstparameters{
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         True if the graphics device is to be cleared before display
         of the array. {\tt [TRUE]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be {\tt "Data"},
         {\tt "Quality"} or {\tt "Variance"}. {\tt ["Data"]}
      }
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either {\tt "WORLD"}
         or {\tt "DATA"}.  {\tt "WORLD"} makes pixel co-ordinates to appear on axes.
         If COSYS = {\tt "DATA"} the NDF's axis information is used to
         annotate axes.  {\tt [}Current co-ordinate system{\tt ]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device. {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         FIRSTCNT = \_REAL (Read)
      }{
         Height of the first contour (Linear and Magnitude modes).
      }
      \sstsubsection{
         HEIGHTS() = \_REAL (Read)
      }{
         Contour levels (Free mode).
      }
      \sstsubsection{
         KEY = \_LOGICAL (Read)
      }{
         A key of the contour level versus pixel value is to be
         produced. {\tt [TRUE]}
      }
      \sstsubsection{
         MAXRES = \_LOGICAL (Read)
      }{
         If true the contours are interpolated to the resolution of the
         plotting device, {\it i.e.}\ provides sub-pixel resolution, otherwise
         straight-line segments at pixel resolution are drawn. {\tt [FALSE]}
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The type of method to selected contour levels.  The options
         are :
         \begin{description}
           \item [Free]      - The user defines a series of contour values.
           \item [Automatic] - The specified number of contours are equally
                         spaced between the maximum and minimum pixel
                         values in the sub-array.
           \item [Area]      - Contours enclose areas of the sub-array for
                         which the equivalent radius increases by equal
                         increments.
           \item [Linear]    - The user defines the number of contours, the
                         start contour level and linear step
                         between contours.
           \item [Magnitude] - The user defines the number of contours, the
                         start contour level and step between contours.
                         The step size is in magnitudes so the $n^{\rm th}$
                         contour is 10$^{-0.4*(n-1)*{\rm step}}$ times the
                         start contour level.
         \end{description}
      }
      \sstsubsection{
         NCONT = \_INTEGER (Read)
      }{
         The number of contours required (all modes except Free). Must
         be between 1 and 50.  If this is large, the plot may be
         cluttered and take longer to produce. 6, the suggested default,
         gives reasonable results.
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         NDF structure containing the 2-d image to be contoured.
      }
      \sstsubsection{
         PXSIZE = \_REAL (Read)
      }{
         The length ($x$ axis) of the plot in metres. {\tt [}Maximum that can
         fit in the current picture whilst preserving square pixels{\tt ]}
      }
      \sstsubsection{
         PYSIZE = \_REAL (Read)
      }{
         The length ($y$ axis) of the plot in metres. {\tt [}Maximum that can
         fit in the current picture whilst preserving square pixels{\tt ]}
      }
      \sstsubsection{
         RESOLUTION = \_REAL (Read)
      }{
         The resolution factor. The actual plotting resolution is this
         times the $x$ and $y$ theoretical resolutions in world
         co-ordinates. In GKS whether or not a given `lamp' is
         illuminated or pen position is marked with ink cannot be
         determined, so a factor of unity is too small for the most
         efficient processing.  It must lie between 2.0 and 10.0. {\tt [2.0]}
      }
      \sstsubsection{
         SMOOTHING = LITERAL (Read and Write)
      }{
         The method to be used to smooth the contours.  The
         alternatives are {\tt "Butland"} or {\tt "McConalogue"}.
         Butland's method
         hardly ever produces crossing contours because it forms tighter
         curves with no unnecessary fluctuations.  McConalogue's method
         gives more chance of crossed contours, but does give
         free-flowing contours that generally look better than those
         derived by the Butland algorithm.  Users should experiment with
         their particular data to determine which gives better results.
         {\tt ["Butland"]}
      }
      \sstsubsection{
         STEPCNT = \_REAL (Read)
      }{
         Separation between contour levels, linear for Linear mode
         and in magnitudes for Magnitude mode.
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB  =  LITERAL (Read)
      }{
         Label for the plot abscissa, in which NCAR fancy founts may be
         embedded when FONT = {\tt "NCAR"}.  If axis information is present the suggested
         default is the NDF's axis label followed by the units, in
         parentheses.  If an error occurs obtaining the label the
         suggested default is {\tt "X"}. {\tt []}
      }
      \sstsubsection{
         ANNOTA = \_LOGICAL (Read)
      }{
         If true the contour lines will be annotated with a contour
         number corresponding to the key entry.  If maximum resolution
         is selected then this parameter is ignored, since all lines
         will be annotated. It is also ignored if there is no key.
         {\tt [FALSE]}
      }
      \sstsubsection{
         AXES = \_LOGICAL (Read)
      }{
         True if labelled and annotated axes are to be drawn around the
         contour plot.  The annotations are either the data
         co-ordinates from the NDF axis components, provided these are
         present and linear and COSYS = {\tt "DATA"}; otherwise pixel
         co-ordinates are used.  {\tt [TRUE]}
      }
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         {\tt "NCAR"} for the NCAR fancy characters and {\tt "GKS"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value. {\tt ["GKS"]}
      }
      \sstsubsection{
         LABELFREQ = \_INTEGER (Read)
      }{
         The frequency with which contour levels are annotated. 1 means
         every level will be labelled.  This may be excessive in
         plots where the contours are closely packed. This is ignored
         unless contour annotation has been selected. It must be between
         1 and the number of contour heights. {\tt [1]}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the numbers of major tick marks
         for the $x$ and $y$ axes.  (Number used is between MAJTIC$+$2 and
         5$*$MAJTIC/2$+$4.) {\tt [3.,3.]}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark
         for the $x$ and $y$ axes.  A negative value forces the graphics
         package to compute appropriate values. {[-1.,-1.]}
      }
      \sstsubsection{
         NOISY = \_LOGICAL (Read)
      }{
         If true the contour lines will alternately be annotated with
         a contour number corresponding to the key entry, but at
         twice the frequency. It is ignored unless annotated contours
         have been selected. {\tt [FALSE]}
      }
      \sstsubsection{
         ORDLAB  =  LITERAL (Read)
      }{
         Label for the plot ordinate, in which NCAR fancy founts may be
         embedded when FONT = {\tt "NCAR"}.  If axis information is present the suggested
         default is the NDF's axis label followed by the units, in
         parentheses.  If an error occurs obtaining the label the
         suggested default is {\tt "Y"}. {\tt []}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         True if the axis tick marks are to appear on the outside of
         the axes instead of inside. By default, the tick marks are
         drawn outside the contouring region to eliminate
         intersections of ticks with the contours. {\tt [TRUE]}
      }
      \sstsubsection{
         PENROT = \_LOGICAL (Read)
      }{
         If true the plotting pens are cycled through the contours to
         aid identification of the contour heights.  It is ignored
         when annotation is selected. {\tt [FALSE]}
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of the plot.  Up to about 40 characters can be
         accommodated, and NCAR fancy founts may be embedded
          when FONT = {\tt "NCAR"}. If an error
         occurs obtaining the title, it is defaulted to {\tt "Contour plot"}.
         {\tt [}The NDF title{\tt ]}
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the axes and annotations in the plot, where
         1.0 is the normal thickness. Currently, this is only available
         on a few devices.  It must take a value in the range 0.5--5.0.
         {\tt [1.0]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CONTOUR MYFILE D $\backslash$
      }{
         Contours the data array in the NDF called MYFILE on the current
         graphics device.  All other settings are defaulted, so for
         example coarse contours are drawn, using the current mode for
         determining heights, and a key is plotted.
      }
      \sstexamplesubsection{
         CONTOUR TAURUS1(100:199,150:269,4) $\backslash$
      }{
         Contours a 2-dimensional portion of current array component in
         the NDF cube called TAURUS1 on the current graphics device.
         The portion extends from pixel (100,150,4) to pixel
         (199,269,4).  All other settings are defaulted, so for example
         coarse contours are drawn, using the current mode for
         determining heights, and a key is plotted.
      }
      \sstexamplesubsection{
         CONTOUR NDF=NGC6872 MODE=AU NCONT=5 MAXRES
      }{
         Contours the data array in the NDF called NGC6872 on the
         current graphics device. Five equally spaced contours between
         the maximum and minimum data values are drawn.  The contours
         are smoothed using Butland's method. The NDF's title adorns
         the plot. A key is plotted.
      }
      \sstexamplesubsection{
         CONTOUR NDF=NGC6872 MODE=AU NCONT=5 ANNOTA LABELFREQ=2 COSYS=W
      }{
         As above. In addition the contours are annotated at
         alternate heights, but not smoothed.  The axes have pixel
         co-ordinates.
      }
      \sstexamplesubsection{
         CONTOUR NDF=NGC6872 MODE=AU NCONT=5 ANNOTA LABELFREQ=2 PENROT
      }{
         As above. In addition the appearance of the contours cycles
         every third contour, and again the contours are not smoothed.
      }
      \sstexamplesubsection{
         CONTOUR NGC6872 MODE=LI FIRSTCNT=10 STEPCNT=2 NCONT=5 NOAXES
      }{
         Contours the data array in the NDF called NGC6872 on the
         current graphics device.  Four contours at heights 10, 12, 14,
         and 16 are drawn. A key is plotted, but no axes surround the
         contour plot.
      }
      \sstexamplesubsection{
         CONTOUR COMP=D NOKEY $\backslash$
      }{
         Contours the portion of the data array in the current NDF on
         the current graphics device using the current method for height
         selection. The NDF' title is the plot's title.  No key is
         drawn.
      }
      \sstexamplesubsection{
         CONTOUR COMP=V MODE=FR HEIGHTS=[10,20,40,80] TITLE=Variance
      }{
         Contours the variance array in the current NDF on the
         current graphics device.  Contours at 10, 20, 40 and 80 are
         drawn. {\tt "Variance"} is the title of the plot.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application stores a number of pictures in the graphics
         database in the following order: a FRAME of the specified size
         containing the title, annotated axes, contours and key; a DATA
         picture which is stored with world co-ordinates in units of data
         pixels; and a KEY picture to store the key if present.  The DATA
         picture also may have double-precision data co-ordinates derived
         from the NDF axis components provided these are linear and
         different from pixel co-ordinates; the data co-ordinates are
         stored via a linear transformation.  The NDF associated with the
         plot is stored by reference with the DATA picture.  On exit the
         current database picture for the chosen device reverts to the
         input picture.

         \sstitem
         There are some options for setting the characteristics of the
         contour lines.  By default, solid lines are drawn with the first
         (default) SGS pen, usually white or black depending on the
         graphics device selected.  There are alternatives to override
         this default behaviour. For each contour height actually used,
         the application can either:
        \begin{enumerate}
         \item cycle the pens (modulo 3), or
         \item annotate the contours using the number of the contour 
               height corresponding to the key entries rather than the
               values themselves.  The frequency of labelling may be defined.
               Clearly, the key option must be chosen in conjunction with
               annotated contours.
         \end{enumerate}
         Should both be selected, annotation takes precedence.  The
         characteristics of the second and third line styles in option 1
         will depend on the chosen graphics device. An image display or
         pen plotter will draw coloured lines, whereas a laser printer or
         monochrome terminal will draw a variety of dashed or thicker
         lines.  The second is not recommended should the data array have
         a large number of bad pixels, or if the contours are closely
         packed. There is an additional parameter to select double
         annotations for short or noisy contours in option 2.
      }
   }
   \sstdiytopic{
      References
   }{
      \begin{refs}
      \item  Butland, J. 1980 ``A method of interpolating reasonably shaped
      curves through any data.''  {\it Proc. Computer Graphics} {\bf 80}, 409.

      \item  McConalogue, D.J. 1970 ``A quasi-intrinsic scheme for passing a
      smooth curve through a discrete set of points.'' {\it Computer J.}
      {\bf 13}, 392.

      \end{refs}
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Only real data can be processed directly.  Other data types
         will undergo a type conversion before the contour plot is drawn.

         \sstitem
         Magic-value bad pixels are ignored when the pens are cycled; in
         all other cases they are removed by a median filter, and should
         any remain they take the minimum value in the chosen sub-array.

         \sstitem
         The smoothed or annotated contouring options use a NAG routine.
         Since this must have a double-precision data array free from
         magic-value pixels, extra processing and data copying is required
         more than doubling the time required by a bespoke subroutine.
      }
   }
}
 
 
\sstroutine{
   CONTOVER
}{
   Contours a 2-d NDF overlaid on an image displayed previously
}{
   \sstdescription{
      This application draws a contour plot of a 2-d NDF on the current
      graphics device using an efficient algorithm.  The array may be
      part or whole of the data array, but also the variance or quality
      can be shown.

      The contour plot is drawn over an existing image that is
      displayed on the chosen graphics workstation or its overlay,
      provided the displayed image has been recorded in the graphics
      database. (This will be the case for other display routines in
      KAPPA.)  The contour plotting occurs within the current picture
      only if it is a DATA picture, otherwise contours are overlaid in
      the last DATA picture within the current picture.  This
      application assumes that the world co-ordinate systems of the data
      array and the displayed image are both in pixel units, but not to
      the same origins.  Pixel $x$-$y$ offsets may be given to match the
      contour plot with the image, provided some contouring will be
      visible.  These displacements are in the sense image co-ordinate
      minus the data-array co-ordinate for an arbitrary fiducial point.

      The contouring algorithm has only pixel resolution, and
      so the contours are not smooth, but this makes the processing
      much faster.  There are five methods for selecting contours.

      The best way to use this application is to first display an image
      on the base plane of an image display, make this the current
      picture, and then plot contours on the overlay plane, clearing
      the overlay picture each time. This enables more than one attempt
      at getting the correct contour heights.  The underlying image will
      not be erased. (Note that if you do not make the underlying image
      the current picture, the contour plot becomes the last DATA
      picture, and so any subsequent $x$-$y$ offsets should be set to 0,0 to
      prevent successive contour plots being incorrectly located.)
   }
   \sstusage{
      CONTOVER NDF [COMP] OFFSET MODE NCONT [DEVICE]
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                    FIRSTCNT=? STEPCNT=? \\
                    HEIGHTS=?
                   \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small mode}
   }
   \sstparameters{
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         True if the graphics device is to be cleared before display
         of the array. It should only be true for an overlay device.
         {\tt [TRUE]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be {\tt "Data"},
         {\tt "Quality"} or {\tt "Variance"}. {\tt ["Data"]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device. The device must be in one of the following
         GNS categories: IMAGE\_DISPLAY, IMAGE\_OVERLAY, WINDOW or
         WINDOW\_OVERLAY.
         {\tt [}Current image-display-overlay device{\tt ]}
      }
      \sstsubsection{
         FIRSTCNT = \_REAL (Read)
      }{
         Height of the first contour (Linear and Magnitude modes).
      }
      \sstsubsection{
         HEIGHTS() = \_REAL (Read)
      }{
         Contour levels (Free mode).
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The type of method to selected contour levels.  The options
         are:
         \begin{description}
           \item [Free]      - The user defines a series of contour values.
           \item [Automatic] - The specified number of contours are equally
                         spaced between the maximum and minimum pixel
                         values in the sub-array.
           \item [Area]      - Contours enclose areas of the sub-array for
                         which the equivalent radius increases by equal
                         increments.
           \item [Linear]    - The user defines the number of contours, the
                         start contour level and linear step
                         between contours.
           \item [Magnitude] - The user defines the number of contours, the
                         start contour level and step between contours.
                         The step size is in magnitudes so the $n^{\rm th}$
                         contour is 10$^{-0.4*(n-1)*{\rm step}}$ times the
                         start contour level.
         \end{description}
      }
      \sstsubsection{
         NCONT = \_INTEGER (Read)
      }{
         The number of contours required (all modes except Free). Must
         be between 1 and 50.  If this is large, the plot may be
         cluttered and take longer to produce. 6, the suggested default,
         gives reasonable results.
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         NDF structure containing the 2-d image to be contoured.
      }
      \sstsubsection{
         OFFSET( 2 ) = \_INTEGER (Read)
      }{
         $x$-$y$ offsets of the input data-array with respect to the
         displayed image ({\it i.e.}\ $x_{\rm data} - x_{\rm image}$
         followed by $y_{\rm data} - y_{\rm image}$ for any fiducial
         point).   These are
         constrained so that some part of the contour plot will be
         overlaid on the displayed image.  The suggested default is
         [0,0], {\it i.e.}\ no shift.
      }
      \sstsubsection{
         PENROT = \_LOGICAL (Read)
      }{
         If true the plotting pens are cycled through the contours to
         aid identification of the contour heights.  It is ignored
         when annotation is selected. {\tt [FALSE]}
      }
      \sstsubsection{
         STEPCNT = \_REAL (Read)
      }{
         Separation between contour levels, linear for Linear mode
         and in magnitudes for Magnitude mode.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CONTOVER MYFILE D [-20,7] $\backslash$
      }{
         Contours the data array in the NDF called MYFILE on the current
         image-display overlay device; the overlay is displaced such
         that pixel ($i$,~$j$) in MYFILE corresponds to pixel
         ($i-20$,~$j+$7) in
         the displayed image.  All other settings are defaulted, so for
         example the current method for determining heights is used,
         and as much of MYFILE will be contoured that fits into the
         current picture.
      }
      \sstexamplesubsection{
         CONTOVER IN=NGC6872 MODE=AU NCONT=5 OFFSET=[0,0]
      }{
         Contours the data array in the NDF called NGC6872 on the
         current image-display overlay device.  Five equally spaced
         contours between the maximum and minimum data values are
         drawn.  There is no offset between the contour plot and the
         displayed image; this can be useful for comparing an NDF
         before and after some processing, {\it e.g.}\ smoothing.
      }
      \sstexamplesubsection{
         CONTOVER IRAS60(200:300,100:350) COMP=D OFFSET=[3,5] $\backslash$
      }{
         Contours the portion of the data array in the NDF called IRAS60
         on the current image-display overlay using the current method
         for height selection.  The maximum portion of the data array
         that can be contoured goes from pixel (200,100) to (300,350).
         The overlay is displaced such that pixel ($i$,~$j$) in the
         data array corresponds to pixel ($i+$3,~$j+$5) in the displayed
         image.
      }
      \sstexamplesubsection{
         CONTOVER COMP=V MODE=FR HEIGHTS=[10,20,40,80] DEVICE=IKONOV $\backslash$
      }{
         Contours the variance array in the current NDF on the
         IKONOV device. Contours at 10, 20, 40 and 80 are
         drawn.  There is no displacement between the variance contour
         plot and the displayed image.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         -  The application records the contour plot as a DATA picture
         with world co-ordinates in units of data pixels in the graphics
         database.  The DATA picture may also may have double-precision
         data co-ordinates derived from the NDF axis components provided
         these are linear and different from pixel co-ordinates; the data
         co-ordinates are stored via a linear transformation.  The NDF
         associated with the plot is stored by reference with the DATA
         picture.  On exit the current database picture for the chosen
         device reverts to the input picture.
         picture for the chosen device reverts to the input picture.

         \sstitem
         There is one option for setting the attribute of the contour
         lines.  By default, solid lines are drawn with the first
         (default) SGS pen, usually white or black depending on the
         graphics device selected.  The alternative is to cycle the pens
         (modulo 3) for each contour height actually used.  The
         characteristics of the second and third line styles will depend on
         the chosen graphics device. An image display or pen plotter will
         draw coloured lines, whereas a laser printer or monochrome
         terminal will draw a variety of dashed or thicker lines.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Only real data can be processed directly.  Other data types
         will undergo a type conversion before the contour plot is drawn.

         \sstitem
         Bad pixels and QUALITY are supported.
      }
   }
}

\manroutine {{\manheadstyle{CREFRAME}}}{ Generate a test 2-d data array from a
  selection of several types.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine allows the user to generate several different types
  of 2-d data array for test purposes. The data array in written to
  a output {\mantt{IMAGE}} structure.  The types of array are summarised as
  follows:

\begin{mandescription}
\mandescriptionitem {Random}  - between 0 and 1, or specified limits
\mandescriptionitem {Constant} - 0 or at a specified value
\mandescriptionitem {Noisy}  - Poissonian or Gaussian noise about a
  specified mean
\mandescriptionitem {Ramped}  - between specified minimum and maximum values
  and a choice of four directions
\mandescriptionitem {Gaussian} - a random distribution of 2-d Gaussians of
  defined FWHM and range of maximum peak values on a specified
  background, with optional invalid pixels and bad column. There is a
  choice of distributions for the Gaussians fixed, or inverse square
  radially from the array centre. (In essence it is equivalent to a
  simulated star field.) The {$x$}-{$y$} position and peak
  value of each Gaussian may be stored in a Fortran
  formatted file, or reported to the user. Magic-value bad
  data may be included randomly, and/or in a column or line of the array.
\end{mandescription}

  The maximum size of generated array is 4096{$\times$}4096 pixels,
  though generally test data should be much smaller.

\manroutineitem {Invocation }{}
  CREFRAME

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure for the generated data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Creframe']}
\manparameterentry {{\mantt{READ}} }{{\mantt{IDIMS}}  }{{\mantt{\_INTEGER}}}
  {$x$} and {$y$} dimensions of the output data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{TYPED}}  }{{\mantt{\_CHAR}}}
  Type of data to be generated. The options are {\mantt{GS}} --- Gaussian;
  {\mantt{RR}} --- random 0 -- 1; {\mantt{RP}} --- random Poisson noise
  about mean; {\mantt{RL}} --- random with set limits;
  {\mantt{FL}} --- flat;   {\mantt{BL}} --- zeroes;
  {\mantt{RA}} --- ramps; and {\mantt{GN}} --- Gaussian noise about mean.
\manparameterentry {{\mantt{READ}} }{{\mantt{HIGH}}  }{{\mantt{\_REAL}}}
  High value used in the generated data array.
   ({\mantt{RA}} and {\mantt{RL}} types)
\manparameterentry {{\mantt{READ}} }{{\mantt{LOW}}  }{{\mantt{\_REAL}}}
  Low value used in the generated data array.
   ({\mantt{RA}} and {\mantt{RL}} types)
\manparameterentry {{\mantt{READ}} }{{\mantt{DIRN}}  }{{\mantt{\_INTEGER}}}
  Direction of the ramp. 1 means left to right, 2 is right to
  left, 3 is bottom to top, and 4 is top to bottom.
  ({\mantt{RA}} type)
\manparameterentry {{\mantt{READ}} }{{\mantt{MEAN}}  }{{\mantt{\_REAL}}}
  Mean value used in the generated data array.
  ({\mantt{FL}} and {\mantt{RP}} types)
\manparameterentry {{\mantt{READ}} }{{\mantt{SIGMA}}  }{{\mantt{\_REAL}}}
  Standard deviation of noise to be used in the generated data
  array. ({\mantt{GS}} type)
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{MAX}}  }{{\mantt{\_REAL}}}
  Peak Gaussian intensity to be used in the generated data array.
 ({\mantt{GS}} type)
\manparameterentry {{\mantt{READ}} }{{\mantt{MIN}}  }{{\mantt{\_REAL}}}
  Lowest Gaussian intensity to be used in the generated data array.
 ({\mantt{GS}} type)
\manparameterentry {{\mantt{READ}} }{{\mantt{BACKGROUND}}  }{{\mantt{\_REAL}}}
  Background intensity to be used in the generated data array.
 ({\mantt{GS}} type)
\manparameterentry {{\mantt{READ}} }{{\mantt{NGAUSS}}  }{{\mantt{\_INTEGER}}}
  Number of Gaussian star-like images to be generated. ({\mantt{GS}} type)
\manparameterentry {{\mantt{READ}} }{{\mantt{SEEING}}  }{{\mantt{\_REAL}}}
  Seeing FWHM in pixels ({\em not} the same as the standard
  deviation). ({\mantt{GS}} type)
\manparameterentry {{\mantt{READ}} }{{\mantt{DISTRIB}}  }{{\mantt{\_CHAR}}}
  Radial distribution of the Gaussians to be used; alternatives
  weightings are {\mantt{FIX}} {\mantt{=}} fixed distance; and
  {\mantt{RSQ}} {\mantt{=}} {${1\over r^2}$}. ({\mantt{GS}} type)
  \mbox{\mantt ['FIX']}
\manparameterentry {{\mantt{READ}} }{{\mantt{BADPIX}}  }{{\mantt{\_LOGICAL}}}
  Whether or not bad pixels are to be included.  ({\mantt{GS}} type)
  \mbox{\mantt [FALSE]}
\manparameterentry {{\mantt{READ}} }{{\mantt{FRACTION}} }{{\mantt{\_REAL}}}
  Fraction of bad pixels to be included. ({\mantt{GS}} type)
  \mbox{\mantt [0.01]}
\manparameterentry {{\mantt{READ}} }{{\mantt{BADCOL}}  }{{\mantt{\_LOGICAL}}}
  Whether or not a bad column is to be included. ({\mantt{GS}} type)
  \mbox{\mantt [FALSE]}
\manparameterentry {{\mantt{READ}} }{{\mantt{SCREEN}}  }{{\mantt{\_LOGICAL}}}
  True if the Gaussian parameters are reported to the user. ({\mantt{GS}} type)
  \mbox{\mantt [FALSE]}
\manparameterentry {{\mantt{READ}} }{{\mantt{FILENAME}} }{{\mantt{\_CHAR}}}
  Filename for the output of the Gaussian parameters.  ({\mantt{GS}} type)
  \mbox{\mantt [!]}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

 
\sstroutine{
   CRELUT
}{
   Creates or manipulates an image-display lookup table using a
   palette
}{
   \sstdescription{
      This application allows a lookup table to be created or modified
      interactively on a chosen image display from a palette of
      colours.  All plotting is performed within the current
      graphics-database picture for that device.  The phases in the
      creation or manipulation of the lookup table are:
      \begin{enumerate}
      \item The initial colour table is read from an NDF lookup-table file
         or a greyscale used if there is no input lookup table.
      \item The name of an NDF containing a 2-d array is obtained and the
         array is scaled and displayed in the top half of the picture
         at the largest magnification without distortion.  Below this an
         histogram of the values between the scaling limits is drawn
         with the colour index of each bin corresponding to the bin's
         scaled value. Thus colours in the image and the histogram
         match.   Axes of number versus data value are plotted about
         the histogram. If a null character, {\tt !}, is given then no NDF
         array is read and a ramp is produced instead of the histogram.
         An axis of pen numbers in the lookup table is drawn around the
         ramp.
      \item A numbered palette is drawn below the histogram.  A palette
         created in an earlier run of CRELUT may be restored from an
         NDF.  Otherwise the palette comprises eight coloured blocks
         (black, white, red, green, blue, yellow, magenta and cyan)
         with palette numbers 0--7, an eight-level greyscale (8--15)
         and a sixteen-level greyscale (16--31).  Palette numbers
         16--31 may be replaced randomly by user-defined colours.  The
         colours are specified by either the giving the red, green, blue
         intensities; or by name.  The loop is terminated by a null.
      \item Inside a loop the user selects the palette colour(s) to be
         assigned to the first and last pen numbers of a band within
         the lookup table.  For convenience, where there is an image
         and histogram the equivalent data values are entered rather
         than pen numbers directly, though they are converted to the
         nearest pens in the lookup table.  Linear interpolation
         between the two palette colours yields the lookup-table
         colours inside the band.  Should only one colour be given then
         all the pens in the requested range are set to that colour.
         Pen numbers may be re-used indefinitely and assigned new
         colours if the desired effect is not obtained.  (The histogram
         of the array is produced to assist in a sensible choice).  The
         loop is terminated by a null in response to either of the
         prompts.
      \item The lookup table may be saved in an NDF.  A null response, 
         {\tt !}, to the request for the name of the file in which the table is
         to be stored will result in the table not being saved.
         Likewise the palette may be saved in an NDF.
      \end{enumerate}
   }
   \sstusage{
      CRELUT INLUT OUTLUT NDF [COMP] LOW HIGH [INPAL] [OUTPAL] [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         COLOUR() = LITERAL (Read)
      }{
         A colour to be added to the palette at the entry given by
         parameter PALNUM.  It is either:
         \begin{itemize}
           \item A named colour from the standard colour set, which may
           be abbreviated.  If the abbreviated name is ambiguous the
           first match is selected.  The case of the name is ignored.
           Some examples are {\tt "Seagreen"}, {\tt "Violet"}, and
           {\tt "Orchid"}.

           \item Normalised red, green, and blue intensities separated by
           commas or spaces.  Each value must lie in the range 0.0--1.0.
           For example, {\tt "1.0,1.0,0.5"} would give a pale yellow.
         \end{itemize}
         To exit the loop that obtains new palette colours enter a null
         character ({\tt !}) in response to the prompt.
      }
      \sstsubsection{
         COLRANGE() = \_INTEGER (Read)
      }{
         The numbers of the palette colours to be allocated to a range
         of pens within the lookup table.  One or two palette colours
         may be entered.  If only one is given all the range of pens
         are assigned that colour.  If two palette colours are given
         the colour of a pen is obtained by linear interpolation
         between the two colours at the fractional position of the pen
         in the range of colour indices.  Allowed values are 0--31.
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be {\tt "Data"},
         {\tt "Quality"} or {\tt "Variance"}. {\tt ["Data"]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display to be used.  The device must be in
         one of the following GNS categories: IMAGE\_DISPLAY,
         IMAGE\_OVERLAY, or WINDOW, and have at least 48 colour indices.
         At least 120 colour indices is recommended.  The device must
         also not reset when the device is opened (since the new colour
         table would be lost).  {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         HIGH = \_DOUBLE (Read)
      }{
         This is the highest value in the 2-d data array used for
         scaling and computing the histogram.  All larger array values
         are set to the highest colour index when HIGH is greater than
         LOW, otherwise all array values greater than HIGH are set to
         the lowest colour index.  The dynamic default is the maximum
         data value.
      }
      \sstsubsection{
         INLUT = NDF (Read)
      }{
         Name of the NDF containing the initial lookup table as its data
         array.  The LUT must be 2-dimensional, the first dimension
         being 3, and the second is arbitrary.  The method used to
         compress or expand the colour table if the second dimension is
         different from the number of unreserved colour indices is
         controlled by parameter NN.  Also the LUT's values must lie in
         the range 0.0--1.0.  If INLUT is null ({\tt !}) a
         greyscale is used.
      }
      \sstsubsection{
         INPAL = NDF (Read)
      }{
         Name of the NDF containing the initial palette as its data
         array.  The palette must be 2-dimensional, the first dimension
         being 3, and the second 32.  If the second dimension is
         greater than 32 only the first 32 colours are used; if it has
         less than 32 just fill as much of the palette as is possible
         starting from the first colour.  The palette's values must lie
         in the range 0.0--1.0.  If INPAL is null ({\tt !}) the default
         palette is loaded.
      }
      \sstsubsection{
         LOW = \_DOUBLE (Read)
      }{
         The array value that scales to the lowest pen in the colour
         table, and the minimum value to be included in the histogram.
         All smaller array values are set to the lowest colour
         index when LOW is less than HIGH, otherwise all array values
         smaller than LOW are set to the highest colour index.   The
         dynamic default is the minimum data value.
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         Input NDF data structure containing the image to be displayed
         to show the effect of the created colour table.
      }
      \sstsubsection{
         NN = \_LOGICAL (Read)
      }{
         If true the input lookup table is mapped to the colour table by
         using the nearest-neighbour method.  This preserves sharp
         edges and is better for lookup tables with blocks of colour.
         If NN is false, linear interpolation is used, and this is
         suitable for smoothly varying colour tables. {\tt [FALSE]}
      }
      \sstsubsection{
         OK = \_LOGICAL (Read)
      }{
         True when the palette colour just produced is acceptable.
      }
      \sstsubsection{
         OUTLUT = NDF (Write)
      }{
         The output lookup table.
      }
      \sstsubsection{
         OUTPAL = NDF (Write)
      }{
         The palette used to create the lookup table.
      }
      \sstsubsection{
         PALNUM = \_INTEGER (Read)
      }{
         The number of the palette entry whose colour is to be
         modified.  (The numbers are plotted on the palette.) It is
         used within a loop to modify up to sixteen entries in the
         palette.  Entering a null, {\tt !}, will end that loop.  The
         suggested default is the next palette number.  PALNUM must lie
         in the range 16--31.
      }
      \sstsubsection{
         PENRANGE() = \_INTEGER (Read)
      }{
         The range of pen numbers in the lookup table which is about to
         be allocated a set of colours from the palette.  PENRANGE is
         only used when there is no image and histogram plotted.  The
         pen number can be read from the axis below the ramp.  If one
         pen number is given, only this pen is altered, and it is given
         the first palette colour of COLRANGE.  If two are supplied,
         the first pen number entered will take the first palette
         colour entered, and the second pen is assigned the second
         palette colour.  The pens must lie in the range zero to the
         maximum number of available pens.
      }
      \sstsubsection{
         PTITLE = LITERAL (Read)
      }{
         Title for the output palette NDF. {\tt ['KAPPA - Crelut']}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output lookup table NDF. {\tt ['KAPPA - Crelut']}
      }
      \sstsubsection{
         VALRANGE() = \_DOUBLE (Read)
      }{
         The range of data values in the histogram/image which is to
         be allocated a set of colours from the palette, and hence be
         assigned to a part of the lookup table.  VALRANGE is only used
         when there is an image and histogram plotted.  The data value
         may be read from the axis below the histogram.  If one data
         value is given, only the single pen in the lookup table
         corresponding to the value is altered, and it is given the
         first palette colour of COLRANGE.  If two values are supplied,
         the first data value entered will take the first palette
         colour entered, and the second data value is assigned the
         second palette colour.  The data values must lie in the range
         PVLO--PVHI.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         Note:
      }{
         Since the application is highly interactive and contains loops
         it is not possible to give one-line commands to perform a
         complete operation.  Therefore the examples show how to
         control the input and output data and not the interactive
         manipulation of the colour table.
      }
      \sstexamplesubsection{
         CRELUT HEAT BIZARRE HH12 $\backslash$
      }{
         Reads a lookup table in an NDF called HEAT.  If resampling of
         the lookup table is required it achieved via linear
         interpolation. The lookup table after the manipulation is
         stored in NDF BIZARRE.  The data array in NDF HH12 is scaled
         between its minimum and maximum values and displayed in the
         top half of the current picture on the current image-display
         device.  Also drawn is an histogram of the intensities.
      }
      \sstexamplesubsection{
         CRELUT HEAT BIZARRE HH12 INPAL=MYPAL $\backslash$
      }{
         As above except a palette created previously via the OUTPAL
         parameter.  This palette is in an NDF called MYPAL.
      }
      \sstexamplesubsection{
         CRELUT INLUT=! DELUXE HH12 V LOW=100 HIGH=400 $\backslash$
      }{
         A greyscale lookup table is manipulated and the result
         is stored in NDF DELUXE.  The variance array in NDF HH12 is
         scaled between 100 and 400, and displayed in the top half of
         the current picture on the current image-display device.  Also
         drawn is an histogram of the intensities between those limits.
      }
      \sstexamplesubsection{
         CRELUT HEAT BIZARRE NDF=! DEVICE=XWINDOWS $\backslash$
      }{
         Reads a lookup table in an NDF called HEAT.  If resampling of
         the lookup table is required it achieved via the
         nearest-neighbour method.  The lookup table after the
         manipulation is stored in NDF BIZARRE.  A linear ramp is
         displayed in the lower half of the current picture on the
         XWINDOWS device.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application stores, in the order given, the following
         pictures in the graphics database: a frame comprising the data
         picture, the histogram or ramp and the palette; the data-array
         picture with world co-ordinates in units of data pixels; the
         histogram/ramp frame picture including the histogram/ramp plus
         the annotated axes; and the histogram with world co-ordinates in
         units of data values and number, or the ramp with units of pen
         numbers and normalised frequency.   The NDF associated with the
         image/histogram plots is stored by reference with the DATA
         picture.  On exit the current database picture for the chosen
         device reverts to the input picture.

         \sstitem
         Bad pixels will appear with the lowest colour index in the
         plot.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The magic-value method is used for processing bad data.

         \sstitem
         This application will handle data in all numeric types, though
         type conversion to integer will occur for unsigned byte and word
         images.
      }
   }
}

\sstroutine{
   CSUB
}{
   Subtracts a scalar from an NDF data structure
}{
   \sstdescription{
      The routine subtracts a scalar ({\it i.e.}\ constant) value from each
      pixel of an NDF's data array to produce a new NDF data structure.
   }
   \sstusage{
      CSUB IN SCALAR OUT
   }
   \sstparameters{
      \sstsubsection{
         IN = NDF (Read)
      }{
         Input NDF data structure, from which the value is to be
         subtracted.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Output NDF data structure.
      }
      \sstsubsection{
         SCALAR = \_DOUBLE (Read)
      }{
         The value to be subtracted from the NDF's data array.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Value for the title of the output NDF. A null value will cause
         the title of the NDF supplied for parameter IN to be used
         instead. {\tt ['KAPPA - Csub']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CSUB A 10 B
      }{
         This subtracts ten from the NDF called A, to make the NDF
         called B.  B has title {\tt "KAPPA - Cadd"}.
      }
      \sstexamplesubsection{
         CSUB TITLE="HD123456" OUT=B IN=A SCALAR=21.9
      }{
         This subtracts 21.9 from the NDF called A, to make the NDF
         called B.  B has the title {\tt "HD123456"}.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine correctly processes the AXIS, DATA, QUALITY,
         LABEL, TITLE, UNITS and VARIANCE components of an NDF data
         structure and propagates all extensions. Bad pixels and all
         non-complex numeric data types can be handled.

         \sstitem
         The HISTORY component is simply propagated without change, if
         present.
      }
   }
}
 
\sstroutine{
   CURSOR
}{
   Reports the co-ordinates of points selected using the cursor and
   selects the current picture
}{
   \sstdescription{
      This reads co-ordinates from the chosen graphics device and
      displays them on your terminal, and is also used to select a
      new current picture.  There is commentary that describes which
      buttons should be pressed to select a point or exit. Optionally,
      the co-ordinates may be stored in an ASCII file.

      For each selected cursor position its Cartesian co-ordinates are
      reported.  If the co-ordinate frame changes between selected
      positions the comment, name and any label associated with the new
      picture are appended to the message.

      There are three modes of operation to define which co-ordinate
      system/picture is to be used.  These are ANCHOR, CURRENT and
      DYNAMIC. See the parameter MODE for details.

      In ANCHOR or DYNAMIC modes there is an option to select only
      pictures of a certain name in the database. This is most useful
      when DATA pictures are covered by transparent FRAME pictures.
   }
   \sstusage{
      CURSOR [MODE] [DEVICE] [LOGFILE] [NAME]
   }
   \sstparameters{
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either
         {\tt "WORLD"} or {\tt "DATA"}.  {\tt "WORLD"} makes the world
         co-ordinates of the cursor position to be reported.  World
         co-ordinates that relate to a location in a data array will be
         in array pixels.  If COSYS = {\tt "DATA"} the graphics database
         is examined for data co-ordinates stored via a transformation. 
         Data co-ordinates are arbitrary but most often they will be a
         linear or logarithmic transformation of the world co-ordinates.
         For example, the $x$ co-ordinate of a spectrum would be given in
         pixels if COSYS = {\tt "WORLD"}, but if COSYS = {\tt "DATA"} the
         $x$ co-ordinate could be in wavelength units, such as
         $\AA$ngstroms.  If the database does not
         have a world-to-data transformation for a given picture, the
         value of this parameter is irrelevant and world co-ordinates
         will be reported for that picture. {\tt [}Current
         co-ordinate system{\tt ]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics workstation. {\tt [}The current graphics device{\tt ]}
      }
      \sstsubsection{
         DOUBLE = LOGICAL (Read)
      }{
         If true co-ordinates will be reported and stored in the ASCII
         file in double precision, otherwise single precision is used.
         {\tt [FALSE]}
      }
      \sstsubsection{
         LOGFILE = FILENAME (Write)
      }{
         The name of the ASCII file in which the co-ordinates of points
         selected with the cursor may be stored.  A null string ({\tt !})
         means that no file is created. The suggested default is the
         current value. {\tt [!]}
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The mode defining the co-ordinate system/picture in which
         cursor positions are returned. There are three options:
         \begin{description}
            \item [CURRENT] selects the current picture in the AGI
            database and reports the position of a point selected by
            the cursor. If the point does not lie within the picture,
            an extrapolated position is reported.

            \item [DYNAMIC] selects the topmost picture in the AGI
            database which encompasses that position selected. Thus
            the second and subsequent cursor hits may result in the
            selection of a new picture. On exit the last picture
            selected becomes the current picture.

            \item [ANCHOR] lets the first cursor hit select a
            picture which remains current throughout the running of
            the application. If subsequent cursor hits fall outside
            the extent of this picture, a position extrapolated from
            the picture's co-ordinate system is reported. On exit the
            anchor picture becomes the current picture.
         \end{description}
         {\tt ["Dynamic"]}
      }
      \sstsubsection{
         NAME = LITERAL (Read)
      }{
         Only pictures of this name are to be selected.  A null string
         ({\tt !}) or blanks means that pictures of all names may be selected.
         {\tt [!]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CURSOR
      }{
         This obtains the co-ordinates of any visible picture for the
         current graphics device by use of the cursor.
      }
      \sstexamplesubsection{
         CURSOR COSYS=W
      }{
         This obtains the world co-ordinates of any visible picture for
         the current graphics device by use of the cursor.
      }
      \sstexamplesubsection{
         CURSOR CURRENT IKON
      }{
         This obtains the co-ordinates of any visible picture in the
         reference frame of the current picture of the Ikon.
      }
      \sstexamplesubsection{
         CURSOR LOGFILE=STARS.DAT NAME=DATA
      }{
         This obtains the co-ordinates of any visible DATA picture
         for the current graphics device.  The $x$-$y$ co-ordinates are
         stored in the ASCII file called STARS.DAT.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Should an error occur trying to obtain the base picture for
         ANCHOR or DYNAMIC modes, the current picture is unchanged.

         \sstitem
         In DYNAMIC and ANCHOR modes, if the cursor is situated at a
         point where there are no pictures of the selected name, the
         co-ordinates in the base picture are reported.
      }   
   }
}
 
 
\sstroutine{
   DISPLAY
}{
   Displays a 2-d NDF
}{
   \sstdescription{
      This application displays an image of a 2-d NDF on the current
      image-display device.  The image may be the data array, but also
      variance or quality can be shown.  The image is situated within
      the current picture with the maximum magnification without
      clipping or distorting the image, though the exact positioning
      and magnification can be controlled.  The colour mapping has
      several scaling methods described below.  All the available
      colour indices are used save a few reserved for annotations.

      Only the parts of the displayed image that lie within the current
      picture are visible;  the rest is clipped.  Should the image be
      too large to fit onto the current picture at unit magnification
      (as selected by the user), then there is an option to squash the
      array in order to make it just fit; otherwise the portion of the
      data array visible within the current picture is displayed as
      originally requested.

      For images much larger than the current picture size measured in
      device pixels, the resolution of the device will allow only a
      fraction of the detail in the array to be plotted.  Therefore,
      the application compresses the image by block averaging when it
      can do so without loss of resolution when displayed.  This saves
      time scaling the data and transmitting them to the image display.

      Annotated axes and a title, or a coloured border may be drawn
      around the displayed image.
   }
   \sstusage{
      DISPLAY IN [COMP] CLEAR [DEVICE] MODE [CENTRE] [XMAGN] [YMAGN]
         [OUT] 
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                    LOW=? HIGH=? \\  
                    PERCENTILES=? \\
                    SIGMAS=? 
                   \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small mode}
   }
   \sstparameters{
      \sstsubsection{
         CENTRE( 2 ) = \_DOUBLE (Read)
      }{
         These two values control the position of the displayed image.
         Specifically, if COSYS = {\tt "WORLD"} they are the pixel indices of
         the NDF image that are to lie at the centre of the current
         picture, but they are not limited to the bounds of the NDF
         array.  If COSYS = {\tt "DATA"} they are the data co-ordinates to
         lie at the centre of the picture, and are limited by the
         bounds of the NDF array.  The CENTRE parameters permit you to
         display a portion of an NDF about a specified pixel at high
         magnification.  The application attempts to display as much of
         the NDF array it can at the magnification, so do not expect a
         symmetric image about the chosen centre.  If you do not
         specify a magnification with centering, it may result in a
         small displayed image.  Further it may not be possible to have
         precisely the pixel you want at the centre of the image; the
         displacement decreases as the magnification is increased.
         {\tt [}Centre of the image{\tt ]}
      }
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         True if the current picture is to be cleared before the
         display of the image. {\tt [FALSE]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be {\tt "Data"},
         {\tt "Quality"} or {\tt "Variance"}. {\tt ["Data"]}
      }
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either
         {\tt "WORLD"} or {\tt "DATA"}.  {\tt "WORLD"} makes pixel
         co-ordinates to appear on axes and the centering is defined
         in pixels.  If COSYS = {\tt "DATA"} the
         NDF's axis information is used to annotate axes and to control
         the position of the displayed image.  {\tt [}Current co-ordinate
         system{\tt ]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the graphics device used to display the image.
         The device must be in one of the following GNS categories:
         IMAGE\_DISPLAY, IMAGE\_OVERLAY, MATRIX\_PRINTER, or WINDOW, and
         have at least 24 colour indices or greyscale intensities.
         {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         HIGH = \_DOUBLE (Read)
      }{
         The array value that scales to the highest pen in the colour
         table.  All larger array values are set to the highest colour
         index when HIGH is greater than LOW, otherwise all array values
         greater than HIGH are set to the lowest colour index.  The
         dynamic default is the maximum data value.  There is an
         efficiency gain when both LOW and HIGH are given on the
         command line, because the extreme values need not be computed.
         (Scale mode)
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         Input NDF data structure containing the image to be displayed.
      }
      \sstsubsection{
         LOW = \_DOUBLE (Read)
      }{
         The array value that scales to the lowest pen in the colour
         table.  All smaller array values are set to the lowest colour
         index when LOW is less than HIGH, otherwise all array values
         smaller than LOW are set to the highest colour index.   The
         dynamic default is the minimum data value.  There is an
         efficiency gain when both LOW and HIGH are given on the
         command line, because the extreme values need not be computed.
         (Scale mode)
      }
      \sstsubsection{
         LUT = NDF (Read)
      }{
         Name of the NDF containing a lookup table as its data array;
         the lookup table is written to the image-display's colour
         table.  The purpose of this parameter is to provide a means of
         controlling the appearance of the image on certain devices,
         such as colour printers, that do not have a dynamic colour
         table, {\it i.e.}\ the colour table is reset when the device is
         opened.  If used with dynamic devices, such as windows or
         Ikons, the new colour table remains after this application has
         completed. A null, {\tt !}, means that the existing colour table will
         be used.

         The LUT must be 2-dimensional, the first dimension
         being 3, and the second being arbitrary.  The method used to
         compress or expand the colour table if the second dimension is
         different from the number of unreserved colour indices is
         controlled by parameter NN.  Also the LUT's values must lie in
         the range 0.0--1.0. {\tt [!]}
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The type of scaling to be applied to the array.  The options
         are:
         \begin{description}
         \item [Flash] - The image is flashed onto the screen without
                         any scaling at all.  This is the fastest
                         option.
         \item [Faint] - The image is scaled from the mean minus one
                         standard deviation to the mean plus seven
                         standard deviations.   The scaling values are
                         reported so that the faster Scale mode may be
                         utilised later.
         \item [Percentiles] - The image is scaled between the values
                         corresponding to two percentiles.  The scaling
                         values are reported so that the faster Scale
                         mode may be utilised later.
         \item [Range]   - The image is scaled between the minimum and
                         maximum data values.
         \item [Scale]   - The user defines the upper and lower limits
                         between which the image is to be scaled. The
                         application reports the maximum and the minimum
                         values for reference and makes these defaults
                         respectively.
         \item [Sigmas]  - The image is scaled between two
                         standard-deviation limits.  The scaling values
                         used are reported so that the faster Scale mode
                         may be utilised later.
         \end{description}
      }
      \sstsubsection{
         NN = \_LOGICAL (Read)
      }{
         If true the input lookup table is mapped to the colour table by
         using the nearest-neighbour method.  This preserves sharp
         edges and is better for lookup tables with blocks of colour.
         If NN is false, linear interpolation is used, and this is
         suitable for smoothly varying colour tables. NN is ignored
         unless LUT is not null. {\tt [FALSE]}
      }
      \sstsubsection{
         NUMBIN  =  \_INTEGER (Read)
      }{
         The number of histogram bins used to compute percentiles for
         scaling. (Percentiles mode) {\tt [2048]}
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         The scaled section of the NDF displayed; it also does not have
         values that equal the reserved portion of the colour table.
         The output NDF is intended to be used as the input data in
         conjunction with SCALE = FALSE.  It will be vertically
         inverted with respect to the input array because of GKS
         convention.  If it has a null value ({\tt !}) no output NDF will be
         created.  This parameter is ignored when SCALE = FALSE. {\tt [!]}
      }
      \sstsubsection{
         PERCENTILES( 2 ) = \_REAL (Read)
      }{
         The percentiles that define the scaling limits. For example,
         {\tt [25,75]} would scale between the quartile values. (Percentile
         mode)
      }
      \sstsubsection{
         SCALE = \_LOGICAL (Read)
      }{
         If true the input array is scaled according to the value of
         parameter MODE.  If it is false MODE is ignored, and the input
         array is displayed as is.  There is no scaling, inversion
         or avoidance of annotation pens.  SCALE = FALSE is intended to
         be used with arrays previously scaled by this or similar
         applications which have already performed the scaling,
         inversion and exclusion.  It provides the quickest method of
         image display within this application. {\tt [TRUE]}
      }
      \sstsubsection{
         SIGMAS( 2 ) = \_REAL (Read)
      }{
         The standard-deviation bounds that define the scaling limits.
         To obtain values either side of the mean both a negative and
         a positive value are required.  Thus {\tt [$-$2,3]} would scale
         between the mean minus two and the mean plus three standard
         deviations.  {\tt [3,$-$2]} would give the negative of that.
      }
      \sstsubsection{
         SQUASH = \_LOGICAL (Read)
      }{
         True if the array is to be squashed otherwise it is displayed
         as is with clipping.  This parameter is only used when the $x$
         and $y$ magnifications are both one, and the image would be
         clipped.  It is not used in Flash mode.
      }
      \sstsubsection{
         XMAGN = \_REAL (Read)
      }{
         The magnification (zooming) in the $x$ direction.  Unit
         magnification means that one NDF pixel maps to one
         display-device pixel. {\tt [}Maximum that gives square pixels and
         just fills the current database picture{\tt ]}
      }
      \sstsubsection{
         YMAGN = \_REAL (Read)
      }{
         The magnification (zooming) in the $y$ direction.  Unit
         magnification means that one NDF pixel maps to one
         display-device pixel. {\tt [\%XMAGN]}
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB  =  LITERAL (Read)
      }{
         Label for the plot abscissa, in which NCAR fancy founts
         may be embedded when FONT = {\tt "NCAR"}.  This parameter is only used when the axes
         option is selected.  If axis information is present the
         suggested default is the NDF's axis label followed by the
         units, in parentheses.  If an error occurs obtaining the label
         the suggested default is {\tt "X"}. {\tt []}
      }
      \sstsubsection{
         AXES = \_LOGICAL (Read)
      }{
         True if labelled and annotated axes are to be drawn around the
         displayed image.  The annotations are either the data
         co-ordinates from the NDF axis components, provided these are
         present and linear and COSYS = {\tt "DATA"}; otherwise pixel
         co-ordinates are used.  {\tt [FALSE]}
      }
      \sstsubsection{
         BADCOL = LITERAL (Read)
      }{
         The colour to give a bad pixel in the display.  The options
         are:
         \begin{description}
           \item [{\tt "}MAX{\tt "}]  - The maximum colour index used for the
                            display of the image.
           \item [{\tt "}MIN{\tt "}]  - The minimum colour index used for the
                            display of the image.
           \item [An integer] - The actual colour index. It is constrained
                            between 0 and the maximum colour index
                            available on the device.
           \item [A named colour] - Uses the named colour from the palette, and
                            if it is not present, the nearest colour
                            from the palette is selected.
         \end{description}
         If the colour is to remain unaltered as the lookup table is
         manipulated choose an integer between 0 and 15, or a named
         colour.  The suggested default is the current value. {\tt [}The
         current value, but equals {\tt "MIN"} if there is no current
         value.{\tt ]}
      }
      \sstsubsection{
         BCOLOUR = LITERAL (Read)
      }{
         The colour of the border.  It is only accessed if BORDER is
         true.  There are a number of options:
         \begin{description}
           \item [{\tt "}MAX{\tt "}]    - The maximum palette colour index.
           \item [{\tt "}MIN{\tt "}]    - The background colour.
           \item [An integer] - The actual colour index in the palette.  It
                              is constrained to be between 0 and 15.
           \item [A named colour] - Uses the named colour from the
                              palette, and if it is not present, the nearest
                              colour from the palette is selected.
         \end{description}
         The suggested default is the current value. {\tt [}The current
         value, but equals {\tt "Yellow"} if there is no current value.{\tt ]}
      }
      \sstsubsection{
         BORDER = \_LOGICAL (Read)
      }{
         True if a coloured border is to be drawn around the
         displayed image.  If AXES is true the value of BORDER will
         be ignored and no border will be drawn.  The colour and width
         of the border is controlled by parameters BCOLOUR and
         BWIDTH. {\tt [FALSE]}
      }
      \sstsubsection{
         BWIDTH( 2 ) = \_REAL (Read)
      }{
         The width of the border along each axis in device pixels.  It
         is only obtained when BORDER is true.  If only a single value
         is given it is duplicated to the second dimension.  The
         suggested default is the current value.  The widths must lie
         in the range 1.0--20.0. {\tt [4.0]}
      }
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         {\tt "NCAR"} for the NCAR fancy characters and {\tt "GKS"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value. {\tt ["GKS"]}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the numbers of major tick marks
         for the $x$ and $y$ axes.  (Number used is between MAJTIC$+$2 and
         5$*$MAJTIC/2$+$4.)   A negative value for an axis makes the
         graphics package decide an appropriate value.  This parameter
         is only used when the axes option is selected. {\tt [3.,3.]}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark
         for the $x$ and $y$ axes.  A negative value forces the graphics
         package to compute appropriate values.   This parameter is
         only used when the axes option is selected. {\tt [-1.,-1.]}
      }
      \sstsubsection{
         ORDLAB  =  LITERAL (Read)
      }{
         Label for the plot ordinate, in which NCAR fancy founts
         may be embedded when FONT = {\tt "NCAR"}.   This parameter is only used when the axes
         option is selected.  If axis information is present the
         suggested default is the NDF's axis label followed by the
         units, in parentheses.  If an error occurs obtaining the label
         the suggested default is {\tt "Y"}. {\tt []}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         True if the axis tick marks are to appear on the outside of
         the axes instead of inside.   This parameter is only used
         when the axes option is selected. {\tt [TRUE]}
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of the plot.  Up to about 40 characters can be
         accommodated, and NCAR fancy founts may be embedded ({\it c.f.}\
         SUN/90) when FONT = {\tt "NCAR"}.  This parameter is only used
         when the axes option is selected. {\tt [}The NDF title{\tt ]}
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the axes and annotations in the plot, where
         1.0 is the normal thickness.  It should be between 0.5 and 5.
         This feature is only available on some devices.   This
         parameter is only used when the axes option is selected. {\tt [1.0]}
      }
   }
   \sstresparameters{
      \sstsubsection{
         SCAHIGH = \_DOUBLE (Write)
      }{
         The array value scaled to the maximum colour index for display.
         In Flash mode or when there is no scaling the highest colour
         index is used.
      }
      \sstsubsection{
         SCALOW = \_DOUBLE (Write)
      }{
         The array value scaled to the minimum colour index for display.
         In Flash mode or when there is no scaling the lowest colour
         index is used.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DISPLAY NGC6872 MODE=P PERCENTILES=[10,90]
      }{
         Displays the NDF called NGC6872 on the current image-display
         device. The scaling is between the 10 and 90 per cent
         percentiles of the image.
      }
      \sstexamplesubsection{
         DISPLAY VV256 MODE=FLASH BORDER BWIDTH=6.0 BADCOL="Red"
      }{
         Displays the NDF called VV256 on the current image-display
         device. There is no scaling of the data; instead the modulus of
         each pixel with respect to the number of colour-table indices
         is shown.  Any bad data will be displayed in red.  A coloured
         border, of width six device pixels, is drawn around the image;
         it will have the current border colour.
      }
      \sstexamplesubsection{
         DISPLAY MODE=FA AXES CLEAR OUT=VIDEO COSYS=D $\backslash$
      }{
         Displays the current NDF data component with annotated axes
         after clearing the current picture on the current image-display
         device.  The axes take the axis labels and title from the NDF,
         and are annotated in data co-ordinates.  The scaling is
         between the $-$1 and $+$7 standard deviations of the image around
         its mean. The scaled data are stored in an NDF called VIDEO.
      }
      \sstexamplesubsection{
         DISPLAY VIDEO NOSCALE $\backslash$
      }{
         Displays the data component of the NDF called VIDEO (created
         in the previous example) without scaling within the current
         picture on the current image-display device.
      }
      \sstexamplesubsection{
         DISPLAY IN=CGS4A COMP=V MODE=SC LOW=1 HIGH=5.2 DEVICE=IKON
      }{
         Displays the variance component of NDF CGS4A on the Ikon,
         scaling between 1 and 5.2.
      }
      \sstexamplesubsection{
         DISPLAY REDRECTANGLE XMAGN=4 CENTRE=[300,200] $\backslash$
      }{
         Displays the REDRECTANGLE NDF with a magnification of four
         times, so that four device pixels corresponds to one image
         pixel, on the current device.  The exact portion of the image
         visible will depend on the size and location of the current
         picture, however the displayed portion will have pixel
         (300,200) at the centre of the current picture.  The current
         scaling is used.
      }
      \sstexamplesubsection{
         DISPLAY NGC6872 MODE=RA DEVICE=LJ250\_P LUT=PIZZA
      }{
         Displays the NDF called NGC6872 on the LJ250\_P device. The
         lookup table in the NDF called PIZZA is mapped on the LJ250\_P's
         colour table. The scaling is between the minimum and maximum
         of the image.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application stores a number of pictures in the graphics
         database in the following order: a FRAME of the specified size
         containing the title, annotated axes, and the image area
         (provided AXES is true) or the border (if BORDER is true), whose
         world co-ordinates are in device pixels; a DATA picture with
         world co-ordinates in pixel co-ordinates.  The DATA picture also
         may have data co-ordinates derived from the NDF axis components
         provided these are linear and different from pixel co-ordinates;
         the data co-ordinates are stored via a double-precision linear
         transformation.  The NDF associated with the plot is stored by
         reference with the DATA picture.  On exit the current database
         picture for the chosen device reverts to the input picture.

         \sstitem
         When axes are requested the axis annotations are defined by
         their lower and upper bounds, {\it i.e.}\ a regular array is assumed.
         The bounds are derived from the part of NDF being displayed, and
         will be in pixel or data co-ordinates.

         \sstitem
         The data type of the output NDF depends on the number of colour
         indices: \_UBYTE for no more than 256, \_UWORD for 257 to 65535,
         and \_INTEGER otherwise.   The output NDF will not contain any
         extensions, UNITS and VARIANCE, but QUALITY, LABEL, TITLE, UNITS
         and AXIS information are propagated from the input NDF.  The
         output NDF does not become the new current data array.  It is a
         Simple NDF (because the bad-pixel flag is set to false in order to
         access the maximum colour index, and to handle sections),
         therefore only NDF-compliant applications can process it.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The magic-value method is used for processing bad data.

         \sstitem
         This application will handle data in all numeric types, though
         type conversion to integer will occur for unsigned byte and word
         images.  However, when there is no scaling only integer data will
         not be type converted, but this is not expensive for the expected
         byte-type data.
      }
   }
}

\sstroutine{
   DIV
}{
   Divides one NDF data structure by another
}{
   \sstdescription{
      The routine divides one NDF data structure by another
      pixel-by-pixel to produce a new NDF.
   }
   \sstusage{
      DIV IN1 IN2 OUT
   }
   \sstparameters{
      \sstsubsection{
         IN1 = NDF (Read)
      }{
         First NDF, to be divided by the second NDF.
      }
      \sstsubsection{
         IN2 = NDF (Read)
      }{
         Second NDF, to be divided into the first NDF.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Output NDF to contain the ratio of the two input NDFs.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Value for the title of the output NDF. A null value will cause
         the title of the NDF supplied for parameter IN1 to be used
         instead. {\tt ['KAPPA - Div']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DIV A B C
      }{
         This divides the NDF called A by the NDF called B, to make the
         NDF called C.  C has title {\tt "KAPPA - Div"}.
      }
      \sstexamplesubsection{
         DIV OUT=C IN1=A IN2=B TITLE="Normalised data"
      }{
         This divides the NDF called A by the NDF called B, to make the
         NDF called C.  C has the title {\tt "Normalised data"}.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the two input NDFs have different pixel-index bounds, then
         they will be trimmed to match before being divided. An error will
         result if they have no pixels in common.

         \sstitem
         Calculations will be performed using either real or double
         precision arithmetic, whichever is more appropriate. If the input
         NDF structures contain values with other data types, then
         conversion will be performed as necessary.

         \sstitem
         This routine correctly processes the AXIS, DATA, QUALITY,
         LABEL, TITLE and VARIANCE components of an NDF data structure and
         propagates all extensions. Bad pixels and all non-complex numeric
         data types can be handled.

         \sstitem
         The HISTORY component is simply propagated without change, if
         present.

         \sstitem
         Units processing is not supported at present and therefore the
         the UNITS component is not propagated.
      }
   }
}

\sstroutine{
   ERASE
}{
   Erases an HDS object
}{
   \sstdescription{
      This routine erases a specified HDS object or container file. If
      the object is a structure, then all the structure's components
      (and sub-components, {\it etc.}) are also erased. If a slice or cell
      of an array is specified, then the entire array is erased.
   }
   \sstusage{
      ERASE OBJECT
   }
   \sstparameters{
      \sstsubsection{
         OBJECT = UNIV (Write)
      }{
         The HDS object or container file to be erased.
      }
      \sstsubsection{
         OK = \_LOGICAL (Read)
      }{
         This parameter is used to seek confirmation before an object
         is erased. If a TRUE value is given, then the HDS object will
         be erased. If a FALSE value is given, then the object will not
         be erased and a message will be issued to this effect.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         ERASE HORSE
      }{
         This erases the HDS container file called HORSE.
      }
      \sstexamplesubsection{
         ERASE FIG123.AXIS
      }{
         This erases the AXIS component of the HDS file called FIG123.
         If AXIS is a structure, all its components are erased too.
      }
      \sstexamplesubsection{
         ERASE FIG123.AXIS(1).LABEL
      }{
         This erases the LABEL component within the first element of
         the AXIS structure of the HDS file called FIG123.
      }
      \sstexamplesubsection{
         ERASE AGI\_USER:AGI\_RESTAR.AGI\_3200\_1
      }{
         This erases the AGIDEV\_3200\_1 structure of the HDS file called
         AGI\_USER:AGI\_RESTAR.
      }
   }
}

\manroutine {{\manheadstyle{EXPE}}}{ Takes the exponential of each pixel of a data
  array (base $e$).}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes the exponential to base e of each pixel of
  a data array. The result goes into a new output data array.
  Both data arrays are stored in the {\mantt{IMAGE}} format.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  EXPE

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{BASE}}  }{{\mantt{\_REAL}}}
  Base of exponential to be taken of each input data array pixel.
  \mbox{\mantt [2.718282]}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure holding result of exponentiated array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Expe']}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{EXP10}}}{ Takes the base-10 exponential of each pixel of
  a data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes the exponential to base 10 of each pixel of
  a data array. The result goes into a new output data array.
  Both data arrays are stored in the {\mantt{IMAGE}} format.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  EXP10

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{BASE}}  }{{\mantt{\_REAL}}}
  Base of exponential to be taken of each input data array pixel. \mbox{\mantt [10]}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure holding result of exponentiated array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Exp10']}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{EXPON}}}{ Takes the exponential of each pixel
   of a data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes the exponential to an input base of each pixel
  of a data array. The result goes into a new output data array.
  Both data arrays are stored in the {\mantt{IMAGE}} format.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  EXPON

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{BASE}}  }{{\mantt{\_REAL}}}
  Base of exponential to be taken of each input data array pixel.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure holding result of exponentiated array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Expon']}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

 
\sstroutine{
   FITSDIN
}{
   Reads a FITS disk file composed of simple, group or table objects
}{
   \sstdescription{
      This application reads selected disk-FITS files.  The files may
      be Basic (simple) FITS, or any one one of the ratified extensions
      to FITS (Harten {\it et al.}\ 1988).  The application reads a simple or
      a random-groups-format FITS file (Wells {\it et al.}\ 1981; Greisen \&
      Harten 1981), and writes the data into HDS files in the NDF
      format, and the headers into the FITS extension. Tables- format
      files (Grosb{\o}l {\it et al.}\ 1988) are read, and the application creates
      two files for use by SCAR: a FACTS description file based upon
      the FITS header cards, and an ASCII formatted catalogue.
      Composite FITS files can be processed.  A list of files,
      including wildcards, may be specified.

      A record of the FITS headers, and group parameters (for a
      group-format file) may be stored in an ASCII file.

      There is an option to run in automatic mode, where the names of
      output NDF data structures are generated automatically, and the
      user can decide whether or not format conversion is to be applied
      to all files (rather than being prompted for each). This is very
      useful if there is a large number of files to be processed.  Even
      if you want unique file names, format-conversion prompting may be
      switched off globally.
   }
   \sstusage{
      FITSDIN FILES OUT [AUTO] FMTCNV [LOGFILE] DSCFTABLE=? TABLE=?
   }
   \sstparameters{
      \sstsubsection{
         AUTO = \_LOGICAL (Read)
      }{
         True if automatic mode is required, where the name of each
         output NDF structure or table file is to be generated by the
         application, and therefore not prompted; and a global
         format-conversion switch may be set.  In manual mode the
         FITS header is reported, but not in automatic.

         In automatic mode the application generates a filename
         beginning with the input filename, less any extension.  For
         example, if the input file was SATURN.FITS the filename of the
         output NDF would be SATURN.SDF, and an output table would be
         SATURN.DAT with a description file DSCFSATURN.DAT.  If there
         are sub-files (more than one FITS object in the file) a suffix
         {\tt \_<subfile>} is appended.  So if SATURN.FITS comprised a simple
         file followed by a table, the table would be called
         SATURN\_2.DAT and the description file DSCFSATURN\_2.DAT.  For
         group format a suffix {\tt G<groupnumber>} is appended.  Thus if
         SATURN.FITS is a group format file, the first NDF created
         would be called SATURN.SDF, the second would be SATURNG2.SDF.
         {\tt [FALSE]}
      }
      \sstsubsection{
         DSCFTABLE = FILENAME (Read)
      }{
         Name of the ASCII file to contain the FACTS descriptors, which
         defines the table's format for SCAR.  This description file
         should have the same name as the catalogue except for the
         prefix {\tt "}DSCF{\tt "}, if it is to be processed by SCAR.  There may
         also be restrictions on the length of catalogue's file name
         imposed by SCAR/ADC.  SCAR users should check the latest SCAR
         documentation for details.

         A suggested filename for the description file is reported
         immediately prior to prompting in manual mode.  It is the name
         of the catalogue, as written in the FITS header, with a {\tt "}DSCF{\tt "}
         prefix.

         A null value ({\tt !}) means that no description file will be
         created. The file extension defaults to .DAT.
      }
      \sstsubsection{
         FILES() = LITERAL (Read)
      }{
         A list of (optionally wild-carded) file specifications which
         identify the disk-FITS files to be processed.  Up to 10 values
         may be given, but only a single specification such as {\tt "*.FITS"}
         is normally required.  Be careful not to include non-FITS files
         in this list.
      }
      \sstsubsection{
         FMTCNV = \_LOGICAL (Read)
      }{
         This specifies whether or not format conversion will occur.
         If false, the HDS type of the data array in the NDF will be
         the equivalent of the FITS data format on tape ({\it e.g.}\ BITPIX =
         16 creates a \_WORD array).  If true, the data array in the
         current file, or all files in automatic mode, will be
         converted from the FITS data type on tape to \_REAL in the NDF.
         The conversion applies the values of the FITS keywords BSCALE
         and BZERO to the tape data to generate the {\tt "}true{\tt "} data values.
         If BSCALE and BZERO are not given in the FITS header, they are
         taken to be 1.0 and 0.0 respectively.
      }
      \sstsubsection{
         GLOCON  = \_LOGICAL (Read)
      }{
         If false a format-conversion query occurs for each FITS file.
         If true, the value of \%FMTCNV is obtained before any file
         numbers and will apply to all data arrays.  It is ignored
         in automatic mode---in effect it becomes true. {\tt [FALSE]}
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         The file name of the ASCII log of the FITS header cards.
         For group-format data the group parameters are evaluated
         and appended to the full header.  The log includes the names of
         the output files used to store the data array or table. A null
         value ({\tt !}) means that no log file is produced. {\tt [!]}
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Output NDF structure holding the full contents of the FITS
         file.  If the null value ({\tt !}) is given no NDF will be created.
         This offers an opportunity to review the descriptors before
         deciding whether or not the data are to be extracted.
      }
      \sstsubsection{
         TABLE = FILENAME (Read)
      }{
         Name of the ASCII file to contain the table itself, read from
         the tape.  There may be restrictions on the length of a
         catalogue's file name imposed by SCAR/ADC.  SCAR users should
         check the latest SCAR documentation for details.

         In manual mode the suggested default filename is the name of
         description file less the {\tt "}DSCF{\tt "} prefix, or if there is no
         description file or if the description file does not have the
         DSCF prefix, the suggested name reverts to the catalogue name
         in the FITS header.  The file extension defaults to .DAT.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         FITSDIN FILES=*.FIT AUTO PREFIX=CCD NOFMTCNV
      }{
         This reads all the files with extension {\tt "}FIT{\tt "} in the default
         directory.  If the files were SAO.FIT and MOIMP.FIT and each
         contained just an image array, the output NDFs will be SAO and
         MOIMP respectively.  The data will not have format conversion.
      }
      \sstexamplesubsection{
         FITSDIN FILES=CCD.IFITS FMTCNV LOGFILE=JKT.LOG
      }{
         This reads the files CCD.IFITS and processes all the FITS
         objects within it.  Integer data arrays are converted to real
         using the scale and zero found in the FITS header.  A record
         of the headers and the names of the output files are written
         to the ASCII file JKT.LOG
      }
      \sstexamplesubsection{
         FITSDIN FILES=[*.*FITS,*.MT] GLOCON FMTCNV
      }{
         This reads the files *.*FITS and *.MT and processes all the
         FITS objects within them.  Integer data arrays are converted
         to real using the scale and zero found in the FITS header.
         Any IEEE-format data will not be converted although the global
         conversion switch is on.
      }
   }

   \sstdiytopic{
      References
   }{
      \begin{refs}
      \item  Wells, D.C., Greisen, E.W. \& Harten, R.H. 1981,
      {\it Astron. Astrophys. Suppl. Ser.} {\bf 44}, 363.

      \item  Greisen, E.W. \& Harten, R.H. 1981,
      {\it Astron. Astrophys. Suppl. Ser.} {\bf 44}, 371.

      \item  Grosb{\o}l, P., Harten, R.H., Greisen, E.W \& Wells, D.C.
      1988 {\it Astron. Astrophys. Suppl. Ser.} {\bf 73}, 359.

      \item  Harten, R.H., Grosb{\o}l, P., Greisen, E.W \& Wells, D.C.
      1988 {\it Astron. Astrophys. Suppl. Ser.} {\bf 73}, 365.

      \end{refs}
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The table description file may need small revisions for optimum
         use in SCAR.  See SUN/70 for more details about description files.

         \sstitem
         The application processes tapes blocked at other than an
         integer multiple of 2880 bytes up to a maximum of 28800, provided
         it is a multiple of the number of bytes per data value.

         \sstitem
         For simple or group format FITS:

         \sstitemlist{

            \sstitem
            IEEE floating point is supported.

            \sstitem
            If BUNIT is present its value will appear as the NDF's units
            component.

            \sstitem
            If OBJECT is present its value will appear as the NDF's title
            component.

            \sstitem
            If the BLANK item is present in the header, undefined pixels
            are converted from the BLANK value to Starlink-standard magic
            value during data conversion.

            \sstitem
            An AXIS component will be stored in the NDF if the CRVAL$n$
            keyword is present.  ($n$ is the number of the dimension.)  If the
            CRPIX$n$ keyword is absent it defaults to 1, and likewise for the
            CDELT$n$ keyword.  The value of CRTYPE$n$ is made the label of the
            axis structure.
         }

         \sstitem
         For groups format, a new NDF is created for each data array.
         The name of the NDF of the second and subsequent data arrays is
         generated by the application as the {\tt <filename>G<number>}, where
         {\tt <filename>} is the name of the first NDF, supplied by the user or
         generated automatically, and {\tt <number>} is the number of the group.

         Each group NDF contains the full header in the FITS extension,
         appended by the set of group parameters.  The group parameters
         are evaluated using their scales and offsets, and made to look
         like FITS cards, whose keywords are derived from the values of
         PTYPE$m$ in the main header.  ($m$ is the number of the group
         parameter.) The same format is used in the log file.

         \sstitem
         If there is no data array on tape, {\it i.e.}\ the FITS file comprises
         header cards only, then a dummy vector data array of dimension
         two is created to make the output a valid NDF.  This data array
         is undefined.
      }
   }
}

\sstroutine{
   FITSIMP
}{
   Imports FITS information into an NDF extension
}{
   \sstdescription{
      This application extracts the values of FITS keywords from a FITS
      extension in an NDF and uses them to construct another NDF
      extension.  The list of new extension components required, their
      data types and the names of the FITS keywords from which to
      derive their values are specified in a {\tt "}keyword translation
      table{\tt "} held in a separate text file.
   }
   \sstusage{
      FITSIMP NDF TABLE XNAME XTYPE
   }
   \sstparameters{
      \sstsubsection{
         NDF = NDF (Read and Write)
      }{
         The NDF in which the new extension is to be created.
      }
      \sstsubsection{
         TABLE = FILE (Read)
      }{
         The text file containing the keyword translation table. The
         format of this file is described under {\tt "}Table Format{\tt "}.
      }
      \sstsubsection{
         XNAME = LITERAL (Read)
      }{
         The name of the NDF extension which is to receive the values
         read from the FITS extension. If this extension does not
         already exist, then it will be created. Otherwise, it should
         be a scalar structure extension within which new components
         may be created (existing components of the same name will be
         over-written). Extension names may contain up to 15
         alpha-numeric characters, beginning with an alphabetic
         character.
      }
      \sstsubsection{
         XTYPE = LITERAL (Read)
      }{
         The HDS data type of the output extension. This value will
         only be required if the extension does not initially exist and
         must be created. New extensions will be created as scalar
         structures.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         FITSIMP DATAFILE FITSTABLE CCDINFO CCD\_EXT
      }{
         Creates a new extension called CCDINFO (with a data type of
         CCD\_EXT) in the NDF structure called DATAFILE. Keyword values
         are read from the NDF's FITS extension and written into the new
         extension as separate components under control of a keyword
         translation table held in the file FITSTABLE.
      }
      \sstexamplesubsection{
         FITSIMP NDF=N1429 TABLE=STD\_TABLE XNAME=STD\_EXTN
      }{
         FITS keyword values are read from the FITS extension in the
         NDF structure N1429 and written into the pre-existing
         extension STD\_EXTN under control of the translation table
         STD\_TABLE.  Components which already exist within the
         extension may be over-written by this process.
      }
   }
   \sstdiytopic{
      Timing
   }{
      Approximately proportional to the number of FITS keywords to be
      translated.
   }
   \sstdiytopic{
      Table Format
   }{
      The keyword translation table should be held in a text file, with
      one extension component specified per line. Each line should
      contain 3 fields, separated by spaces and/or tabs, as follows:

      \sstitemlist{

         \sstitem
         Field 1:
            The name of the component in the output extension for which a
            value is to be obtained.

         \sstitem
         Field 2:
            The data type of the output component, to which the keyword
            value will be converted (one of \_INTEGER, \_REAL, \_DOUBLE,
            \_LOGICAL or \_CHAR).

         \sstitem
         Field 3:
            The name of the FITS keyword from which the value is to be
            obtained.  Hierarchical keywords are permissible; the format
            is concatenated keywords joined with fullstops and no spaces,
            {\it e.g.}\ HIERARCH.ESO.NTT.HUMIDITY, ING.DETHEAD.

      }
      Comments may appear at any point in the table and should begin
      with an exclamation mark. The remainder of the line will then be
      ignored.
   }
}

\newpage
\sstroutine{
   FITSIN
}{
   Reads a FITS tape composed of simple, group or table files
}{
   \sstdescription{
      This application reads selected files from a FITS tape.  The files
      may be Basic (simple) FITS, or any one one of the ratified
      extensions to FITS (Harten {\it et al.}\ 1988).  The application reads a
      simple or a random-groups-format FITS file (Wells {\it et al.}\ 1981;
      Greisen \& Harten 1981), and writes the data into HDS files in the
      NDF format, and the headers into the FITS extension. Tables-
      format files (Grosb{\o}l {\it et al.}\ 1988) are read, and the application
      creates two files for use by SCAR: a FACTS description file based
      upon the FITS header cards, and an ASCII formatted catalogue.
      Composite FITS files can be processed.  Files are specified by
      number.

      A record of the FITS headers, and group parameters (for a
      group-format file) may be stored in an ASCII file.

      There is an option to run in automatic mode, where the names of
      output NDF data structures are generated automatically, and the
      user can decide whether or not format conversion is to be applied
      to all files (rather than being prompted for each). This is very
      useful if there is a large number of files to be processed.  Even
      if you want unique file names, format-conversion prompting may be
      switched off globally.
   }
   \sstusage{
      FITSIN MT FILES OUT [AUTO] FMTCNV [LOGFILE] MORE=? DSCFTABLE=?
         TABLE=?
   }
   \sstparameters{
      \sstsubsection{
         AUTO = \_LOGICAL (Read)
      }{
         True if automatic mode is required, where the name of each
         output NDF structure or table file is to be generated by the
         application, and therefore not prompted; and a global
         format-conversion switch may be set.  In manual mode the
         FITS header is reported, but not in automatic.

         For simple or group format FITS objects in automatic mode the
         application generates a filename beginning with a defined
         prefix followed by the number of the file on tape.  For
         example, if the prefix was {\tt "XRAY"} and the 25$^{\rm th}$ file of the
         tape was being processed, the filename of the NDF would be
         XRAY25.

         For table-format FITS objects in the automatic mode the
         application generates a filename beginning with a defined
         prefix followed by the number of the file on tape.  For
         example, if the prefix was {\tt "CAT"} and the 9$^{\rm th}$ file of the tape
         was being processed, the filename of the table and its
         associated FACTS description file would be CAT9.DAT and
         DSCFCAT9.DAT respectively.
         {\tt [FALSE]}
      }
      \sstsubsection{
         DSCFTABLE = FILENAME (Read)
      }{
         Name of the ASCII file to contain the FACTS descriptors, which
         defines the table's format for SCAR.  This description file
         should have the same name as the catalogue except for the
         prefix {\tt "}DSCF{\tt "}, if it is to be processed by SCAR.  There may
         also be restrictions on the length of catalogue's file name
         imposed by SCAR/ADC.  SCAR users should check the latest SCAR
         documentation for details.

         A suggested filename for the description file is reported
         immediately prior to prompting in manual mode.  It is the name
         of the catalogue, as written in the FITS header, with a {\tt "}DSCF{\tt "}
         prefix.

         A null value ({\tt !}) means that no description file will be
         created. The file extension defaults to .DAT.
      }
      \sstsubsection{
         FILES()  = \_CHAR (Read)
      }{
         The list of the file numbers to be processed.  Files are
         numbered consecutively from 1.  Single files or a set of
         adjacent files may be specified, {\it e.g.}\  typing 
         {\tt [4,6-9,12,14-16]} will read files 4,6,7,8,9,12,14,15,16. 
         (Note that the
         brackets are required to distinguish this array of characters
         from a single string including commas.  The brackets are
         unnecessary when there only one item.) For efficiency reasons
         it is sensible to give the file numbers in ascending order.

         If you wish to extract all the files enter the wildcard $*$.
         5-$*$ will read from 5 to the last file.  The processing will
         continue until the end of the tape is reached; no error
         will result from this.
      }
      \sstsubsection{
         FMTCNV = \_LOGICAL (Read)
      }{
         This specifies whether or not format conversion will occur.
         If false, the HDS type of the data array in the NDF will be
         the equivalent of the FITS data format on tape ({\it e.g.}\ BITPIX =
         16 creates a \_WORD array).  If true, the data array in the
         current file, or all files in automatic mode, will be
         converted from the FITS data type on tape to \_REAL in the NDF.
         The conversion applies the values of the FITS keywords BSCALE
         and BZERO to the tape data to generate the {\tt "}true{\tt "} data values.
         If BSCALE and BZERO are not given in the FITS header, they are
         taken to be 1.0 and 0.0 respectively.
      }
      \sstsubsection{
         GLOCON  = \_LOGICAL (Read)
      }{
         If false a format-conversion query occurs for each FITS file.
         If true, the value of FMTCNV is obtained before any file
         numbers and will apply to all data arrays.  It is ignored
         in automatic mode---in effect it becomes true. {\tt [FALSE]}
      }
      \sstsubsection{
         LABEL  = \_LOGICAL (Read)
      }{
         True if the tape has labelled files. Labelled files are
         non-standard.  If true, the application skips three file
         marks per file, rather that one. {\tt [FALSE]}
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         The file name of the ASCII log of the FITS header cards.
         For group-format data the group parameters are evaluated
         and appended to the full header.  The log includes the names of
         the output files used to store the data array or table. A null
         value ({\tt !}) means that no log file is produced. {\tt [!]}
      }
      \sstsubsection{
         MORE   = \_LOGICAL (Read)
      }{
         A prompt asking if any more files are to be processed once the
         current list has been exhausted.
      }
      \sstsubsection{
         MT = DEVICE (Read)
      }{
         Tape deck containing the data, usually an explicit device,
         though it can be a pre-assigned logical name.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Output NDF structure holding the full contents of the FITS
         file.  If the null value ({\tt !}) is given no NDF will be created.
         This offers an opportunity to review the descriptors before
         deciding whether or not the data are to be extracted.
      }
      \sstsubsection{
         PREFIX = LITERAL (Read)
      }{
         The prefix of the NDF's or table's file name.  It is only used
         in the automatic mode.
      }
      \sstsubsection{
         TABLE = FILENAME (Read)
      }{
         Name of the ASCII file to contain the table itself, read from
         the tape.  There may be restrictions on the length of a
         catalogue's file name imposed by SCAR/ADC.  SCAR users should
         check the latest SCAR documentation for details.

         In manual mode the suggested default filename is the name of
         description file less the {\tt "}DSCF{\tt "} prefix, or if there is no
         description file or if the description file does not have the
         DSCF prefix, the suggested name reverts to the catalogue name
         in the FITS header.  The file extension defaults to .DAT.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         FITSIN MT=MUB0 FILES=[2-4,9] AUTO PREFIX=CCD NOFMTCNV
      }{
         This reads files 2, 3, 4, and 9 from the FITS tape on
         device MUB0.  The output file names will be CCD2, CCD3, CCD4,
         and CCD9 (assuming there are no groups).  The data will not
         have format conversion.
      }
      \sstexamplesubsection{
         FITSIN MT=MUC1 FILES=$*$ AUTO PREFIX=CCD FMTCNV LOGFILE=JKT.LOG
      }{
         This reads all the files from the FITS tape on device MUC1.
         The output files begin with a prefix "CCD".  Integer data
         arrays are converted to real using the scale and zero
         found in the FITS header.  A record of the headers and the
         names of the output files are written to the ASCII file
         JKT.LOG
      }
   }
   \sstdiytopic{
      References
   }{
      \begin{refs}
      \item  Wells, D.C., Greisen, E.W. \& Harten, R.H. 1981,
      {\it Astron. Astrophys. Suppl. Ser.} {\bf 44}, 363.

      \item  Greisen, E.W. \& Harten, R.H. 1981,
      {\it Astron. Astrophys. Suppl. Ser.} {\bf 44}, 371.

      \item  Grosb{\o}l, P., Harten, R.H., Greisen, E.W \& Wells, D.C.
      1988 {\it Astron. Astrophys. Suppl. Ser.} {\bf 73}, 359.

      \item  Harten, R.H., Grosb{\o}l, P., Greisen, E.W \& Wells, D.C.
      1988 {\it Astron. Astrophys. Suppl. Ser.} {\bf 73}, 365.

      \end{refs}
   }
   \sstdiytopic{
      Prior requirements
   }{
      The tape must be mounted prior to use of this application.  In
      ICL use the command MOUNT.  From DCL use MOUNT/FOREIGN.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The table description file may need small revisions for optimum
         use in SCAR.  See SUN/70 for more details about description files.

         \sstitem
         The application processes tapes blocked at other than an
         integer multiple of 2880 bytes up to a maximum of 63360, provided
         it is a multiple of the number of bytes per data value.

         \sstitem
         For simple or group format FITS:

         \sstitemlist{

            \sstitem
            IEEE floating point is supported.

            \sstitem
            If BUNIT is present its value will appear as the NDF's units
            component.

            \sstitem
            If OBJECT is present its value will appear as the NDF's title
            component.

            \sstitem
            If the BLANK item is present in the header, undefined pixels
            are converted from the BLANK value to Starlink-standard magic
            value during data conversion.

            \sstitem
            An AXIS component will be stored in the NDF if the CRVAL$n$
            keyword is present.  ($n$ is the number of the dimension.)  If the
            CRPIX$n$ keyword is absent it defaults to 1, and likewise for the
            CDELT$n$ keyword.  The value of CRTYPE$n$ is made the label of the
            axis structure.
         }

         \sstitem
         For groups format, a new NDF is created for each data array.
         The name of the NDF of the second and subsequent data arrays is
         generated by the application as the {\tt <filename>G<number>}, where
         {\tt <filename>} is the name of the first NDF, supplied by the user or
         generated automatically, and {\tt <number>} is the number of the group.

         Each group NDF contains the full header in the FITS extension,
         appended by the set of group parameters.  The group parameters
         are evaluated using their scales and offsets, and made to look
         like FITS cards, whose keywords are derived from the values of
         PTYPE$m$ in the main header.  ($m$ is the number of the group
         parameter.) The same format is used in the log file.

         \sstitem
         If there is no data array on tape, {\it i.e.}\ the FITS file comprises
         header cards only, then a dummy vector data array of dimension
         two is created to make the output a valid NDF.  This data array
         is undefined.
      }
   }
}
 
\sstroutine{
   FITSLIST
}{
   Lists the FITS extension of an NDF
}{
   \sstdescription{
      This application lists the FITS header stored in an NDF FITS
      extension.  The list may either be reported directly to the
      user, or written to an ASCII file.
   }
   \sstusage{
      FITSLIST IN [LOGFILE]
   }
   \sstparameters{
      \sstsubsection{
         IN = NDF (Read)
      }{
         The NDF whose FITS extension is to be listed.
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         The name of the ASCII file to store a list of the FITS
         extension.  If it is null ({\tt !}) the list of the FITS extension
         is reported directly to the user. {\tt [!]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         FITSLIST SATURN
      }{
         The contents of the FITS extension in NDF SATURN are
         reported to the user.
      }
      \sstexamplesubsection{
         FITSLIST NGC205 LOGFILE=NGCFITS.LIS
      }{
         The contents of the FITS extension in NDF NGC205 are
         written to the ASCII file NGCFITS.LIS.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the NDF does not have a FITS extension the application will
         exit.
      }
   }
}
\sstroutine{
   FLIP
}{
   Reverses an NDF's pixels along a specified dimension
}{
   \sstdescription{
      This application reverses the order of an NDF's pixels along a
      specified dimension, leaving all other aspects of the data
      structure unchanged.
   }
   \sstusage{
      FLIP IN OUT DIM
   }
   \sstparameters{
      \sstsubsection{
         AXIS = \_LOGICAL (Read)
      }{
         If a {\tt TRUE} value is given for this parameter (the default),
         then any axis values associated with the NDF dimension being
         reversed will also be reversed in the same way. If a {\tt FALSE}
         value is given, then all axis values will be left unchanged.
         {\tt [TRUE]}
      }
      \sstsubsection{
         DIM = \_INTEGER (Read)
      }{
         The number of the dimension along which the NDF's pixels
         should be reversed. The value should lie between 1 and the
         total number of NDF dimensions. If the NDF has only a single
         dimension, then this parameter is not used, a value of 1 being
         assumed.
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         The input NDF data structure whose pixel order is to be
         reversed.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         The output NDF data structure.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         A title for the output NDF. A null value will cause the title
         of the NDF supplied for parameter IN to be used instead.
         {\tt ['KAPPA - Flip']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         FLIP A B 2
      }{
         Reverses the pixels in the NDF called A along its second
         dimension to create the new NDF called B.
      }
      \sstexamplesubsection{
         FLIP SPECIN SPECOUT
      }{
         If SPECIN is a 1-dimensional spectrum, then this example
         reverses the order of its pixels to create a new spectrum
         SPECOUT. Note that no value for the DIM parameter need be
         supplied in this case.
      }
      \sstexamplesubsection{
         FLIP IN=CUBE OUT=NEWCUBE DIM=2 NOAXIS
      }{
         Reverses the order of the pixels along dimension 2 of the NDF
         called CUBE to give NEWCUBE, but leaves the associated axis
         values in their original order.
      }
   }
   \sstnotes{
      The pixel-index bounds of the NDF are unchanged by this routine.
   }
   \sstimplementationstatus{
      This routine correctly processes the AXIS, DATA, QUALITY, LABEL,
      TITLE, UNITS and VARIANCE components of an NDF and propagates all
      extensions. Bad pixels and all non-complex numeric types can be
      handled. The data type of the input pixels is preserved in the
      output NDF.
   }
}
\sstroutine{
   FOURIER
}{
   Performs forward and inverse Fourier transforms of 2-d NDFs
}{
   \sstdescription{
      This application performs forward or reverse Fast Fourier
      Transforms (FFTs) of 2-d NDFs. The output in the forward
      transformation (from the space domain to the Fourier) can be
      produced in Hermitian form in a single NDF, or as two NDFs giving
      the real and imaginary parts of the complex transform, or as two
      NDFs giving the power and phase of the complex transform.  Any
      combination of these may also be produced. The inverse procedure
      accepts any of these NDFs and produces a purely real output NDF.

      Any bad pixels in the input NDF are replaced by a constant value
      specified by the user.  Input NDFs need neither be square, nor be
      a power of 2 in size in either dimension.  However, there are
      some restrictions on the shape and size of the input NDF.
      Specifically, the routine which performs the FFT cannot cope with
      dimensions which have any prime factors bigger than 19.  If the
      given NDF does not meet this requirement, it is padded out to the
      next larger acceptable size which does, and an informational
      message displayed.  The output NDF(s) has the padded dimensions.
      If this is not wanted you can specify that each output dimension
      should be trimmed to the next smaller permitted size.

      The Hermitian transform is a single image in which each quadrant
      consisting of a linear combination of the real and imaginary
      parts of the transform.  This form is useful if you just want to
      multiply the Fourier transform by some known purely real mask and
      then invert it to get a filtered image.  However, if you want to
      multiply the Fourier transform by a complex mask ({\it e.g.}\ the
      Fourier transform of another NDF), or do any other operation
      involving combining complex values, then the Hermitian NDF must
      be untangled into separate real and imaginary parts.

      There is an option to swap the quadrants of the input NDF around
      before performing a forward FFT.  This is useful if you want to
      perform convolutions with the FFTs, since the point-spread
      function (PSF) image can be created with the PSF centre at the
      array centre, rather than at pixel (1,1) as is usually required.
   }
   \sstusage{
      FOURIER IN HERMOUT
   }
   \sstparameters{
      \sstsubsection{
         FILLVAL = LITERAL (Read)
      }{
         A value to replace bad pixels before performing the transform.
         The input image is also padded with this value if necessary to
         form an image of acceptable size. A value of {\tt "MEAN"} will cause
         the mean value in the array to be used. {\tt [0.0]}
      }
      \sstsubsection{
         HERMIN = NDF (Read)
      }{
         Hermitian frequency-domain input NDF containing the complex
         transform. If null is entered no Hermitian NDF is read and
         then the application should be supplied either separate real
         and imaginary NDFs, or the power and phase NDFs. Prompting
         will not occur if one of the other (inverse) input NDFs has
         been given on the command line, but not HERMIN as well.  This
         parameter is only relevant for an inverse transformation.
      }
      \sstsubsection{
         HERMOUT = NDF (Write)
      }{
         Hermitian output NDF from a forward transform. If a null value
         is given then this NDF is not produced.
      }
      \sstsubsection{
         HM\_TITLE = LITERAL (Read)
      }{
         Title for the Hermitian Fourier-transform output NDF.
         A null (!) value means using the title of the input NDF.
         {\tt ['KAPPA - Fourier - Hermitian']}
      }
      \sstsubsection{
         IM\_TITLE = LITERAL (Read)
      }{
         Title for the frequency-domain imaginary output NDF.
         A null (!) value means using the title of the input NDF.
         {\tt ['KAPPA - Fourier - Imaginary']}
      }
      \sstsubsection{
         IMAGIN = NDF (Read)
      }{
         Input frequency-domain NDF containing the real part of the
         complex tranform. If a null is given then an image of zeros is
         assumed unless a null is also given for REALIN, in which case
         the input is requested in power and phase form. This parameter
         is only available if HERMIN is not used.  One way to achieve
         that is to supply IMAGIN, but not HERMIN, on the command
         line.  This parameter is only relevant for an inverse
         transformation.
      }
      \sstsubsection{
         IMAGOUT = NDF (Write)
      }{
         Frequency-domain output NDF containing the imaginary part of
         the complex Fourier transform. If a null value is given then
         this NDF is not produced. {\tt [!]}
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         Real (space-domain) input NDF for a forward transformation.
         There are no restrictions on the size or shape of the input
         NDF, although the it may have to be padded or trimmed before
         being transformed. This parameter is only used if a forward
         transformation was requested.
      }
      \sstsubsection{
         INVERSE = \_LOGICAL (Read)
      }{
         If true then the inverse transform---frequency domain to
         space domain---is required, otherwise a transform from the
         space to the frequency domain is undertaken. {\tt [FALSE]}
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Real space-domain output NDF. This parameter is only used if
         an inverse transformation is requested.
      }
      \sstsubsection{
         PH\_TITLE = LITERAL (Read)
      }{
         Title for the frequency-domain phase output NDF.
         A null (!) value means using the title of the input NDF.
         {\tt ['KAPPA - Fourier - Phase']}
      }
      \sstsubsection{
         PHASEIN = NDF (Read)
      }{
         Input frequency-domain NDF containing the phase of the complex
         tranform.  If a null is given then an image of zeros is
         assumed unless a null is also given for PHASEIN, in which
         case the application quits.  This parameter is only available
         if HERMIN, REALIN and IMAGIN are all not used.  One way to
         achieve that is to supply PHASEIN, but none of the
         aforementioned parameters, on the command line.  This
         parameter is only relevant for an inverse transformation.
      }
      \sstsubsection{
         PHASEOUT = NDF (Write)
      }{
         Frequency-domain output NDF containing the phase of the
         complex Fourier transform. If a null value is given then this
         NDF is not produced. {\tt [!]}
      }
      \sstsubsection{
         POWERIN = NDF (Read)
      }{
         Input frequency-domain NDF containing the modulus of the
         complex tranform.  Note, this should be the square root of the
         power rather than the power itself.  If a null is given then an
         image of zeros is assumed unless a null is also given for
         PHASEIN, in which case the application quits.  This parameter
         is only available if HERMIN, REALIN and IMAGIN are all not
         used.  One way to achieve that is to supply POWERIN, but none
         of the aforementioned parameters, on the command line.  This
         parameter is only relevant for an inverse transformation.
      }
      \sstsubsection{
         POWEROUT = NDF (Write)
      }{
         Frequency-domain output NDF containing the modulus of the
         complex Fourier transform. Note, this is the square root of
         the power rather than the power itself. If a null value is
         given then this NDF is not produced. {\tt [!]}
      }
      \sstsubsection{
         PW\_TITLE = LITERAL (Read)
      }{
         Title for the frequency-domain power output NDF.
         A null (!) value means using the title of the input NDF.
         {\tt ['KAPPA - Fourier - Power']}
      }
      \sstsubsection{
         REALIN = NDF (Read)
      }{
         Input frequency-domain NDF containing the real part of the
         complex tranform. If a null is given then an image of zeros is
         assumed unless a null is also given for IMAGIN, in which case
         the input is requested in power and phase form. This parameter
         is only available if HERMIN is not used.  One way to achieve
         that is to supply REALIN, but not HERMIN, on the command
         line.  This parameter is only relevant for an inverse
         transformation.
      }
      \sstsubsection{
         REALOUT = NDF (Write)
      }{
         Frequency-domain output NDF containing the real part of the
         complex Fourier transform. If a null value is given then this
         NDF is not produced. {\tt [!]}
      }
      \sstsubsection{
         RL\_TITLE = LITERAL (Read)
      }{
         Title for the frequency-domain real output NDF.
         A null (!) value means using the title of the input NDF.
         {\tt ['KAPPA - Fourier - Real']}
      }
      \sstsubsection{
         SHIFT = \_LOGICAL (Read)
      }{
         If true the transform origin is to be located at the array's
         centre. This is implemented by swapping bottom-left and
         top-right, and bottom-right and top-left array quadrants,
         before doing the transform. This results in the transformation
         effectively being done about pixel $x$ = INT(NAXIS1/2)$+$1 and
         $y$ = INT(NAXIS2/2)$+$1, where NAXIS$n$ are the padded or trimmed
         dimensions of the NDF. {\tt [FALSE]}
      }
      \sstsubsection{
         TRIM = LOGICAL (Read)
      }{
         If true when the input array dimension cannot be processed by
         the transform, the output arrays will be trimmed rather than
         padded with the fill value. {\tt [FALSE]}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the real space-domain output NDF.
         A null (!) value means using the title of the input NDF.
         {\tt ['KAPPA - Fourier']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         FOURIER GALAXY FT\_GAL
      }{
         Makes an Hermitian Fourier transform stored in an NDF called
         FT\_GAL from the 2-d NDF called GALAXY.
      }
      \sstexamplesubsection{
         FOURIER HERMIN=FT\_GAL OUT=GALAXY INVERSE
      }{
         Takes an Hermitian Fourier transform stored in an NDF called
         FT\_GAL and performs the inverse transformation to yield a
         normal (spatial domain) image in NDF GALAXY.
      }
      \sstexamplesubsection{
         FOURIER IN=GALAXY POWEROUT=GALPOW HERMOUT=FT\_GAL FILLVAL=MEAN
      }{
         Makes an Hermitian Fourier transform stored in an NDF called
         FT\_GAL from the 2-d NDF called GALAXY.  Any bad values in
         GALAXY are replaced by the mean data value of GALAXY.  In
         addition the power of the transform is written to an NDF
         called GALPOW.
      }
      \sstexamplesubsection{
         FOURIER REALIN=REAL\_GAL OUT=GALAXY INVERSE
      }{
         Takes the real component of a Fourier transform stored in an
         NDF called REAL\_GAL and performs the inverse transformation to
         yield a normal image in NDF GALAXY.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         See the NAG documentation, Chapter C06, for more details of
           Hermitian Fourier transforms.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         AXIS, VARIANCE and QUALITY are not propagated from the input to
         output NDFs, but the LABEL, TITLE, HISTORY components and all
         extensions are.
      }
   }
}

\sstroutine{
   GAUSS
}{
   Smooths a 2-dimensional image using a symmetrical Gaussian
   filter
}{
   \sstdescription{
      This application applies a symmetrical filter to a 2-dimensional
      image so as to convolve it with a Gaussian point spread function
      (PSF) of specified width. The image is held in an NDF data
      structure.
   }
   \sstusage{
      GAUSS IN OUT FWHM
   }
      \sstparameters{
      \sstsubsection{
         BOX = \_INTEGER (Read)
      }{
         Size (in pixels) of the square region over which the Gaussian
         PSF should be applied at each point.  The smoothing PSF will
         be set to zero outside this square, which should therefore be
         sufficiently large not to truncate the PSF too early.  The
         value given will be rounded up to a positive odd integer if
         necessary.  A dynamic default value is calculated which is
         just sufficient to accommodate the Gaussian PSF out to a
         radius of 3 standard deviations. Note that the time taken to
         perform the smoothing increases in approximate proportion to
         the value of this parameter. {\tt []}
      }
      \sstsubsection{
         FWHM = \_REAL (Read)
      }{
         Full-width at half-maximum of the Gaussian PSF to be used in
         smoothing the image. A value between 0.1 and 100.0 should be
         given. Note that unless a non-default value is specified for
         the BOX parameter, the time taken to perform the smoothing
         will increase in approximate proportion to the value of FWHM.
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         The input NDF containing the 2-dimensional image to which
         Gaussian smoothing is to be applied.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         The output NDF which is to contain the smoothed image.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Value for the title of the output NDF. A null value will cause
         the title of the input NDF to be used. {\tt ['KAPPA - Gauss']}
      }
      \sstsubsection{
         WLIM = \_DOUBLE (Read)
      }{
         If the input image contains bad pixels, then this parameter
         may be used to determine the number of good pixels which must
         be present within the PSF area before a valid output pixel is
         generated.  It can be used, for example, to prevent output
         pixels from being generated in regions where good pixels are
         only present in the wings of the PSF.

         By default, a null ({\tt !}) value is used for WLIM, which causes
         the pattern of bad pixels to be propagated from the input
         image to the output image unchanged. In this case, smoothed
         output values are only calculated for those pixels which are
         not bad in the input image.

         If a numerical value is given for WLIM, then it specifies the
         minimum PSF-weighted fraction of good pixels which must be
         present in the PSF area ({\it i.e.}\ box) in order to generate a good
         output pixel.  The maximum value, in the absence of bad
         pixels, is unity.  If the specified minimum fraction of good
         input pixels is not present, then a bad output pixel will
         result, otherwise a smoothed output value will be calculated.
         The value of this parameter should lie between 1E-6 and 1.0.
         {\tt [!]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GAUSS IMAGE1 IMAGE2 5.0
      }{
         Smooths the 2-dimensional image held in the NDF structure
         IMAGE1 using a symmetrical Gaussian PSF with a full-width at
         half-maximum of 5.  The smoothed image is written to IMAGE2.
         If any pixels in the input image are bad, then the
         corresponding pixels in the output image will also be bad.
      }
      \sstexamplesubsection{
         GAUSS IN=A OUT=B FWHM=3.5 BOX=31
      }{
         Smooths the 2-dimensional image held in the NDF structure A,
         writing the result into the structure B. The Gaussian
         smoothing PSF has a full-width at half-maximum of 3.5 pixels
         and is evaluated over a large square of size 31x31 pixels.
      }
      \sstexamplesubsection{
         GAUSS NGC1097 NGC1097S FWHM=7.2 WLIM=0.1
      }{
         Smooths the specified image data using a Gaussian PSF with a
         full-width at half-maximum of 7.2. An output value is
         calculated for any pixel for which the PSF-weighted fraction
         of good input pixels is at least 0.1. This will cause the
         smoothing operation to fill in moderately-sized regions of bad
         pixels.
      }
   }
   \sstdiytopic{
      Timing
   }{
      The execution time is approximately proportional to the number of
      pixels in the image to be smoothed and to the value given for the
      BOX parameter. By default, this latter value is proportional to
      the value given for FWHM. Execution time will be approximately
      doubled if a variance array is present in the input NDF.
   }
   \sstimplementationstatus{
      This routine correctly processes the AXIS, DATA, QUALITY, LABEL,
      TITLE, VARIANCE and UNITS components of the input NDF. Processing
      of bad pixels and all non-complex numeric types is supported.
      Arithmetic is performed using single precision floating point, or
      double precision if appropriate.
   }
}

 
\sstroutine{
   GDCLEAR
}{
   Clears a graphics device and purges its database entries
}{
   \sstdescription{
      This application software resets an SGS graphics device. In effect
      the device is cleared.  It purges the graphics-database entries
      for the device.  Optionally, only the current picture is cleared
      and the database unchanged. (Note the clearing of the current
      picture may not work on some graphics devices.)
   }
   \sstusage{
      GDCLEAR [DEVICE] [CURRENT]
   }
   \sstparameters{
      \sstsubsection{
         CURRENT = \_LOGICAL (Read)
      }{
         If true then only the current picture is cleared. {\tt [FALSE]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics device to be cleared.
         {\tt [}Current graphics device{\tt ]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GDCLEAR
      }{
         Clears the current graphics device and purges its graphics
         database entries.
      }
      \sstexamplesubsection{
         GDCLEAR CURRENT
      }{
         Clears the current picture on the current graphics device.
      }
      \sstexamplesubsection{
         GDCLEAR IKON
      }{
         Clears the Ikon device and purges its graphics database
         entries.
      }
   }
}

\sstroutine{
   GDNAMES
}{
   Shows which graphics devices are available
}{
   \sstdescription{
      The routine displays a list of the graphics devices available and
      the names which identify them.  Each name is accompanied by a
      brief descriptive comment.
   }
   \sstusage{
      GDNAMES
   }
}
 
\sstroutine{
   GDSET
}{
   Selects a current graphics device
}{
   \sstdescription{
      This application selects a current SGS graphics device.  This
      device will be used for all applications requiring an
      image-display until changed explicitly.
   }
   \sstusage{
      GDSET DEVICE
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics device to become the current graphics device.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GDSET IKON
      }{
         Makes the Ikon device the current graphics device.
      }
   }
}

\sstroutine{
   GDSTATE
}{
   Show the current status of a graphics device
}{
   \sstdescription{
      This application displays the current status of a graphics
      device, including details of the current graphics-database
      picture ({\it e.g.}\ its co-ordinate system and position on the display
      surface).
   }
   \sstusage{
      GDSTATE [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the graphics device about which information is
         required. {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         OUTLINE = \_LOGICAL (Read)
      }{
         If OUTLINE is TRUE, then an outline will be drawn around the
         current picture to indicate its position. {\tt [FALSE]}
      }
      \sstsubsection{
         REPORT = \_LOGICAL (Read)
      }{
         If this is false details of the graphics device are not
         reported, merely the results are written to the output
         parameters.  It is intended for use within procedures. {\tt [TRUE]}
      }
   }
   \sstresparameters{
      \sstsubsection{
         COMMENT = LITERAL (Write)
      }{
         The comment of the current picture.  Up to 132 characters
         will be written.
      }
      \sstsubsection{
         LABEL = LITERAL (Write)
      }{
         The label of the current picture.  It is blank if there is no
         label.
      }
      \sstsubsection{
         NAME = LITERAL (Write)
      }{
         The name of the current picture.
      }
      \sstsubsection{
         NCX1 = \_REAL (Write)
      }{
         The lower $x$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         NCX2 = \_REAL (Write)
      }{
         The upper $x$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         NCY1 = \_REAL (Write)
      }{
         The lower $y$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         NCY2 = \_REAL (Write)
      }{
         The upper $y$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         REFNAM = LITERAL (Write)
      }{
         The reference object associated with the current picture.  It
         is blank if there is no reference object.  Up to 132 characters
         will be written.
      }
      \sstsubsection{
         WCX1 = \_REAL (Write)
      }{
         The lower $x$ world co-ordinate of the current picture.
      }
      \sstsubsection{
         WCX2 = \_REAL (Write)
      }{
         The upper $x$ world co-ordinate of the current picture.
      }
      \sstsubsection{
         WCY1 = \_REAL (Write)
      }{
         The lower $y$ world co-ordinate of the current picture.
      }
      \sstsubsection{
         WCY2 = \_REAL (Write)
      }{
         The upper $y$ world co-ordinate of the current picture.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GDSTATE
      }{
         Shows the status of the current graphics device.
      }
      \sstexamplesubsection{
         GDSTATE IKON
      }{
         Shows the status of the Ikon device.
      }
      \sstexamplesubsection{
         GDSTATE OUTLINE
      }{
         Shows the status of the current graphics device and draws an
         outline around the current database picture.
      }
      \sstexamplesubsection{
         GDSTATE REFNAM=(NDFNAME)
      }{
         Shows the status of the current graphics device.  If there
         is a reference data object, its name is written to the ICL
         variable NDFNAME.
      }
      \sstexamplesubsection{
         GDSTATE NCX1=(X1) NCX2=(X2) NCY1=(Y1) NCY2=(Y2)
      }{
         Shows the status of the current graphics device.  The bounds
         of the current picture in normalised device co-ordinates
         are written to the ICL variables: X1, X2, Y1, Y2.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a channel to the graphics device cannot be opened, then
         this application will still execute without error, but a reduced
         amount of information will be displayed and an outline around the
         current picture (if requested) will not be drawn.
      }
   }
}

\manroutine {{\manheadstyle{GLITCH}}}{ Replaces bad pixels in a 2-d data array with
  the local median.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This application removes bad pixels from a 2-d data array, stored
  in the input {\mantt{IMAGE}} structure, and replaces them with the local
  median of the eight (or less at the edges) neighbouring pixels.
  At least three defined pixels must be in the neighbourhood,
  otherwise the resultant pixel becomes bad.

  There are three modes of use:
\begin{manenumerate}
\manenumerateitem {1.}
  The application can be used interactively until the user is
  finished cleaning his array. The user specifies the position of
  `glitches' or bad pixels by their {$x$} and {$y$} pixel indices.
\manenumerateitem {2.}
  The user can give the name of a file which contains a free-format
  list giving the {$x$} and {$y$} positions of the pixels to be
  deglitched. The glitch list file should look like the following
  example:

\begin{verbatim}
        Glitch list for SBRC FPA #005
        22  45
        19  56
        2  30
        .  .
        .  .
        .  .
        <EOF>
\end{verbatim}

  {\it i.e.}\ a header string that is output to the user, followed by
  integer {$x$}-{$y$} pixel position pairs, terminated just by the
  end-of-file marker. The header string is output to the user.
\manenumerateitem {3.}
  The bad (undefined/magic) pixels are automatically deglitched.
  (Edge, especially corner pixels will need checking if the
  density of bad pixels is high, because of the constraints
  mentioned above. Such conditions may require a repeat dose of
  this application, probably with option 1 or 2.)

\end{manenumerate}
  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  GLITCH

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the 2-d data array to be deglitched.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the deglitched version of
  the data array.
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure.
  \mbox{\mantt ['KAPPA - Glitch']}
\manparameterentry {{\mantt{READ}} }{{\mantt{WHERE}}  }{{\mantt{\_CHAR}}}
  Source of glitch positions - {\mantt Interface} or {\mantt File} or
  {\mantt Bad}.
\manparameterentry {{\mantt{READ}} }{{\mantt{FILENAME}}  }{{\mantt{\_CHAR}}}
  File containing the free-format glitch list.
\manparameterentry {{\mantt{READ}} }{{\mantt{XCOORD}}  }{{\mantt{\_INTEGER}}}
  {$x$} pixel index of the pixel to be deglitched.
\manparameterentry {{\mantt{READ}} }{{\mantt{YCOORD}}  }{{\mantt{\_INTEGER}}}
  {$y$} pixel index of the pixel to be deglitched.
\manparameterentry {{\mantt{READ}} }{{\mantt{AGAIN}}  }{{\mantt{\_LOGICAL}}}
  Whether or not user is prompted for another pixel.
\end{manparametertable}
\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

 
\sstroutine{
   GLOBALS
}{
   Displays the values of the KAPPA global parameters
}{
   \sstdescription{
      This procedure lists the meanings and values of the KAPPA global
      parameters.  If a global parameter does not have a value, the
      string {\tt "<undefined>"} is substituted where the value would have been
      written.
   }
   \sstusage{
      GLOBALS
   }
}

\sstroutine{
   GREYPLOT
}{
   Produces a greyscale plot of a 2-d NDF
}{
   \sstdescription{
      This applications produce a greyscale plot of a 2-d NDF,
      especially for a hardcopy device.  The image is usually the data
      array, but may also be the variance or quality.  The plot appears
      in the current graphics-database picture.

      The greyscale plot resides within optional, annotated and
      enumerated axes. An optional key may be drawn to the right of the
      greyscale plot comprising a title and grey blocks annotated with
      the corresponding array value.  There are a number of scaling
      methods to map array values to grey levels in the plot.

      The time to output to hardcopy devices can be quite lengthy
      and generally depends on the size of the greyscale plot.
      Therefore, there are parameters for controlling the size of
      the plot.
   }
   \sstusage{
      GREYPLOT IN [COMP] KEY [DEVICE] MODE [PXSIZE] [PYSIZE] [OUT]
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                    WHITE=? BLACK=? \\  
                    PERCENTILES=? \\
                    SIGMAS=? 
                  \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small mode}
   }
   \sstparameters{
      \sstsubsection{
         BLACK = \_DOUBLE (Read)
      }{
         The array value that scales to the black in the greyscale
         colour table.  All smaller array values appear black when
         BLACK is less than WHITE, otherwise all array values
         smaller than BLACK appear white.  The dynamic default is the
         minimum data value.   There is an efficiency gain when both
         BLACK and WHITE are given on the command line, because the
         extreme values need not be computed.  (Scale mode)
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be {\tt "Data"},
         {\tt "Quality"} or {\tt "Variance"}. {\tt ["Data"]}
      }
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either
         {\tt "WORLD"} or {\tt "DATA"}.  {\tt "WORLD"} makes pixel
         co-ordinates to appear on axes. If COSYS = {\tt "DATA"} the
         NDF's axis information is used to annotate axes.
         {\tt [}Current co-ordinate system{\tt ]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the graphics device used to display the image.
         The device must be in one of the following GNS categories:
         IMAGE\_DISPLAY, IMAGE\_OVERLAY, MATRIX\_PRINTER, or WINDOW, and
         have at least 24 greyscale intensities.
         {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         FULL = \_LOGICAL (Read)
      }{
         If true, the whole greyscale lookup table for the device is
         used including the normally reserved pens.  Thus all but two
         of the available intensities participate in the greyscale,
         which improves the photographic quality of the image.  The
         remaining pens are for the background, and for the key and
         axes.  This option is only available for devices that reset
         their `colour' tables when the device is opened, such as
         Laserprinters. (This restriction prevents problems on devices
         that retain their `colour tables', where using the normally
         reserved pens would mean that either part of the greyscale
         would be emphemeral---departing when the application
         completes if the reserved pens are stored and reinstated on
         completion, or earlier plots drawn by other applications would
         be altered.)

         If FULL = {\tt FALSE}, only non-reserved intensities will form the
         greyscale.  The default is {\tt TRUE} when the non-reserved pens
         is less than 32, and {\tt FALSE} otherwise.  (This figure was chosen
         because it is roughly the number of grey levels at which the
         eye will clearly detect the quantisation in a complex scene.)
         []
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         Input NDF data structure containing the image to be displayed.
      }
      \sstsubsection{
         KEY = \_LOGICAL (Read)
      }{
         A key of the greyscale versus pixel value and title is to be
         produced. {\tt [TRUE]}
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The type of scaling to be applied to the array.  The options
         are:
         \begin{description}
         \item [Flash] - The image is flashed onto the screen without
                         any scaling at all.  This is the fastest
                         option.  Since there is no longer a one-to-one
                         mapping between data values and grey levels
                         this scaling mode is not available with a key.
         \item [Faint] - The image is scaled from the mean minus one
                         standard deviation to the mean plus seven
                         standard deviations.   The scaling values are
                         reported so that the faster Scale mode may be
                         utilised later.
         \item [Percentiles] - The image is scaled between the values
                         corresponding to two percentiles.  The scaling
                         values are reported so that the faster Scale
                         mode may be utilised later.
         \item [Range]   - The image is scaled between the minimum and
                         maximum data values.
         \item [Scale]   - The user defines the upper and lower limits
                         between which the image is to be scaled. The
                         application reports the maximum and the minimum
                         values for reference and makes these defaults
                         respectively.
         \item [Sigmas]  - The image is scaled between two
                         standard-deviation limits.  The scaling values
                         used are reported so that the faster Scale mode
                         may be utilised later.
         \end{description}
      }
      \sstsubsection{
         NUMBIN  =  \_INTEGER (Read)
      }{
         The number of histogram bins used to compute percentiles for
         scaling. (Percentiles mode) {\tt [2048]}
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         The scaled NDF that is displayed; it also does not have
         values that equal the reserved portion of the colour table.
         The output NDF is intended to be used as the input data in
         conjunction with SCALE = FALSE.  It will be vertically
         inverted with respect to the input array because of GKS
         convention.  If it has a null value ({\tt !}) no output NDF will be
         created.  This parameter is ignored when SCALE = FALSE.
         {\tt [!]}
      }
      \sstsubsection{
         PERCENTILES( 2 ) = \_REAL (Read)
      }{
         The percentiles that define the scaling limits. For example,
         {\tt [75,25]} would scale between the quartile values. (Percentile
         mode)
      }
      \sstsubsection{
         PXSIZE = \_REAL (Read)
      }{
         The length ($x$ axis) of the plot in metres.  {\tt [}Maximum that can
         fit in the current picture whilst preserving square pixels.{\tt ]}
      }
      \sstsubsection{
         PYSIZE = \_REAL (Read)
      }{
         The length ($y$ axis) of the plot in metres.  {\tt [}Maximum that can
         fit in the current picture whilst preserving square pixels.{\tt ]}
      }
      \sstsubsection{
         REDUCT = \_REAL (Read)
      }{
         The reduction factor of the array, and must be in the range
         1/MAX($NX$,$NY$)--1.0, where $NX$ and $NY$ are the number of pixels
         in the image along the $x$ and $y$ directions.  Since the output
         to the hardcopy device may be long, the size of the image
         with respect to the key can be reduced by lowering REDUCT.
         The spooling time goes approximately proportional to the
         square of REDUCT.  1.0 means the array fills the plotting zone.
         {\tt [1.0]}
      }
      \sstsubsection{
         SCALE = \_LOGICAL (Read)
      }{
         If true the input array is scaled according to the value of
         parameter MODE.  If it is false MODE is ignored, and the input
         array is displayed as is.  There is no scaling, inversion
         or avoidance of annotation pens.  SCALE = {\tt FALSE} is intended to
         be used with arrays previously scaled by this or similar
         applications which have already performed the scaling,
         inversion and exclusion.  It provides the quickest method of
         image display within this application. {\tt [TRUE]}
      }
      \sstsubsection{
         SIGMAS( 2 ) = \_REAL (Read)
      }{
         The standard-deviation bounds that define the scaling limits.
         To obtain values either side of the mean both a negative and
         a positive value are required.  Thus {\tt [$-$2,3]} would scale
         between the mean minus two and the mean plus three standard
         deviations.  {\tt [3,$-$2]} would give the negative of that. (Sigmas
         mode).
      }
      \sstsubsection{
         WHITE = \_DOUBLE (Read)
      }{
         The array value that scales to white in the greyscale
         colour table.  All larger array values appear white when
         WHITE is greater than BLACK, otherwise all array values
         larger than WHITE appear black.  The dynamic default is the
         maximum data value.   There is an efficiency gain when both
         BLACK and WHITE are given on the command line, because the
         extreme values need not be computed.  (Scale mode)
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB  =  LITERAL (Read)
      }{
         Label for the plot abscissa, in which NCAR fancy founts may be
         embedded when FONT = {\tt "NCAR"}.  This parameter is only used
         when the axes option is selected.  If axis information is present
         the suggested default is the NDF's axis label followed by the
         units, in parentheses.  If an error occurs obtaining the label
         the suggested default is {\tt "X"}. {\tt []}
      }
      \sstsubsection{
         AXES = \_LOGICAL (Read)
      }{
         True if annotated axes are to be drawn around the displayed
         image.  The annotations are either the data co-ordinates from
         the NDF axis components, provided these are present and linear
         and COSYS = {\tt "DATA"}; otherwise pixel co-ordinates are used.
         {\tt [FALSE]}
      }
      \sstsubsection{
         BADCOL = LITERAL (Read)
      }{
         The grey level to give a bad pixel in the display.  The options
         are:

         \begin{description}
           \item [{\tt "}MAX{\tt "}]  - Black
           \item [{\tt "}MIN{\tt "}]  - White
           \item [An integer] - The actual 'colour' index. It is constrained
                            between 0 and the maximum colour index
                            available on the device, and so gives a shade
                            of grey.  0 gives the background colour.
           \item [A named 'colour'] - Uses the named 'colour' from the
                            palette, and if it is not present, the nearest
                            colour from the palette is selected.  The
                            palette contains grey levels at percentages
                            from black to white, {\it e.g.}\ GREY50 is
                            midway between black and white.
         \end{description}
         If this application is run on a device that supports colour
         it is possible to mark the bad pixels in colour on the
         greyscale provided BADCOL is an integer between 0 and 15, or
         a named colour.  The bad pixels will remain unaltered if the
         lookup table is manipulated.  The suggested default is the
         current value. {\tt [}The current value, but equals {\tt "MIN"} if
         there is no current value.{\tt ]}
      }
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         {\tt "NCAR"} for the NCAR fancy characters and {\tt "GKS"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value. {\tt ["GKS"]}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the numbers of major tick marks
         for the $x$ and $y$ axes.  (Number used is between MAJTIC$+$2 and
         5$*$MAJTIC/2$+$4.)   A negative value for an axis makes the
         graphics package decide an appropriate value.  This parameter
         is only used when the axes option is selected. {\tt [3.,3.]}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark
         for the $x$ and $y$ axes.  A negative value forces the graphics
         package to compute appropriate values.   This parameter is
         only used when the axes option is selected. {\tt [-1.,-1.]}
      }
      \sstsubsection{
         ORDLAB  =  LITERAL (Read)
      }{
         Label for the plot ordinate, in which NCAR fancy founts
         may be embedded when FONT = {\tt "NCAR"}.  This parameter is only
         used when the axes option is selected.  If axis information is
         present the suggested default is the NDF's axis label followed by
         the units, in parentheses.  If an error occurs obtaining the label
         the suggested default is {\tt "Y"}. {\tt []}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         True if the axis tick marks are to appear on the outside of
         the axes instead of inside.   This parameter is only used
         when the axes option is selected. {\tt [TRUE]}
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of the plot.  Up to about 25 characters can be
         accommodated when there are no axes, and about 40 otherwise.
         NCAR fancy founts may be embedded ({\it c.f.}\ SUN/90) when
         FONT = {\tt "NCAR"}.  This parameter is only used when either
         the axes or key option is selected. {\tt [}The NDF title{\tt ]}
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the axes and annotations in the plot, where
         1.0 is the normal thickness.  It should be between 0.5 and 5.
         This feature is only available on some devices.   This
         parameter is only used when the axes option is selected.
         {\tt [1.0]}
      }
   }
   \sstresparameters{
      \sstsubsection{
         SCAHIGH = \_DOUBLE (Write)
      }{
         The array value scaled to white in the greyscale display.
         In Flash mode or when there is no scaling the colour index of
         white is used.
      }
      \sstsubsection{
         SCALOW = \_DOUBLE (Write)
      }{
         The array value scaled to black in the greyscale display.
         In Flash mode or when there is no scaling the colour index of
         black is used.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GREYPLOT SDOR KEY MODE=SC BLACK=1 WHITE=5.2
      }{
         Makes a greyscale display of the data component of the NDF
         called SDOR on the current image-display device, scaling
         between 1 and 5.2.  Values up to 1.0 in the data array will
         appear black in the plot, and values larger than 5.2 will be
         white.  Intermediate values will a grey level determined by
         linear interpolation.  A key is drawn to the right of the
         greyscale.
      }
      \sstexamplesubsection{
         GREYPLOT IN=SDOR NOKEY MODE=P PERCENTILES=[10,90] BADCOL="Black"
      }{
         This makes a greyscale plot of the NDF called SDOR on the
         current image-display device. The scaling is between the 10 and
         90 per cent percentiles of the image.  No key is drawn.  Bad
         data appear black in the plot.
      }
      \sstexamplesubsection{
         GREYPLOT MODE=FA AXES OUT=VIDEO COSYS=D $\backslash$
      }{
         Displays a greyscale of the current NDF data component with
         annotated axes on the current image-display device.  The axes
         take the axis labels and title from the NDF, and are annotated
         in data co-ordinates.  The scaling is between the $-$1 and $+$7
         standard deviations of the image around its mean.  A key is
         drawn.  The scaled data are stored in an NDF called VIDEO.
      }
      \sstexamplesubsection{
         GREYPLOT VIDEO NOSCALE $\backslash$
      }{
         Displays the data component of the NDF called VIDEO (created
         in the previous example) without scaling within the current
         picture on the current image-display device.
      }
      \sstexamplesubsection{
         GREYPLOT CGS4K V KEY MODE=RA DEVICE=CANON\_L
      }{
         Makes a greyscale display of the variance component of NDF
         CGS4K on the Canon\_l device, scaling between the minimum and
         maximum variance values.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         -  The application stores a number of pictures in the graphics
         database in the following order: a FRAME of the specified size
         containing the title, annotated axes, and the image area
         (provided AXES is true), whose world co-ordinates are in pixels;
         a DATA picture with world co-ordinates in units of data pixels;
         and a KEY.  The DATA picture also may have double-precision data
         co-ordinates derived from the NDF axis component provided these
         are linear and different from pixel co-ordinates; the data
         co-ordinates are stored via a linear transformation.  The NDF
         associated with the plot is stored by reference with the DATA
         picture.  On exit the current database picture for the chosen
         device reverts to the input picture.

         \sstitem
         When axes are requested the axis annotations are defined by
         their lower and upper bounds, {\it i.e.}\ a regular array is assumed.
         The bounds are in pixel or data co-ordinates.

         \sstitem
         The data type of the output NDF depends on the number of colour
         indices: \_UBYTE for no more than 256, \_UWORD for 257 to 65535,
         and \_INTEGER otherwise.   The output NDF will not contain any
         extensions, UNITS and VARIANCE, but QUALITY, LABEL, TITLE, UNITS
         and AXIS information are propagated from the input NDF.   The
         output NDF does not become the new current data array.  It is a
         Simple NDF (because the bad-pixel flag is set to false in order to
         access the maximum grey level), therefore only NDF-compliant
         applications can process it.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The magic-value method is used for processing bad data.

         \sstitem
         This application will handle data in all numeric types, though
         type conversion to integer will occur for unsigned byte and word
         images.  However, when there is no scaling only integer data will
         not be type converted, but this is not expensive for the expected
         byte-type data.
      }
   }
}
 
 
\sstroutine{
   HIDE
}{
   Draws a perspective plot of a 2-d NDF
}{
   \sstdescription{
      This application draws a hidden-line perspective view of a 2-d
      NDF on the current graphics device.  The image may be part or
      whole of the data, variance or quality array.  It may be
      compressed in both dimensions to reduce noise and/or reduce the
      plotting time.  The image size is limited to 100-by-100 pixels.
      If the image is larger than this size it can be compressed so
      that it fits (the default), or clipped to plot no more than 100
      pixels in either direction.

      Any viewing angle above the surface may be specified.  The axes
      may be labelled but not enumerated.  The plot is situated within
      the current graphics-database picture.
   }
   \sstusage{
      HIDE NDF [COMP] [ELEVATION] [ORIENT] [BLOCK] [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         BLOCK = \_INTEGER (Read)
      }{
         The blocking factor used to average the image in both
         dimensions before it is plotted.  At least two pixels should
         remain in each dimension after blocking.  The value of the
         blocking is contrained between 1 and the smallest factor that
         would give two pixels in either direction.  A value of one
         will be the dynamic default when there is no need to compress,
         {\it i.e.}\ the image is less than 100-by-100 pixels. 
         {\tt [}The smallest value such that the image can fit within the
         100-by-100 pixel constraint{\tt ]}
      }
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         True if the graphics device is to be cleared before display
         of the array. {\tt [TRUE]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be {\tt "Data"},
         {\tt "Quality"} or {\tt "Variance"}. {\tt ["Data"]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device. {\tt [}Current graphics device{\tt ]}
      }
      \sstsubsection{
         ELEVATION = \_DOUBLE (Read)
      }{
         The angle of elevation of the viewer above the horizontal
         base plane in degrees. This must lie between 0 and 180. {\tt [30.]}
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         NDF structure containing the 2-d image to be displayed in a
         perspective plot.
      }
      \sstsubsection{
         ORIENT = \_DOUBLE (Read)
      }{
         The rotation of the vertical axis through the centre of the
         grid, in a clockwise direction, in degrees.  At zero degrees
         the $y$ axis of the image runs parallel with the $x$ axis of the
         display surface, and vice versa.  An example: for a rotation
         of 45 degrees and elevation angle is less than 90 degrees the
         furthest point is the lower bound, the $x$ axis goes to the left
         and the $y$ to the right, and the nearest point is the upper
         bound.  {\tt [45.]}
      }
      \sstsubsection{
         PXSIZE = \_REAL (Read)
      }{
         The length ($x$ axis) of the plot in metres. {\tt [}Maximum that can
         fit in the current picture whilst preserving square pixels{\tt ]}
      }
      \sstsubsection{
         PYSIZE = \_REAL (Read)
      }{
         The length ($y$ axis) of the plot in metres. {\tt [}Maximum that can
         fit in the current picture whilst preserving square pixels{\tt ]}
      }
      \sstsubsection{
         RESOLUTION = \_REAL (Read)
      }{
         The resolution factor. The actual plotting resolution is this
         times the $x$ and $y$ theoretical resolutions in world
         co-ordinates. In GKS whether or not a given `lamp' is
         illuminated or pen position is marked with ink cannot be
         determined, so a factor of unity is too small for the most
         efficient processing.  It must lie between 2.0 and 10.0. {\tt [2.0]}
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB  =  LITERAL (Read)
      }{
         Label for the plot abscissa.  Only the first 50 characters will
         be plotted.   If axis information is present the suggested
         default is the NDF's axis label followed by the units, in
         parentheses.  If an error occurs obtaining the label the
         suggested default is {\tt "X"}. {\tt []}
      }
      \sstsubsection{
         ORDLAB  =  LITERAL (Read)
      }{
         Label for the plot ordinate.  Only the first 50 characters will
         be plotted.  If axis information is present the suggested
         default is the NDF's axis label followed by the units, in
         parentheses.  If an error occurs obtaining the label the
         suggested default is {\tt "Y"}. {\tt []}
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of the plot.  Up to about 30 characters can be
         accommodated.  If an error occurs obtaining the title, it is
         defaulted to {\tt "Perspective Plot"}.
         {\tt [}The NDF's title{\tt ]}
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the axes and annotations in the plot, where
         1.0 is the normal thickness. Currently, this is only available
         on a few devices.  It must take a value in the range 0.5--5.0.
         {\tt [1.0]}
      }
   }
   \newpage
   \sstexamples{
      \sstexamplesubsection{
         HIDE MYFILE
      }{
         Draws a perspective plot of the data array in the NDF
         called MYFILE on the current graphics device.  If MYFILE has
         more than 100 pixels in either $x$ and $y$ it will be compressed.
         All other settings are defaulted.
      }
      \sstexamplesubsection{
         HIDE MYFILE V
      }{
         Draws a perspective plot of the variance array in the NDF
         called MYFILE on the current graphics device.  If MYFILE has
         more than 100 pixels in either $x$ and $y$ it will be compressed.
         All other settings are defaulted.
      }
      \sstexamplesubsection{
         HIDE MYFILE(10:73,16:55)
      }{
         Draws a perspective plot of part of the data array in the NDF
         called MYFILE on the current graphics device.  The part lies
         between pixel (10,16) and (73,55), {\it i.e.}\ 64 pixels in $x$ and 40
         in $y$.  All other settings are defaulted, so there is no
         compression.
      }
      \sstexamplesubsection{
         HIDE MYFILE(10:73,3,16:55) BLOCK=2
      }{
         Draws a perspective plot of part of the data array cube in the
         NDF called MYFILE on the current graphics device.  The part
         lies in the plane with y index 3 between pixel (10,3,16) and
         (73,3,55), {\it i.e.}\ 64 pixels in $x$ and 40 in $z$, but it is
         compressed to 32-by-20 pixels for plotting.
      }
      \sstexamplesubsection{
         HIDE IN=MYFILE COMP=V ABSLAB=R.A. ORDLAB=Dec. PLTITL=Variance
      }{
         Draws a perspective plot of the variance array in the NDF
         called MYFILE on the current graphics device.  If MYFILE has
         more than 100 pixels in either $x$ and $y$ it will be compressed.
         The axis labels are  {\tt "R.A"} and {\tt "Dec."} rather than
         {\tt "X"} and {\tt "Y"}, and the title is {\tt "Variance"}.
      }
      \sstexamplesubsection{
         HIDE IN=MYFILE ELEVATION=60 ORIENT=135
      }{
         Draws a perspective plot of the data array in the NDF
         called MYFILE on the current graphics device.  If MYFILE has
         more than 100 pixels in either $x$ and $y$ it will be compressed.
         The orientation angle is adjusted by 90 degrees clockwise from
         the default; and the viewing angle is twice the default, thus
         appearing to been observed from nearer the zenith.  All other
         settings are defaulted.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application stores a number of pictures in the graphics
         database in the following order: a FRAME of the specified size
         containing the title, and plot; and a DATA picture, which is
         currently stored with world co-ordinates of a unit square for the
         plot itself.  The NDF associated with the plot is stored by
         reference with the DATA picture.  On exit the current database
         picture for the chosen device reverts to the input picture.

         \sstitem
         For certain shaped images, particularly highly oblong ones,
         there may be no compression factor that enables the whole of
         the image to be plotted.  The application plots as much as it can
         in these circumstances.
      }
   }
   \sstdiytopic{
      Timing
   }{
      On slow graphics devices the timing is approximately proportional
      to the number of pixels to plot after blocking, plus a second
      small term depending on the original image size.  However, on fast
      graphics devices the latter term becomes more important, and
      blocking may increase the elapsed time slightly.  If there are bad
      pixels present the elapse time will increase, but this is hardly
      noticeable on slow devices.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Only real data can be processed directly.  Other data types
         will undergo a type conversion before the perspective plot is
         drawn.

         \sstitem
         Magic-value bad pixels cannot be plotted so should the image
         contain any, they are removed first by median filtering of the
         eight neighbouring pixels; if any remain they are set to the
         minimum value within the image.  If other bad-removal strategies
         are required these must be performed before calling this
         application.

         \sstitem
         This application calls a NAG routine.  Since this must have a
         double-precision data array free from magic-value pixels, extra
         processing and data copying is required more than doubling the
         time required by a bespoke subroutine.
      }
   }
}

\manroutine {{\manheadstyle{HISTAT}}}{ Generates an histogram of a 2-d data
 array to compute statistics.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  An histogram is computed for the pixel values of a user-specified
  sub-array of the 2-d data array, stored in the input {\mantt{IMAGE}}
  structure. From the histogram certain statistical parameters
  (mean; maximum and minimum, and their positions; median; mode;
  sum; number of pixels and number of bad/undefined pixels) are
  found from the histogram.  Note the mode is only estimated from
  {$3*{\rm median}-2*{\rm mode}$}, which is only valid for moderately
  skew distributions. Optionally, a set of percentiles may be evaluated.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  HISTAT

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{LOGFILE}} }{{\mantt{FILENAME}}}
  Name of the ASCII file to record the statistics. If null,
  there will be no logging. {\mantt [!]}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the data array from which
  histogram is to be formed.
\manparameterentry {{\mantt{READ}} }{{\mantt{XSTART}} }{{\mantt{\_INTEGER}}}
  {$x$} start pixel index of the sub-array to be included.
\manparameterentry {{\mantt{READ}} }{{\mantt{YSTART}} }{{\mantt{\_INTEGER}}}
  {$y$} start pixel index of the sub-array to be included.
\manparameterentry {{\mantt{READ}} }{{\mantt{XFINISH}} }{{\mantt{\_INTEGER}}}
  {$x$} end pixel index of the sub-array to be included.
\manparameterentry {{\mantt{READ}} }{{\mantt{YFINISH}} }{{\mantt{\_INTEGER}}}
  {$y$} end pixel index of the sub-array to be included.
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMBIN}} }{{\mantt{\_INTEGER}}}
  Number of bins to be used in the histogram. \mbox{\mantt [2048]}
\manparameterentry {{\mantt{READ}} }{{\mantt{PERCENTILES(100)}} }
{{\mantt{\_REAL}}}
  A list of percentiles to be found. None are computed if this
  parameter is null (!). {\mantt [!]}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{NUMPIX}} }{{\mantt{\_INTEGER}}}
  Number of pixels in the chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{NUMBAD}} }{{\mantt{\_INTEGER}}}
  Number of bad pixels in the chosen section.
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MAXIMUM}} }{{\mantt{\_REAL}}}
  Maximum value in the chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MAXPOS( 2 )}} }{{\mantt{\_INTEGER}}}
  {$x$},{$y$} indices of the pixel with the maximum value in the chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MINIMUM}} }{{\mantt{\_REAL}}}
  Minimum value in the chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MINPOS( 2 )}} }{{\mantt{\_INTEGER}}}
  {$x$},{$y$} indices of the pixel with the minimum value in the chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{TOTAL}} }{{\mantt{\_REAL}}}
  The total of pixel values in the chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MEAN}} }{{\mantt{\_REAL}}}
  The mean of pixel values in the chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MEDIAN}} }{{\mantt{\_REAL}}}
  The median of pixel values in the chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MODE}} }{{\mantt{\_REAL}}}
  The mode of pixel values in the chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{PERVAL()}} }{{\mantt{\_REAL}}}
  The values of the given percentiles in the chosen section.
  This parameter is only output when one or more percentiles
\end{manparametertable}
\manroutineitem {Deficiencies }{}
  The routine does not yet allow interactive display and
  manipulation of the histogram. (The subroutines used will be
  utilised elsewhere in histogram-equalisation applications,
  background determination and so on.)

\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{HISTEQ}}}{ Performs an histogram equalisation on a 2-d
  data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  Histogram equalisation is performed on a user-specified
  sub-array of a 2-d data array in the input {\mantt{IMAGE}} structure. The
  transformed array is output to a new data array in the output
  {\mantt{IMAGE}} structure.

  Histogram equalisation is an image-processing technique in which
  the distribution (between limits) of grey levels in the input
  picture is adjusted so that in the output picture there are
  approximately equal numbers of pixels at each grey level.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  HISTEQ

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the 2-d data array to be
  transformed.
\manparameterentry {{\mantt{READ}} }{{\mantt{XSTART}}  }{{\mantt{\_INTEGER}}}
  {$x$} start pixel index of sub-array to be included.
\manparameterentry {{\mantt{READ}} }{{\mantt{YSTART}}  }{{\mantt{\_INTEGER}}}
  {$y$} start pixel index of sub-array to be included.
\manparameterentry {{\mantt{READ}} }{{\mantt{XFINISH}} }{{\mantt{\_INTEGER}}}
  {$x$} end pixel index of sub-array to be included.
\manparameterentry {{\mantt{READ}} }{{\mantt{YFINISH}} }{{\mantt{\_INTEGER}}}
  {$y$} end pixel index of sub-array to be included.
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMBIN}}  }{{\mantt{\_INTEGER}}}
  Number of histogram bins to be used. \mbox{\mantt [2048]}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure to contain transformed data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for new {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Histeq']}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{HISTOGRAM}}}{ Derives histograms of sub-arrays within 
  a 2-d data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes a 2-d data array in the input {\mantt{IMAGE}} structure
  and outputs histogram information about that array between
  specified limits, defaulted to the maximum and minimum values.
  The region analysed is a sub-array specified by the four corners.
  There are two loops. The inner one allows the histogram limits
  and the number of bins to be redefined for the current sub-array.
  The outer loop enables another sub-array to be defined.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  HISTOGRAM

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{LOGFILE}} }{{\mantt{FILENAME}}}
  Name of the ASCII file to record the histograms. If null,
  there will be no logging. {\mantt [!]}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the 2-d data array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{XSTART}} }{{\mantt{\_INTEGER}}}
  {$x$} start pixel index of the sub-array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{YSTART}} }{{\mantt{\_INTEGER}}}
  {$y$} start pixel index of the sub-array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{XFINISH}} }{{\mantt{\_INTEGER}}}
  {$x$} end pixel index of the sub-array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{YFINISH}} }{{\mantt{\_INTEGER}}}
  {$y$} end pixel index of the sub-array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMBIN}} }{{\mantt{\_INTEGER}}}
  Number of bins in the histogram.
\manparameterentry {{\mantt{READ}} }{{\mantt{LOWLIM}} }{{\mantt{\_REAL}}}
  Lower limit for the histogram.
\manparameterentry {{\mantt{READ}} }{{\mantt{UPPLIM}} }{{\mantt{\_REAL}}}
  Upper limit for the histogram.
\manparameterentry {{\mantt{READ}} }{{\mantt{HSTPAR}} }{{\mantt{\_LOGICAL}}}
  Whether or not other histogram parameters are required.
\manparameterentry {{\mantt{READ}} }{{\mantt{AGAIN}}  }{{\mantt{\_LOGICAL}}}
  Whether or not another sub-array is to be analysed.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Malcolm Currie ~STARLINK ( {\mantt {RAL}}::{\mantt {CUR}} )
\end{manroutinedescription}

 
\sstroutine{
   IDCLEAR
}{
   Clears an image display and purges its database entries
}{
   \sstdescription{
      This application software resets an image-display device. In effect
      the device is cleared.  It purges the graphics-database entries
      for the device.  Optionally, only the current picture is cleared
      and the database unchanged. (Note that the clearing of the current
      picture may not work on some image-display devices.)
   }
   \sstusage{
      IDCLEAR [DEVICE] [CURRENT]
   }
   \sstparameters{
      \sstsubsection{
         CURRENT = \_LOGICAL (Read)
      }{
         If true then only the current picture is cleared. {\tt [FALSE]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics device to be cleared. {\tt [}Current image-display
         device{\tt ]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         IDCLEAR
      }{
         Clears the current image display and purges its graphics
         database entries.
      }
      \sstexamplesubsection{
         IDCLEAR CURRENT
      }{
         Clears the current picture on the current image display.
      }
      \sstexamplesubsection{
         IDCLEAR IKON
      }{
         Clears the Ikon and purges its graphics-database entries.
      }
   }
}
 
\sstroutine{
   IDINVISIBLE
}{
   Makes memory planes of an image-display device invisible
}{
   \sstdescription{
      This routine makes invisible nominated planes of an IDI-supported
      image display, such as the Ikon.
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose memory plane is to
         be made invisible. The name of the base plane should be given
         even if an overlay plane is to be made invisible.
         {\tt [}Current image display{\tt ]}
      }
      \sstsubsection{
         PLANES() = \_INTEGER (Read)
      }{
         The numbers of the memory planes to be made invisible.  All
         unspecified planes become visible. If it is null the base
         (image) memory is made invisible. The base memory is 0 and
         overlays are numbered consecutively from 1.  For an Ikon the
         only overlay plane is 1.
         {\tt [0]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         IDINVISIBLE [0,1]
      }{
         Makes only planes 0 and 1 invisible on the current image
         display device.
      }
      \sstexamplesubsection{
         IDINVISIBLE DEVICE=IKON
      }{
         Makes the base plane invisible on the Ikon device.
      }
      \sstexamplesubsection{
         IDINVISIBLE 1 IKON
      }{
         Makes the first overlay plane invisible on the Ikon device.
      }
   }
   \newpage
   \sstnotes{
      \sstitemlist{

         \sstitem
         ARGS and X-windows are not supported.

         \sstitem
         On some devices making a memory invisible may have the effect
         of making other memories visible.

         \sstitem
         On the Ikon the visibilities are set to visible on start up,
         so that any set up change introduced by an application calling
         GKS are not lost, therefore all planes to be made invisible must
         be given in one invocation.
      }
   }
}

\manroutine {{\manheadstyle{IDPAN}}}{ Pans and zooms an {\mantt{ARGS}} or an
  {\mantt{IKON}}.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This application allows an image to be panned and zoomed on an
  image-display device. This application only works on an {\mantt{ARGS}} or an
  early-model {\mantt{IKON}}. Currently, the devices defined by the logical
  names {\mantt{ARGS\_DEVICE}} and {\mantt{IKON\_DEFAULT}} are used rather
  than the device obtained from the parameter system.

  For the {\mantt{ARGS}} pressing the choice-device (trackerball) buttons has
  the following effects:
\begin{mandescription}
\mandescriptionitem {1} (green) --- resets the image position and the {$x$},{$y$}
  zoom factors
\mandescriptionitem {2} (left white) --- increases the {$x$},{$y$} zoom factors
\mandescriptionitem {3} (right white) --- decreases the {$x$},{$y$} zoom factors
\mandescriptionitem {ESC} (red) --- exits
  Moving the trackerball smoothly pans the image.

\end{mandescription}
  For the {\mantt{IKON}} pressing the choice-device (mouse) buttons has the
  following effects:
\begin{mandescription}
\mandescriptionitem {1} (left) --- increases the {$x$},{$y$} zoom factors
\mandescriptionitem {2} (centre) --- decreases the {$x$},{$y$} zoom factors
\mandescriptionitem {ESC} (right) --- exits
  Moving the mouse over the tablet pans the image, though it has
  `quantum jumps'. Also, the image shifts to the top corners of
  the screen.

\end{mandescription}
\manroutineitem {Invocation }{}
  IDPAN

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{DEVICE}} }{{\mantt{DEVICE}}}
  The image-display device.
  {\mantt [}Current image-display device{\mantt ]}
\end{manparametertable}
\manroutineitem {Deficiencies }{}
  It is not device independent. Only works on an {\mantt{ARGS}} or an
  early-model {\mantt{IKON}}. {\mantt{IKON}} mode shifts the displayed
  image to the top-left of the screen.

\manroutineitem {Bugs }{}
  Occasionally cannot be run consecutively.

\manroutineitem {Authors }{}
  Malcolm Currie ~STARLINK ( {\mantt {RAL}}::{\mantt {CUR}} )
\end{manroutinedescription}

 
\sstroutine{
   IDPAZO
}{
   Pans and zooms an image-display device
}{
   \sstdescription{
      This routine pans all planes of an IDI-supported image display,
      such as the Ikon. The zoom factor is controlled by the mouse
      or trackerball buttons.

      For an Ikon pressing the left button of the mouse increases
      the zooming, the centre button reduces the zoom factor, and
      the right-hand button ends the pan and zoom operation.
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device to be panned and zoomed.
         The name of the base plane should be given.
         {\tt [}Current image display{\tt ]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         IDPAZO IKON
      }{
         Pans and zooms the Ikon.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         ARGS and X-windows are not supported.
      }
   }
}

\manroutine {{\manheadstyle{IDRESET}}}{ Performs a hardware reset of an {\mantt{ARGS}}
  or an {\mantt{IKON}}.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This application performs a hardware reset of an image-display
  device. The current implementation only works on a {\mantt{SIGMEX}}
  {\mantt{ARGS}} or a Digisolve {\mantt{IKON}}. For the {\mantt{ARGS}},
  the application resets the device assigned to the logical name
  {\mantt{ARGS\_DEVICE}}.  The graphics-database
  entries for the device are purged.

\manroutineitem {Invocation }{}
  IDRESET

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{DEVICE}} }{{\mantt{DEVICE}}}
  The image-display device.
  {\mantt [}Current image-display device{\mantt ]}
\end{manparametertable}
\manroutineitem {Deficiencies }{}
  It is not device independent. Only works on an {\mantt{ARGS}} or an
  {\mantt{IKON}}.

\manroutineitem {Bugs }{}
  Occasionally cannot be run consecutively.

\manroutineitem {Authors }{}
  Malcolm Currie ~STARLINK ( {\mantt {RAL}}::{\mantt {CUR}} )
\end{manroutinedescription}

 
\sstroutine{
   IDSET
}{
   Selects a current image-display device
}{
   \sstdescription{
      This application selects a current image-display device. This
      device will be used for all applications requiring an
      image-display until changed explicitly.
   }
   \sstusage{
      IDSET DEVICE
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The image-display device to become the current image-display
         device.  The device must be in one of the following GNS
         categories: IMAGE\_DISPLAY, IMAGE\_OVERLAY, MATRIX\_PRINTER, or
         WINDOW, and have at least 24 colour indices or greyscale
         intensities.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         IDSET IKON
      }{
         Makes the Ikon device the current image-display device.
      }
   }
}

\sstroutine{
   IDSTATE
}{
   Shows the current status of an image display
}{
   \sstdescription{
      This application displays the current status of an image-display
      device, including details of the current graphics-database
      picture ({\it e.g.}\ its co-ordinate system and position on the display
      surface), and the reserved colour table.
   }
   \sstusage{
      IDSTATE [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image-display device about which information is
         required. {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         OUTLINE = \_LOGICAL (Read)
      }{
         If OUTLINE is TRUE, then an outline will be drawn around the
         current picture to indicate its position. {\tt [FALSE]}
      }
      \sstsubsection{
         REPORT = \_LOGICAL (Read)
      }{
         If this is false details of the image-display device are not
         reported, merely the results are written to the output
         parameters.  It is intended for use within procedures. [TRUE]
      }
   }
   \sstresparameters{
      \sstsubsection{
         COMMENT = LITERAL (Write)
      }{
         The comment of the current picture.  Up to 132 characters
         will be written.
      }
      \sstsubsection{
         LABEL = LITERAL (Write)
      }{
         The label of the current picture.  It is blank if there is no
         label.
      }
      \sstsubsection{
         NAME = LITERAL (Write)
      }{
         The name of the current picture.
      }
      \sstsubsection{
         NCX1 = \_REAL (Write)
      }{
         The lower $x$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         NCX2 = \_REAL (Write)
      }{
         The upper $x$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         NCY1 = \_REAL (Write)
      }{
         The lower $y$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         NCY2 = \_REAL (Write)
      }{
         The upper $y$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         REFNAM = LITERAL (Write)
      }{
         The reference object associated with the current picture.  It
         is blank if there is no reference object.  Up to 132 characters
         will be written.
      }
      \sstsubsection{
         WCX1 = \_REAL (Write)
      }{
         The lower $x$ world co-ordinate of the current picture.
      }
      \sstsubsection{
         WCX2 = \_REAL (Write)
      }{
         The upper $x$ world co-ordinate of the current picture.
      }
      \sstsubsection{
         WCY1 = \_REAL (Write)
      }{
         The lower $y$ world co-ordinate of the current picture.
      }
      \sstsubsection{
         WCY2 = \_REAL (Write)
      }{
         The upper $y$ world co-ordinate of the current picture.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         IDSTATE
      }{
         Shows the status of the current image-display device.
      }
      \sstexamplesubsection{
         IDSTATE IKON
      }{
         Shows the status of the Ikon device.
      }
      \sstexamplesubsection{
         IDSTATE OUTLINE
      }{
         Shows the status of the current image-display device and draws
         an outline around the current database picture.
      }
      \sstexamplesubsection{
         IDSTATE REFNAM=(NDFNAME)
      }{
         Shows the status of the current image-display device.  If there
         is a reference data object, its name is written to the ICL
         variable NDFNAME.
      }
      \sstexamplesubsection{
         IDSTATE WCX1=(X1) WCX2=(X2) WCY1=(Y1) WCY2=(Y2)
      }{
         Shows the status of the current image-display device.  The
         bounds of the current picture in world co-ordinates are
         written to the ICL variables: X1, X2, Y1, Y2.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a channel to the image-display device cannot be opened, then
         this application will still execute without error, but a reduced
         amount of information will be displayed and an outline around the
         current picture (if requested) will not be drawn.
      }
   }
}
 
\sstroutine{
   IDUNZOOM
}{
   Unzooms and re-centres an image-display device
}{
   \sstdescription{
      This routine unzooms all planes of an IDI-supported image display,
      such as the Ikon. The offset of the memory with respect to the
      screen may be zeroed, so that the memory centre matches the screen
      centre.
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device to be panned and zoomed.
         The name of the base plane should be given.
         {\tt [}Current image display{\tt ]}
      }
      \sstsubsection{
         CENTRE = \_LOGICAL (Read)
      }{
         If true the origin of the image display's memory is the same
         as that of the screen, in other words it removes the effect
         of a pan operation. {\tt [TRUE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         IDUNZOOM
      }{
         Unzooms and re-centres the current image-display device.
      }
      \sstexamplesubsection{
         IDUNZOOM NOCENTRE
      }{
         Unzooms the current image-display device.
      }
      \sstexamplesubsection{
         IDUNZOOM IKON
      }{
         Unzooms and re-centres the Ikon display.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         ARGS and X-windows are not supported.
      }
   }
}

\sstroutine{
   IDVISIBLE
}{
   Makes all the memory planes of an image-display device visible
}{
   \sstdescription{
      This routine makes visible all planes of an IDI-supported
      image display, such as the Ikon.
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose memory plane is to
         be made visible. The name of the base plane should be given
         even if the overlay lookup table is to be rotated.
         {\tt [}Current image display{\tt ]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         IDVISIBLE
      }{
         Makes all planes visible on the current image display device.
      }
      \sstexamplesubsection{
         IDVISIBLE IKON
      }{
         Makes all planes visible on the Ikon device.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         ARGS and X-windows are not supported.

         \sstitem
         Although a plane may be `visible', it may still be obscured
         by an overlying plane.  Likewise on some devices making a memory
         visible may have the effect of making other memories invisible.

         \sstitem
         On some hardware it may not be possible to have certain
         combinations of planes visible simultaneously.
      }
   }
}
 
 
\sstroutine{
   INSPECT
}{
   Inspects a 2-d NDF in a variety of ways
}{
   \sstdescription{
      This application provides an interactive facility to inspect the
      details of whole or part of the 2-d data array in an input NDF.
      Briefly, the inspection options permit: a region to be selected
      for which statistics may be calculated, its values written to an
      ASCII file, or an histogram be plotted and saved in an NDF; the
      region itself may be saved in an NDF; the value of a pixel or a
      region of pixels to be viewed; a slice between two pixels may be
      calculated, plotted and saved in an NDF; ASCII files containing
      $x$-$y$-value of selected pixels may be created and extended, and
      chosen pixels marked.

      The application has two modes of interaction: cursor and
      interface.  In cursor mode the selection of pixels, and the
      definition of the region are made by moving a graphics cursor
      over a previously displayed image or contour plot.  Since
      instructional text showing the function of the mouse or
      trackerball buttons is shown, the graphics device providing the
      cursor must be an image-display overlay.  Also the name of the
      NDF used to display the image or contour plot is known and need
      not be entered.  This is the recommended interaction mode.  The
      alternative, interface, means that the pixel indices of pixels
      and regions to be inspected are specified in response to prompts.

      The application is composed of two parts.  First the preliminaries
      obtains the mode, the input NDF and graphics devices.  In cursor
      mode this usually amounts to a single prompt, and but two in
      interface mode.  The second stage is a loop where the inspection
      option is selected and performed.
   }
   \sstusage{
      INSPECT IN [MODE] GDEVICE OPTION [OVERLAY]
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                   NUMBIN=? HIREP=? HISTOGRAM=? HITITLE=? \\
                   FILENAME=? \\
                   PEIND=? \\
                   LBOUND=? UBOUND=? \\
                   OUT=? \\
                   SLSTART=? SLEND=? SLICE=? SLTITLE=? \\
                   VAIND=? \\
                   XYCONT=? XYFILE=? XYTITLE=?
                   \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small option}
   }
   \newpage
   \sstparameters{
      \sstsubsection{
         FILENAME = LITERAL (Read)
      }{
         Name of the ASCII file to contain the Listing of image values.
         The suggested default is INSPECT\_LIST.LIS.  This is only
         required for the {\tt "List"} option.
      }
      \sstsubsection{
         GDEVICE = DEVICE (Read)
      }{
         The name of the graphics device for line plots. The device
         should not be the image display, but it may be the
         image-display overlay plane, {\it i.e.}\ the same as parameter
         OVERLAY.  In the latter case plotting occurs in the same
         picture as the overlay annotations, namely the current picture.
         If the existing plot on the base plane of the image display has
         text, {\it e.g.}\ annotated axes, a mess can of confused lines can
         appear.  To avoid this the current picture should be made the
         DATA picture rather than the FRAME around it. If null, {\tt !}, is
         given no line plots will be drawn unless the Device option is
         selected.
      }
      \sstsubsection{
         HIREP = \_LOGICAL (Read)
      }{
         True if the full Histogram is to be reported to the user.  A
         large number of bins may be required for the plot but need not
         be listed in full.  This parameter provides a way of preventing
         unwanted, tedious and long output.  The suggested default is
         false.  HIREP is only required for the {\tt "Histogram"} option.
      }
      \sstsubsection{
         HISTOGRAM = NDF (Read)
      }{
         Name of the NDF structure to save the Histogram in its data
         array.  The suggested default is HISTOGRAM.  If null, {\tt !}, is
         entered the histogram NDF is not created.  This parameter is
         only required for the {\tt "Histogram"} option.
      }
      \sstsubsection{
         HITITLE = LITERAL (Read)
      }{
         Title for the output NDF containing the Histogram.  For the
         first histogram saved this defaults to
         {\tt 'KAPPA - Inspect\_Histogram'}, and subsequently this becomes
         the suggested default.   This parameter is only required for
         the {\tt "Histogram"} option. {\tt []}
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         NDF structure containing the 2-d data array to be inspected.
      }
      \sstsubsection{
         LBOUND( 2 ) = \_INTEGER (Read)
      }{
         Lower bounds in pixel indices of the Region.  The chosen pixel
         must be different from that at the lower bound.  It is only
         used in Interface mode with the {\tt "Region"} option.
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The interaction mode.  The options are {\tt "Cursor"} to use a
         graphics cursor to select regions and pixels to inspect,
         or {\tt "Interface"} where prompted ADAM parameters are used to
         define those parts of the image to inspect. {\tt [}Current
         interaction mode{\tt ]}
      }
      \sstsubsection{
         NUMBIN = \_INTEGER (Read)
      }{
         Number of bins needed for the Histogram.  The suggested default
         is the current value, which is 100 initially.  A value is the
         range 2--5000 is required.  This parameter is only required
         for the {\tt "Histogram"} option.
      }
      \sstsubsection{
         OPTION = LITERAL (Read)
      }{
         Current inspection mode.  The options are:
         \begin{description}
         \item [Device] - This allows the selection and opening of a new
                          line-plot graphics device, at the same time
                          closing down the old one, whose last plot is
                          stored in the graphics database.
         \item [Exit]   - Exit the application.
         \item [Histogram] - This calculates the histogram of the current
                          region. A summary and plot (if there is a
                          graphics device available) of the histogram
                          is produced.  The style of the plot may be
                          adjusted via several parameters.  The full
                          histogram may also be reported. The histogram
                          data can be stored in a 1-d NDF.
         \item [List]   - This produces a formatted and headed listing
                          of the chosen region to an ASCII file.
         \item [Peep]   - Obtain a formatted listing of the 7$\times$7 section
                          of the array data, centred on a pixel
                          specified using the cursor or via prompting.
         \item [Region] - To define the region of the array to be used
                          by other options. If the image display
                          is available, then the cursor is used to
                          define the area, otherwise, the pixel bounds
                          of the region come from the environment. Using
                          the cursor, the functions of the choice-device
                          buttons are drawn on the overlay.
         \item [Slice]  - Two points are defined via the cursor or from
                          parameter prompting between which a slice ({\it i.e.}\
                          cross-section) is calculated.  Using the
                          cursor, the functions of the trackerball or
                          mouse buttons are drawn on the overlay. A plot
                          is made to the graphics device if available.
                          The style of the plot may be adjusted via
                          several parameters.  The slice can be stored
                          in a 1-d NDF.  The slice abscissa has units in
                          true pixels (assuming pixels are square), thus
                          a 45$\dgs$ slice would have a length $\surd$2
                          times its projected length in $x$ or $y$.
         \item [Statistics] - The key statistical parameters of the current
                          region are determined and reported.
         \item [Value]  - Obtain the value of a pixel at a point selected
                          via the cursor or via prompting.
         \item [XYcur]  - A list of the co-ordinates and values of pixels
                          selected by the image-display cursor are
                          written to an ASCII file with Fortran carriage
                          control. The functions of the trackerball or
                          mouse buttons are displayed.  Optionally, an
                          existing file in the same format as produced
                          by XYcur can be appended to, for example, when
                          a session has been interrupted.  These stored
                          pixels are displayed on the overlay plane as
                          if there had been no interruption.  XYcur
                          requires cursor mode.
         \end{description}
         The suggested default is {\tt "Region"}.

         If the option is specified on the command line a single
         inspection may be undertaken, {\it i.e.}\  there is no looping.  This
         feature is intended for command procedures.
      }
      \sstsubsection{
         OUT = NDF (Read)
      }{
         Name of the NDF structure to contain the Saved Region.  This
         is only used in the {\tt "Save"} option.
      }
      \sstsubsection{
         OVERLAY = DEVICE (Read)
      }{
         Name of the overlay-plane device.  It must have class
         IMAGE\_OVERLAY or WINDOW\_OVERLAY, and support colour.
         {\tt [}Current image-display-overlay device{\tt ]}
      }
      \sstsubsection{
         PEIND( 2 ) = \_INTEGER (Read)
      }{
         $x$-$y$ pixel index of the pixel about which the Peep is required.
         The values must lie within their respective bounds of the
         input image.  The suggested default is the image centre.  It
         is only used in Interface mode with the {\tt "Peep"} option.
      }
      \sstsubsection{
         SLEND( 2 ) = \_INTEGER (Read)
      }{
         The $x$-$y$ pixel index defining the end of the Slice.  It
         must lie within the bounds of the array and be distinct from
         the start of the slice.  The suggested default is the upper
         bound of the input NDF.  It is only used in Interface mode
         with the {\tt "Slice"} option.
      }
      \sstsubsection{
         SLICE = NDF (Read)
      }{
         Name of the NDF structure to save the Slice in its data array.
         The suggested default is SLICE.   If null, {\tt !}, is entered the
         slice NDF is not created.  It is only required in the {\tt "Slice"}
         option.
      }
      \sstsubsection{
         SLSTART( 2 ) = \_INTEGER (Read)
      }{
         The $x$-$y$ pixel index defining the start of the Slice.  It must
         lie within the bounds of the array.  The suggested default is
         the lower bound of the input NDF.  It is only used in
         Interface mode with the {\tt "Slice"} option.
      }
      \sstsubsection{
         SLTITLE = LITERAL (Read)
      }{
         Title for the Slice NDF.  Title for the Region NDF.  For the
         first region saved this defaults to {\tt 'KAPPA - Inspect\_Slice'},
         and subsequently this becomes the suggested default.  It is
         only required in the {\tt "Slice"} option. {\tt []}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the Region NDF.  For the first region saved this
         defaults to {\tt 'KAPPA - Inspect'}, and subsequently this becomes
         the suggested default.  It is only used in the {\tt "Save"} option.
         {\tt []}
      }
      \sstsubsection{
         UBOUND( 2 ) = \_INTEGER (Read)
      }{
         Upper bounds in pixel indices of the Region.  The chosen pixel
         must be different from that at the lower bound.  It is only
         used in Interface mode with the {\tt "Region"} option.
      }
      \sstsubsection{
         VAIND( 2 ) = \_INTEGER (Read)
      }{
         $x$-$y$ pixel index of pixel whose Value is required.  The values
         must lie within their respective bounds of the input image.
         The suggested default is the image centre.  It is only used in
         Interface mode with the {\tt "Value"} option.
      }
      \sstsubsection{
         XYCONT = \_LOGICAL (Read)
      }{
         If true an existing file is appended to in the XYcur option.
         The suggested default is false.  It is only available in
         cursor mode with the {\tt "XYcur"} option.
      }
      \sstsubsection{
         XYFILE = LITERAL (Read)
      }{
         Name of the ASCII file to which pixel data are written by
         XYcur option.  The suggested default is XYLIST.LIS.  It is
         only available in cursor mode with the {\tt "XYcur"} option.
      }
      \sstsubsection{
         XYTITLE = LITERAL (Read)
      }{
         Title for the ASCII file in XYcur option.  For the first file
         created this defaults to {\tt '\# KAPPA - Inspect\_XYcur'}, and
         subsequently this becomes the suggested default. It is not
         accessed if XYCONT is true.   It is only available in cursor
         mode with the {\tt "XYcur"} option. {\tt []}
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB  =  LITERAL (Read)
      }{
         Label for the line-plot abscissa, in which NCAR fancy founts
         may be embedded when FONT = {\tt "NCAR"}.  Note Slice and
         Histogram have different defaults and these are stored separately.

         For a slice plot the suggested default is the current value,
         which is initially {\tt "Pixels"}.  If an error occurs obtaining the
         label the default is {\tt "Pixels"}.

         If axis information is present the suggested default for a
         plot of an histogram is the NDF's axis label followed by the
         units, in parentheses.  If an error occurs obtaining the label
         or there is no axis information, the label takes its current
         value, which initially is {\tt "Values"}.

         For the first plot ABSLAB is defaulted to the suggested value
         unless PLOTSTYLE is included on the command line, and
         subsequently will only be obtained whenever PLOTSTYLE is {\tt TRUE}.
         {\tt []}
      }
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         {\tt "NCAR"} for the NCAR fancy characters and {\tt "GKS"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value.

         For the first plot FONT is defaulted to {\tt "GKS"}, and subsequently
         will only be obtained whenver PLOTSTYLE is TRUE. {\tt []}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the numbers of major tick marks
         for the $x$ and $y$ axes in the slice or histogram plot.
         (The number used is between MAJTIC$+$2 and 5$*$MAJTIC/2$+$4.).

         By default, it is {\tt [4.,4.]}.  For the first plot MAJTIC is
         defaulted, and subsequently will only be obtained whenever
         PLOTSTYLE is {\tt TRUE}.  {\tt []}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark
         for linear $x$ and $y$ axes in the slice or histogram plot.  A
         negative value forces the graphics package to compute
         appropriate values.  The number of minor tick marks per major
         tick is fixed (8) for a logarithmic axis.

         By default, it is {\tt [-1.,-1.]}.  For the first plot MINTIC is
         defaulted, and subsequently will only be obtained whenever
         PLOTSTYLE is {\tt TRUE}.  {\tt []}
      }
      \sstsubsection{
         ORDLAB  =  LITERAL (Read)
      }{
         Label for the line-plot ordinate, in which NCAR fancy founts
         may be embedded.  Note Slice and Histogram have different
         defaults and these are stored separately.

         For an histogram plot the suggested default is the current
         value, which is initially {\tt "Number"}.  If an error occurs
         obtaining the label the default is {\tt "Number"}.

         If axis information is present the suggested default for a
         plot of a slice is the NDF's axis label followed by the
         units, in parentheses.  If an error occurs obtaining the label
         or there is no axis information, the label takes its current
         value, which initially is {\tt "Data values"}.

         For the first plot ORDLAB is defaulted to the suggested value
         unless PLOTSTYLE is included on the command line, and
         subsequently will only be obtained whenever PLOTSTYLE is {\tt TRUE}.
         {\tt []}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         True if the axis tick marks are to appear on the outside of
         the axes instead of inside in the slice or histogram plots.
         This eliminates intersections of ticks with the data locus.

         By default, the tick marks are drawn inside the plot region.
         For the first plot OUTTIC is defaulted, and subsequently will
         only be obtained whenever PLOTSTYLE is {\tt TRUE}.  {\tt []}
      }
      \sstsubsection{
         PLOTSTYLE = \_LOGICAL (Read)
      }{
         If true the plotting style of line plots is to be altered from
         the default for the first plot, or the existing values for
         subsequent graphs.  Initially, it is defaulted to false, then
         the suggested value is the current value.  Therefore to
         override the plotting-style parameters on the first plot, new
         values should be given on the command line, and along with the
         PLOTSTYLE keyword for ABSLAB, ORDLAB, and PLTITL.
         Subsequently, the plotting style may be
         retained or modified via prompts.  {\tt []}
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of a line plot, in which NCAR fancy founts may be
         embedded.  Note Slice and Histogram have different defaults
         and these are stored separately.  Both attempt to use the NDF's
         title if present and no error occurs, otherwise the current
         value becomes the suggested default.  For the histogram plot
         this is initially {\tt "Histogram of current region"} and for the
         slice plot it is initially {\tt "Slice plot"}.

         For the first plot PLTITL is defaulted to the suggested value
         unless PLOTSTYLE is included on the command line, and
         subsequently will only be obtained whenever PLOTSTYLE is {\tt TRUE}.
         {\tt []}
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the axes and annotations in the histogram and
         line plots, where 1.0 is the normal thickness.  Currently,
         this is only available on a few devices.  It must take a value
         in the range 0.5--5.0.

         By default the line thickness is 1.0.  For the first plot
         THICK is defaulted to the suggested value, and subsequently
         will only be obtained whenever PLOTSTYLE is {\tt TRUE}.  {\tt []}
      }
      \sstsubsection{
         XLOG = \_LOGICAL (Read)
      }{
         True if the line-plot abscissa is to be logarithmic.  Note, for
         Slice and Histogram options each has its own independent
         switch.  It is unlikely that you would want to do this.  By
         default, the abscissa is linear.  For the first plot XLOG is
         defaulted, and subsequently will only be obtained whenever
         PLOTSTYLE is {\tt TRUE}. {\tt []}
      }
      \sstsubsection{
         YLOG = \_LOGICAL (Read)
      }{
         True if the line-plot ordinate is to be logarithmic. Note, for
         Slice and Histogram options each has its own independent
         switch.  By default, the ordinate is linear.  For the first
         plot YLOG is defaulted, and subsequently will only be
         obtained whenever PLOTSTYLE is {\tt TRUE}.  {\tt []}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         Note:
      }{
         Since INSPECT is an interacting, graphical and self-contained
         monolith of applications it is not straightforward to give
         command-line examples.  Generally, the best way to run INSPECT
         is in cursor mode after having displayed an image.  The
         following examples use the prompting mode.
      }
      \sstexamplesubsection{
         INSPECT RULUPI I CANON\_L SL SLSTART=[3,10] SLEND=[9,42] SLICE=!
      }{
         Plots a slice from pixel (3,10) to (9,42) of the NDF called
         RULUPI to the CANON\_L graphics device.
      }
      \sstexamplesubsection{
         INSPECT RULUPI I GDEVICE=IKON OPTION=HI NUMBIN=100 $\backslash$
      }{
         Calculates the histogram of the NDF called RULUPI, reporting
         a summary to the user, and plots the histogram to the Ikon
         device.  The histogram has one hundred bins and is stored in
         an NDF called HISTOGRAM.
      }
      \sstexamplesubsection{
         INSPECT RULUPI I ! OPTION=HI NUMBIN=100 HISTOGRAM=! HIREP
      }{
         As above except no plot is made, no NDF is created, and
         the full one hundred histogram values are reported.  In this
         particular example the second parameter could equally well be
         C for cursor mode since no co-ordinate information is
         obtained.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         In cursor mode there must be an existing DATA picture for the
         chosen image display stored in the graphics database.  Valid
         cursor positions are bounded by the DATA picture.

         \sstitem
         On exit the input picture, if there was one, is made the
         current picture on the overlay; and the last graphics plot is
         stored in the database as a FRAME picture.  Also, if the
         {\tt "Device"} option is used a FRAME picture is stored for
         that device.

         \sstitem
         The Histogram NDF has an AXIS component whose the LABEL and
         UNITS are those of the input NDF's data array; its centres are
         in data value of the bin centre.  The NDF LABEL is {\tt "Number"}.

         \sstitem
         The Slice NDF has an AXIS component whose LABEL is {\tt "Pixel"} and
         centres are pixel co-ordinates from 0.5; its LABEL and UNITS are
         propagated from the input NDF.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Only real data can be processed directly.  Other data types
         will undergo a type conversion before processing occurs.

         \sstitem
         The routine correctly processes the AXIS, DATA, QUALITY, LABEL,
         TITLE, UNITS and VARIANCE components of an NDF, and propagates all
         extensions to the output Region NDF.

         \sstitem
         The HISTORY component, if present, is simply propagated without
         change.

         \sstitem
         Bad pixels are assumed to be present and are correctly
         processed, {\it e.g.}\ they are excluded from statistics and are
         indicated in reports of data values by the word {\tt INVALID}.  In the
         slice plot they appear as gaps, and they do not affect the limits
         of the ordinate.  The same applies to zero or negative data
         values if the plot is to have a logarithmic ordinate.  Similarly,
         for the histogram abscissa.
      }
   }
}

\sstroutine{
   KAPHELP
}{
   Gives help about KAPPA
}{
   \sstdescription{
      Displays help about {\sc KAPPA}.  The help information has classified
      and alphabetical lists of commands, general information about
      {\sc KAPPA} and related material; it describes individual commands in
      detail.

      Here are some of the main options:
      \begin{tabbing}
      abc \= \kill
      {\tt KAPHELP} \\
      \> No parameter is given so the introduction and the top-level
         help index is displayed.
      \\
      {\tt KAPHELP application/topic} \\
         \>   This gives help about the specified application or topic. \\
      {\tt KAPHELP application/topic subtopic} \\
      \> \begin{minipage}[t]{143mm}
            This lists help about a subtopic of the specified
            application or topic. The hierarchy of topics has a maximum
            of four levels.
      \end{minipage}
      \\
      {\tt KAPHELP Hints} \\
         \>   This gives hints for new and intermediate users. \\
      {\tt KAPHELP SUMMARY} \\
         \>   This shows a one-line summary of each application. \\
      {\tt KAPHELP CLASSIFIED classification} \\
         \>   This lists a one-line summary of each application in the
            given functionality classification. \\
      \end{tabbing}

      Once in the help library, it can be navigated in the normal
      way.  CTRL/Z to exit from any level, and $<$CR$>$ to move up a
      level in the hierarchy.
   }
   \sstusage{
      KAPHELP [TOPIC] [SUBTOPIC] [SUBSUBTOPIC] [SUBSUBSUBTOPIC]
   }
   \sstparameters{
      \sstsubsection{
         TOPIC = LITERAL (Read)
      }{
         Topic for which help is to be given. {\tt [" "]}
      }
      \sstsubsection{
         SUBTOPIC = LITERAL (Read)
      }{
         Subtopic for which help is to be given. {\tt [" "]}
      }
      \sstsubsection{
         SUBSUBTOPIC = LITERAL (Read)
      }{
         Subsubtopic for which help is to be given. {\tt [" "]}
      }
      \sstsubsection{
         SUBSUBSUBTOPIC = LITERAL (Read)
      }{
         Subsubsubtopic for which help is to be given. {\tt [" "]}
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Uses the portable help system.

         \sstitem
         The help libraries are slightly different for VMS and UNIX.
      }
   }
}

\manroutine {{\manheadstyle{LAPLACE}}}{ Performs a Laplacian convolution as an
  edge detector in a 2-d data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine works out the Laplacian of the 2-d data array, in the
  input {\mantt{IMAGE}} structure, and subtracts it from the original array
  to create a new data array in the output {\mantt{IMAGE}} structure. The
  subtractions can be done a specified integer number of times.
  This operation can be approximated with a convolution by
\[
\begin{array}{ccc}
  -N & -N & -N \\
  -N & +8N & -N \\
  -N & -N & -N
\end{array}
\]

  where {$N$} is the integer number of times the Laplacian is
  subtracted.  This convolution is used as a uni-directional edge
  detector.  Areas where the input data array is flat become zero
  in the output data array.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  LAPLACE

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}} }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the 2-d data array to be
  processed.
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMBER}} }{{\mantt{\_INTEGER}}}
  Number of times the Laplacian is to be subtracted. \mbox{\mantt [1]}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the processed data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Title string for output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Laplace']}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

 
\sstroutine{
   LINPLOT
}{
   Draws a line plot of a 1-d NDF's data values against their axis
   co-ordinates
}{
   \sstdescription{
      This application creates a line plot of a one-dimensional NDF on
      the current graphics device, as would be used for a spectrum.
      The array may be part or whole of the data array, but also the
      variance or quality can be shown.  The plot is situated within
      the current graphics-database picture.

      The graph joining the $x$-$y$ data points resides within labelled
      and enumerated axes corresponding to pixel or data co-ordinates
      and data value respectively.  The data co-ordinates are derived
      from the NDF's axis component.   A title and the axis labels are
      specified.
   }
   \sstusage{
      LINPLOT NDF [COMP] [PLTITL] [ABSLAB] [ORDLAB] [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         True if the current picture is to be cleared before the line
         plot is drawn. {\tt [TRUE]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be {\tt "Data"},
         {\tt "Quality"} or {\tt "Variance"}. {\tt ["Data"]}
      }
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either
         {\tt "WORLD"} or {\tt "DATA"}.  {\tt "WORLD"} makes pixel
         co-ordinates to appear on axes and the bounds are obtained in
         pixel indices.  If COSYS = {\tt "DATA"} the NDF's axis
         information is used to annotate axes and the bounds are
         specified in that co-ordinate system.  {\tt [}Current
         co-ordinate system{\tt ]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device. {\tt [}Current graphics device{\tt ]}
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         NDF structure containing the array to be plotted.
      }
      \sstsubsection{
         ORDLIM = \_LOGICAL (Read)
      }{
         If true the user decides the upper and lower limits of the
         data (ordinate) axis, otherwise NCAR decides. (The limits of
         the ordinate correspond to the maximum and minimum data
         elements.) {\tt [FALSE]}
      }
      \sstsubsection{
         ORDLOW = \_REAL (Read)
      }{
         The ordinate lower limit when ORDLIM is true.  It is usually
         best to allow some margin, but the lower limit may be greater
         than the minimum data value.
      }
      \sstsubsection{
         ORDUPP = \_REAL (Read)
      }{
         The ordinate upper limit when ORDLIM is true.  It is usually
         best to allow some margin, but the upper limit may be less
         than the maximum data value.
      }
      \sstsubsection{
         PXSIZE = \_REAL (Read)
      }{
         The horizontal size of the display in metres. If a value less
         than the default is requested, the display will appear at
         the bottom left of the current device.  There is an upper
         limit given by the $x$ size of the current picture. {\tt [}Maximum
         that can fit in the current picture{\tt ]}
      }
      \sstsubsection{
         PYSIZE = \_REAL (Read)
      }{
         The vertical size of the display in metres. If a value less
         than the default is requested, then the display will appear at
         the bottom left of the current device.  There is an upper
         limit given by the $y$ size of the current picture. {\tt [}Maximum
         that can fit in the current picture{\tt ]}
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB = LITERAL (Read)
      }{
         Label for the plot abscissa, in which NCAR fancy founts may be
         embedded when FONT = {\tt "NCAR"}.  If axis information is present the suggested
         default is the NDF's axis label followed by the units, in
         parentheses.  If an error occurs obtaining the label the
         default is {\tt "Pixel co-ordinates"}. {\tt []}
      }
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         {\tt "NCAR"} for the NCAR fancy characters and {\tt "GKS"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value. {\tt ["GKS"]}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the numbers of major tick marks
         for the $x$ and $y$ axes.  (Number used is between MAJTIC$+$2 and
         5$*$MAJTIC/2$+$4.) {\tt [4.,4.]}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark
         for the $x$ and $y$ axes.  A negative value forces the graphics
         package to compute appropriate values.  The number of
         minor tick marks per major tick is fixed (8) for a logarithmic
         axis. {\tt [-1.,-1.]}
      }
      \sstsubsection{
         ORDLAB = LITERAL (Read)
      }{
         Label for the plot ordinate, in which NCAR fancy founts may be
         embedded when FONT = {\tt "NCAR"}.  The suggested default is the NDF's label followed
         by the units, if present, in parentheses.  If an error occurs
         obtaining the label the default is the component name followed
         by {\tt " values"}. {\tt []}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         True if the axis tick marks are to appear on the outside of
         the axes instead of inside. By default, the tick marks are
         drawn inside the plot region.  {\tt [FALSE]}
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of the plot.  Up to about 40 characters can be
         accommodated, and NCAR fancy founts may be embedded when
         FONT = {\tt "NCAR"}.  The suggested default is the title of
         the NDF. If an error occurs obtaining the title, it is
         defaulted to {\tt "Line plot"}. {\tt []}
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the axes and annotations in the plot, where
         1.0 is the normal thickness. Currently, this is only available
         on a few devices.  It must take a value in the range 0.5--5.0.
         {\tt [1.0]}
      }
      \sstsubsection{
         XLOG = \_LOGICAL (Read)
      }{
         True if the abscissa (pixel number) is to be logarithmic.  It
         is unlikely that you would want to do this. {\tt [FALSE]}
      }
      \sstsubsection{
         YLOG = \_LOGICAL (Read)
      }{
         True if the ordinate (data value) is to be logarithmic.  This
         is useful when the data have wide dynamic range. {\tt [FALSE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LINPLOT SPECTRUM COSYS=D
      }{
         Plots data values versus data co-ordinate for the whole of the
         1-D NDF called SPECTRUM on the current graphics device.  The
         data co-ordinates will be in pixels if SPECTRUM does not have
         an axis component (this remark applies to all the examples save
         the last where world co-ordinates are plotted).
      }
      \sstexamplesubsection{
         LINPLOT SPECTRUM(1:500) DEVICE=GRAPHON
      }{
         Plots data values versus the data or pixel co-ordinates
         (whichever is the current system) for the first 500 elements
         of the 1-D NDF called SPECTRUM on the Graphon device.
      }
      \sstexamplesubsection{
         LINPLOT IRONARC V PLTITL="Fe Arc variance"
      }{
         Plots variance values versus data or pixel co-ordinate for the
         whole of the 1-D NDF called IRONARC on the current graphics
         device.  The plot has a title of {\tt "Fe Arc variance"}.
      }
      \sstexamplesubsection{
         LINPLOT RSCVN(3000.42:3994.) NOCLEAR YLOG ABSLAB="Epoch" COSYS=D
      }{
         This plots on the current graphics device data values versus
         data co-ordinates for those elements of the 1-D NDF called
         RSCVN whose axis values lie between 3000.42 and 3994.0.  If
         the current co-ordinate system is already {\tt "DATA"}, the COSYS
         parameter may be dispensed with.  The device is not cleared so
         the plot will overlay the existing picture.  The data values
         will be plotted logarithmically.  The abscissa has label
         {\tt "Epoch"}.
      }
      \sstexamplesubsection{
         LINPLOT NDF=SPECTRUM ORDLIM ORDLOW=100 ORDUPP=250 COSYS=W
      }{
         Plots data values versus pixel co-ordinate for the whole of the
         1-D NDF called SPECTRUM on the current graphics device.  The
         limits of the ordinate axis are 100 and 250, so data values
         outside this range will be clipped.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application stores a number of pictures in the graphics
         database in the following order: a FRAME of the specified size
         containing the title, annotated axes, and line plot; and a DATA
         picture, which has world co-ordinates for linear axes measured in
         pixels along the x axis and data values along y, and their
         logarithms if a logarithmic axis is selected.  The DATA picture
         also has data co-ordinates stored; for a linear axis this
         requires that the NDF's axis units are not pixel co-ordinates;
         for a logarithmic axis the actual data co-ordinate or value is
         recorded.  If there is no NDF axis information and a logarithmic
         abscissa, the DATA co-ordinates are pixel co-ordinates.  The NDF
         associated with the plot is stored by reference with the DATA
         picture.  On exit the current database picture for the chosen
         device reverts to the input picture.

         \sstitem
         In a logarithmic plot only positive data along each
         logarithmic axis can be displayed, therefore negative data are
         excluded.  A logarithmic axis will always increase from left to
         right, and from bottom to top.

         \sstitem
         Bad pixels appear as gaps in the plot, and they do not affect
         the limits of the ordinate.  The same applies to zero or negative
         data values if the plot is to have a logarithmic ordinate.
      }
   }
   \sstimplementationstatus{
      The following NDF features are supported by this application:
      \sstitemlist{

         \sstitem
         The DATA, VARIANCE and QUALITY arrays (the TITLE, LABEL, UNITS
         and AXIS components are also used).

         \sstitem
         Bad-pixel handling, including automatic quality masking.

         \sstitem
         Only single-precision floating-point data can be processed
         directly.  Other non-complex data types will undergo a type
         conversion before the line plot is drawn.

         \sstitem
         The lower and upper-bound parameters are used to define a
         slice.  This is a temporary scheme until slices can be specified
         following the NDF's name.
      }
   }
}

\manroutine {{\manheadstyle{LOG10}}}{ Takes the base-10 logarithm of each pixel of a
  data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes the logarithm to base 10 of each pixel of
  a data array. The result goes into a new output data array.
  Both data arrays are stored in the {\mantt{IMAGE}} format.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  LOG10

\newpage
\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{BASE}}  }{{\mantt{\_REAL}}}
  Base of logarithm to be taken of each input data array pixel.
  {\mantt [10]}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure holding result of processed data.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Log10']}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{LOGAR}}}{ Takes the logarithm of each pixel of a data
  array (specified base).}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes the logarithm to a specified base of each
  pixel of a data array. The result goes into a new output data
  array. Both data arrays are stored in the {\mantt{IMAGE}} format.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  LOGAR

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{BASE}}  }{{\mantt{\_REAL}}}
  Base of logarithm to be taken of each input data array pixel.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure holding result of processed data.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Logar']}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{LOGE}}}{ Takes the natural logarithm of each pixel
  of a data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes the logarithm to base e of each pixel of
  a data array. The result goes into a new output data array.
  Both data arrays are stored in the {\mantt{IMAGE}} format.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  LOGE

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{BASE}}  }{{\mantt{\_REAL}}}
  Base of logarithm to be taken of each input data array pixel. {\mantt [2.718282]}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure holding result of processed data.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for the output {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Loge']}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{LOOK}}}{ Outputs the values of a sub-array of a 2-d
  data array to the screen or an ASCII file.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine reports to user or writes to an ASCII file the values
  in a specified sub-array of the 2-d data array in the input {\mantt{IMAGE}}
  structure. Three options are allowed:
\begin{mandescription}
\mandescriptionitem {Peep}  - gives a fixed 7{$\times$}7 box on the screen, centred
  on a given pixel;
\mandescriptionitem {Examine} - gives an {$n\times m$} box on the screen, with the
  lower-left pixel as specified;
\mandescriptionitem {List}  - outputs the specified sub-array to an
  ASCII text file (maximum width 132 characters) of a defined
  name.  Beware that the List option can produce very
  large files if it is not used sensibly.

\end{mandescription}
  The magic-value method is used for processing bad data. Bad pixels
  are denoted in the display or file by {\mantt{INVALID}} rather than a
  numerical value.

\manroutineitem {Invocation }{}
  LOOK

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the 2-d data array to be inspected.
\manparameterentry {{\mantt{READ}} }{{\mantt{CHOICE}} }{{\mantt{LITERAL}}}
  The means by which the data array is examined.  The options
  are {\mantt{Peep}} --- reports the values in a 7{$\times$}7 pixel region;
  {\mantt{Examine}} --- reports the values of a region whose size is defined
  by the user; and {\mantt{List}} is similar to {\mantt{Examine}}, but it
  generates a listing to an ASCII file.
\manparameterentry {{\mantt{READ}} }{{\mantt{XCEN}}  }{{\mantt{\_INTEGER}}}
  {$x$} centre of box to be examined on the screen.
\manparameterentry {{\mantt{READ}} }{{\mantt{YCEN}}  }{{\mantt{\_INTEGER}}}
  {$y$} centre of box to be examined on the screen.
\manparameterentry {{\mantt{READ}} }{{\mantt{XLOW}}  }{{\mantt{\_INTEGER}}}
  {$x$} pixel index of the lower left of the sub-array to be output.
\manparameterentry {{\mantt{READ}} }{{\mantt{YLOW}}  }{{\mantt{\_INTEGER}}}
  {$y$} pixel index of the lower left of the sub-array to be output.
\manparameterentry {{\mantt{READ}} }{{\mantt{XSIZE}}  }{{\mantt{\_INTEGER}}}
  {$x$} size of the sub-array to be output.
\manparameterentry {{\mantt{READ}} }{{\mantt{YSIZE}}  }{{\mantt{\_INTEGER}}}
  {$y$} size of the sub-array to be output.
\manparameterentry {{\mantt{READ}} }{{\mantt{FILENAME}}  }{{\mantt{FILENAME}}}
  Name of the file to be used for the output of the sub-array listing.
\manparameterentry {{\mantt{READ}} }{{\mantt{ANOTHER}} }{{\mantt{\_LOGICAL}}}
  If true, another look at the data is required.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\sstroutine{
   LUTABLE
}{
   Manipulates an image-display colour table
}{
   \sstdescription{
      This application allows manipulation of the colour table of an
      image-display device provided some data are, according to the
      graphics database, already displayed upon the device.  A 2-d data
      array, stored in the input NDF structure, may be nominated to
      assist in defining the colour table via an histogram
      equalisation.  There are two stages to the running of this
      application.
      \begin{enumerate}
      \item The way in which the lookup table (LUT) is to distributed
      amongst the pens (colour indices) of the colour table is
      required.  Some pens are reserved by KAPPA as a palette, particularly
      for annotation.  This application only modifies the unreserved
      portion of the colour table.

      \item The lookup table is now chosen from a programmed selection or
      read from an NDF.
      \end{enumerate}

      The two stages may be repeated cyclically if desired.  To exit the
      loop give the null response, {\tt !}, to a prompt.  Looping will not
      occur if the lookup table and the distribution method are supplied
      on the command line.
   }
   \sstusage{
      LUTABLE MAPPING COLTAB LUT [DEVICE] NDF PERCENTILES SHADE
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display to be used.  The device must be in
         one of the following GNS categories: IMAGE\_DISPLAY,
         IMAGE\_OVERLAY, MATRIX\_PRINTER, or WINDOW, and have at least 34
         greyscale intensities or colour indices.  It must also not
         reset when the device is opened (since the new colour table
         would be lost).  {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         COLTAB = LITERAL (Read)
      }{
         The lookup table required.  The options are:
         \begin{description}
            \item [Negative] - This is negative grey scale with black assigned
                         to the highest pen, and white assigned to the
                         lowest available pen.
            \item [Colour]   - This consists of eighteen standard colour
                         blocks.
            \item [Grey]     - This a standard grey scale.
            \item [External] - Obtain a lookup table stored in an NDF's data
                         array.  If the table cannot be found in the
                         specified NDF or if it is not a LUT then a
                         grey scale is used.
         \end{description}
      }
      \sstsubsection{
         FULL = \_LOGICAL (Read)
      }{
         If true the whole colour-table for the device is stored
         including the reserved pens.  This is necessary to save a
         colour table written by another package that does not reserve
         colour indices.  For colour tables produced by KAPPA this
         should be false. {\tt [FALSE]}
      }
      \sstsubsection{
         LUT = NDF (Read)
      }{
         Name of the NDF containing the lookup table as its data
         array.  The LUT must be 2-dimensional, the first dimension
         being 3, and the second being arbitrary.  The method used to
         compress or expand the colour table if the second dimension is
         different from the number of unreserved colour indices is
         controlled by parameter NN.  Also the LUT's values must lie in
         the range 0.0--1.0.
      }
      \sstsubsection{
         MAPPING = LITERAL (Read)
      }{
         The way in which the colours are to be distributed among
         the pens.  If NINTS is the number of unreserved colour indices
         the mapping options are:
         \begin{description}
            \item [Logarithmic] - The colours are fitted logarithmically to
                           to the pens, with colour 1 given to the first
                           available pen and colour NINTS given to the
                           last pen.
            \item [Histogram] - The colours are fitted to the pens using
                           histogram equalisation of an NDF, given by
                           parameter IN, so that the colours
                           approximately have an even distribution. In
                           other words each pen is used approximately
                           an equal number of times to display the
                           2-d NDF array.  There must be an existing
                           image displayed.  This is determined by
                           looking for a DATA picture in the database.
                           This is not foolproof as this may be a line
                           plot rather an image.
            \item [Linear]  - The colours are fitted directly to the pens.
         \end{description}
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         The input NDF structure containing the 2-d data array to be
         used for the histogram-equalisation mapping of the pens.  The
         the data object referenced by the last DATA picture in the
         graphics database is reported.  This assumes that the
         displayed data picture was derived from the nominated NDF data
         array.
      }
      \sstsubsection{
         NN = \_LOGICAL (Read)
      }{
         If true the input lookup table is mapped to the colour table by
         using the nearest-neighbour method.  This preserves sharp
         edges and is better for lookup tables with blocks of colour.
         If NN is false linear interpolation is used, and this is
         suitable for smoothly varying colour tables. {\tt [FALSE]}
      }
      \sstsubsection{
         PERCENTILES( 2 ) = \_REAL (Read)
      }{
         The percentiles that define the range of the histogram to be
         equalised. For example, {\tt [25,75]} would scale between the
         quartile values. It is advisable not to choose the limits
         less than 3 per cent and greater than 97.  The percentiles are
         only required for histogram mapping.  All values in the NDF's
         data array less than the value corresponding to the lower
         percentile will have the colour of the first unreserved pen.
         All values greater than the value corresponding to the upper
         percentile will have the colour of the last unreserved pen.
      }
      \sstsubsection{
         SHADE = \_REAL (Read)
      }{
         The type of shading.  This only required for the histogram
         mapping.  A value of $-$1 emphasises low values; $+$1 emphasises
         high values; 0 is neutral, all values have equal weight.  The
         shade must lie in the range $-$1 to $+$1.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LUTABLE LO CO
      }{
         Changes the colour table on the current image-display device
         to a series of coloured blocks whose size increase
         logarithmically with the table index number.
      }
      \sstexamplesubsection{
         LUTABLE LI EX ROCOCO
      }{
         This maps the lookup table stored in the NDF called ROCOCO
         linearly to the colour table on the current image-display
         device.
      }
      \sstexamplesubsection{
         LUTABLE LI EX ROCOCO FULL
      }{
         This maps the lookup table stored in the NDF called ROCOCO
         linearly to the full colour table on the current image-display
         device, {\it i.e.}\ ignoring the reserved pens.
      }
      \sstexamplesubsection{
         LUTABLE HI GR IN=NEBULA SHADE=0 PERCENTILES=[5,90]
      }{
         This maps the greyscale lookup table via histogram
         equalisation between the 5 and 90 percentiles of an NDF called
         NEBULA to the colour table on the current image-display
         device.  There is no bias or shading to white or black.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The magic-value method is used for processing bad data in
         the image NDF.

         \sstitem
         This application will handle data in all numeric types, though
         type conversion to \_REAL will occur for non-real images.
      }
   }
}

\sstroutine{
   LUTBGYRW
}{
   Loads the {\it BGYRW} lookup table
}{
   \sstdescription{
      This procedure loads the {\it BGYRW}\ lookup table with linear scaling
      into the current image-display device.  It is a continuous LUT
      starting with blue, followed by green, yellow, red and a splash of
      white.
   }
   \sstusage{
      LUTBGYRW
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         {\tt [}Current image-display device{\tt ]}
      }
   }
   \sstnotes{
      This is a procedure that calls LUTABLE.  Therefore, the ADAM
      parameter cannot be specified on the command line.  You will 
      only be prompted for the DEVICE parameter if the current
      image display is not suitable or not available.
   }
}

\sstroutine{
   LUTCOL
}{
   Loads the standard colour lookup table
}{
   \sstdescription{
      Procedure for loading the standard colour lookup table into
      the current image-display device with linear scaling.
   }
   \sstusage{
      LUTCOL
   }
   \newpage
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         {\tt [}Current image-display device{\tt ]}
      }
   }
   \sstnotes{
      This is a procedure that calls LUTABLE.  Therefore, the ADAM
      parameter cannot be specified on the command line.  You will 
      only be prompted for the DEVICE parameter if the current
      image display is not suitable or not available.
   }
}

\sstroutine{
   LUTCONT
}{
   Loads a lookup table to give the display the appearance of a
   contour plot
}{
   \sstdescription{
      This procedure loads a lookup table that gives a contour-plot
      appearance into the current image-display device.  The lookup table
      is mainly black with a set of white stripes and it is loaded with
      linear scaling.
   }
   \sstusage{
      LUTCONT
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         {\tt [}Current image-display device{\tt ]}
      }
   }
   \sstnotes{
      This is a procedure that calls LUTABLE.  Therefore, the ADAM
      parameter cannot be specified on the command line.  You will 
      only be prompted for the DEVICE parameter if the current
      image display is not suitable or not available.
   }
}

\sstroutine{
   LUTFC
}{
   Loads the standard false-colour lookup table
}{
   \sstdescription{
      This procedure loads the standard false-colour lookup table with
      linear scaling into the current image-display device.
   }
   \sstusage{
      LUTFC
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         {\tt [}Current image-display device{\tt ]}
      }
   }
   \sstnotes{
      This is a procedure that calls LUTABLE.  Therefore, the ADAM
      parameter cannot be specified on the command line.  You will 
      only be prompted for the DEVICE parameter if the current
      image display is not suitable or not available.
   }
}

 
\sstroutine{
   LUTFLIP
}{
   Flips the colour table of an image-display device
}{
   \sstdescription{
      This routine `flips' the colour table of a nominated plane of
      an IDI-supported image display, such as the Ikon.  The flip
      reverses the order of the colours, so that the first colour
      becomes the last and vice versa, {\it etc.}\
   }
   \sstusage{
      LUTFLIP [DEVICE] [PLANE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose colour table is to
         be flipped. The name of the base plane should be given even if
         the overlay colour table is to be flipped.
         {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         PLANE = \_INTEGER (Read)
      }{
         The number of the memory plane whose colour table is to be
         flipped.  If it is null the base (image) memory's colour table
         is reversed. The base memory is 0 and overlays are numbered
         consecutively from 1.  For an Ikon the only overlay plane is 1.
         PLANE is only permitted to have a value in the range 0 to the
         number of planes minus one. {\tt [0]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LUTFLIP
      }{
         This reverses the colour table on the current image-display
         device.
      }
      \sstexamplesubsection{
         LUTFLIP XWINDOWS
      }{
         This reverses the colour table on the XWINDOWS device.
      }
      \sstexamplesubsection{
         LUTFLIP IKON 1
      }{
         This flips the colour table on the Ikon overlay plane.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Only Ikons and Xwindows are supported.

         \sstitem
         Reserved pens are not flipped.
      }
   }
}

\sstroutine{
   LUTGREY
}{
   Loads the standard greyscale lookup table
}{
   \sstdescription{
      Procedure for loading the standard greyscale lookup table into
      the current image-display device with linear scaling.
   }
   \sstusage{
      LUTGREY
   }
   \newpage
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         {\tt [}Current image-display device{\tt ]}
      }
   }
   \sstnotes{
      This is a procedure that calls LUTABLE.  Therefore, the ADAM
      parameter cannot be specified on the command line.  You will 
      only be prompted for the DEVICE parameter if the current
      image display is not suitable or not available.
   }
}

\sstroutine{
   LUTHEAT
}{
   Loads the {\tt heat} lookup table
}{
   \sstdescription{
      This procedure loads the {\it heat} lookup table with linear scaling
      into the current image-display device.
   }
   \sstusage{
      LUTHEAT
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         {\tt [}Current image-display device{\tt ]}
      }
   }
   \sstnotes{
      This is a procedure that calls LUTABLE.  Therefore, the ADAM
      parameter cannot be specified on the command line.  You will 
      only be prompted for the DEVICE parameter if the current
      image display is not suitable or not available.
   }

}

 
\sstroutine{
   LUTHILITE
}{
   Highlights a colour table of an image-display device
}{
   \sstdescription{
      This routine adjusts the colour table of a nominated plane of
      an IDI-supported image display, such as the Ikon.  The adjustment
      is like a highlight pen, only here it can traverse the colour
      table, widen or thin is under mouse, joystick or trackerball
      button control; and the colour of the highlight is arbitrary.
      Thus particular features in an image may readily become visible.

      For an Ikon or Vaxstation, moving the mouse left or right shifts
      the highlight in the colour table towards lower and higher colour
      indices respectively.  The highlight does not rotate around the
      colour table.  Pressing the left button of the mouse reduces the
      width of the highlight by one colour index.  Pressing the centre
      button increases the width of the highlight by one colour index.
      Hitting the right-hand button ends the modification of the colour
      table.

      The colour table may be viewed during its manipulation without
      permanently altering the display memory.  The colour-table
      display is situated via the cursor, and will disappear once the
      highlighting is complete.
   }
   \sstusage{
      LUTHILITE COLOUR [DEVICE] [PLANE] [VIEW]
   }
   \sstparameters{
      \sstsubsection{
         COLOUR() = LITERAL (Read)
      }{
         The colour to be used as a highlight.  It is either:
         \begin{itemize}
           \item  A named colour from the standard colour set, which may
           be abbreviated.  If the abbreviated name is ambiguous the
           first match is selected.  The case of the name is ignored.
           Some examples are {\tt "Seagreen"}, {\tt "Violet"}, and
           {\tt "Orchid"}.

           \item Normalised red, green, and blue intensities separated by
           commas or spaces.  Each value must lie in the range 0.0--1.0.
           For example, {\tt 1.0,1.0,0.5} would give a pale yellow.
         \end{itemize}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose lookup table is to
         be adjusted.  The name of the base plane should be given even
         if the overlay lookup table is to be adjusted.
         {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         PLANE = \_INTEGER (Read)
      }{
         The number of the memory plane whose lookup table is to be
         manipulated. If it is null the base (image) memory's lookup
         table is adjusted.  The base memory is 0 and overlays are
         numbered consecutively from 1.  For an Ikon the only overlay
         plane is 1.  PLANE is only permitted to have a value in the
         range 0 to the number of planes minus one. {\tt [0]}
      }
      \sstsubsection{
         VIEW = \_LOGICAL (Read)
      }{
         If true the colour table is displayed during its manipulation.
         {\tt [FALSE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LUTHILITE RED
      }{
         Highlights the colour table on the current image-display
         device with a red marker.
      }
      \sstexamplesubsection{
         LUTHILITE SKYBLUE XWINDOWS
      }{
         Highlights the colour table on the XWINDOWS device with a
         sky-blue marker.
      }
      \sstexamplesubsection{
         LUTHILITE [1.0,1.0,0.3] IKON 1
      }{
         Highlights the colour table on the Ikon overlay plane in a
         pale yellow.
      }
      \sstexamplesubsection{
         LUTHILITE RED VIEW
      }{
         Highlights the colour table on the current image-display
         device with a red marker.  The colour table is displayed
         during the highlighting.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Only Ikons and Xwindows are supported.

         \sstitem
         Initially, the highlight has a width of two colour indices,
         and it is located at the second lowest colour index.  The maximum
         width of the highlight is the larger of six and a quarter of the
         colour table, but may be narrower when there are less than 12
         colour indices.  Should the highlight prove to be unsuitable, it
         may be made invisible by reducing the width to zero.

         \sstitem
         The reserved pens cannot be highlighted.

         \sstitem
         The rate of motion of the highlight is a function of the
         speed of cursor movement in addition to the cursor position.
         For a given cursor displacement slow motion moves the highlight
         more slowly, and faster motion moves it more rapidly.  This
         permits both fine control and swift change in the highlight's
         location.
      }
   }
}

\sstroutine{
   LUTIKON
}{
   Loads the default {\it Ikon} lookup table
}{
   \sstdescription{
      This procedure loads the default {\it Ikon} lookup table with linear
      scaling into the current image-display device.
   }
   \sstusage{
      LUTIKON
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         {\tt [}Current image-display device{\tt ]}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This is a procedure that calls LUTABLE.  Therefore, the ADAM
         parameter cannot be specified on the command line.  You will 
         only be prompted for the DEVICE parameter if the current
         image display is not suitable or not available.

         \sstitem
         The device need not be an Ikon.
      }
   }
}

\sstroutine{
   LUTNEG
}{
   Loads the standard negative greyscale lookup table
}{
   \sstdescription{
      Procedure for loading the standard greyscale lookup table into
      the current image-display device with negative linear scaling.
   }
   \sstusage{
      LUTNEG
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         {\tt [}Current image-display device{\tt ]}
      }
   }
   \sstnotes{
      This is a procedure that calls LUTABLE.  Therefore, the ADAM
      parameter cannot be specified on the command line.  You will 
      only be prompted for the DEVICE parameter if the current
      image display is not suitable or not available.
   }
}

\sstroutine{
   LUTRAMPS
}{
   Loads the coloured-ramps lookup table
}{
   \sstdescription{
      This procedure loads the coloured-ramps lookup table with linear
      scaling into the current image-display device.
   }
   \sstusage{
      LUTRAMPS
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         {\tt [}Current image-display device{\tt ]}
      }
   }
   \sstnotes{
      This is a procedure that calls LUTABLE.  Therefore, the ADAM
      parameter cannot be specified on the command line.  You will 
      only be prompted for the DEVICE parameter if the current
      image display is not suitable or not available.
   }
}

\sstroutine{
   LUTREAD
}{
   Loads an image-display lookup table from an NDF
}{
   \sstdescription{
      This application reads a lookup table stored in an NDF with
      the standard format, and loads it into the current image-display
      device.
   }
   \sstusage{
      LUTREAD LUT
   }
   \sstarguments{
      \sstsubsection{
        LUT = LITERAL (Given)
      }{
           The file containing the lookup table.  An error will result
           if it is not given from ICL.  It is passed to the ADAM
           parameter LUT but not validated.
      }
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         [Current image-display device]
      }
      \sstsubsection{
         LUT = NDF (Read)
      }{
         Name of the NDF containing the lookup table as its data
         array.  The LUT must be 2-dimensional, the first dimension
         being 3, and the second being arbitrary.  Linear interpolation
         is used to compress or expand the colour table if the second
         dimension is different from the number of unreserved colour
         indices.  Also the LUT's values must lie in the range 0.0--1.0.
      }
   }
   \sstnotes{
      This is a procedure that calls LUTABLE.  Therefore, the ADAM
      parameters cannot be specified on the command line.  You will 
      only be prompted for the ADAM parameters if the device is not
      suitable or not available, and/or the lookup table file could
      not be accessed.  However, the argument to the procedure must be
      given when calling from ICL, but not DCL.
   }
}
 
\sstroutine{
   LUTROT
}{
   Rotates the colour table of an image-display device
}{
   \sstdescription{
      This routine rotates the colour table of a nominated plane of
      an IDI-supported image display, such as the Ikon. The rotation
      is under mouse, joystick or trackerball button control.

      For an Ikon or a Vaxstation moving the mouse left or right
      rotates the colour table towards lower and higher pen numbers
      respectively.  Pressing the left button of the mouse resets the
      colour table to its input state, and hitting the right-hand
      button ends the rotation.
   }
   \sstusage{
      LUTROT [DEVICE] [PLANE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose colour table is to
         be rotated.  The name of the base plane should be given even if
         the overlay colour table is to be rotated.
         {\tt [}Current image display{\tt ]}
      }
      \sstsubsection{
         PLANE = \_INTEGER (Read)
      }{
         The number of the memory plane whose colour table is to be
         rotated. If it is null the base (image) memory's colour table
         is rotated. The base memory is 0 and overlays are numbered
         consecutively from 1.  For an Ikon the only overlay plane is 1.
         PLANE is only permitted to have a value in the range 0 to the
         number of planes minus one. {\tt [0]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LUTROT
      }{
         This enables rotation of the colour table on the current
         image-display device.
      }
      \sstexamplesubsection{
         LUTROT XWINDOWS
      }{
         This enables rotation of the colour table on the XWINDOWS
         device.
      }
      \sstexamplesubsection{
         LUTROT IKON 1
      }{
         This enables rotation of the colour table on the Ikon overlay
         plane.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Only Ikons and Xwindows are supported.

         \sstitem
         The reserved pens are not rotated.

         \sstitem
         The rate of motion of the colour table is a function of the
         speed of cursor movement in addition to the cursor position.
         For a given cursor displacement slow motion rotates the colour
         table more slowly, and faster motion moves it more rapidly.  This
         permits both fine control and swift rotation.
      }
   }
}

\sstroutine{
   LUTSAVE
}{
   Saves the current colour table of an image-display device in an NDF
}{
   \sstdescription{
      This routine reads the colour table of a nominated plane of
      an IDI-supported image display, such as the Ikon, and then copies
      it to an NDF LUT file.
   }
   \sstusage{
      LUTSAVE LUT [DEVICE] [PLANE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose colour table is to
         be saved. The name of the base plane should be given even if
         the overlay colour table is to be saved.
         {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         FULL = \_LOGICAL (Read)
      }{
         If true the whole colour-table for the device is stored
         including the reserved pens.  This is necessary to save a
         colour table written by another package that does not reserve
         colour indices.  For colour tables produced by KAPPA this
         should be false. {\tt [FALSE]}
      }
      \sstsubsection{
         LUT = NDF (Write)
      }{
         The output NDF into which the colour table is to be stored.
         Its second dimension equals the number of colour-table
         entries that are stored.  This will be less than the
         total number of colour indices on the device if FULL is false.
      }
      \sstsubsection{
         PLANE = \_INTEGER (Read)
      }{
         The number of the memory plane whose colour table is to be
         saved. If it is null the base (image) memory's colour table
         is reversed. The base memory is 0 and overlays are numbered
         consecutively from 1.  For an Ikon the only overlay plane is 1.
         PLANE is only permitted to have a value in the range 0 to the
         number of planes minus one. {\tt [0]}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         The title for the output NDF. {\tt ['KAPPA - Lutsave']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LUTSAVE PIZZA
      }{
         This saves the current colour table on the current
         image-display device to an NDF called PIZZA.
      }
      \sstexamplesubsection{
         LUTSAVE RAMPS IKON 1
      }{
         This saves the current colour table on the Ikon overlay plane
         an NDF called RAMPS.
      }
      \sstexamplesubsection{
         LUTSAVE REDSHIFT FULL
      }{
         This saves in full the current colour table on the current
         image-display device to an NDF called REDSHIFT.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Only Ikons and Xwindows are supported.

         \sstitem
         Only the non-reserved portion of the colour table is saved.
      }
   }
}

\sstroutine{
   LUTSPEC
}{
   Loads a spectrum-like lookup table
}{
   \sstdescription{
      This procedure loads a spectrum-like lookup table with linear scaling
      into the current image-display device.
   }
   \sstusage{
      LUTSPEC
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         {\tt [}Current image-display device{\tt ]}
      }
   }
   \sstnotes{
      This is a procedure that calls LUTABLE.  Therefore, the ADAM
      parameter cannot be specified on the command line.  You will 
      only be prompted for the DEVICE parameter if the current
      image display is not suitable or not available.
   }
}
 
\sstroutine{
   LUTTWEAK
}{
   Tweaks a colour table of an image-display device
}{
   \sstdescription{
      This routine adjusts the colour table of a nominated plane of
      an IDI-supported image display, such as the Ikon. The adjustment
      is under mouse, joystick or trackerball button control.

      For an Ikon or Vaxstation, moving the mouse left or right shifts
      the colour table towards lower and higher colour indices
      respectively.  Moving the mouse up stretches the lookup table,
      and moving it down squashes the lookup table until it disappears,
      then the lookup table is flipped.  If the lookup table is
      reversed, moving down stretches, and moving up squashes.
      Pressing the left button of the mouse resets the colour table to
      its input state.  Pressing the centre button alters the way in
      which a squashed lookup table is padded.  The two states are
      white or to use the first and last colours of the input lookup
      table, the sense depending on whether the lookup table is
      flipped.  Hitting the right-hand button ends the modification of
      the colour table.

      The colour table may be viewed during its manipulation without
      permanently altering the display memory.  The colour-table
      display is situated via the cursor, and will disappear once the
      tweaking is complete.
   }
   \sstusage{
      LUTTWEAK [DEVICE] [PLANE] [VIEW]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose lookup table is to
         be adjusted.  The name of the base plane should be given even
         if the overlay lookup table is to be adjusted.
         {\tt [}Current image display{\tt ]}
      }
      \sstsubsection{
         PLANE = \_INTEGER (Read)
      }{
         The number of the memory plane whose lookup table is to be
         manipulated. If it is null the base (image) memory's lookup
         table is adjusted.  The base memory is 0 and overlays are
         numbered consecutively from 1.  For an Ikon the only overlay
         plane is 1.  PLANE is only permitted to have a value in the
         range 0 to the number of planes minus one. {\tt [0]}
      }
      \sstsubsection{
         VIEW = \_LOGICAL (Read)
      }{
         If true the colour table is displayed during its manipulation.
         {\tt [FALSE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LUTTWEAK
      }{
         Tweaks the colour table on the current image-display device.
      }
      \sstexamplesubsection{
         LUTTWEAK XWINDOWS
      }{
         Tweaks the colour table on the Xwindows device.
      }
      \sstexamplesubsection{
         LUTTWEAK IKON 1
      }{
         Tweaks the colour table on the Ikon overlay plane.
      }
      \sstexamplesubsection{
         LUTTWEAK VIEW
      }{
         Tweaks the colour table on the current image-display device.
         The colour table is displayed during the tweaking.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Only Ikons and Xwindows are supported.

         \sstitem
         The reserved pens are not tweaked.

         \sstitem
         The speed of the colour-table rotation is not linearly
         proportional to the mouse displacement; the speed of displacement
         tunes the effect so that slow motion makes a small change than
         a faster motion.  The squashing and stretching factors are also
         non-linear.
      }
   }
}
 
\sstroutine{
   LUTVIEW
}{
   Draws a colour-table key
}{
   \sstdescription{
      This application draws a key of the colour table at a location
      selected by the user. The key may be constrained to lie within
      either the current or the base picture.  The key may be annotated
      in which case sufficient room must be given for the annotations.
      For oblate regions colour index increases from left to right, and
      for prolate it increases from bottom to top; annotations appearing
      to the top and right respectively.  The annotations scale linearly
      between the values corresponding to the lower and upper indices
      of the colour table.

      The situation of the key is defined by the co-ordinates of a pair
      of opposite corners of a rectangular region.  These may be
      specified by via one of the following methods:
      \begin{enumerate}
      \item moving a cursor and pressing a button on the mouse or
            trackerball;
      \item obtaining bounds from the environment (in normalised
            co-ordinates of the reference picture).
      \end{enumerate}
   }
   \sstusage{
      LUTVIEW [MODE] [LOW] [HIGH] [ANNOTA] [CURPIC] [DEVICE] LBOUND=?
        UBOUND=?
   }
   \sstparameters{
      \sstsubsection{
         ANNOTA = \_LOGICAL (Read)
      }{
         True if the colour table is to be annotated with the pen
         numbers. Note a squarer picture should be created so that the
         annotations are legible. {\tt [False]}
      }
      \sstsubsection{
         CURPIC = \_LOGICAL (Read)
      }{
         True if the colour table key is to lie within the current
         picture, otherwise the new picture can lie anywhere within
         the base picture. It is ignored when the current-picture mode
         is selected. {\tt [False]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The image-display device on which the colour table is to be
         drawn.   The device must be in one of the following GNS
         categories: IMAGE\_DISPLAY, IMAGE\_OVERLAY, MATRIX\_PRINTER, or
         WINDOW, and have at least 24 greyscale intensities or colour
         indices.  It must also not reset when the device is opened
         (since the colour table would be lost).
         {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         HIGH = \_REAL (Read)
      }{
         The value corresponding to the maximum colour index.  It is
         used to calculate the annotation scale for the key.  If it
         is null ({\tt !}) the maximum colour index is used. {\tt [!]}
      }
      \sstsubsection{
         LBOUND( 2 ) = \_REAL (Read)
      }{
         Co-ordinates of the lower bound that defines the location of
         the colour-table plot. These are in the world system of the
         base or current picture. (XY mode)
      }
      \sstsubsection{
         LOW = \_REAL (Read)
      }{
         The value corresponding to the minimum colour index.  It is
         used to calculate the annotation scale for the key.  If it
         is null ({\tt !}) the minimum colour index is used. {\tt [!]}
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         Method for defining the position, size and shape of the
         colour-table key.  The options are {\tt "Cursor"} for cursor mode
         (provided the graphics device has one), {\tt "XY"} to select $x$-$y$
         limits via the parameter system, and {\tt "Picture"} where the
         whole of the current picture is used.  Additional positioning
         options are available by using other KAPPA applications to
         create new pictures and then specifying the picture mode.
         {\tt ["Cursor"]}
      }
      \sstsubsection{
         OUTLINE = \_LOGICAL (Read)
      }{
         If true, a box that delimits the key is drawn.  A box
         is always drawn when there are annotations. {\tt [True]}
      }
      \sstsubsection{
         UBOUND( 2 ) = \_REAL (Read)
      }{
         Co-ordinates of the upper bound that defines the location
         of the colour-table plot. These are in the world system of the
         base or current picture. (XY mode)
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LUTVIEW ANNOTA
      }{
         Draws an annotated colour table at a position selected via
         the cursor on the current image-display device.
      }
      \sstexamplesubsection{
         LUTVIEW P
      }{
         Draws a colour table that fills the current picture on the
         current image-display device.
      }
      \sstexamplesubsection{
         LUTVIEW CURPIC
      }{
         Draws a colour table within the current picture positioned
         via the cursor.
      }
      \sstexamplesubsection{
         LUTVIEW MODE=XY OUTLINE DEVICE=IKON $\backslash$
      }{
         Draws a outlined colour table within the base picture
         on the Ikon, defined by $x$-$y$ extents.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         When annotations are selected their precise height and the
         width of the colour table, depend on the largest number of
         significant figures in an annotation.  The colour table will have
         an aspect ratio in the range 0.17--0.45, and the text height is
         adjusted to fit the characters within the available room.  The
         default aspect ratio is 0.275.

         \sstitem
         The text has a maximum height as a fraction of width (if
         oblate) or height of the initial picture (base or current) so
         that ridiculously large characters are drawn for big keys.
         However, this can result in characters which are too if for
         example a highly oblate colour table is plotted within a strongly
         prolate current picture.

         \sstitem
         A frame picture (when there are annotations) and the
         colour-table picture are stored in the graphics database. These
         have names FRAME and KEY respectively.  On completion the
         current picture is unchanged.

         \sstitem
         Parameters LOW and HIGH are single precision because they are
         also required to define world co-ordinates of the graphics.  Thus
         this application is not suitable for double-precision data that
         have been scaled over a range near the precision of real values.
      }
   }
}

\sstroutine{
   LUTZEBRA
}{
   Loads a pseudo-contour lookup table
}{
   \sstdescription{
      This procedure loads a pseudo-contour lookup table with linear
      scaling into the current image-display device. The lookup table
      is mainly black with a set of white stripes.
   }
   \sstusage{
      LUTZEBRA
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display whose colour table is to be changed.
         {\tt [}Current image-display device{\tt ]}
      }
   }
   \sstnotes{
      This is a procedure that calls LUTABLE.  Therefore, the ADAM
      parameter cannot be specified on the command line.  You will 
      only be prompted for the DEVICE parameter if the current
      image display is not suitable or not available.
   }
}

\manroutine {{\manheadstyle{MANIC}}}{ Converts all or part of a data array from one
  dimensionality to another.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This application copies or converts all or part of a 1, 2 or
  3-dimensional data array to one or more output data arrays, each
  of 1, 2 or 3 dimensions. All data arrays are stored in {\mantt{IMAGE}}
  structures. Windows may be set in any of the dimensions of the
  input data array. All or part of the input array may be projected
  on to any of the rectangular planes or axes of the input before
  being written to an output array; or a 1- or 2-dimensional data
  array may be grown to more dimensions to fill an output data
  array. Many output data arrays, each of a different configuration
  if required, may be extracted from a single input data array with
  one call to the routine.

\manroutineitem {Invocation }{}
  MANIC

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPUT}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure holding the input data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{ONDIM}}  }{{\mantt{\_INTEGER}}}
  Dimensionality of an output data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{XLIMITS}}(2) }{{\mantt{\_INTEGER}}}
  The {$x$}-axis window on the input data array to be used in
  forming an output data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{YLIMITS}}(2) }{{\mantt{\_INTEGER}}}
  The {$y$}-axis window on the input data array to be used in
  forming an output data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{ZLIMITS}}(2) }{{\mantt{\_INTEGER}}}
  The {$z$}-axis window on the input data array to be used in
  forming an output data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{XRANGE}}(2)  }{{\mantt{\_INTEGER}}}
  The {$x$}-axis range for summation in the input data array in
  forming an output data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{YRANGE}}(2)  }{{\mantt{\_INTEGER}}}
  The {$y$}-axis range for summation in the input data array in
  forming an output data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{ZRANGE}}(2)  }{{\mantt{\_INTEGER}}}
  The {$z$}-axis range for summation in the input data array in
  forming an output data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{EPLANE}}  }{{\mantt{\_CHAR}}}
  Plane to be extracted from the input 3-d data array.   The options are
  {\mantt 'XY'}, {\mantt 'YZ'}, {\mantt 'ZX'}, {\mantt 'YX'},
  {\mantt 'ZY'}, {\mantt 'XZ'}.
\manparameterentry {{\mantt{READ}} }{{\mantt{GPLANE}}  }{{\mantt{\_CHAR}}}
  Input 2-d data array forms this plane when being grown into
  a 3-d data array.   The options are {\mantt 'XY'}, {\mantt 'YZ'},
  {\mantt 'ZX'}, {\mantt 'YX'}, {\mantt 'ZY'}, {\mantt 'XZ'}.
\manparameterentry {{\mantt{READ}} }{{\mantt{ELINE1}}  }{{\mantt{\_CHAR}}}
  Axis of input 2-d data array to be extracted to form an output
  1-d data array.   The alternatives are {\mantt 'X'} or {\mantt 'Y']}.
\manparameterentry {{\mantt{READ}} }{{\mantt{ELINE2}}  }{{\mantt{\_CHAR}}}
  Axis of input 3-d data array to be extracted to form an output
  1-d data array.  The options are {\mantt 'X'}, {\mantt 'Y'}, {\mantt 'Z'}.
\manparameterentry {{\mantt{READ}} }{{\mantt{GLINE1}}  }{{\mantt{\_CHAR}}}
  Input 1-d data array will form this axis of an output 2-d
  data array.   The alternatives are {\mantt 'X'} or {\mantt 'Y'}.
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{GLINE2}}  }{{\mantt{\_CHAR}}}
  Input 1-d data array will form this axis of an output 3-d
  data array.  The options are {\mantt 'X'}, {\mantt 'Y'}, {\mantt 'Z'}.
\manparameterentry {{\mantt{READ}} }{{\mantt{XDIM}}  }{{\mantt{\_INTEGER}}}
  {$x$}-dimension of output 2-d or 3-d data array grown from input
  1-d or 2-d data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{YDIM}}  }{{\mantt{\_INTEGER}}}
  {$y$}-dimension of output 2-d or 3-d data array grown from input
  1-d or 2-d data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{ZDIM}}  }{{\mantt{\_INTEGER}}}
  {$z$}-dimension of output 2-d or 3-d data array grown from input
  1-d or 2-d data array.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPUT}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure to hold an output data array.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title for {\mantt{IMAGE}} structure holding an output data array.
  \mbox{{\mantt ['KAPPA - Manic']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{LOOP}}  }{{\mantt{\_LOGICAL}}}
  Extract or grow further output data arrays from the same input
  data array.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
  Dave Baines ({\mantt{ROE}}::{\mantt{ASOC5}})
  Dave Pike ({\mantt{RGO}}::{\mantt{CDP}})
  Roger Wood ({\mantt{RGO}}::{\mantt{RW}})
\end{manroutinedescription}

\sstroutine{
   MATHS
}{
   Evaluates mathematical expressions applied to NDF data structures
}{
   \sstdescription{
      This application allows arithmetic and mathematical functions to
      be applied pixel-by-pixel to a number of NDF data structures and
      constants so as to produce a new NDF. The operations to be
      performed are specified using a FORTRAN-like mathematical
      expression. Up to 26 input NDFs and 26 parameterised `constants'
      may be combined in wide variety of ways using this application,
      which can also calculate variance estimates for the result.
   }
   \sstparameters{
      \sstsubsection{
         EXP = LITERAL (Read)
      }{
         The mathematical expression to be evaluated for each NDF
         pixel, {\it e.g.}\ {\tt "(IA-IB+2)*PX"}. In this expression, input NDFs are
         denoted by the variables IA, IB, ... IZ, while constants may
         either be given literally or represented by the variables PA,
         PB, ...  PZ.  Values for those NDFs and constants which appear
         in the expression will be requsted via the application's
         parameter of the same name. At least one input NDF must
         appear in the expression.

         FORTRAN 77 syntax is used for specifying the expression, which
         may contain the usual intrinsic functions, plus a few extra
         ones. An appendix in SUN/61 gives a full description of the
         syntax used and an up to date list of the functions available.
         The expression may be up to 132 characters long.
      }
      \sstsubsection{
         IA-IZ = NDF (Read)
      }{
         The set of 26 parameters named IA, IB, ... IZ is used to
         obtain the input NDF data structure(s) to which the
         mathematical expression is to be applied.  Only those
         parameters which actually appear in the expression are used,
         and their values are obtained in alphabetical order.  For
         instance, if the expression were {\tt "SQRT(IB+IA)"}, then the
         parameters IA and IB would be used (in this order) to obtain
         the two input NDF data structures.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Output NDF to contain the result of evaluating the expression
         at each pixel.
      }
      \sstsubsection{
         PA-PZ = \_DOUBLE (Read)
      }{
         The set of 26 parameters named PA, PB, ... PZ is used to
         obtain the numerical values of any parameterised `constants'
         which appear in the expression being evaluated.  Only those
         parameters which actually appear in the expression are used,
         and their values are obtained in alphabetical order.  For
         instance, if the expression were {\tt "PT*SIN(IA/PS)"}, then the
         parameters PS and PT (in this order) would be used to obtain
         numerical values for substitution into the expression at the
         appropriate points.

         These parameters are particularly useful for supplying the
         values of constants when writing procedures, where the
         constant may be determined by a command-language variable, or
         when the constant is stored in a data structure such as a
         global parameter. In other cases, constants should normally be
         given literally as part of the expression, as in
         {\tt "IZ**2.77"}.
      }
      \sstsubsection{
         QUICK = \_LOGICAL (Read)
      }{
         Specifies the method by which values for the variance
         component of the output NDF are calculated. The algorithm used
         to determine these values involves perturbing each of the
         input NDF data arrays in turn by an appropriate amount, and
         then combining the resulting output perturbations.  If QUICK
         is set to {\tt TRUE}, then each input data array will be perturbed
         once, in the positive direction only.  If QUICK is set to
         {\tt FALSE}, then each will be perturbed twice, in the positive and
         negative directions, and the maximum resultant output
         perturbation will be used to calculate the output variance.
         The former approach (the normal default) executes more
         quickly, but the latter is likely to be more accurate in cases
         where the function being evaluated is highly non-linear,
         and/or the errors on the data are large.  {\tt [TRUE]}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Value for the title of the output NDF. A null value will cause
         the title of the (alphabetically) first input NDF to be used
         instead. {\tt ['KAPPA - Maths']}
      }
      \sstsubsection{
         UNITS = \_LOGICAL (Read)
      }{
         Specifies whether the units component of the (alphabetically)
         first input NDF will be propagated to the output NDF. By
         default this component is not propagated since, in most cases,
         the units of the output data will differ from those of any of
         the input data structures. In simple cases, however, the units
         may be unchanged, and this parameter then allows the units
         component to be preserved. {\tt [FALSE]}
      }
      \sstsubsection{
         VARIANCE = \_LOGICAL (Read)
      }{
         Specifies whether values for the variance component of the
         output NDF should be calculated. If this parameter is set to
         {\tt TRUE} (the normal default), then output variance values will be
         calculated if any of the input NDFs contain variance
         information. Any which do not are regarded as having zero
         variance. Variance calculations will normally be omitted only
         if none of the input NDFs contain variance information.
         However, if VARIANCE is set to {\tt FALSE}, then calculation of
         output variance values will be disabled under all
         circumstances, with a consequent saving in execution time.
         {\tt [TRUE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         MATHS "IA-1" DAT2 IA=DAT1
      }{
         The expression {\tt "IA-1"} is evaluated to subtract 1 from each
         pixel of the input NDF referred to as IA, whose values reside
         in the data structure DAT1. The result is written to the NDF
         structure DAT2.
      }
      \sstexamplesubsection{
         MATHS "(IA-IB)/IC" IA=DATA IB=BACK IC=FLAT OUT=RESULT UNITS
      }{
         The expression {\tt "(IA-IB)/IC"} is evaluated to remove a
         background from an image and to divide it by a flat-field. All
         the images are held in NDF data structures, the input image
         being obtained from the data structure DATA, the background
         image from BACK and the flat-field from FLAT. The result is
         written to the NDF structure RESULT. The data units are
         unchanged and are therefore propagated to the output NDF.
      }
      \sstexamplesubsection{
         MATHS {\tt "-2.5*log10(II)+25.7"} II=FILE1 OUT=FILE2
      }{
         The expression {\tt "-2.5*log10(II)+25.7"} is evaluated to convert
         intensity measurements into magnitudes, including a zero
         point.  II represents the input measurements held in the NDF
         structure FILE1. The result is written to the NDF structure
         FILE2. If FILE1 contains variance values, then corresponding
         variance values will also be calculated for FILE2.
      }
      \sstexamplesubsection{
         MATHS EXP={\tt "PA*EXP(IA+PB)"} OUT=OUTFILE PB=13.7 NOVARIANCE
      }{
         The expression {\tt "PA*EXP(IA+PB)"} is evaluated with a value of
         13.7 for the constant PB, and output is written to the NDF
         structure OUTFILE. The input NDF structure to be used for IA
         and the value of the other numerical constant PA will be
         prompted for. NOVARIANCE has been specified so that output
         variance values will not be calculated.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The alphabetically first input NDF is regarded as the primary
         input dataset. NDF components whose values are not changed by
         this application will be propagated from this NDF to the output.

         \sstitem
         If illegal arithmetic operations ({\it e.g.}\ division by zero, or
         square root of a negative number) are attempted, then a bad pixel
         will be generated as a result.

         \sstitem
         All arithmetic performed by this application is floating
         point. Single-precision will normally be used, but
         double-precision will be employed if any of the input NDF arrays
         has a numeric type of \_DOUBLE.
      }
   }
   \sstdiytopic{
      Calculating Variance
   }{
      The algorithm used to calculate output variance values is
      general-purpose and will give correct results for any reasonably
      well-behaved mathematical expression.  However, this application
      as a whole, and the variance calculations in particular, are
      likely to be less efficient than a more specialised application
      written knowing the form of the mathematical expression in
      advance. For simple operations (addition, subtraction, {\it etc.}) the
      use of other applications (ADD, SUB, {\it etc.}) is therefore
      recommended, particularly if variance calculations are required.

      The main value of the variance estimation algorithm used here
      arises when the expression to be evaluated is too complicated, or
      too infrequently used, to justify the work of deriving a direct
      formula for the variance. It is also of value when the data
      errors are especially large, so that the linear approximation
      normally used in error analysis breaks down.
   }
   \sstdiytopic{
      Timing
   }{
      If variance calculations are not being performed, then the time
      taken is approximately proportional to the number of NDF pixels
      being processed. The execution time also increases with the
      complexity of the expression being evaluated, depending in the
      usual way on the nature of any arithmetic operations and
      intrinsic functions used. If certain parts of the expression will
      often give rise to illegal operations (resulting in bad pixels),
      then execution time may be minimised by placing these operations
      near the beginning of the expression, so that later parts may not
      need to be evaluated.

      If output variance values are being calculated and the QUICK
      parameter is set to {\tt TRUE}, then the execution time will be
      multiplied by an approximate factor ($N+1$), where $N$ is the number
      of input NDFs which contain a variance component. If QUICK is set
      to {\tt FALSE}, then the execution time will be multiplied by an
      approximate factor ($2N+1$).
   }
   \sstdiytopic{
      Implementation Status
   }{
      This routine correctly processes the AXIS, DATA, QUALITY, LABEL,
      TITLE, VARIANCE and UNITS components of the input NDFs.  NDFs
      with any number of dimensions can be handled. The NDFs supplied
      as input need not all be the same shape. Processing of bad pixels
      and all non-complex numeric types is supported.
   }
}

\manroutine {{\manheadstyle{MEDIAN}}}{ Smooths a 2-d data array using a 2-d
  weighted median filter.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  Filters the 2-d data array, in the input {\mantt{IMAGE}} structure with a
  Weighted Median Filter (WMF) of a type defined by the user,
  or selected from some predefined types, modes 0 to 7.

  The predefined modes have the following weighting functions:  \mbox {}
\[
\begin{array}{lccclccclccclccc}
{\bf 0:}&1&1&1\hspace{4ex}&{\bf 1:}&0&1&0\hspace{4ex}&{\bf 2:}&1&0&1\hspace{4ex}&{\bf 3:}&1&1&1 \\
  &  1&1&1\hspace{4ex}&&  1&1&1\hspace{4ex}&&  0&1&0\hspace{4ex}&&  1&3&1 \\
  &  1&1&1\hspace{4ex}&&  0&1&0\hspace{4ex}&&  1&0&1\hspace{4ex}&&  1&1&1 \\
\\
\\
{\bf 4:}&0&1&0\hspace{4ex}&{\bf 5:}&1&0&1\hspace{4ex}&{\bf 6:}&1&2&1\hspace{4ex}&{\bf 7:}&1&3&1 \\
  &  1&3&1\hspace{4ex}&&  0&3&0\hspace{4ex}&&  2&3&2\hspace{4ex}&&  3&3&3 \\
  &  0&1&0\hspace{4ex}&&  1&0&1\hspace{4ex}&&  1&2&1\hspace{4ex}&&  1&3&1
\end{array}
\]

  If the WMF is to be user defined then the parameters for the
  weighting function, {\mantt {\%CORNER}}, {\mantt {\%SIDE}} and {\mantt {\%CENTRE}}, will be requested.
  A step size has to be specified; this determines the spacing of
  the elements of the weighting function. The weighting function has
  the form :
\[
\begin{array}{ccccc}

  \%\-{\mantt CORNER} & . &  \%\-{\mantt SIDE}  & . &  \%\-{\mantt CORNER} \\
  . &  & . &  & . \\
  \%\-{\mantt SIDE}  & . &  \%\-{\mantt CENTRE} & . &  \%\-{\mantt SIDE} \\
  . &  & . &  & . \\
  \%\-{\mantt CORNER} & . &  \%\-{\mantt SIDE}  & . &  \%\-{\mantt CORNER}

\end{array}
\]

  The . indicates that the weights are separated by the stepsize-minus-one
  zeros.

  A threshold for replacement of a value by the median can be set.
  If the absolute value of the difference between the actual value
  and the median is less than the threshold, the replacement will
  not occur. The array boundary is dealt by either pixel replication
  or a reflection about the edge pixels of the array. The WMF can be
  repeated a specified number of times before the filtered version
  is written to the output data array, in an {\mantt{IMAGE}} structure.

  The magic-value method is used for processing bad data. Bad pixels
  are not included in the calculation of the median. There is a
  defined threshold which specifies minimum-allowable median
  position as a fraction of the median position when there are no
  bad pixels.  For neighbourhoods with too many bad pixels, and so
  the median position is too small, the resulting output pixel is
  bad.

\manroutineitem {Invocation }{}
  MEDIAN

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the 2-d data array to be filtered.
\manparameterentry {{\mantt{READ}} }{{\mantt{MODE}}  }{{\mantt{\_INTEGER}}}
  Determines type of weighting used, {$-$}1 gives user-defined
  weighting, and 0 to 7 the predefined filters. {\mantt{[0]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{CORNER}} }{{\mantt{\_INTEGER}}}
  Corner value for weighting function, required  if {\mantt{MODE}}
  {\mantt{=}} {$-$}1.
\manparameterentry {{\mantt{READ}} }{{\mantt{SIDE}}  }{{\mantt{\_INTEGER}}}
  Side value for weighting function, required if {\mantt{MODE}}
  {\mantt{=}} {$-$}1.
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{CENTRE}} }{{\mantt{\_INTEGER}}}
  Central value for weighting function, required if {\mantt{MODE}}
  {\mantt{=}} {$-$}1.
\manparameterentry {{\mantt{READ}} }{{\mantt{STEP}}  }{{\mantt{\_INTEGER}}}
  Spacing between the median filter elements. {\mantt{[1]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{DIFF}}  }{{\mantt{\_REAL}}}
  Replacement of a value by the median occurs if \hbox{abs(value{$-$}median)}
  {$>$} {\mantt \%DIFF}. \mbox{{\mantt [0.0]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{MEDTHR}} }{{\mantt{\_REAL}} }
  Minimum-allowable actual median position as a fraction of
  the median position when there are no bad pixels, before the computation
  of the median at a given pixel is undertaken. \mbox{{\mantt [0.8]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{BOUND}}  }{{\mantt{\_CHAR}}}
  Determines whether padding by reflection ({\mantt{'Reflect'}}) or
  replication ({\mantt{'Replicate'}}) occurs at the data-array edge.
  \mbox{{\mantt ['Replicate']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMIT}}  }{{\mantt{\_INTEGER}}}
  Number of iterations of the filter. \mbox{{\mantt [1]}}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure to contain the 2-d data array after filtering.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Will form the {\mantt{TITLE}} component of the output {\mantt{IMAGE}}
  structure. \mbox{{\mantt ['KAPPA - Median']}}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
  Dave Baines ({\mantt{ROE}}::{\mantt{ASOC5}})
\end{manroutinedescription}
 
\sstroutine{
   MEM2D
}{
   Performs a Maximum Entropy deconvolution of a 2-D NDF
}{
   \sstdescription{
      MEM2D is based on the Gull and Skilling Maximum Entropy package
      MEMSYS3. It takes an image and a Point-Spread Function as input
      and produces an equal-sized image as output with higher
      resolution. Facilities are provided to `analyse' the resulting
      deconvolved image, {\it i.e.}\ to calculate an integrated flux in some
      area of the deconvolved image and also an estimate of the
      uncertainty in the integrated flux. This allows the significance
      of structure visible in the deconvolution to be checked.

      For a detailed description of the algorithm, and further
      references, see the MEMSYS3 users manual, and SUN/117.
   }
   \sstusage{
      MEM2D IN OUT MASK=? $\left\{ {\begin{tabular}{l}
                                     FWHMPSF=? \\
                                     PSF=?
                                    \end{tabular} }
                          \right.$
                                    \newline\hspace*{10.3em}
                                    \makebox[0mm][c]{\small psftype}
   }
   \sstparameters{
      \sstsubsection{
         ANALYSE = \_LOGICAL (Read)
      }{
         ANALYSE should be given a true value if an analysis of a
         previously generated deconvolution is to be performed, instead
         of a whole new deconvolution being started.  An analysis
         returns the integrated flux in some user-specified area of the
         deconvolved image, together with the standard deviation on the
         integrated flux value. The area to be integrated over is
         specified by an image associated with parameter MASK. This
         facility can, for instance, be used to assess the significance
         of structure seen in the deconvolution. An analysis can only
         be performed if the input NDF (see parameter IN) contains a
         MEM2D extension (see parameter EXTEND). If the input does
         contain such an extension, and if the extension shows that the
         deconvolution was completed, then ANALYSE is defaulted to
         true, otherwise it is defaulted to false. {\tt []}
      }
      \sstsubsection{
         DEF = \_REAL (Read)
      }{
         This is the value to which the output image will default in
         areas for which there is no valid data in the input. The `zero
         entropy' image is defined to be a flat surface with value
         given by parameter DEF. Any deviation of the output image away
         from this image will cause its entropy to become negative.
         Thus a maximum-entropy criterion causes the output image to be
         as similar as possible to a flat surface with value DEF
         (within the constraints of the data). DEF is defaulted to the
         mean data value in the input image and must always be strictly
         positive. {\tt []}
      }
      \sstsubsection{
         EXTEND = \_LOGICAL (Read)
      }{
         If EXTEND has a true value, then the output NDF will contain
         an extension called MEM2D which will contain all the
         information required to either restart or analyse the
         deconvolution. Note, including this extension makes the output
         file much bigger.  {\tt [TRUE]}
      }
      \sstsubsection{
         FWHMICF = \_REAL (Read)
      }{
         This is the Full Width at Half Maximum (in pixels) of a
         Gaussian Intrinsic Correlation Function (ICF) to be used in
         the deconvolution.  The ICF can be used to encode prior
         knowledge of pixel-to-pixel correlations in the output image.
         A value of zero for FWHMICF causes no ICF to be used, and so
         no correlations are expected in the output. Larger values
         encourage smoothness in the output on the scale of the ICF. If
         a non-zero ICF is used, the image entropy which is maximises
         is not the output image, but a `hidden' image. This hidden
         image is the deconvolution of the output image with the ICF,
         and is assumed to have no pixel-to-pixel correlations. {\tt [2]}
      }
      \sstsubsection{
         FWHMPSF = \_REAL (Read)
      }{
         This is the Full Width at Half Maximum (in pixels) of a
         Gaussian Point Spread Function (PSF). This PSF is used to
         deconvolve the input only if parameter PSFTYPE has the value
         {\tt "GAUSSIAN"}.
      }
      \sstsubsection{
         ILEVEL = \_INTEGER (Read)
      }{
         ILEVEL controls the amount of information displayed as MEM2D
         runs.  If set to zero then no information is displayed. Larger
         values up to a maximum of 3, give larger amounts of
         information.  A value of 3 gives full MEMSYS3 diagnostics
         after each iteration. {\tt [1]}
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         The input NDF. This can either contain an image to be
         deconvolved, or the output from a previous run of MEM2D. The
         NDF is considered to be an output from MEM2D if it contains an
         extension called MEM2D (see parameter EXTEND). If such an
         extension is found, a check is made to see if the NDF contains
         a completed deconvolution or a partial deconvolution. If the
         deconvolution is complete, the ANALYSE parameter is defaulted
         to true, and unless the user overrides this default, an
         analysis of the deconvolution contained in the input NDF is
         performed. If the input deconvolution is not complete, then
         the deconvolution process is restarted from where it left off.
         If no MEM2D extension is found, then a new deconvolution
         is started from scratch.
      }
      \sstsubsection{
         MASK = NDF (Read)
      }{
         An image to use as a mask to define the areas to be integrated
         when performing an analysis (see parameter ANALYSE). The
         integrated-flux value calculated by the analysis is actually
         the total data sum in the product of the mask and the
         deconvolved image. Mask pixel values can be positive or
         negative (or zero) and so, for instance, masks can be arranged
         which subtract off a background brightness from a source
         before returning the integrated source flux.
      }
      \sstsubsection{
         MODEL = NDF (Read)
      }{
         An image to use as the default model for the reconstruction.
         If a null value is given, then a constant value given by the
         parameter DEF is used to define a flat default model. The
         section of the given image which matches the bounds of the
         input image is used. Any bad pixels in the image cause the
         corresponding pixels in the input image to be ignored. Such
         pixels are set bad in the output. The model image should
         contain no pixels with a value of zero or less. The default
         model is defined to have zero entropy. The hidden image will
         tend to the default model in the absence of data. It should be
         noted that this model applies to the `hidden' image, not the
         actually required reconstructed image. The reconstructed image
         is obtained from the hidden image by blurring the hidden image
         with the ICF. {\tt [!]}
      }
      \sstsubsection{
         MODELOUT = NDF (Write)
      }{
         An image which can be used for the default model in a further
         run of MEM2D. Each pixel value in the created image is a
         linear combination of the model value at the corresponding
         pixel in the current reconstruction, and the hidden image
         pixel value. Pixels for which the hidden image is well away
         from the current model, tend towards the value of the hidden
         image; pixels for which the hidden image is close to the
         current model tend towards the model. Running MEM2D several
         times, using the new model created on the previous run as the
         model for the current run, can reduce the `mottling' often
         seen in MEM2D reconstructions. {\tt [!]}
      }
      \sstsubsection{
         NITER = \_INTEGER (Read)
      }{
         The maximum number of MEMSYS3 iterations to perform. MEM2D
         continues the deconvolution until either MEMSYS3 indicates
         that the termination criterion ($\Omega=1.0$) has been reached,
         or the maximum number of iterations is reached. If a
         deconvolution requires more iterations than was allowed by
         NITER, then the user can choose to continue the deconvolution
         by giving the prematurely terminated output from MEM2D as the
         input to another run of MEM2D, specifying a larger value for
         NITER. {\tt [50]}
      }
      \sstsubsection{
         NOISE = LITERAL (Read)
      }{
         NOISE defines the noise statistics within the input image. It
         can take the value {\tt "GAUSSIAN"} or {\tt "POISSON"}. If Gaussian noise
         is selected, the data variances are set initially to the
         values stored in the VARIANCE component of the input NDF. If
         no such component exists, then the data variances are set to a
         constant value equal to the RMS difference between adjacent
         pixels in the $x$ direction. MEMSYS3 scales these initial noise
         estimates to maximise the data `evidence'. The evidence is
         displayed as {\tt "LOG(PROB)"} and the noise scaling factor as
         {\tt "SIGMA"}, if parameter ILEVEL is set to 2 or more.  If Poisson
         statistics are selected the uncertainty in each data value is,
         as usual, of the order of the square root of the data value.
         When using Poisson statistics, there is no equivalent to the
         noise scaling performed when using Gaussian statistics. Any
         input VARIANCE component is ignored. {\tt ["GAUSSIAN"]}
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         The output image in a `primitive' NDF. The output is the same
         size as the input. Any pixels which were flagged as bad in the
         input will also be bad in the output. If parameter EXTEND has
         a true value, then the output NDF contains an extension called
         MEM2D containing information which allows the deconvolution to
         be either continued or analysed. There is no VARIANCE
         component in the output, but any QUALITY values are propagated
         from the input to the output.  If UPDATE has a true value then
         the output NDF is created after the first iteration and is
         updated after each subsequent iteration.
      }
      \sstsubsection{
         PSF = NDF (Read)
      }{
         An NDF holding an estimate of the Point Spread Function (PSF)
         of the input image.  This PSF is used to deconvolve the input
         only if parameter PSFTYPE has the value {\tt "NDF"}. The PSF can be
         centred anywhere within the image, the location of the centre
         is specified using parameters XCENTRE and YCENTRE.  The
         extent of the PSF actually used is controlled by parameter
         THRESH.
      }
      \sstsubsection{
         PSFTYPE = LITERAL (Read)
      }{
         PSFTYPE determines if the Point Spread Function used in the
         deconvolution is to be Gaussian (if PSFTYPE = {\tt "GAUSSIAN"}), or
         is to be defined by an image supplied by the user (if PSFTYPE
         = {\tt "NDF"}).  {\tt ["NDF"]}
      }
      \sstsubsection{
         RATE = \_REAL (Read)
      }{
         This is the value to use for the MEMSYS3 RATE parameter. It
         determines the rate at which the convergence is allowed to
         proceed. If RATE is high, each MEMSYS3 iteration is allowed to
         make a big change to the current reconstruction. This can
         cause numeric problems within MEMSYS3 resulting in MEM2D
         crashing with a {\tt "}floating overflow{\tt "} error. If this happens,
         try reducing RATE. Useful values will normally be of the order
         of unity, and must lie in the interval 0.0001 to 100.  {\tt [0.5]}
      }
      \sstsubsection{
         THRESH = \_REAL (Read)
      }{
         The fraction of the PSF peak amplitude at which the extents of
         the NDF PSF are determined.  It must be positive and less than
         0.5.  This parameter is only used when PSFTYPE = {\tt "NDF"}. An
         error will result if the input PSF is truncated above this
         threshold. [0.0625]
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         A title for the output NDF.  A null (!) value means using the
         title of the input NDF. {\tt ['KAPPA - Mem2d']}
      }
      \sstsubsection{
         UPDATE = \_LOGICAL (Read)
      }{
         If UPDATE is given a true value, then the output NDF will be
         created after the first iteration, and will then be updated
         after each subsequent iteration. This means that the current
         reconstruction can be examined without aborting the
         application.  Also, if parameter EXTEND has a true value, then
         if the job aborts for any reason, it can be restarted from the
         last completed iteration (see parameter IN). {\tt [TRUE]}
      }
      \sstsubsection{
         XCENTRE = \_INTEGER (Read)
      }{
         The $x$ pixel index of the centre of the PSF within the supplied
         PSF image.  This is only required if PSFTYPE is {\tt "NDF"}. XCENTRE
         is defaulted to the middle pixel (rounded down if there are an
         even number of pixels per line). {\tt []}
      }
      \sstsubsection{
         YCENTRE = \_INTEGER (Read)
      }{
         The $y$ pixel index (line number) of the centre of the PSF
         within the supplied PSF image. This is only required if
         PSFTYPE is {\tt "NDF"}. YCENTRE is defaulted to the middle line
         (rounded down if there are an even number of lines). {\tt []}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         MEM2D M51 M51\_HIRES PSFTYPE=GAUSSIAN PSFFWHM=3
      }{
         This example deconvolves the data array in the NDF called M51,
         putting the resulting image in the data array of the NDF called
         M51\_HIRES. A circular Gaussian Point-Spread Function is used
         with a Full Width at Half Maximum of 3 pixels.
      }
      \sstexamplesubsection{
         MEM2D M51 M51\_HIRES PSF=STAR XCENTRE=20 YCENTRE=20
      }{
         This example performs the same function as the previous
         example, but the PSF is defined by the data array of the NDF
         called STAR, instead of being defined to be Gaussian. This
         allows the PSF to be any arbitrary 2D function. STAR could be
         produced for example, by the KAPPA application called PSF.
         Parameters XCENTRE and YCENTRE give the pixel indices of
         the centre of the beam defined by the PSF in STAR.  The PSF is
         truncated to one sixteenth of its peak amplitude.
      }
      \sstexamplesubsection{
         MEM2D M51\_HIRES M51\_HIRES NITER=70 PSF=STAR
      }{
         If the previous example failed to converge within the default
         50 iterations, the deconvolution can be started again from
         its current state, rather than having to start again from
         scratch. Here NITER gives the upper limit on the total number
         of iterations which can be performed (including those performed
         in the previous run of MEM2D), {\bf not} just the number performed in
         this single run of MEM2D. This facility can also be used if a
         MEM2D run is interrupted for any reason, such as the host
         computer going down, or a batch-queue CPU limit being reached.
         To use this facility the parameters EXTEND and UPDATE should
         have the default values of TRUE.
      }
      \sstexamplesubsection{
         MEM2D M51\_HIRES MASK=NUCLEUS
      }{
         Once a deconvolved image has been produced, the significance
         of features seen in the deconvolution can be assessed. This
         example takes in the NDF M51\_HIRES produced by a previous run
         of MEM2D. If this is a completed deconvolution then the
         parameter ANALYSE will be defaulted to TRUE, and an analysis
         will be performed. This effectively results in the
         deconvolution being multiplied by the data array of the NDF
         called NUCLEUS, and the total data sum in the resulting image
         being displayed, together with the standard deviation on the
         total data sum. The image in M51\_HIRES is the most probable
         deconvolution, but there may be other deconvolutions only
         slightly less probable than M51\_HIRES. The standard deviation
         produced by an analysis takes account of the spread between
         such deconvolutions. If the total data sum is not significantly
         greater than the standard deviation, then the feature selected
         by the mask image (called NUCLEUS in this case) may well be
         spurious. The mask image itself may for instance consist of an
         area of uniform value $+$1 covering some feature of interest,
         and the bad value (or equivalently the value zero) everywhere
         else. The analysis would then give the integrated flux in the
         feature, assuming that the background is known to be zero. If
         the background is not zero, then the mask may contain a
         background region containing the value $-$1, of equal area to
         the region containing the value $+$1. The resulting integrated
         flux would then be the total flux in the source minus the flux
         in a background region of equal area.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         MEM2D requires a large quantity of memory---about three times
         more than the rest of KAPPA.  In order for the KAPPA monolith to
         load without users having to increase their paging quota, and
         because MEM2D is batch oriented (see Timing) it is only
         available as a separate application.
      }
   }
   \sstdiytopic{
      Timing
   }{
      MEM deconvolution is extremely CPU intensive. The total CPU time
      taken depends partly on the size of the image, and partly on the
      complexity of the structure within the image. As a typical
      example, a 100x100 image containing 20 Gaussians on a flat
      background took about 2.5 hours of CPU on a VAXstation 3100 Model
      38. Deconvolution jobs should therefore always be done in batch.
      To perform an analysis on a deconvolution takes about the same
      length of time as a single deconvolution iteration.
   }
   \sstimplementationstatus{
      The following NDF features are supported by this application:
      \sstitemlist{

         \sstitem
         The DATA, VARIANCE and QUALITY arrays.  AXIS, HISTORY, LABEL
         and UNITS are propagated to the deconvolved NDF.

         \sstitem
         Bad-pixel handling, including automatic quality masking, though
         only to remove them by the DEF value.

         \sstitem
         All non-complex numeric types, though the arithmetic is
         performed using single-precision floating point.
      }
   }
}
 
 
\sstroutine{
   MLINPLOT
}{
   Draws a multi-line plot of a 2-d NDF's data values against their
   axis co-ordinates
}{
   \sstdescription{
      This application takes one dimension of a 2-d NDF as a line index
      and draws a multi-line plot of the NDF's data values against
      selected line indices from its other dimension.  Thus one obvious
      application is the display of 2-d spectra.

      The plot is situated within the current picture on the current
      graphic device. By default, the first dimension of the NDF will
      be selected as the abscissa of the plot and the second dimension
      of the NDF will be selected as the line index.  However, a user
      can choose the opposite.  The vertical axis of the plot is the
      value of the data lines after offsetting.  The horizontal axis of
      the plot is the axis co-ordinates of the selected dimension of
      the NDF. If the axis co-ordinates are not defined in the NDF, the
      pixel co-ordinates of that dimension will be used in the plot.

      To separate the data lines from each other, four methods can be
      selected to offset the lines.  Each line is labelled with its
      line index, the indices of the dimension are selected as the line
      index. The offsets of the lines are display in a table.
   }
   \sstusage{
      MLINPLOT NDF [COMP] LNINDX YLIMIT [PLTITL] [ABSLAB] [ORDLAB]
        \newline\hspace*{1.5em} [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         ABSAXS = \_INTEGER (Read)
      }{
         If it is 1, the first significant dimension of the input NDF
         will be taken as the abscissa of the plot. If it is 2, the
         second significant dimension will be taken as the abscissa. 
         {\tt [1]}
      }
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         True if the current picture is to be cleared before the line
         plot is drawn. {\tt [TRUE]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be {\tt "Data"},
         {\tt "Quality"} or {\tt "Variance"}. {\tt ["Data"]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device. {\tt [}Current graphics device{\tt ]}
      }
      \sstsubsection{
         LNINDX = LITERAL (Read)
      }{
         A comma-separated number string specifies the line-index number
         to be displayed. It can take any of the following values:
         \begin{description}
            \item [ALL or $*$] - All lines

            \item [$xx$,$yy$,$zz$] - A list of line indices.

            \item [$xx$-$yy$] - Line indices between $xx$ and $yy$
                   inclusively. When $xx$ is omitted the range begins
                   from the lower bound of the line dimension; when
                   $yy$ is omitted the range ends
                   with the maximum value it can take, that is the
                   upper bound of the line dimension or the maximum
                   number of lines this routine can plot.
         \end{description}
            Any reasonable combination of above values separated by
            commas.
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         NDF structure containing the array to be plotted.
      }
      \sstsubsection{
         OFFSET = \_REAL (Read)
      }{
         When the offset method is specified as {\tt "FREE"}, this
         parameter is used to get the offset values for each locus of
         data values from the user.
      }
      \sstsubsection{
         PXSIZE = \_REAL (Read)
      }{
         The horizontal size of the display in metres. If a value less
         than the default is requested, the display will appear at
         the bottom left of the current device.  There is an upper
         limit given by the $x$ size of the current picture. {\tt [}Maximum
         that can fit in the current picture{\tt ]}
      }
      \sstsubsection{
         PYSIZE = \_REAL (Read)
      }{
         The vertical size of the display in metres. If a value less
         than the default is requested, then the display will appear at
         the bottom left of the current device.  There is an upper
         limit given by the $y$ size of the current picture. {\tt [}Maximum
         that can fit in the current picture{\tt ]}
      }
      \sstsubsection{
         SPACE = LITERAL (Read)
      }{
         The value of this parameter specifies the method by which
         the data line or locus in the plot are offset.  It can be
         given the values:
         \begin{description}
         \item [FREE] -
           The offset of each data locus is specified by the user.

         \item [CONSTANT] -
           The base lines of the curves are evenly spaced between upper
           and lower limits of the plotting box. The width of any line-
           to-line strip is constant, which could result in the loci
           becoming confused when the biases of some loci from their
           base lines are so large that these loci lie totally in the
           strips of other curves.

         \item [AVERAGE] -
           This method uses an average data value for each locus and
           produces offsets which ensure that these average data
           values are equally spaced over the plotting area. Any line-
           to-line striping is thus hidden and the amount of overlap of
           adjacent traces is minimised.
         \end{description}
         The input can be abbreviated to an unambiguous length and
         is case insensitive. {\tt ["AVERAGE"]}
      }
      \sstsubsection{
         YLIMIT( 2 ) = \_REAL (Read)
      }{
         Used to get the lower and upper vertical display limits. The
         suggest default lower limit is the min. value of the bottom
         line in the display. The default upper limit is such that
         no line will ever overlap.
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB = LITERAL (Read)
      }{
         Label for the plot abscissa. If axis information is present
         the suggested default is the NDF's axis label followed by
         the units, in parentheses. If an error occurs obtaining the
         label the default is {\tt "Pixel co-ordinates"}. {\tt []}
      }
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         {\tt "NCAR"} for the NCAR fancy characters and {\tt "GKS"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value. {\tt ["GKS"]}
      }
      \sstsubsection{
         LBSIZE = \_REAL (Read)
      }{
         The text width of the horizontal and vertical axis labels
         given as a fraction of the smaller dimension of the display
         window. The value less than or equal to zero means using NCAR
         default setting.  The title of the display will have the text
         width of 1.2 $*$ LBSIZE, and the numerical label of the axes
         will have the text width of 0.8 $*$ LBSIZE for mantissa, and
         0.55 $*$ LBSIZE for exponent. The range is 0.0--0.05.
         {\tt [0.025]}
      }
      \sstsubsection{
         LINLAB = \_LOGICAL (Read)
      }{
         If true, the lines in the plot will be interrupted and be
         labelled by their line indices, otherwise the lines will be
         solid. {\tt [TRUE]}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the number of major tick marks for
         the $x$ and $y$ axes. (Number used is between MAJTIC$+$2 and
         5$*$MAJTIC / 2 $+$ 4 ) {\tt [4.0, 4.0]}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark for
         the $x$ and $y$ axes. A negative value forces the graphics package
         to compute appropriate values. The number of minor tick marks
         per major tick is fixed ( 8 ) for a logarithmic axis.
         {\tt [-1.0, -1.0]}
      }
      \sstsubsection{
         ORDLAB = LITERAL (Read)
      }{
         Label for the vertical axis of the plot. The suggested default
         is the NDF's label followed by the units, if present, in
         parentheses. If an error occurs obtaining the label the
         default, is the component name followed by {\tt " values"}. {\tt []}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         True if the axis tick marks are to appear on the outside of
         the axes instead of inside. By default, the tick marks are
         drawn inside the plot region. {\tt [FALSE]}
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of the plot.  Up to about 40 characters can be
         accommodated, and NCAR fancy founts may be embedded.  The
         suggested default is the title of the NDF. If an error occurs
         obtaining the title, it is defaulted to {\tt "Lines plot"}. {\tt []}
      }
      \sstsubsection{
         TICLN = \_REAL (Read)
      }{
         The length of the major tick marks given in the fraction of the
         small dimension of the plot box.  Its value should be within
         range 0.0--0.05.  A value outside this range means using NCAR
         default. The minor tick marks will have the length 0.66$*$TICLN.
         {\tt [0.015]}
      }
      \sstsubsection{
         XLOG = \_LOGICAL (Read)
      }{
         True if the abscissa is to be logarithmic. It is unlikely that
         you would want to do this. {\tt [FALSE]}
      }
      \sstsubsection{
         YLOG = \_LOGICAL (Read)
      }{
         True if the vertical axis is to be logarithmic. This is useful
         when the data have a wide dynamic range. {\tt [FALSE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         MLINPLOT RCW3\_B1 $\backslash$
      }{
         Plot the first five lines of the 2-d NDF file, RCW3\_B1,
         against its first significant dimension on the current
         graphics device.  The data co-ordinate will be in pixels if
         RCW3\_B1 does not have an axis component. The lines are
         offset such that the averages of the lines are evenly
         separated in the range of vertical axis.
      }
      \sstexamplesubsection{
         MLINPLOT RCW3\_B1 LNINDX="1,3,5,7-10" $\backslash$
      }{
         Plot the lines 1, 3, 5, 7, 8, 9 and 10 of the 2-d NDF file,
         RCW3\_B1, against its first significant dimension on the
         current graphics device.
      }
      \sstexamplesubsection{
         MLINPLOT CRDD:RCW3\_B1 LNINDX=$*$ $\backslash$
      }{
         Plot all lines of the 2-d NDF file, RCW3\_B1, against its
         first significant dimension on the current graphics device.
      }
      \sstexamplesubsection{
         MLINPLOT CRDD:RCW3\_B1 ABSAXS=2 LNINDX="20-25,30,31" $\backslash$
      }{
         Plot lines 20, 21, 22, 23, 24, 25, 30 and 31 of the 2-d NDF
         file, RCW3\_B1, against its second significant dimension on
         the current graphics device.
      }
      \sstexamplesubsection{
         MLINPLOT CRDD:RCW3\_B1 PLTITL="CRDD RCW3\_B1" $\backslash$
      }{
         Plot the first five lines of the 2-d NDF file, RCW3\_B1,
         against its first significant dimension on the current
         graphics device.  The plot has a title of {\tt "CRDD RCW3\_B1"}.
      }
      \sstexamplesubsection{
         MLINPLOT CRDD:RCW3\_B1(100.0:500.0,) YLIMIT=[0.0,1.0E-3] $\backslash$
      }{
         Plot the first five lines of the 2-d NDF file, RCW3\_B1,
         against its first significant dimension within co-ordinates
         100.0 to 500.0. The vertical display range is from 0.0 to
         1.0E-3.
      }
      \sstexamplesubsection{
         MLINPLOT CRDD:RCW3\_B1 SPACE=CONSTANT DEVICE=IKON $\backslash$
      }{
         Plot the first five lines of the 2-d NDF file, RCW3\_B1,
         against its first significant dimension on the Ikon device.
         The base lines of them are evenly distributed in the range of
         vertical axis.
      }
      \sstexamplesubsection{
         MLINPLOT CRDD:RCW3\_B1 SPACE=FREE OFFSET=[0.0,2.0E-4,4.0E-4,6.0E-4,0.1] $\backslash$
      }{
         Plot the first five lines of the 2-d NDF file, RCW3\_B1,
         against its first significant dimension. The base lines are
         set by user as 0.0 for the first line, 2.0E-12 for the second,
         4.0E-2 for the third, 6.0E-12 for the fourth, and 0.1 for
         the fifth.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application stores a number of pictures in the graphics
         database in the following order: a FRAME of the specified size
         containing the title, annotated axes, and line plot; and a DATA
         picture, which has world co-ordinates for linear axes measured in
         pixels along the $x$ axis and data values along $y$, and their
         logarithms if a logarithmic axis is selected.  The DATA picture
         also has data co-ordinates stored; for a linear axis this
         requires that the NDF's axis units are not pixel co-ordinates;
         for a logarithmic axis the actual data co-ordinate or value is
         recorded.  If there is no NDF axis information and a logarithmic
         abscissa, the DATA co-ordinates are pixel co-ordinates.  The NDF
         associated with the plot is stored by reference with the DATA
         picture.  On exit the current database picture for the chosen
         device reverts to the input picture.

         \sstitem
         In a logarithmic plot only positive data along each
         logarithmic axis can be displayed, therefore such data are
         excluded.  A logarithmic axis will always increase from left to
         right, and from bottom to top.

         \sstitem
         Bad pixels appear as gaps in the plot, and they do not affect
         the limits of the ordinate.  The same applies to zero or negative
         data values if the plot is to have a logarithmic ordinate.
      }
   }
   \newpage
   \sstimplementationstatus{
      The following NDF features are supported by this application:
      \sstitemlist{

         \sstitem
         The DATA, VARIANCE and QUALITY arrays (the TITLE, LABEL, UNITS
         and AXIS components are also used).

         \sstitem
         Bad-pixel handling, including automatic quality masking.

         \sstitem
         Only single-precision floating-point data can be processed
         directly.  Other non-complex data types will undergo a type
         conversion before the line plot is drawn.
      }
   }
}

\manroutine {{\manheadstyle{MOSAIC}}}{ Merges several non-congruent
  2-d data arrays into one output data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  Up to 20 non-congruent 2-d data arrays may be input, along with
  their relative offsets from the first data array, and these are
  then made into a mosaic into one (usually larger) output 2-d data
  array. Where the frames overlap, either the mean value or just the
  sum is inserted into the output data array. Normally averaging is
  performed. All data arrays are stored in {\mantt{IMAGE}} structures.

  The magic-value method is used for processing bad data.  Bad
  pixels are excluded from the averaging in overlap areas. Output
  pixels that have been mapped or correspond to one or more input
  arrays, yet have no good pixels contributing, are set to bad.
  Pixels in the output data array not mapped by any of the input
  arrays are set to zero.

\manroutineitem {Invocation }{}
  MOSAIC

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMBER}}  }{{\mantt{\_INTEGER}}}
  Number of data arrays to be merged.
\manparameterentry {{\mantt{READ}} }{{\mantt{AVERAGE}}  }{{\mantt{\_LOGICAL}}}
  If true overlap regions are averaged, alternatively, they are
  summed.  \mbox{{\mantt [TRUE]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}{$n$}  }{{\mantt{IMAGE}}}
  {$n^{\rm th}$} {\mantt{IMAGE}} structure containing a data array to be a
  constituent of a mosaic.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the merged data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure. \mbox{{\mantt ['KAPPA - Mosaic']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{XOFFSET}} }{{\mantt{\_INTEGER}}}
  {$x$} offset of {$n^{\rm th}$} data array from the first.
\manparameterentry {{\mantt{READ}} }{{\mantt{YOFFSET}} }{{\mantt{\_INTEGER}}}
  {$y$} offset of {$n^{\rm th}$} data array from the first.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{MSTATS}}}{ Does cumulative statistics on
  a 2-d sub-array over a sequence of data arrays.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine is used for the statistics of multiple 2-d data
  arrays. The data arrays must have the same dimensions and reside
  in {\mantt{IMAGE}} structures. The user is asked to specify a number of
  data arrays (up to a fixed limit) either by naming each file
  or defining a sequence of {\mantt{IMAGE}} structures (frames). If the
  latter option is chosen the files must adopt the following naming scheme:
  {\mantt{groupnamennnn}}, where {\mantt{nnnn}} is a four-digit number,
  and {\mantt{groupname}} is the collective name for the set of arrays,
  {\it e.g.}\ {\mantt{ORION0001}}. Missing
  container files, data arrays, or data arrays of the wrong
  dimensions are skipped. The maximum number of data files is 1000.

  Then either Single pixel or Box mode is chosen. In the former
  case the pixel of interest is specified, and in the latter, the
  sub-array of interest. In the Single pixel mode, the value for the
  same pixel is pulled out of each array in sequence, and this
  sequence of values is then statistically analysed over the
  sequence of input frames. The resultant values (mean, median
  and standard deviation) are reported directly to the user.

  In Box mode, a choice of statistics is selected.  The alternatives
  are mean and standard deviation (the default), or median. The
  statistic(s) are formed over the sequence of arrays at each pixel
  position in the box. The output is in the form of one or two 2-d
  data arrays, each being the size of the defined sub-array and
  contains a chosen statistic (mean, standard deviation or median)
  in each pixel. Each output data array is stored in an {\mantt{IMAGE}}
  structure.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  MSTATS

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INMODE}}  }{{\mantt{\_CHAR}}}
  Mode of data array input, the alternatives being {\mantt{Sequential}}
  or {\mantt{Random}}.
\manparameterentry {{\mantt{READ}} }{{\mantt{PIXMODE}}  }{{\mantt{\_CHAR}}}
  Mode of calculation, the alternatives being a {\mantt{Single}} pixel or
  a {\mantt{Box}} of pixels.
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  One of the sequence of input {\mantt{IMAGE}} structures.
\manparameterentry {{\mantt{READ}} }{{\mantt{FIRSTFILE}}  }{{\mantt{\_CHAR}}}
  Name of first container filename in the sequence.
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMSEQ}}  }{{\mantt{\_INTEGER}}}
  Number of sequential frames to be processed.
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMRAN}}  }{{\mantt{\_INTEGER}}}
  Number of random frames to be processed.
\manparameterentry {{\mantt{READ}} }{{\mantt{XPIX}}  }{{\mantt{\_INTEGER}}}
  {$x$} pixel index of the pixel to be used in Single mode.
\manparameterentry {{\mantt{READ}} }{{\mantt{YPIX}}  }{{\mantt{\_INTEGER}}}
  {$y$} pixel index of the pixel to be used in Single mode.
\manparameterentry {{\mantt{READ}} }{{\mantt{ORDRST}}  }{{\mantt{\_LOGICAL}}}
  If true ordered statistics will be computed in Box mode,
  currently only the median, otherwise the mean and standard
  deviation are derived. \mbox{{\mantt [FALSE]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{XSTART}}  }{{\mantt{\_INTEGER}}}
  {$x$} start pixel index of the sub-arrays to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{YSTART}}  }{{\mantt{\_INTEGER}}}
  {$y$} start pixel index of the sub-arrays to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{XSIZE}}  }{{\mantt{\_INTEGER}}}
  {$x$} size of the sub-array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{YSIZE}}  }{{\mantt{\_INTEGER}}}
  {$y$} size of the sub-array to be analysed.
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MEDIAN}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing array of medians for Box
  option.
\manparameterentry {{\mantt{READ}} }{{\mantt{OMTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for {\mantt{IMAGE}} structure containing the median array.
  \mbox{{\mantt ['KAPPA - Mstats - Medians']}}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MEAN}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing array of means for Box
  option.
\manparameterentry {{\mantt{READ}} }{{\mantt{MTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for {\mantt{IMAGE}} structure containing the mean array.
  \mbox{{\mantt ['KAPPA - Mstats - Means']}}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{STDDEV}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing standard deviations for Box
  option.
\manparameterentry {{\mantt{READ}} }{{\mantt{STITLE}}  }{{\mantt{\_CHAR}}}
  Title string for {\mantt{IMAGE}} structure containing the
  standard-deviation array. \mbox{{\mantt ['KAPPA - Mstats - Stddevs']}}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\sstroutine{
   MULT
}{
   Multiplies two NDF data structures
}{
   \sstdescription{
      The routine multiplies two NDF data structures pixel-by-pixel to
      produce a new NDF.
   }
   \sstusage{
      MULT IN1 IN2 OUT
   }
   \sstparameters{
      \sstsubsection{
         IN1 = NDF (Read)
      }{
         First NDF to be multiplied.
      }
      \sstsubsection{
         IN2 = NDF (Read)
      }{
         Second NDF to be multiplied.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Output NDF to contain the product of the two input NDFs.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Value for the title of the output NDF. A null value will cause
         the title of the NDF supplied for parameter IN1 to be used
         instead. {\tt ['KAPPA - Mult']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         MULT A B C
      }{
         This multiplies the NDF called A by the NDF called B, to make
         the NDF called C.  C has title {\tt "KAPPA - Mult"}.
      }
      \sstexamplesubsection{
         MULT OUT=C IN1=A IN2=B TITLE="Normalised spectrum"
      }{
         This multiplies the NDF called A by the NDF called B, to make
         the NDF called C.  C has the title {\tt "Normalised spectrum"}.
      }
   }
   \newpage
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the two input NDFs have different pixel-index bounds, then
         they will be trimmed to match before being multiplied. An error
         will result if they have no pixels in common.

         \sstitem
         Calculations are performed using the most appropriate of the
         data types integer, real or double precision. If the input NDF
         structures contain values with other data types, then conversion
         will be performed as necessary.

         \sstitem
         This routine correctly processes the AXIS, DATA, QUALITY,
         LABEL, TITLE and VARIANCE components of an NDF data structure and
         propagates all extensions. Bad pixels and all non-complex numeric
         data types can be handled.

         \sstitem
         The HISTORY component is simply propagated without change, if
         present.

         \sstitem
         Units processing is not supported at present and therefore the
         the UNITS component is not propagated.
      }
   }
}

\sstroutine{
   NATIVE
}{
   Converts an HDS object to native machine data representation
}{
   \sstdescription{
      This application converts an HDS object (or structure) so that
      all primitive data values within it are represented using the
      appropriate native data representation for the machine in use
      (this includes the appropriate number format and byte ordering).
      This may typically be required after moving HDS files from
      another machine which uses a different number format and/or byte
      order, and will minimise the subsequent access time on the new
      machine.  Conversion is performed by modifying the data {\it in situ}.
      No separate output file is produced.
   }
   \sstusage{
      NATIVE OBJECT
   }
   \sstparameters{
      \sstsubsection{
         OBJECT = UNIVERSAL (Read and Write)
      }{
         The HDS structure to be converted; either an entire container
         file or a particular object or structure within the file may
         be specified. If a structure is given, all components (and
         sub-components, {\it etc.}) within it will also be converted.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         NATIVE MYFILE
      }{
         Converts all the primitive data in the HDS container file
         MYFILE to be held using the appropriate native machine
         representation for faster subsequent access.
      }
      \sstexamplesubsection{
         NATIVE YOURFILE.DATA\_ARRAY
      }{
         Converts just the DATA\_ARRAY component (and its contents, if a
         structure) in the container file YOURFILE to the appropriate
         native machine data representation. Other file contents remain
         unchanged.
      }
   }
}

\sstroutine{
   NDFCOPY
}{
   Copies an NDF (or NDF section) to a new location
}{
   \sstdescription{
      This application copies an NDF to a new location. By supplying an
      NDF section as input it may be used to extract a subset, or to
      change the size or dimensionality of an NDF. A second NDF may
      also be supplied to act as a shape template, and hence to define
      the region of the first NDF which is to be copied.

      Any unused space will be eliminated by the copying operation
      performed by this routine, so it may be used as a way of
      compressing NDF structures from which components have been
      deleted.  This ability also makes NDFCOPY a useful alternative to
      SETBOUND in cases where an NDF's size is to be reduced.
   }
   \sstusage{
      NDFCOPY IN OUT
   }
   \sstparameters{
      \sstsubsection{
         IN = NDF (Read)
      }{
         The input NDF (or section) which is to be copied.
      }
      \sstsubsection{
         LIKE = NDF (Read)
      }{
         This parameter may be used to supply an NDF to be used as a
         shape template during the copying operation. If such a
         template is supplied, then its shape will be used to select a
         matching section from the input NDF before copying takes
         place.  By default, no template will be used and the shape of
         the output NDF will therefore match that of the input NDF (or
         NDF section). {\tt [!]}
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         The output NDF data structure.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         A title for the output NDF. A null value (the default) will
         cause the title of the NDF supplied for parameter IN to be
         used instead. {\tt [!]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         NDFCOPY INFILE OUTFILE
      }{
         Copies the contents of the NDF structure INFILE to the new
         structure OUTFILE. Any unused space will be eliminated during
         the copying operation.
      }
      \sstexamplesubsection{
         NDFCOPY IN=DATA1(3:40,-3:17) OUT=DATA2 TITLE="Extracted section"
      }{
         Copies the section (3:40,-3:17) of the NDF called DATA1 to a
         new NDF called DATA2. The output NDF is assigned the new title
         {\tt "Extracted section"}, which replaces the title derived from the
         input NDF.
      }
      \sstexamplesubsection{
         NDFCOPY GALAXY NEWGALAXY LIKE=OLDGALAXY
      }{
         Copies a section of the NDF called GALAXY to form a new NDF
         called NEWGALAXY. The section which is copied will correspond
         in shape with the template OLDGALAXY. Thus, after the copying
         operation, both NEWGALAXY and OLDGALAXY will have the same
         pixel-index bounds.
      }
      \sstexamplesubsection{
         NDFCOPY A(20$\sim$11,20$\sim$11) B LIKE=A
      }{
         Copies from the NDF section consisting of an 11$\times$11-pixel
         region of A centred on pixel (20,20), into a new NDF called B.
         The shape of the region copied is made to match the original
         shape of A.  The effect is to extract the selected square
         region of pixels into a new NDF of the same shape as the
         original, setting the surrounding region to the bad-pixel
         value.
      }
   }
   \sstimplementationstatus{
      If present, an NDF's TITLE, LABEL, UNITS, DATA, VARIANCE,
      QUALITY, AXIS and HISTORY components are copied by this routine,
      together with all extensions. The output NDF's title may be
      modified, if required, by specifying a new value via the TITLE
      parameter.
   }
}

\sstroutine{
   NDFTRACE
}{
   Displays the attributes of an NDF data structure
}{
   \sstdescription{
      This routine displays the attributes of an NDF data structure
      including:
      \sstitemlist{

         \sstitem
         Its name.

         \sstitem
         The values of its character components (title, label and
         units).

         \sstitem
         Its shape (pixel bounds, dimension sizes, number of dimensions
         and total number of pixels).

         \sstitem
         Axis coordinate information (axis labels, units and extents).

         \sstitem
         Optionally, axis array attributes (type and storage form) and
         the values of the axis normalisation flags.

         \sstitem
         Attributes of the main data array and any other array
         components present (including the type and storage form and an
         indication of whether {\tt "}bad{\tt "} pixels may be present).

         \sstitem
         A list of any NDF extensions present, together with their data
         types.
      }
   }
   \sstusage{
      NDFTRACE NDF
   }
   \sstparameters{
      \sstsubsection{
         FULLAXIS = \_LOGICAL (Read)
      }{
         If the NDF being examined has an axis coordinate system
         defined, then by default only the label, units and extent of
         each axis will be displayed. However, if a {\tt TRUE} value is given
         for this parameter, full details of the attributes of all the
         axis arrays will also be given. {\tt [FALSE]}
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         The NDF data structure whose attributes are to be displayed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         NDFTRACE MYDATA
      }{
         Displays information about the attributes of the NDF structure
         called MYDATA.
      }
      \sstexamplesubsection{
         NDFTRACE NDF=R106 FULLAXIS
      }{
         Displays information about the NDF structure R106, including
         full details of any axis arrays present.
      }
   }
}

\manroutine {{\manheadstyle{NOMAGIC}}}{ Replaces all occurrences of
  magic-value pixels in a data array by a user-defined value.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  All magic-value pixels in the data array, contained in the input
  {\mantt{IMAGE}} structure, are replaced by a user-defined value within a
  new data array, which is stored in the output {\mantt{IMAGE}} structure.

\manroutineitem {Invocation }{}
  NOMAGIC

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array to have its
  magic-value pixels removed.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the data array that is a
  copy of the input data array, but without magic-value
  pixels.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure.
 \mbox{{\mantt ['KAPPA - Nomagic']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{REPVAL}}  }{{\mantt{\_REAL}}}
  The value to substitute for the magic values.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Malcolm J. Currie ~STARLINK ( {\mantt {RAL}}::{\mantt {CUR}} )
\end{manroutinedescription}

\sstroutine{
   NORMALIZE
}{
   Normalises one NDF to a similar NDF by calculating a scale factor
   and zero difference
}{
   \sstdescription{
      This application compares the data values in one NDF against the
      corresponding values in the other NDF. A least-squares
      straight-line is then fitted to the relationship between the two
      sets of data values in order to determine the relative scale
      factor and any zero-level offset between the NDFs.  To reduce
      computation time, the data points are binned according to the
      data value in the first NDF. The mean data value within each bin
      is used to find the fit and weights are applied according to the
      number of pixels which contribute to each bin.

      To guard against erroneous data values, which can corrupt the fit
      obtained, the application then performs a number of iterations. It
      calculates a noise estimate for each bin according to the rms
      deviation of data values in the bin from the straight-line fit
      obtained previously. It then re-bins the data, omitting values
      which lie more than a specified number of standard deviations
      from the expected value in each bin.  The straight-line fit is
      then re-calculated.  The number of standard deviations and the
      number of iterations used can be specified by the user.

      A plot is produced after the final iteration showing the bin
      centres, with error bars representing the spread of values in each
      bin. This plot is produced within the current AGI picture and is
      of a size specified by the user.

      Optionally, an output NDF can be created containing a normalised
      version of the data array from the first input NDF.
   }
   \sstusage{
      NORMALIZE IN1 IN2 OUT
   }
   \sstparameters{
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         Determines if the graphics workstation is to be cleared before
         producing the plot. {\tt [TRUE]}
      }
      \sstsubsection{
         DATARANGE( 2 ) = \_REAL (Read)
      }{
         This parameter may be used to override the plot auto-scaling
         feature.  If given, two real numbers should be supplied
         specifying the lower and upper data values in IN2, between
         which data will be used.  If not given, the default is to use
         the auto-scaled values, calculated according to the value of
         PCRANGE. {\tt [,]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics workstation on which to produce the plot.  If it
         is null, {\tt !}, there will be no plot made.
         {\tt [}Current graphics device{\tt ]}
      }
      \sstsubsection{
         IN1 = NDF (Read)
      }{
         The NDF to be normalised.
      }
      \sstsubsection{
         IN2 = NDF (Read)
      }{
         The NDF to which IN1 will be normalised.
      }
      \sstsubsection{
         MINPIX = \_INTEGER (Read)
      }{
         The minimum number of good pixels required in a bin before it
         contributes to the fitted line.  It must be in the range 1 to
         the number of pixels per bin. {\tt [2]}
      }
      \sstsubsection{
         NBIN = \_INTEGER (Read)
      }{
         The number of bins to use when binning the scatter plot prior
         to fitting a straight line, in the range 2 to 10000. {\tt [50]}
      }
      \sstsubsection{
         NITER = \_INTEGER (Read)
      }{
         The number of iterations performed to reject bad data values
         in the range 0 to 100. {\tt [2]}
      }
      \sstsubsection{
         NSIGMA = \_REAL (Read)
      }{
         The number of standard deviations at which bad data is
         rejected.  It must lie in the range 0.1 to 1.0E6. {\tt [3.0]}
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         An optional output NDF to hold a version of IN1 which is
         normalised to IN2.  A null ({\tt !}) value indicates that an output
         NDF is not required.
      }
      \sstsubsection{
         PCRANGE( 2 ) = \_REAL (Read)
      }{
         This parameter takes two real values in the range 0 to 100 and
         is used to modify the action of the auto-scaling algorithm
         which scales the plots. The two values correspond to the
         percentage points in the histogram of IN2 at which the lower
         and upper cuts on data value are placed. With the default
         value, the plots will omit those pixels which lie in the lower
         and upper 2 percent intensity range of IN2. {\tt [2,98]}
      }
      \sstsubsection{
         PXSIZE = \_REAL (Read)
      }{
         The horizontal size of the plot in metres. If a value less
         than the default is requested, then the plot will appear at
         the bottom left of the current picture. {\tt [}The size of the
         current picture{\tt ]}
      }
      \sstsubsection{
         PYSIZE = \_REAL (Read)
      }{
         The vertical size of the plot in metres. If a value less than
         the default is requested, then the plot will appear at the
         bottom left of the current picture. {\tt [}The size of the current
         picture{\tt ]}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         A title for the output NDF. {\tt ['KAPPA - Normalize']}
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB = LITERAL (Read)
      }{
         A title for the plot's $x$ axis. Only the first 50 characters
         are used. The default is {\tt "Data value in $\wedge$NDF"} where $\wedge$NDF is
         replaced by the name of the NDF associated with IN2. {\tt []}
      }
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         {\tt "NCAR"} for the NCAR fancy characters and {\tt "GKS"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value. {\tt ["GKS"]}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the numbers of major tick marks
         for the $x$ and $y$ axes.  (Number used is between MAJTIC$+$2 and
         5$*$MAJTIC/2$+$4.) {\tt [3.,3.]}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark
         for the $x$ and $y$ axes.  A negative value forces the graphics
         package to compute appropriate values. {\tt [-1.,-1.]}
      }
      \sstsubsection{
         ORDLAB = LITERAL (Read)
      }{
         A title for the plots $y$ axis. Only the first 50 characters
         are used. The default is {\tt "Data value in $\wedge$NDF"} where
         $\wedge$NDF is replaced by the name of the NDF associated with IN1.
         {\tt []}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         True if the axis tick marks are to appear on the outside of
         the axes instead of inside. {\tt [FALSE]}
      }
      \sstsubsection{
         PTITLE = LITERAL (Read)
      }{
         A title for the top of the plot. Only the first 50 characters
         are used. {\tt ["Normalization plot"]}
      }
   }
   \sstresparameters{
      \sstsubsection{
         OFFSET = \_REAL (Write)
      }{
         An output parameter giving the offset in the linear
         normalization expression: IN1 = SLOPE $*$ IN2 $+$ OFFSET.
      }
      \sstsubsection{
         SLOPE = \_REAL (Write)
      }{
         An output parameter giving the slope of the linear
         normalization expression: IN1 = SLOPE $*$ IN2 $+$ OFFSET.
      }
   }
   \newpage
   \sstexamples{
      \sstexamplesubsection{
         NORMALIZE CL123A CL123B CL123C
      }{
         This normalises NDF CL123A to the NDF CL123B.  A plot of the
         fit is made on the current graphics device, and the resulting
         normalisation scale and offset are written to the file
         ADAM\_USER:NORMALIZE.SDF.  The NDF CL123C is the normalised
         version of the input CL123A.
      }
      \sstexamplesubsection{
         NORMALIZE CL123A CL123B CL123C TITLE="Gain calibration"
      }{
         This normalises NDF CL123A to the NDF CL123B.  A plot of the
         fit is made on the current graphics device with the title
         {\tt "Gain calibration"}.  The resulting normalisation scale
         and offset are written to the file ADAM\_USER:NORMALIZE.SDF. 
         The NDF CL123C is the normalised version of the input CL123A. 
      }
      \sstexamplesubsection{
         NORMALIZE CL123A CL123B CL123B OFFSET=(SHIFT) SLOPE=(SCALE)
      }{
         This normalises NDF CL123A to the NDF CL123B.  A plot of the
         fit is made on the current graphics device.  The resulting
         normalisation scale and offset are written to the ICL
         variables SCALE and SHIFT respectively, where they could be
         passed to another application via an ICL procedure.  The NDF
         CL123C is the normalised version of the input CL123A.
      }
      \sstexamplesubsection{
         NORMALIZE IN2=OLD IN1=NEW OUT=! DEVICE=IKON
      }{
         This normalises NDF NEW to the NDF OLD.  A plot of the fit is
         made on the Ikon.  The file ADAM\_USER:NORMALIZE.SDF will
         contain the resulting normalisation scale and offset.  No
         output NDF is produced.
      }
      \sstexamplesubsection{
         NORMALIZE IN1=NEW IN2=OLD OUT=YOUNG NITER=5 PCRANGE=[3,98.5]
      }{
         This normalises NDF NEW to the NDF OLD.  It has five iterations
         to reject outliers from the linear regression, and forms the
         regression using pixels in OLD whose data values lie between
         the 3 and 98.5 percentiles, comparing with the corresponding
         pixels in NEW.  A plot of the fit is made on the current
         graphics device.  The resulting normalisation scale and offset
         are written to the file ADAM\_USER:NORMALIZE.SDF. The NDF
         YOUNG is the normalised version of the input NEW.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Provided the application does not fail two pictures are stored
         in the graphics database: a FRAME of the specified size containing
         the title, annotated axes and the plot; and a DATA picture with
         each world co-ordinate being the pixel value of each NDF.  Both
         pictures have comment {\tt "}KAPPA - Normalize{\tt "}.  The associated NDFs
         are not stored in the database.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Only \_REAL data can be processed directly.  Other data types
         will undergo a type conversion before processing occurs. \_DOUBLE
         data cannot be processed due to a loss of precision.

         \sstitem
         The routine correctly processes the AXIS, DATA, QUALITY, LABEL,
         TITLE, UNITS and VARIANCE components of an NDF, and propagates all
         extensions to the output NDF.  All propagated components come from
         the NDF to be normalised.

         \sstitem
         The HISTORY component, if present, is simply propagated
         without change.

         \sstitem
         At the moment, variance values are not used in the fitting
         algorithm but are modified in the output NDF to take account of
         the scaling introduced by the normalisation. (A later version may
         take account of variances in the fitting algorithm.)

         \sstitem
         Processing of bad pixels is supported.

         \sstitem
         The pixel bounds of the two input NDFs are matched by trimming
         before calculating the normalisation constants, and are mapped as
         vectors to allow processing of NDFs of any dimensionality. An
         output NDF may optionally be produced which is based on the
         first input NDF (IN1) by applying the calculated normalisation
         constants to IN1.
      }
   }
}
 
\manroutine {{\manheadstyle{NUMB}}}{ Counts the number of elements of
  a data array with values greater than a specified value.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine counts the number of points of a data array in the
  input {\mantt{IMAGE}} structure that have a value greater than the
  specified value.

  The magic-value method is used for processing bad data, which are
  excluded from the summation.

\manroutineitem {Invocation }{}
  NUMB

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array to be tested.
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{VALUE}}  }{{\mantt{\_REAL}}}
  Value against which the values of the data-array elements will
  be tested.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Malcolm Currie ~STARLINK ( {\mantt {RAL}}::{\mantt {CUR}} )
\end{manroutinedescription}

\manroutine {{\manheadstyle{NUMBA}}}{ Counts the number of elements of
  a data array with absolute values greater than a specified value.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine counts the number of points of a data array in the
  input {\mantt{IMAGE}} structure that have an absolute value greater
  than the specified value.

  The magic-value method is used for processing bad data, which are
  excluded from the summation.

\manroutineitem {Invocation }{}
  NUMBA

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array to be tested.
\manparameterentry {{\mantt{READ}} }{{\mantt{VALUE}}  }{{\mantt{\_REAL}}}
  Value against which the absolute values of the data-array
  elements will be tested.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{OUTSET}}}{ Sets pixels outside a specified
  circle in a 2-d data array to a specified value.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  A circle of a given centre and diameter within the 2-d data array
  of the input {\mantt{IMAGE}} structure is specified.  The data array
  written to the output {\mantt{IMAGE}} structure, is a copy of the input
  data array except pixels outside the circle are set to a specified value.

\manroutineitem {Invocation }{}
  OUTSET

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the array to be modified.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the modified array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure.
  \mbox{{\mantt ['KAPPA - Outset']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{XCENTRE}}  }{{\mantt{\_REAL}}}
  {$x$} co-ordinate of the centre of the circle to be used.
\manparameterentry {{\mantt{READ}} }{{\mantt{YCENTRE}}  }{{\mantt{\_REAL}}}
  {$y$} co-ordinate of the centre of the circle to be used.
\manparameterentry {{\mantt{READ}} }{{\mantt{DIAMETER}}  }{{\mantt{\_REAL}}}
  Diameter of the circle to be used.
\manparameterentry {{\mantt{READ}} }{{\mantt{NEWVAL}}  }{{\mantt{\_REAL}}}
  Value to replace old values in the pixels outside the circle.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}
 
 
\sstroutine{
   OVSET
}{
   Selects a current image-display overlay
}{
   \sstdescription{
      This application selects a current image-display overlay. This
      device will be used for all applications requiring an
      image-display overlay until changed explicitly.
   }
   \sstusage{
      OVSET DEVICE
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The image-display overlay to become the current image-display
         overlay device.  The device must be in GNS categories
         IMAGE\_OVERLAY or WINDOW\_OVERLAY.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         OVSET IKONOV
      }{
         Makes the IKONOV device the current image-display overlay.
      }
   }
}
 
\sstroutine{
   PALDEF
}{
   Loads the default palette to a colour table
}{
   \sstdescription{
      This application loads the standard palette of colours to fill
      the portion of the current image display's colour table which is
      reserved for the palette.  The palette comprises 16 colours and
      is intended to provide coloured annotations, borders, axes,
      graphs {\it etc.}\ that are unaffected by changes to the lookup table
      used for images.

      The standard palette is as follows
        0: Black     1: White     2: Red       3: Green     4: Blue
        5: Yellow    6: Magenta   7: Cyan      8--15: Black
   }
   \sstusage{
      PALDEF [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display to be used.  The device must be in
         one of the following GNS categories: IMAGE\_DISPLAY,
         IMAGE\_OVERLAY, or WINDOW, and have at least 24 colour indices.
         The device must also not reset when the device is opened
         (since the existing colour table would be lost).  {\tt [}Current
         image-display device{\tt ]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PALDEF
      }{
         This loads the standard palette into the reserved portion of
         the colour table of the current image display.
      }
      \sstexamplesubsection{
         PALDEF XWINDOWS
      }{
         This loads the standard palette into the reserved portion of
         the colour table of the XWINDOWS device.
      }
   }
}

 
\sstroutine{
   PALENTRY
}{
   Enters a colour into an image display's palette
}{
   \sstdescription{
      This application obtains a colour and enters it into the palette
      portion of the current image display's colour table.  The palette
      comprises 16 colours and is intended to provide coloured
      annotations, borders, axes, graphs {\it etc.}\ that are unaffected by
      changes to the lookup table used for images.

      A colour is specified either by the giving the red, green, blue
      intensities; or named colours.
   }
   \sstusage{
      PALENTRY PALNUM COLOUR [DEVICE]
   }
   \newpage
   \sstparameters{
      \sstsubsection{
         COLOUR() = LITERAL (Read)
      }{
         A colour to be added to the palette at the entry given by
         parameter PALNUM.  It is either:

           o  A named colour from the standard colour set, which may
           be abbreviated.  If the abbreviated name is ambiguous the
           first match (in alphabetical order) is selected.  The case
           of the name is ignored.  Some examples are {\tt "Pink"},
           {\tt "Yellow"}, {\tt "Aquamarine}", and {\tt "Orchid"}.

           o  Normalised red, green, and blue intensities separated by
           commas or spaces.  Each value must lie in the range 0.0--1.0.
           For example, {\tt "1.0,1.0,0.5"} would give a pale yellow.
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display to be used.  The device must be in
         one of the following GNS categories: IMAGE\_DISPLAY,
         IMAGE\_OVERLAY, or WINDOW, and have at least 24 colour indices.
         The device must also not reset when the device is opened
         (since the existing colour table would be lost). {\tt [}Current
         image-display device{\tt ]}
      }
      \sstsubsection{
         PALNUM = \_INTEGER (Read)
      }{
         The number of the palette entry whose colour is to be
         modified.  PALNUM must lie in the range 0 to 15.  The
         suggested default is 8.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PALENTRY 5 GOLD
      }{
         This makes palette entry number 5 have the colour gold in the
         reserved portion of the colour table of the current image
         display.
      }
      \sstexamplesubsection{
         PALENTRY 12 [1.0,1.0,0.3] Ikon
      }{
         This makes the Ikon's palette entry number 12 have a
         pale-yellow colour.
      }
   }
}

 
\sstroutine{
   PALREAD
}{
   Fills the palette of a colour table from an NDF
}{
   \sstdescription{
      This application reads a palette of colours from an NDF, stored as
      red, green and blue intensities, to fill the portion of
      the current image display's colour table which is reserved for
      the palette.  The palette comprises 16 colours and is intended
      to provide coloured annotations, borders, axes, graphs {\it etc.}\ that
      are unaffected by changes to the lookup table used for images.
   }
   \sstusage{
      PALREAD PALETTE [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display to be used.  The device must be in
         one of the following GNS categories: IMAGE\_DISPLAY,
         IMAGE\_OVERLAY, or WINDOW, and have at least 24 colour indices.
         The device must also not reset when the device is opened
         (since the existing colour table would be lost).  {\tt [}Current
         image-display device{\tt ]}
      }
      \sstsubsection{
         PALETTE = NDF (Read)
      }{
         The name of the NDF containing the palette of reserved colours
         as its data array.  The palette must be 2-dimensional, the
         first dimension being 3, and the second 16.  If the second
         dimension is greater than 16 only the first 16 colours are
         used; if it has less than 16 just fill as much of the palette
         as is possible starting from the first colour.  The palette's
         values must lie in the range 0.0--1.0.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PALREAD RUSTIC
      }{
         This loads the palette stored in the NDF called RUSTIC into
         the reserved portion of the colour table of the current
         image display.
      }
      \sstexamplesubsection{
         PALREAD RUSTIC XWINDOWS
      }{
         This loads the palette stored in the NDF called RUSTIC into
         the reserved portion of the colour table of the XWINDOWS
         device.
      }
   }
}

 
\sstroutine{
   PALSAVE
}{
   Saves the current palette of a colour table to an NDF
}{
   \sstdescription{
      This application reads the palette portion of the current image
      display's colour table and saves it in an NDF.  The palette
      comprises 16 colours and is intended to provide coloured
      annotations, borders, axes, graphs {\it etc.}\ that are unaffected by
      changes to the lookup table used for images.  Thus once you have
      established a palette of colours you prefer, it is straightforward
      to recover the palette at a future time.
   }
   \sstusage{
      PALSAVE PALETTE [DEVICE] [TITLE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display to be used.  The device must be in
         one of the following GNS categories: IMAGE\_DISPLAY,
         IMAGE\_OVERLAY, or WINDOW, and have at least 24 colour indices.
         The device must also not reset when the device is opened
         (since the existing colour table would be lost).  {\tt [}Current
         image-display device{\tt ]}
      }
      \sstsubsection{
         PALETTE = NDF (Write)
      }{
         The NDF in which the current colour-table reserved pens are
         to be stored.  Thus if you have created non-standard colours
         for annotation, doodling, colour of axes {\it etc.}\ they may be
         stored for future use.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output NDF. {\tt ['KAPPA - Palsave']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PALSAVE RUSTIC
      }{
         This saves the palette of the colour table of the current
         image display into the NDF called RUSTIC.
      }
      \sstexamplesubsection{
         PALSAVE HITEC XWINDOWS TITLE={\tt "}Hi-tech-look palette{\tt "}
      }{
         This saves the palette of the colour table of the XWINDOWS
         device in the NDF called HITEC.  The NDF has a title called
         {\tt "Hi-tech-look palette"}.
      }
   }
}

 
\sstroutine{
   PICDEF
}{
   Defines a new graphics-database picture or an array of pictures
}{
   \sstdescription{
      This application enables either one new graphics-database picture,
      or a grid of new pictures to be defined and created in a variety
      of ways.  A new picture may be constrained to lie within either
      the current or the base picture, and it adopts the world
      co-ordinate system of that reference picture.

      A single picture new may be specified via one of three methods:
      \begin{enumerate}
      \item moving a cursor to define the lower and upper bounds via
            pressing choice number 1 (the application will instruct what
            to do for the specific graphics device), provided a cursor
            is available on the chosen graphics workstation;
      \item obtaining the bounds from the environment (in world
            co-ordinates of the reference picture);
      \item or by giving a position code for the new picture, and
            specifying its linear fractional size in terms of the
            reference picture. The position code comprises two
            characters. The first controls the vertical location, and
            may be {\tt T}, {\tt B}, or {\tt C} to create the new picture
            at the top, bottom, or in the centre respectively. The second
            defines the horizontal situation, and may be {\tt L},
            {\tt R}, or {\tt C} to define a new picture to the left,
            right, or in the centre respectively. Thus a code of
            {\tt BR} will make a new picture in the bottom-right corner.
      \end{enumerate}

      The picture created becomes the current picture on exit.

      Alternatively, an array of $n$-by-$m$ equal-sized pictures may be
      created by giving the number of pictures in the horizontal and
      vertical directions.  These may or may not be abutted. For easy
      reference in later processing the pictures may be labelled
      automatically.  The label consists of a user-defined prefix
      followed by the number of the picture.  The numbering starts at a
      defined value, usually one, and increments by one for each new
      picture starting from the bottom-left corner and moving from left
      to right to the end of the line.  This is repeated in each line
      until the top-right picture.  Thus if the prefix was {\tt "GALAXY"},
      the start number is one and the array comprises three pictures
      horizontally and two vertically, the top-left picture would have
      the label {\tt "GALAXY4"}.  On completion the bottom-left picture in
      the array becomes the current picture.
   }
   \sstusage{
      PICDEF [MODE] [FRACTION] [CURRENT] [DEVICE]
        $\left\{ {\begin{tabular}{l}
                    XPIC=? YPIC=? PREFIX=? \\
                    LBOUND=? UBOUND=?
                  \end{tabular} }
        \right.$
        \newline\hspace*{21.9em}
        \makebox[0mm][c]{\small mode}
   }
   \sstparameters{
      \sstsubsection{
         CURRENT = \_LOGICAL (Read)
      }{
         True if the new picture is to lie within the current picture,
         otherwise the new picture can lie anywhere within the base
         picture. {\tt [FALSE]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics device. {\tt [}Current graphics device{\tt ]}
      }
      \sstsubsection{
         FILL = \_REAL (Read)
      }{
         The linear filling factor for the Array mode.  In other words
         the fractional size (applied to both co-ordinates) of the new
         picture within each of the XPIC $*$ YPIC abutted sections of
         the picture being sub-divided.  Each new picture is located
         centrally within the section.  A filling factor of 1.0 means
         that the pictures in the array abut.  Smaller factors permit a
         gap between the pictures.  For example, FILL = 0.9 would give
         a gap between the created pictures of 10 per cent of the
         height and width of each picture, with exterior borders of 5
         per cent.  FILL must lie between 0.1 and 1.0. {\tt [1.0]}
      }
      \sstsubsection{
         FRACTION = \_REAL (Read)
      }{
         The fractional size of the new picture applied to both
         co-ordinates for modes other than Array, Cursor, and XY.  So a value
         of 0.5 would create a picture 0.25 the area of the current or
         base picture. {\tt [0.5]}
      }
      \sstsubsection{
         LABELNO = \_INTEGER (Read)
      }{
         The number of the first (bottom-left) picture to form the
         in Array mode.  It cannot be negative. {\tt [1]}
      }
      \sstsubsection{
         LBOUND( 2 ) = \_REAL (Read)
      }{
         Co-ordinates of the lower bound that defines the new picture.
         The suggested default is the bottom-left of the current
         picture.  (XY mode)
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         Method for selecting the new picture. The options are {\tt "Cursor"}
         for cursor mode (provided the graphics device has one), {\tt "XY"}
         to select $x$-$y$ limits, and {\tt "Array"} to create a grid of
         equal-sized pictures.  The remainder are locations specified
         by two characters, the first corresponding to the vertical
         position and the second the horizontal.  For the vertical,
         valid positions are {\tt T}(op), {\tt B}(ottom), or
         {\tt C}(entre); and for the horizontal the options are
         {\tt L}(eft), {\tt R}(ight), or {\tt C}(entre). (It
         is the same as the disposition code in SGS). {\tt ["Cursor"]}
      }
      \sstsubsection{
         OUTLINE = \_LOGICAL (Read)
      }{
         If true a box that delimits the new picture is drawn. {\tt [TRUE]}
      }
      \sstsubsection{
         PREFIX = LITERAL (Read)
      }{
         The prefix to be given to the labels of picture created in
         Array mode.  It should contain no more than twelve characters.
         If the empty string {\tt ""} is given the pictures will have
         enumerated labels.  Note that the database can contain only
         one picture with a given label, and so merely numbering labels
         increases the chance of losing existing labels.  A {\tt !} response
         means no labelling is required.  The suggested default is the
      }
      \sstsubsection{
         UBOUND( 2 ) = \_REAL (Read)
      }{
         Co-ordinates of the upper bound that defines the new picture.
         THe suggested default is the top-right of the current picture.
         (XY mode)
      }
      \sstsubsection{
         XPIC = \_INTEGER (Read)
      }{
         The number of new pictures to be formed horizontally in the
         base or current picture in Array mode.  The total number of
         new pictures is XPIC $*$ YPIC.    The value must lie in the
         range 1--20.  The suggested default is 2.
      }
      \sstsubsection{
         YPIC = \_INTEGER (Read)
      }{
         The number of new pictures to be formed vertically in the base
         or current picture in Array mode.  The value must lie in the
         range 1--20.  The suggested default is the value of parameter
         XPIC.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PICDEF TR
      }{
         Creates a new picture in the top-right quarter of the full
         display area on the current graphics device, and an outline
         is drawn around the new picture.  This picture becomes the
         current picture.
      }
      \sstexamplesubsection{
         PICDEF CC 0.7 CURRENT NOOUTLINE
      }{
         Creates a new picture situated in the centre of the current
         picture on the current graphics device.  The new picture has
         the same shape as the current one, but it is linearly reduced
         by a factor of 0.7.  No outline is drawn around it.  The new
         picture becomes the current picture.
      }
      \sstexamplesubsection{
         PICDEF CU DEVICE=GRAPHON
      }{
         Creates a new picture within the full display area of the
         Graphon device.  The bounds of the new picture are defined by
         cursor interaction.  An outline is drawn around the new picture
         which becomes the current picture.
      }
      \sstexamplesubsection{
         PICDEF MODE=A PREFIX=M XPIC=3 YPIC=2
      }{
         Creates six new equally sized and abutting pictures within the
         full display area of the current graphics device. All are outlined.
         They have labels M1, M2, M3, M4, M5, and M6.  The bottom-left
         picture (M1) becomes the current picture.
      }
      \sstexamplesubsection{
         PICDEF MODE=A PREFIX="" XPIC=3 YPIC=2 FILL=0.8
      }{
         As above except that the pictures do not abut since each is
         0.8 times smaller in both dimensions, and the labels are 1,
         2, 3, 4, 5, and 6.
      }
   }
}
 
\sstroutine{
   PICIN
}{
   Finds the attributes of a picture interior to the current picture
}{
   \sstdescription{
      This application finds the attributes of a picture, selected by
      name, which was created since the current picture and lies within
      the bounds of the current picture.  The search starts from the
      most-recent picture, unless the current picture is included,
      whereupon the current picture is tested first.

      The attributes reported are the name, comment, label, name of the
      reference data object, the bounds in world and normalised device
      co-ordinates.
   }
   \sstusage{
      PICIN [NAME] [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         CURRENT = \_LOGICAL (Read)
      }{
         If this is true, the current picture is compared against the
         chosen name before searching from the most-recent picture
         within the current picture. {\tt [FALSE]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the graphics device about which information is
         required. {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         NAME = LITERAL (Read)
      }{
         The name of the picture to be found within the current picture.
         If it is null (!), the first interior picture is selected.
         {\tt ["DATA"]}
      }
      \sstsubsection{
         REPORT = \_LOGICAL (Read)
      }{
         If this is false details of the interior picture are not
         reported, merely the results are written to the output
         parameters.  It is intended for use within procedures.
         {\tt [TRUE]}
      }
   }
   \sstresparameters{
      \sstsubsection{
         COMMENT = LITERAL (Write)
      }{
         The comment of the current picture.  Up to 132 characters
         will be written.
      }
      \sstsubsection{
         LABEL = LITERAL (Write)
      }{
         The label of the current picture.  It is blank if there is no
         label.
      }
      \sstsubsection{
         NCX1 = \_REAL (Write)
      }{
         The lower $x$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         NCX2 = \_REAL (Write)
      }{
         The upper $x$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         NCY1 = \_REAL (Write)
      }{
         The lower $y$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         NCY2 = \_REAL (Write)
      }{
         The upper $y$ normalised device co-ordinate of the current
         picture.
      }
      \sstsubsection{
         PNAME = LITERAL (Write)
      }{
         The name of the current picture.
      }
      \sstsubsection{
         REFNAM = LITERAL (Write)
      }{
         The reference object associated with the current picture.  It
         is blank if there is no reference object.  Up to 132 characters
         will be written.
      }
      \sstsubsection{
         WCX1 = \_REAL (Write)
      }{
         The lower $x$ world co-ordinate of the current picture.
      }
      \sstsubsection{
         WCX2 = \_REAL (Write)
      }{
         The upper $x$ world co-ordinate of the current picture.
      }
      \sstsubsection{
         WCY1 = \_REAL (Write)
      }{
         The lower $y$ world co-ordinate of the current picture.
      }
      \sstsubsection{
         WCY2 = \_REAL (Write)
      }{
         The upper $y$ world co-ordinate of the current picture.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PICIN
      }{
         This reports the attributes of the last DATA picture within
         the current picture for the current graphics device.
      }
      \sstexamplesubsection{
         PICIN FRAME GRAPHON
      }{
         This reports the attributes of the last FRAME picture within
         the current picture for the Graphon device.
      }
      \sstexamplesubsection{
         PICIN REFNAM=(OBJECT) CURRENT
      }{
         This reports the attributes of the last data picture within
         the current picture for the current graphics device. If there
         is a reference data object, its name is written to the ICL
         variable OBJECT.  The search includes the current picture.
      }
      \sstexamplesubsection{
         PICIN NCX1=(X1) NCX2=(X2) NCY1=(Y1) NCY2=(Y2)
      }{
         This reports the attributes of the last DATA picture within
         the current picture for the current graphics device. The bounds
         of the current picture in normalised device co-ordinates
         are written to the ICL variables: X1, X2, Y1, Y2.
      }
   }
   \sstnotes{
      This application is intended for use within procedures.  Also if
      a DATA picture is selected and the current picture is included in
      the search, this application informs about the same picture that
      an application that works in a cursor interaction mode would
      select, and so acts as a check that the correct picture will be
      accessed.
   }
}

\manroutine {{\manheadstyle{PICK2D}}}{ Creates a new 2-d data array
  from a subset of another.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  A 2-d data array is created from a user-specified slice of an
  existing input 2-d data array.  Both data arrays should be {\mantt{IMAGE}}
  structures. Origin information is lost.

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the 2-d data array from
  which the subset is to be taken.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the 2-d data array subset.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for the output {\mantt{IMAGE}} structure.
 \mbox{{\mantt ['KAPPA - Pick2d']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{XSTART}}  }{{\mantt{\_INTEGER}}}
  Pixel index of the first column to be included in the subset.
\manparameterentry {{\mantt{READ}} }{{\mantt{YSTART}}  }{{\mantt{\_INTEGER}}}
  Pixel index of the first line to be included in the subset.
\manparameterentry {{\mantt{READ}} }{{\mantt{XFINISH}}  }{{\mantt{\_INTEGER}}}
  Pixel index of the last column to be included in the subset.
\manparameterentry {{\mantt{READ}} }{{\mantt{YFINISH}}  }{{\mantt{\_INTEGER}}}
  Pixel index of the last line to be included in the subset.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Malcolm J. Currie ~STARLINK ( {\mantt {RAL}}::{\mantt {CUR}} )
\end{manroutinedescription}

 
\sstroutine{
   PICLABEL
}{
   Labels the current graphics-database picture
}{
   \sstdescription{
      This application annotates the current graphics-database picture
      of a specified device with a user-defined label. This provides an
      easy-to-remember handle for selecting pictures in subsequent
      processing.
   }
   \sstusage{
      PICLABEL LABEL [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics device. {\tt [}Current graphics device{\tt ]}
      }
      \sstsubsection{
         LABEL = LITERAL (Read)
      }{
         The label to be given to the current picture.  It is limited
         to 15 characters, but may be in mixed case.  If it is null ({\tt !})
         a blank label is inserted in the database.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PICLABEL GALAXY
      }{
         This makes the current picture of the current graphics device
         have a label of {\tt "GALAXY"}.
      }
      \sstexamplesubsection{
         PICLABEL A3 IKON
      }{
         This labels the current Ikon picture {\tt "A3"}.
      }
   }
}

 
\sstroutine{
   PICLIST
}{
   Lists the pictures in the graphics database for a device
}{
   \sstdescription{
      This application produces a summary of the contents of the
      graphics database for a graphics device.  The list may either be
      reported to the user or written to an ASCII file.  In the former
      case the application also permits a picture from the list to be
      restored by number.

      The headed list has one line per picture comprising a reference
      number; the picture's name comment (up to 24 characters), and
      label; a flag to indicate whether or there is a reference data
      object associated with the picture.  In the ASCII file, because
      there is more room, the name of the reference object is given (up
      to 64 characters) instead of the reference flag.  The list is in
      chronological order.
   }
   \sstusage{
      PICLIST [NAME] [LOGFILE] [DEVICE] PICNUM=?
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics workstation. {\tt [}The current graphics device{\tt ]}
      }
      \sstsubsection{
         LOGFILE = FILENAME (Write)
      }{
         The name of the ASCII file in which the list of pictures will
         be made.  A null string ({\tt !}) means the list will be reported
         to the user.  The suggested default is the current value. {\tt [!]}
      }
      \sstsubsection{
         NAME = LITERAL (Read)
      }{
         Only pictures of this name are to be selected.  A null string
         ({\tt !}) or blanks means that pictures of all names may be selected.
         {\tt [!]}
      }
      \sstsubsection{
         PICNUM = INTEGER (Read)
      }{
         The reference number of the picture to be made the current
         picture when the application exits.  It is not accessed if the
         list is written to the ASCII file.  A null ({\tt !}) or any other
         error causes the current picture on entry to be current again
         on exit.  The suggested default is null.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PICLIST
      }{
         This reports all the pictures in the graphics database for the
         current graphics device.
      }
      \sstexamplesubsection{
         PICLIST DEVICE=IKON
      }{
         This reports all the pictures in the graphics database for the
         Ikon.
      }
      \sstexamplesubsection{
         PICLIST DATA
      }{
         This reports all the DATA pictures in the graphics database for
         the current graphics device.
      }
      \sstexamplesubsection{
         PICLIST DATA LOGFILE=DATAPIC
      }{
         This lists all the DATA pictures in the graphics database for
         the current graphics device into the ASCII file DATAPIC.DAT.
      }
      \sstexamplesubsection{
         PICLIST FRAME PICNUM=5
      }{
         This reports all the FRAME pictures in the graphics database
         for the current graphics device and selects the fifth most
         ancient one as the current picture.
      }
   }
   \sstdiytopic{
      Timing
   }{
      The execution time is approximately proportional to the number of
      pictures in the database for the chosen graphics device.
      Selecting only a subset by name is slightly faster.
   }
}

 
\sstroutine{
   PICSEL
}{
   Selects a graphics-database picture by its label
}{
   \sstdescription{
      This application selects by label a graphics-database picture of a
      specified device.  If such a picture is found then it becomes the
      current picture on exit, otherwise the input picture remains
      current.  Labels in the database are stored in the case supplied
      when they were created.  However, the comparisons of the
      user-supplied label with the labels in the database are made in
      uppercase, and leading spaces are ignored.

      Should the label not be found the current picture is unchanged.
   }
   \sstusage{
      PICSEL LABEL [DEVICE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics device. {\tt [}Current graphics device{\tt ]}
      }
      \sstsubsection{
         LABEL = LITERAL (Read)
      }{
         The label of the picture to be selected.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PICSEL GALAXY
      }{
         This makes the picture labelled {\tt "GALAXY"} the current picture on
         the current graphics device.  Should there be no picture of
         this name, the current picture is unchanged.
      }
      \sstexamplesubsection{
         PICSEL A3 IKON
      }{
         This makes the picture labelled {\tt "A3"} the current picture on the
         Ikon.  Should there be no picture of this name, the current
         picture is unchanged.
      }
   }
}

\manroutine {{\manheadstyle{PIXDUPE}}}{ Expands a 2-d data array by pixel
duplication.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes a 2-d data array an input {\mantt{IMAGE}} structure and
  expands it in size by duplicating each input pixel a calculated
  number of times to form a square, containing the required number
  of pixels, in the data array written to the output {\mantt{IMAGE}}
  structure.

\manroutineitem {Invocation }{}
  PIXDUPE

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the 2-d data array to be
  expanded.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the expanded 2-d data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure.
 \mbox{{\mantt ['KAPPA - Pixdupe']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{EXPAND}} }{{\mantt{\_INTEGER}}}
  Linear expansion factor to be used to create the new data
  array.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{POW}}}{ Takes the specified power of each
  pixel of a data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes the specified power of each pixel of the
  data array in the input {\mantt{IMAGE}} structure. The result goes into a
  new output array, also in an {\mantt{IMAGE}} structure.

  The magic-value method is used for processing bad data.  Output
  pixels become bad if the result raising to the specified power is
  undefined or out of range.  Negative pixel values will only
  generate good output pixels when the power is an even integer.

\manroutineitem {Invocation }{}
  POW

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array to be
  processed.
\manparameterentry {{\mantt{READ}} }{{\mantt{POWER}}  }{{\mantt{\_REAL}}}
  Power to be taken of each input data-array pixel.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure holding result of the processed data
  array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for the output {\mantt{IMAGE}} structure.
 \mbox{{\mantt ['KAPPA - Pow']}}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

 
\sstroutine{
   PSF
}{
   Determines the parameters of a model star profile by fitting star
   images in a 2-dimensional NDF
}{
   \sstdescription{
      This application finds a set of parameters to describe a model
      Gaussian star image.  It can be used for profile-fitting stellar
      photometry, to evaluate correction terms to aperture
      photometry, or for filtering.

      The model has a radial profile:
      {\Large
      \[   D =  A \exp^{-0.5\,(r/\sigma)^{\gamma}} \]
      }
      where $r$ is calculated from the true radial distance from the star
      centre allowing for image ellipticity, $\sigma$ is the Gaussian
      precision constant or profile width.  The application combines a
      number of star images specified by the user and determines a mean
      seeing disk size, radial fall-off parameter ($\gamma$), axis ratio,
      and orientation of a model star image.

      A table, giving details of the seeing and ellipticity of each
      star image used can be reported to an output ASCII file.  This
      table indicates if any star could not be used.  Reasons for
      rejecting stars are too-many bad pixels present in the image,
      the star is too close to the edge of the data array, the
      `star' is a poor fit to model or it could not be located.

      An optional plot of the mean profile and the fitted function may
      be produced.  The point-spread function may be stored in an NDF
      for later use.
   }
   \sstusage{
      PSF IN COFILE DEVICE OUT [CUT] [RANGE] [ISIZE] [POSCOLS] [CLEAR]
   }
   \sstparameters{
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         Determines if the graphics workstation is to be cleared before
         producing the plot.  It is ignored if no plotting is required
         defined by DEVICE. {\tt [TRUE]}
      }
      \sstsubsection{
         COFILE = FILENAME (Read)
      }{
         ASCII file containing the $x$ and $y$ co-ordinates.  The data
         should be in columns separated by spaces or tabs, however
         precise alignment is not necessary.
      }
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either
         {\tt "WORLD"} or {\tt "DATA"}.  If COSYS = {\tt "DATA"} the
         input co-ordinates are to be expressed in data co-ordinates,
         otherwise pixel (world) co-ordinates are used.  In order to
         compute the point-spread function data co-ordinates are
         converted to pixel indices via the NDF's axis values; if there
         is no axis information within the NDF, world co-ordinates are
         then used.  If COSYS = {\tt "WORLD"} pixel co-ordinates are
         used throughout.  {\tt [}Current co-ordinate system{\tt ]}
      }
      \sstsubsection{
         CUT = \_REAL (Read)
      }{
         This parameter controls the size of the output NDF.  If it is
         null, {\tt !}, the dimension of the square NDF will be the size of
         the region used to calculate the radial profile, which usually
         is given by RANGE $*$ width in pixels $*$ AXISR, unless truncated.
         If CUT has a value it is the threshold which must be included
         in the PSF NDF, and it is given as the fraction of the peak
         amplitude of the PSF.  For example, if CUT=0.5 the NDF would
         contain the point-spread function to half maximum.  CUT must
         be greater than 0 and less than 1.  The suggested default is
         0.0001 {\tt [!]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics workstation on which to produce a plot of the
         mean radial profile of the stars and the fitted function.  A
         null ({\tt !}) name indicates that no plot is required.  The
         suggested default is the current graphics device.
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         The NDF containing the star images to be fitted.
      }
      \sstsubsection{
         ISIZE = \_INTEGER (Read)
      }{
         The side of the square area to be used when forming the
         marginal profiles for a star image.  It should be sufficiently
         large to contain the entire star image.  It should be an odd
         number and must lie in the range from 3 to 101.  If an even
         value is given, the next largest odd number is used instead.
         {\tt [15]}
      }
      \sstsubsection{
         LOGFILE = FILENAME (Read)
      }{
         ASCII file to contain the table of parameters for each star.  A
         null ({\tt !}) name indicates that no log file is required. {\tt [!]}
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         The NDF containing the fitted point-spread function evaluated
         at each pixel. Its dimensions are always odd numbered and
         the centre of the PSF is located at the centre of the image.
         If null, {\tt !}, is entered no output NDF will be created.  The
         dimensions of the array are controlled by parameter CUT. {\tt [!]}
      }
      \sstsubsection{
         POSCOLS = \_INTEGER (Read)
      }{
         Column positions of the co-ordinates in an input record of the
         ASCII file, $x$ then $y$.  The columns must be different amongst
         themselves. If there is duplication new values will be
         requested.  {\tt [1,2]}
      }
      \sstsubsection{
         PXSIZE = \_REAL (Read)
      }{
         The horizontal size of the plot in metres. If a value less
         than the default is requested, then the plot will appear at
         the bottom left of the current picture. {\tt [}The size of the
         current picture{\tt ]}
      }
      \sstsubsection{
         PYSIZE = \_REAL (Read)
      }{
         The vertical size of the plot in metres. If a value less than
         the default is requested, then the plot will appear at the
         bottom left of the current picture. {\tt [}The size of the current
         picture{\tt ]}
      }
      \sstsubsection{
         RANGE = \_REAL (Read)
      }{
         The number of image profile widths out to which the radial
         star profile is to be fitted.  (There is an upper limit of 100
         pixels to the radius at which data are actually used.) {\tt [4.0]}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         The title for the NDF to contain the fitted point-spread
         function.  If null, {\tt !}, is entered the NDF will not contain a
         title.  {\tt ['KAPPA - PSF']}
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         {\tt "NCAR"} for the NCAR fancy characters and {\tt "GKS"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value. {\tt ["GKS"]}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the numbers of major tick marks
         for the $x$ and $y$ axes.  (Number used is between MAJTIC$+$2 and
         5$*$MAJTIC/2$+$4.) {\tt [3.,3.]}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark
         for the $x$ and $y$ axes.  A negative value forces the graphics
         package to compute appropriate values. {\tt [-1.,-1.]}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         True if the axis tick marks are to appear on the outside of
         the axes instead of inside. {\tt [FALSE]}
      }
   }
   \sstresparameters{
      \sstsubsection{
         AXISR = \_REAL (Write)
      }{
         The axis ratio of the star images: the ratio of the major
         axis length to that of the minor axis.
      }
      \sstsubsection{
         FWHM = \_REAL (Write)
      }{
         The seeing disk size: the full width at half maximum across the
         minor axis of the stars.
      }
      \sstsubsection{
         GAMMA = \_REAL (Write)
      }{
         The radial fall-off parameter, $\gamma$, of the star images. See
         the description for more details.  $\gamma = 2$ would be a
         Gaussian.
      }
      \sstsubsection{
         ORIENT = \_REAL (Write)
      }{
         The orientation of the major axis of the star images to the $x$
         axis (increasing pixel-index direction).  This value is in
         degrees, $x$ through $y$ being considered positive.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         PSF NGC6405I STARLIST $\backslash$
      }{
         Derives the mean point-spread function for the stars images
         in NDF NGC6405I that are situated near the $x$-$y$ co-ordinates
         given in the first two columns of file STARLIST.DAT.  A plot
         of the profile is drawn on the current graphics device.  The
         results are stored in the parameter file ADAM\_USER:PSF.SDF
      }
      \sstexamplesubsection{
         PSF NGC6405I STARLIST DEVICE=!
      }{
         As above but there is no graphical output. (At the time of
         writing this will not work because of an ADAM bug.  Instead
         you should enter {\tt !} when prompted for the device, to
         obtain no plotting.)
      }
      \sstexamplesubsection{
         PSF COFILE=STARLIST IN=NGC6405I LOGFILE=@FIT.LOG FWHM=(SEEING) $\backslash$
      }{
         As the first example, but the results, including the fits to
         each star, are written to the ASCII file FIT.LOG.  The
         full-width half-maximum is written to the ICL variable SEEING
         rather than the parameter file.
      }
      \sstexamplesubsection{
         PSF NGC6405I STARLIST ISIZE=31 $\backslash$
      }{
         As the first example, but the area including a star image is
         31 pixels square, say because the seeing is poor or the pixels
         are smaller than normal.
      }
      \sstexamplesubsection{
         PSF NGC6405I STARLIST OUT=STARPSF CUT=1.0E-3 $\backslash$
      }{
         As the first example, but the resultant point-spread function
         is stored in the NDF called STARPSF, and will contain signals
         as low as 1.0E-3.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The stars used to determine the mean image parameters should
         be chosen to represent those whose magnitudes are to be found
         using a stellar photometry application, and to be sufficiently
         bright, uncrowded, and noise-free to allow an accurate fit to be
         made.

         \sstitem
         The method to calculate the fit is as follows.
         \begin{itemize}
            \item  Marginal profiles of each star image are formed in four
            directions, inclined at 45$\dgs$ intervals.  A Gaussian curve
            and background is fitted to each profile.  Using the resulting
            four Gaussian centres, a mean centre is found for each star.
            \item The four Gaussian widths of all the stars are combined,
            using a weighted average with rejection of erroneous data, and
            from the four average widths the seeing disk size, axis ratio
            and axis inclination are calculated.
            \item The data surrounding each star is then binned into
            isophotal zones which are elliptical annuli centred on the
            star---the ellipse parameters being those just calculated.
            The data in each zone is processed to remove erroneous points
            and to find an average value.  A Gaussian profile is fitted to
            these average values and the derived amplitude is used to
            normalise the values to an amplitude of unity.  The normalised
            values are put into bins together with the corresponding data
            from all other stars and this binned data represents a
            weighted average radial profile for the set of stars, with the
            image ellipticity removed.  Finally a radial profile is fitted
            to these data, giving the radial profile parameter $\gamma$ and a
            final re-estimate of the seeing disk size.
         \end{itemize}

         \sstitem
         If a plot was requested the application stores two pictures in
         the graphics database in the following order: a FRAME of the
         specified size containing the title, annotated axes, and line
         plot; and a DATA picture, which has world co-ordinates measured
         in pixels along the $x$ axis and normalized intensity values along
         $y$.  The NDF associated with the plot is not stored by reference
         with the DATA picture.  On exit the current database picture for
         the chosen device reverts to the input picture.
      }
   }
   \sstdiytopic{
      Timing
   }{
      Approximately proportional to the number of stars used and the
      image area which each occupies.
   }
   \sstimplementationstatus{
      The following NDF features are supported by this application:
      \sstitemlist{

         \sstitem
         The DATA and QUALITY arrays.

         \sstitem
         Bad-pixel handling, including automatic quality masking.

         \sstitem
         Processing of all non-complex numeric types.  The output
         point-spread-function NDF has type \_REAL.
      }
   }
}

\newpage
\manroutine {{\manheadstyle{QUILT}}}{ Generates a mosaic from equally sized
  2-d data arrays, optionally specified from an ASCII file.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine provides a more-sophisticated version of the {\mantt{MOSAIC}}
  application for combining many 2-d data arrays into one large
  output data array. All the data arrays are stored in {\mantt{IMAGE}}
  structures.  The pixels in overlapping regions may be averaged or
  summed.

  The names of {\mantt{IMAGE}} structures to be concatenated and their
  respective offsets of their data arrays from a central
  data array can be input either one by one from the interface, or
  all at once from a free-format file.  The format of the file is
  as follows:  \mbox {}

\begin{minipage}[t]{60mm}
\begin{verbatim}
        Mosaic title
        central_image
        125
        345  229
        -356  -232
        image_2
        35  34
        image_3
        36  -33
        .
        .
        .

\end{verbatim}
\end{minipage}
\begin{minipage}[t]{60mm}
\begin{verse}

! header \\
! name of central {\mantt {IMAGE}} \\
! total no. frames \\
! max {$x$}-{$y$} offsets \\
! min {$x$}-{$y$} offsets \\
! subsequent {\mantt {IMAGE}} and \\
! its {$x$}-{$y$} offsets
\end{verse}
\end{minipage}

  Only like-sized data arrays may be input. The reason for this is
  that it is difficult to work out how big the output data array
  needs to be until all the input data arrays and their offsets have
  been read in. By confining the data arrays to be the same size,
  only the maximum and minimum {$x$} and {$y$} offsets from the central data
  array need be input by the user, then the output image size can be
  worked out from these numbers along with the size of the central
  data array.

  Bad pixels are processed by the magic-value method.

\manroutineitem {Invocation }{}
  QUILT

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{WHERE}}  }{{\mantt{\_CHAR}}}
  Whether input comes from an ASCII {\mantt{'File'}} or from the
  {\mantt{'Interface'}}.
\manparameterentry {{\mantt{READ}} }{{\mantt{FNAME}}  }{{\mantt{\_CHAR}}}
  Name of the ASCII file holding the input information to define 
  the mosaic.
\manparameterentry {{\mantt{READ}} }{{\mantt{NUMBER}}  }{{\mantt{\_INTEGER}}}
  Number of data arrays to form the mosaic.
\manparameterentry {{\mantt{READ}} }{{\mantt{INPICI}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the central data array (offset 0, 0).
\manparameterentry {{\mantt{READ}} }{{\mantt{MAXX}}  }{{\mantt{\_INTEGER}}}
  Maximum {$x$} offset of any data array from the central data array
  in {\mantt Interface} mode (must be {$\geq$}0).
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{MAXY}}  }{{\mantt{\_INTEGER}}}
  Maximum {$y$} offset of any data array from the central data array
  in {\mantt Interface} mode (must be {$\geq$}0).
\manparameterentry {{\mantt{READ}} }{{\mantt{MINX}}  }{{\mantt{\_INTEGER}}}
  Minimum {$x$} offset of any data array from the central data array
  in {\mantt Interface} mode (must be {$\leq$}0).
\manparameterentry {{\mantt{READ}} }{{\mantt{MINY}}  }{{\mantt{\_INTEGER}}}
  Minimum {$y$} offset of any data array from the central data array
  in {\mantt Interface} mode (must be {$\leq$}0).
\manparameterentry {{\mantt{READ}} }{{\mantt{AVERAGE}}  }{{\mantt{\_LOGICAL}}}
  If true overlap regions are averaged, alternatively, they are
  summed.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for output {\mantt{IMAGE}} structure.
 \mbox{{\mantt ['KAPPA - Quilt']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{CURPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} containing the current data array being concatenated to
  the mosaic.
\manparameterentry {{\mantt{READ}} }{{\mantt{OFFSETX}}  }{{\mantt{\_INTEGER}}}
  {$x$} offset of current data array from the central one
  ({\mantt{Interface}} mode).
\manparameterentry {{\mantt{READ}} }{{\mantt{OFFSETY}}  }{{\mantt{\_INTEGER}}}
  {$y$} offset of current data array from the central one
  ({\mantt{Interface}} mode).
\end{manparametertable}
\manroutineitem {Deficiencies }{}
  Works with like-sized images only and uses Fortran i/o for getting
  stuff from a file. 

\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{ROTATE}}}{ Rotates a 2-d data array through any
  angle.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  The 2-d data array, stored in the input {\mantt{IMAGE}} structure, can be
  square or rectangular, is rotated through a defined number of
  degrees clockwise. The rotated data array is written to the new
  data array, stored in the output {\mantt{IMAGE}} structure.  Output pixels
  can be generated from the input data array by one of
  two methods: nearest-neighbour substitution or by bilinear
  interpolation.  The latter is slower, but gives better results.

  The magic-value method is used for processing bad data.  Bad
  pixels are ignored in the bi-linear interpolation.  If all four
  pixels are bad, the result is bad.

\manroutineitem {Invocation }{}
  ROTATE

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the 2-d data array to be rotated.
\manparameterentry {{\mantt{READ}} }{{\mantt{ANGLE}}  }{{\mantt{\_REAL}}}
  Number of clockwise degrees by which the data array is to be
  rotated.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure to contain the 2-d data array after rotation.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Will be used as the {\mantt{TITLE}} component for the output
  {\mantt{IMAGE}} structure.  \mbox{{\mantt ['KAPPA - Rotate']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{NNMETH}} }{{\mantt{\_LOGICAL}}}
  If true, the nearest-neighbour method will be used to
  evaluate the output data-array pixels. \mbox{{\mantt [TRUE]}}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{SEGMENT}}}{ Copies polygonal segments from one 2-d data
array to another.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine copies polygonal segments of one 2-d data array into
  the same location in another 2-d data array. The application is
  intended to allow regions of a data array to be removed to
  another from separate processing.  It may also be used to copy
  bad pixels into a data array in order to delete a region which is not
  required. All the data arrays are stored in the {\mantt{IMAGE}} format.

  The vertices of a polygon segment are defined by a list of {$x$}-{$y$}
  positions. The polygon is completed by connecting the last position
  in the list to the first.  Pixels within the polygon segment are copied
  from the first data array (A) to the corresponding position in the
  second data array (B). A sequence of polygons, each in a separate ASCII
  file, may be supplied, and each is copied in turn.  The file is free
  format with {$x$} co-ordinates in column one and {$y$} co-ordinates in
  column two. (This is the format produced by other {\small KAPPA}
  applications such as CURSOR.) Image A or B may be given as null
  ({\mantt{!}}) and its pixels will then be considered as bad.  Thus,
  bad pixels may be copied into a data array, deleting an undesired
  feature (A is null), or a feature may be isolated by copying it into an
  otherwise bad data array (B is null).  The data arrays need not be of
  the same size, and an attempt to copy from outside data array A results
  in bad pixels at the corresponding locations in the output data array.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  SEGMENT

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC1}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array to be copied
  from, {\it i.e.}\ image A. If null ({\mantt{!}}) is given, an array of
  bad pixels is used.
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC2}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array to be copied
  into, {\it i.e.}\ image B. If null ({\mantt{!}}) is given, an array of
  bad pixels is used.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure holding the copy of the second image
  (B) including the polygonal regions replaced by elements from the first
  image (A).
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for output {\mantt{IMAGE}} structure.
  \mbox{{\mantt ['KAPPA - Segment']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{POLYGON}} }{{\mantt{FILENAME}}}
  File name of each list of {$x$}-{$y$} points that define a polygon.
  A null name ({\mantt{!}}) will end the application.
\end{manparametertable}

\manroutineitem {Bugs }{}
   None known.

\manroutineitem {Authors }{}
   Malcolm J. Currie ~STARLINK ( {\mantt {RAL}}::{\mantt {CUR}} )
\end{manroutinedescription}

\sstroutine{
   SETBAD
}{
   Sets new bad-pixel flag values for an NDF
}{
   \sstdescription{
      This application sets new logical values for the bad-pixel flags
      associated with an NDF's data and/or variance arrays.  It may
      either be used to test whether bad pixels are actually present in
      these arrays and to set their bad-pixel flags accordingly, or to
      set explicit TRUE or FALSE values for these flags.
   }
   \sstusage{
      SETBAD NDF [VALUE]
   }
   \sstparameters{
      \sstsubsection{
         DATA = \_LOGICAL (Read)
      }{
         This parameter controls whether the NDF's data array is
         processed. If a {\tt TRUE} value is supplied (the default), then it
         will be processed. Otherwise it will not be processed, so that
         the variance array (if present) may be considered on its own.
         The DATA and VARIANCE parameters should not both be set to
         {\tt FALSE}.  {\tt [TRUE]}
      }
      \sstsubsection{
         MODIFY = \_LOGICAL (Read)
      }{
         If a {\tt TRUE} value is supplied for this parameter (the default),
         then the NDF's bad-pixel flags will be permanently modified if
         necessary. If a {\tt FALSE} value is supplied, then no modifications
         will be made. This latter mode allows the routine to be used
         to check for the presence of bad pixels without changing the
         current state of an NDF's bad-pixel flags.  It also allows the
         routine to be used on NDFs for which write access is not
         available. {\tt [TRUE]}
      }
      \sstsubsection{
         NDF = NDF (Read and Write)
      }{
         The NDF in which bad pixels are to be checked for, and/or
         whose bad-pixel flags are to be modified. (Note that setting
         the MODIFY parameter to {\tt FALSE} makes it possible to check for
         bad pixels without permanently modifying the NDF.)
      }
      \sstsubsection{
         VALUE = \_LOGICAL (Read)
      }{
         If a null ({\tt !}) value is supplied for this parameter (the
         default), then the routine will check to see whether any bad
         pixels are present.  This will only involve testing the value
         of each pixel if the bad-pixel flag value is initially TRUE,
         in which case it will be reset to FALSE if no bad pixels are
         found.  If the bad-pixel flag is initially FALSE, then it will
         remain unchanged.

         If a logical ({\tt TRUE} or {\tt FALSE}) value is supplied for
         this parameter, then it indicates the new bad-pixel flag value
         which is to be set.  Setting a {\tt TRUE} value indicates to later
         applications that there may be bad pixels present in the NDF,
         for which checks must be made. Conversely, setting a {\tt FALSE}
         value indicates that there are definitely no bad pixels
         present, in which case later applications need not check for
         them and should interpret the pixel values in the NDF
         literally.

         The VALUE parameter is not used (a null value is assumed) if
         the MODIFY parameter is set to {\tt FALSE} indicating that the NDF
         is not to be permanently modified. {\tt [!]}
      }
      \sstsubsection{
         VARIANCE = \_LOGICAL (Read)
      }{
         This parameter controls whether the NDF's variance array is
         processed. If a {\tt TRUE} value is supplied (the default), then it
         will be processed. Otherwise it will not be processed, so that
         the data array may be considered on its own.  The DATA and
         VARIANCE parameters should not both be set to {\tt FALSE}. 
         {\tt [TRUE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SETBAD NGC1097
      }{
         Checks the data and variance arrays (if present) in the NDF
         called NGC1097 for the presence of bad pixels. If the initial
         bad-pixel flag values indicate that bad pixels may be present,
         but none are found, then the bad-pixel flags will be reset to
         FALSE. The action taken will be reported.
      }
      \sstexamplesubsection{
         SETBAD NDF=NGC1368 NOMODIFY
      }{
         Performs the same checks as described above, this time on the
         NDF called NGC1368. The presence or absence of bad pixels is
         reported, but the NDF is not modified.
      }
      \sstexamplesubsection{
         SETBAD MYFILE NODATA
      }{
         Checks the variance array (if present) in the NDF called
         MYFILE for the presence of bad pixels, and modifies its
         bad-pixel flag accordingly. Specifying {\tt NODATA} inhibits
         processing of the data array, whose bad-pixel flag is left
         unchanged.
      }
      \sstexamplesubsection{
         SETBAD HALPHA FALSE
      }{
         Sets the bad-pixel flag for the NDF called HALPHA to FALSE.
         Any pixel values which might previously have been regarded as
         bad will subsequently be interpreted literally as valid
         pixels.
      }
      \sstexamplesubsection{
         SETBAD HBETA TRUE
      }{
         Sets the bad-pixel flags for the NDF called HBETA to be TRUE.
         If any pixels have the special `bad' value, then they will
         subsequently be regarded as invalid pixels. Note that if this
         is followed by a further command such as {\tt "SETBAD HBETA"}, then
         an actual check will be made to see whether any pixels have
         this special value. The bad-pixel flags will be returned to
         FALSE if they do not.
      }
   }
   \sstdiytopic{
      Bad-Pixel Flag Values
   }{
      If a bad-pixel flag is TRUE, it indicates that the associated NDF
      array may contain the special `bad' value and that affected
      pixels are to be regarded as invalid.  Subsequent applications
      will need to check for such pixels and, if found, take account of
      them.

      Conversely, if a bad-pixel flag value is FALSE, it indicates that
      there are no bad pixels present.  In this case, any special `bad'
      values appearing in the array are to be interpreted literally as
      valid pixel values.
   }
   \sstdiytopic{
      Quality Components
   }{
      Bad pixels may also be introduced into an NDF's data and variance
      arrays implicitly through the presence of an associated NDF
      quality component. This application will not take account of such
      a component, nor will it modify it.

      However, if either of the NDF's data or variance arrays do not
      contain any bad pixels themselves, a check will be made to see
      whether a quality component is present. If it is (and its
      associated bad-bits mask is non-zero), then a warning message
      will be issued indicating that bad pixels may be introduced via
      this quality component. If required, these bad pixels may be
      eliminated either by setting the bad-bits mask to zero or by
      erasing the quality component.
   }
}

\sstroutine{
   SETBB
}{
   Sets a new value for the quality bad-bits mask of an NDF
}{
   \sstdescription{
      This application sets a new value for the bad-bits mask
      associated with the quality component of an NDF.  This 8-bit mask
      is used to select which of the bits in the quality array should
      normally be used to generate `bad' pixels when the NDF is
      accessed.

      Wherever a bit is set to 1 in the bad-bits mask, the
      corresponding bit will be extracted from the NDF's quality array
      value for each pixel (the other quality bits being ignored). A
      pixel is then considered `bad' if any of the extracted quality
      bits is set to 1. Effectively, the bad-bits mask therefore allows
      selective activation of any of the eight 1-bit masks which can be
      stored in the quality array.
   }
   \sstusage{
      SETBB NDF BB
   }
   \sstparameters{
      \sstsubsection{
         AND = \_LOGICAL (Read)
      }{
         By default, the value supplied via the BB parameter will be
         used literally as the new bad-bits mask value. However, if a
         {\tt TRUE} value is given for the AND parameter, then a bit-wise
         `AND' will first be performed with the old value of the mask.
         This facility allows individual bits in within the mask to be
         cleared ({\it i.e.}\ reset to zero) without affecting the current
         state of other bits (see the Examples section).

         The AND parameter is not used if a {\tt TRUE} value is given for the
         OR parameter. {\tt [FALSE]}
      }
      \sstsubsection{
         BB = LITERAL (Read)
      }{
         The new integer value for the bad-bits mask. This may either
         be specified in normal decimal notation, or may be given using
         binary, octal or hexadecimal notation by adding a {\tt "B"}, 
         {\tt "O"} or {\tt "Z"} prefix (respectively) to the appropriate string of digits.
         The value supplied should lie in the range 0 to 255 decimal (or
         8 bits of binary).

         If the AND and OR parameters are both {\tt FALSE}, then the value
         supplied will be used directly as the new mask value.
         However, if either of these logical parameters is set to {\tt TRUE},
         then an appropriate bit-wise `AND' or `OR' operation with the
         old mask value will first be performed.

         The default value suggested when prompting for this value is
         chosen so as to leave the original mask value unchanged.
      }
      \sstsubsection{
         NDF = NDF (Read and Write)
      }{
         The NDF whose bad-bits mask is to be modified.
      }
      \sstsubsection{
         OR = \_LOGICAL (Read)
      }{
         By default, the value supplied via the BB parameter will be
         used literally as the new bad-bits mask value. However, if a
         {\tt TRUE} value is given for the OR parameter, then a bit-wise `OR'
         will first be performed with the old value of the mask.  This
         facility allows individual bits in within the mask to be set
         to 1 without affecting the current state of other bits (see
         the Examples section). {\tt [FALSE]}
      }
   }
   \newpage
   \sstexamples{
      \sstexamplesubsection{
         SETBB MYFRAME 3
      }{
         Sets the bad-bits mask value for the quality component of the
         NDF called MYFRAME to the value 3. This means that bits 1 and
         2 of the associated quality array will be used to generate bad
         pixels.
      }
      \sstexamplesubsection{
         SETBB NDF=MYFRAME BB=B11
      }{
         This example performs the same operation as above, but in this
         case the new mask value has been specified using binary
         notation.
      }
      \sstexamplesubsection{
         SETBB XSPEC B10001000 OR
      }{
         Causes the bad-bits mask value in the NDF called XSPEC to
         undergo a bit-wise `OR' operation with the binary value
         10001000. This causes bits 4 and 8 to be set without changing
         the state of any other bits in the mask.
      }
      \sstexamplesubsection{
         SETBB QUASAR ZE7 AND
      }{
         Causes the bad-bits mask value in the NDF called QUASAR to
         undergo a bit-wise `AND' operation with the hexadecimal value
         E7 (binary 11100111). This causes bits 4 and 5 to be cleared
         ({\it i.e.}\  reset to zero) without changing the state of any other
         bits in the mask.
      }
   }
   \sstnotes{
      The bad-bits value will be disregarded if the NDF supplied does
      not have a quality component present. A warning message will be
      issued if this should occur.
   }
}

\sstroutine{
   SETBOUND
}{
   Sets new bounds for an NDF
}{
   \sstdescription{
      This application sets new pixel-index bounds for an NDF, either
      trimming it to remove unwanted pixels, or padding it with bad
      pixels to achieve the required shape. The number of dimensions
      may also be altered. The NDF is accessed in update mode and
      modified {\it in situ}, preserving existing pixel values which lie
      within the new bounds.
   }
   \sstusage{
      SETBOUND NDF
   }
   \sstparameters{
      \sstsubsection{
         LIKE = NDF (Read)
      }{
         This parameter may be used to specify an NDF which is to be
         used as a shape template. If such a template is supplied, then
         its bounds will be used to determine the new shape required
         for the NDF specified via the NDF parameter. By default no
         template will be used and the new shape will be determined
         by means of a section specification applied to the NDF being
         modified (see the Examples section).  {\tt [!]}
      }
      \sstsubsection{
         NDF = NDF (Read and Write)
      }{
         The NDF whose bounds are to be modified. In normal use, an NDF
         section will be specified for this parameter (see the Examples
         section) and the routine will use the bounds of this section
         to determine the new bounds required for the base NDF from
         which the section is drawn. The base NDF is then accessed in
         update mode and its bounds are modified {\it in situ\/} to make them
         equal to the bounds of the section specified. If a section is
         not specified, then the NDF's shape will only be modified if a
         shape template is supplied via the LIKE parameter.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SETBOUND DATAFILE(1:512,1:512)
      }{
         Sets the pixel-index bounds of the NDF called DATAFILE to be
         (1:512,1:512), either by trimming off unwanted pixels or by
         padding out with bad pixels, as necessary.
      }
      \sstexamplesubsection{
         SETBOUND ALPHA(:7,56:)
      }{
         Modifies the NDF called ALPHA so that its first dimension has
         an upper bound of 7 and its second dimension has a lower bound
         of 56. The lower bound of the first dimension and the upper
         bound of the second dimension remain unchanged.
      }
      \sstexamplesubsection{
         SETBOUND NDF=KG74B(,5500.0$\sim$100.0)
      }{
         Sets new bounds for the NDF called KG74B. The bounds of the
         first dimension are left unchanged, but those of the second
         dimension are changed so that this dimension has an extent of
         100.0 centred on 5500.0, using the physical units in which
         this second dimension is calibrated.
      }
      \sstexamplesubsection{
         SETBOUND NEWSPEC LIKE=OLDSPEC
      }{
         Changes the bounds of the NDF NEWSPEC so that they are equal
         to the bounds of the NDF called OLDSPEC.
      }
      \sstexamplesubsection{
         SETBOUND XFLUX(:2048) LIKE=XFLUX
      }{
         Extracts the section extending from the lower bound of the
         1-dimensional NDF called XFLUX up to pixel 2048, and then
         modifies the bounds of this section to be equal to the
         original bounds of XFLUX, replacing XFLUX with this new NDF.
         This leaves the final shape unchanged, but sets all pixels
         from 2049 onwards to be equal to the bad-pixel value.
      }
      \sstexamplesubsection{
         SETBOUND WHOLE(5:10,5:10) LIKE=WHOLE(0:15,0:15)
      }{
         Extracts the section (5:10,5:10) from the base NDF called
         WHOLE and then sets its bounds to be equal to those of the
         section WHOLE(0:15,0:15), replacing WHOLE with this new NDF.
         The effect is to select a 6-pixel-square region from the
         original NDF and then to pad it with a 5-pixel-wide border of
         bad pixels.
      }
   }
   \sstnotes{
      This routine modifies the NDF {\it in situ\/} and will not release unused
      file space if the size of the NDF is reduced. If recovery of
      unused file space is required, then the related application
      NDFCOPY should be used. This will copy the selected region of an
      NDF to a new data structure from which any unused space will be
      eliminated.
   }
}

\sstroutine{
   SETLABEL
}{
   Sets a new label for an NDF data structure
}{
   \sstdescription{
      This routine sets a new value for the label component of an
      existing NDF data structure. The NDF is accessed in update mode
      and any pre-existing label is over-written with a new value.
      Alternatively, if a `null' value ({\tt !}) is given for the LABEL
      parameter, then the NDF's label will be erased.
   }
   \sstusage{
      SETLABEL NDF LABEL
   }
   \newpage
   \sstparameters{
      \sstsubsection{
         LABEL = LITERAL (Read)
      }{
         The value to be assigned to the NDF's label component. This
         should describe the type of quantity represented in the NDF's
         data array ({\it e.g.}\ {\tt "Surface Brightness"} or {\tt "Flux Density"}).
         The value may later be used by other applications, for instance to
         label the axes of graphs where the NDF's data values are
         plotted.
      }
      \sstsubsection{
         NDF = NDF (Read and Write)
      }{
         The NDF data structure whose label is to be modified.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SETLABEL NGC1068 "Surface Brightness"
      }{
         Sets the label component of the NDF structure NGC1068 to be
         {\tt "Surface Brightness"}.
      }
      \sstexamplesubsection{
         SETLABEL NDF=DATASTRUCT LABEL="Flux Density"
      }{
         Sets the label component of the NDF structure DATASTRUCT to be
         {\tt "Flux Density"}.
      }
      \sstexamplesubsection{
         SETLABEL RAW\_DATA LABEL=!
      }{
         By specifying a null value ({\tt !}), this example erases any
         previous value of the label component in the NDF structure
         RAW\_DATA.
      }
   }
}

\manroutine {{\manheadstyle{SETMAGIC}}}{ Replaces all occurrences of pixels of a %
given value in a data array by the magic value.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  All pixels in the data array, contained in the input {\mantt{IMAGE}}
  structure, that have a user-defined value are flagged with the
  magic value within a new data array, which is stored in the
  output {\mantt{IMAGE}} structure.  One application is to convert data from
  another system, whose magic value is different from the Starlink
  standard.

\manroutineitem {Invocation }{}
  SETMAGIC

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array to be edited.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the data array that is a
  copy of the input data array, but with the magic-value
  replacing the defined pixel value throughout.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure.
  \mbox{{\mantt ['KAPPA - Setmagic']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{REPVAL}}  }{{\mantt{\_REAL}}}
  The value of input pixel to be substituted by magic values in
  the output data array.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Malcolm J. Currie ~STARLINK ( {\mantt {RAL}}::{\mantt {CUR}} )
\end{manroutinedescription}

\sstroutine{
   SETORIGIN
}{
   Sets a new pixel origin for an NDF
}{
   \sstdescription{
      This application sets a new pixel origin value for an NDF data
      structure.  The NDF is accessed in update mode and the indices of
      the first pixel (the NDF's lower pixel-index bounds) are set to
      specified integer values, which may be positive or negative.  No
      other properties of the NDF are altered.  If required, a template
      NDF may be supplied and the new origin values will be derived
      from it.
   }
   \sstusage{
      SETORIGIN NDF ORIGIN
   }
   \sstparameters{
      \sstsubsection{
         LIKE = NDF (Read)
      }{
         This parameter may be used to supply an NDF which is to be
         used as a template. If such a template is supplied, then its
         origin (its lower pixel-index bounds) will be used as the new
         origin value for the NDF supplied via the NDF parameter.  By
         default, no template will be used and the new origin will be
         specified via the ORIGIN parameter. {\tt [!]}
      }
      \sstsubsection{
         NDF = NDF (Read and Write)
      }{
         The NDF data structure whose pixel origin is to be modified.
      }
      \sstsubsection{
         ORIGIN() = \_INTEGER (Read)
      }{
         A 1-dimensional array specifying the new pixel origin values,
         one for each NDF dimension.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SETORIGIN IMAGE\_2D [1,1]
      }{
         Sets the indices of the first pixel in the 2-dimensional image
         IMAGE\_2D to be (1,1). The image pixel values are unaltered.
      }
      \sstexamplesubsection{
         SETORIGIN NDF=STARFIELD
      }{
         A new pixel origin is set for the NDF structure called
         STARFIELD. SETORIGIN will prompt for the new origin values,
         supplying the existing values as defaults.
      }
      \sstexamplesubsection{
         SETORIGIN NDF=CUBE ORIGIN=[-128,-128]
      }{
         Sets the pixel origin values for the first two dimensions of
         the 3-dimensional NDF called CUBE to be ($-$128,$-$128). A value
         for the third dimension is not specified, so the origin of
         this dimension will remain unchanged.
      }
      \sstexamplesubsection{
         SETORIGIN BETAPIC LIKE=ALPHAPIC
      }{
         Sets the pixel origin of the NDF called BETAPIC to be equal to
         that of the NDF called ALPHAPIC.
      }
   }
   \sstnotes{
      If the number of new pixel origin values is less than the number
      of NDF dimensions, then the pixel origin of the extra dimensions
      will remain unchanged. If the number of values exceeds the number
      of NDF dimensions, then the excess values will be ignored.
   }
   \sstdiytopic{
      Timing
   }{
      Setting a new pixel origin is a quick operation whose timing does
      not depend on the size of the NDF.
   }
}

\sstroutine{
   SETTITLE
}{
   Set a new title for an NDF data structure
}{
   \sstdescription{
      This routine sets a new value for the title component of an
      existing NDF data structure. The NDF is accessed in update mode
      and any pre-existing title is over-written with a new value.
      Alternatively, if a `null' value ({\tt !}) is given for the TITLE
      parameter, then the NDF's title will be erased.
   }
   \sstusage{
      SETTITLE NDF TITLE
   }
   \sstparameters{
      \sstsubsection{
         NDF = NDF (Read and Write)
      }{
         The NDF data structure whose title is to be modified.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         The value to be assigned to the NDF's title component ({\it e.g.}\
         {\tt "NGC1068 with a B filter"} or {\tt "Ice band in HD123456"}).  This
         value may later be used by other applications as a heading for
         graphs and other forms of display where the NDF's data values
         are plotted.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SETTITLE NGC1068 "NGC1068 with a B filter"
      }{
         Sets the title component of the NDF structure NGC1068 to be
         {\tt "NGC1068 with a B filter"}.
      }
      \sstexamplesubsection{
         SETTITLE NDF=MYSPEC TITLE="Ice band, short integration"
      }{
         Sets the title component of the NDF structure MYSPEC to be
         {\tt "Ice band, short integration"}.
      }
      \sstexamplesubsection{
         SETTITLE DAT123 TITLE=!
      }{
         By specifying a null value ({\tt !}), this example erases any
         previous value of the title component in the NDF structure
         DAT123.
      }
   }
}

\sstroutine{
  SETTYPE
}{
   Sets a new numeric type for the data and variance components of
   an NDF
}{
   \sstdescription{
      This application allows the numeric type of the data and variance
      components of an NDF to be changed. The NDF is accessed in update
      mode and the values stored in these components are converted
      {\it in situ}\ to the new type. No other attributes of the NDF are
      changed.
   }
   \sstusage{
      SETTYPE NDF TYPE
   }
   \newpage
   \sstparameters{
      \sstsubsection{
         COMPLEX = \_LOGICAL (Read)
      }{
         If a {\tt TRUE} value is given for this parameter, then the NDF's
         array components will be altered so that they hold complex
         values, an imaginary part containing zeros being created if
         necessary. If a {\tt FALSE} value is given, then the components will
         be altered so that they hold non-complex values, any imaginary
         part being deleted if necessary. The dynamic default for this
         parameter is chosen so that no change is made to the current
         state. {\tt []}
      }
      \sstsubsection{
         DATA = \_LOGICAL (Read)
      }{
         If a {\tt TRUE} value is given for this parameter, then the numeric
         type of the NDF's data array will be changed.  Otherwise, this
         component's type will remain unchanged. {\tt [TRUE]}
      }
      \sstsubsection{
         NDF = NDF (Read and Write)
      }{
         The NDF data structure whose array components are to have
         their numeric type changed.
      }
      \sstsubsection{
         TYPE = LITERAL (Read)
      }{
         The new numeric type to which the NDF's array components are
         to be converted. The value given should be one of the
         following: {\tt \_DOUBLE}, {\tt \_REAL}, {\tt \_INTEGER}, 
         {\tt \_WORD}, {\tt \_UWORD}, {\tt \_BYTE} or {\tt \_UBYTE}
         (note the leading underscore). Existing pixel values
         stored in the NDF will not be lost, but will be converted to
         the new type. Any values which cannot be represented using the
         new type will be replaced with the bad-pixel value.
      }
      \sstsubsection{
         VARIANCE = \_LOGICAL (Read)
      }{
         If a {\tt TRUE} value is given for this parameter, then the numeric
         type of the NDF's variance array will be changed.  Otherwise,
         this component's type will remain unchanged. {\tt [TRUE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SETTYPE RAWDATA \_REAL
      }{
         Converts the data and variance values held in the NDF data
         structure RAWDATA to have a numeric type of \_REAL ({\it i.e.}\ to be
         stored as single-precision floating-point numbers).
      }
      \sstexamplesubsection{
         SETTYPE INST.RUN1 \_WORD NOVARIANCE
      }{
         Converts the data array in the NDF structure INST.RUN1 to be
         stored as word ({\it i.e.}\ Fortran INTEGER$*$2) values. No change is
         made to the variance component.
      }
      \sstexamplesubsection{
         SETTYPE HD26571 \_DOUBLE COMPLEX
      }{
         Causes the data and variance components of the NDF structure
         HD26571 to be altered so as to hold complex values using
         double precision numbers. The existing pixel values are
         converted to this new type.
      }
   }
   \sstdiytopic{
      Timing
   }{
      The execution time is approximately proportional to the number of
      pixel values to be converted.
   }
}

\sstroutine{
   SETUNITS
}{
   Sets a new units value for an NDF data structure
}{
   \sstdescription{
      This routine sets a new value for the units component of an
      existing NDF data structure. The NDF is accessed in update mode
      and any pre-existing units component is over-written with a new
      value.  Alternatively, if a `null' value ({\tt !}) is given for the
      UNITS parameter, then the NDF's units component will be erased.
   }
   \sstusage{
      SETUNITS NDF UNITS
   }
   \sstparameters{
      \sstsubsection{
         NDF = NDF (Read and Write)
      }{
         The NDF data structure whose units component is to be
         modified.
      }
      \sstsubsection{
         UNITS = LITERAL (Read)
      }{
         The value to be assigned to the NDF's units component ({\it e.g.}\
         {\tt "J/(m**2*Ang*s)"} or {\tt "count/s"}).  This value
         may later be used
         by other applications for labelling graphs and other forms of
         display where the NDF's data values are shown.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SETUNITS NGC1342 "count/s"
      }{
         Sets the units component of the NDF structure NGC1342 to have
         the value {\tt "count/s"}.
      }
      \sstexamplesubsection{
         SETUNITS NDF=SPECT UNITS="J/(m**2*Ang*s)"
      }{
         Sets the units component of the NDF structure SPECT to have
         the value {\tt "J/(m**2*Ang*s)"}.
      }
      \sstexamplesubsection{
         SETUNITS DATAFILE UNITS=!
      }{
         By specifying a null value ({\tt !}), this example erases any
         previous value of the units component in the NDF structure
         DATAFILE.
      }
   }
}

\sstroutine{
   SETVAR
}{
   Sets new values for the variance component of an NDF data
   structure
}{
   \sstdescription{
      This routine sets new values for the variance component of an NDF
      data structure. The data structure is accessed in `update' mode,
      and new variance values are generated from the NDF's data array
      by means of a Fortran-like arithmetic expression.  Any previous
      variance information is over-written with the new values.
      Alternatively, if a `null' value ({\tt !}) is given for the
      variance, then any pre-existing variance information is erased.
   }
   \sstusage{
      SETVAR NDF VARIANCE
   }
   \sstparameters{
      \sstsubsection{
         NDF = NDF (Read and Write)
      }{
         The NDF data structure whose variance values are to be
         modified.
      }
      \sstsubsection{
         VARIANCE = LITERAL (Read)
      }{
         A Fortran-like arithmetic expression giving the variance value
         to be assigned to each pixel in terms of the variable DATA,
         which represents the value of the corresponding data array
         pixel. For example, \%VARIANCE = {\tt "DATA"} implies normal
         $\surd N$ error estimates, whereas \%VARIANCE ={\tt "DATA + 50.7"}
         might be used if a sky background of 50.7 units had previously
         been subtracted.

         If a `null' value ({\tt !}) is given for this parameter, then
         no new variance component will be created and any pre-existing
         variance values will be erased.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SETVAR NGC4709 DATA
      }{
         This sets the variance component within the NDF structure
         NGC4709 to equal its corresponding data-array component.
      }
      \sstexamplesubsection{
         SETVAR NDF=ARCSPEC "DATA - 0.31"
      }{
         This sets the variance component within the NDF structure
         ARCSPEC to be its corresponding data-array component less a
         constant 0.31.
      }
      \sstexamplesubsection{
         SETVAR CUBE4 DATA=!
      }{
         This erases the values of the variance component within
         the NDF structure CUBE4, if it exists.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         All of the standard Fortran 77 intrinsic functions are
         available for use in the variance expression, plus a few others
         (see SUN/61 for details and an up-to-date list).

         \sstitem
         Calculations are performed using real arithmetic (or double
         precision if appropriate) and are constrained to be non-negative.

         \sstitem
         The data type of the variance component is set to match that of
         the data component.
      }
   }
}

\manroutine {{\manheadstyle{SHADOW}}}{ Enhances edges in a 2-d data array
  using a shadow effect.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes the 2-d array in the input {\mantt{IMAGE}} structure,
  and creates an enhanced version of it stored in the data array of the
  output {\mantt{IMAGE}} structure. The enhancement is a shadow effect that
  causes features in an array to appear as though they have been
  illuminated from the side by some imaginary light source. The
  enhancement is useful in locating edges and fine detail in an
  array.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  SHADOW

\newpage
\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the 2-d data array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{XSHIFT}}  }{{\mantt{\_REAL}}}
  Shift in {$x$} co-ordinate to be used in the enhancement. {\mantt [1.0]}
\manparameterentry {{\mantt{READ}} }{{\mantt{YSHIFT}}  }{{\mantt{\_REAL}}}
  Shift in {$y$} co-ordinate to be used in the enhancement. {\mantt [1.0]}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the enhanced data array.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title string for output {\mantt{IMAGE}} structure.
 \mbox{{\mantt ['KAPPA - Shadow']}}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\manroutine {{\manheadstyle{SHIFT}}}{ Realigns a 2-d data array via an
{$x$}-{$y$} shift.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  The data array in the input {\mantt{IMAGE}} structure is shifted, in either
  or both of the {$x$} and {$y$} axes, to produce the new array, in the
  output image structure. The shifts in {$x$} and {$y$} are either input as
  absolute {$x$} and {$y$} shifts by the user, or alternatively, are
  calculated from the co-ordinates of two points provided by the
  user. These are a fiducial point, with co-ordinates {\mantt {\%FIDX}},
  {\mantt {\%FIDY}}, and a standard object, with co-ordinates {\mantt {\%OBJX}},
  {\mantt {\%OBJY}}. The shift in {$x$} is then given by
  {\mantt {\%FIDX}}{$-$}{\mantt {\%OBJX}} and the shift in {$y$} is given by
  {\mantt {\%FIDY}}{$-$}{\mantt {\%OBJY}}. The output data array is padded with
  zeros in the regions not occupied by the shifted input array.  Fractional
  shifts are computed by bilinear interpolation.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  SHIFT

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the 2-d data array to be shifted.
\manparameterentry {{\mantt{READ}} }{{\mantt{STYPE}}  }{{\mantt{\_CHAR}}}
  The sort of shift is to be used. The choice is {\mantt{'Relative'}} or
  {\mantt{'Absolute'}}.
\manparameterentry {{\mantt{READ}} }{{\mantt{ABSX}}  }{{\mantt{\_REAL}}}
  Absolute {$x$} shift in pixels. ({\mantt{Absolute}} shift)
\manparameterentry {{\mantt{READ}} }{{\mantt{ABSY}}  }{{\mantt{\_REAL}}}
  Absolute {$y$} shift in pixels. ({\mantt{Absolute}} shift)
\manparameterentry {{\mantt{READ}} }{{\mantt{FIDX}}  }{{\mantt{\_REAL}}}
  {$x$}-co-ordinate of the fiducial point. ({\mantt{Relative}} shift)
\manparameterentry {{\mantt{READ}} }{{\mantt{FIDY}}  }{{\mantt{\_REAL}}}
  {$y$}-co-ordinate of the fiducial point. ({\mantt{Relative}} shift)
\manparameterentry {{\mantt{READ}} }{{\mantt{OBJX}}  }{{\mantt{\_REAL}}}
  {$x$}-co-ordinate of the standard object. ({\mantt{Relative}} shift)
\manparameterentry {{\mantt{READ}} }{{\mantt{OBJY}}  }{{\mantt{\_REAL}}}
  {$y$}-co-ordinate of the standard object. ({\mantt{Relative}} shift)
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure to contain the 2-d data array after being
  shifted.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Will be used as the {\mantt{TITLE}} component for the output
  {\mantt{IMAGE}} structure. \mbox{{\mantt ['KAPPA - Shift']}}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
  Dave Baines ({\mantt{ROE}}::{\mantt{ASOC5}})
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
\end{manroutinedescription}

\sstroutine{
   SNAPSHOT
}{
   Dumps an image-display memory to a graphics hardcopy and
   optionally to an NDF
}{
   \sstdescription{
      This routine captures the data in the memory of an image-display
      device, and writes these data to a different GKS device.  For
      example, the contents of the Ikon memory might be captured and
      sent to a Canon laser printer.

      Various options are available:
      \begin{itemize}
         \item you may choose to capture a whole or part of what is visible
           on the screen, or the entire contents of the memory.  For the
           former you adjust a rubber-band region until the desired
           area is enclosed. Instructions for controlling the
           rubber-band are given at run time.
         \item A title may be included in the output.
         \item The array may be output to an NDF.
      \end{itemize}
   }
   \sstusage{
      SNAPSHOT ODEVICE [OUT] [WHOLE] [SCALE] [NEGATIV] [TITLE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Input image-display device.  {\tt [}Current image-display 
         device{\tt ]}
      }
      \sstsubsection{
         NEGATIVE = \_LOGICAL (Read)
      }{
         If true, the output hardcopy is a negative version of what is
         stored in the image display.  On some output devices a
         constant dark background can give a non-uniform result, and
         so a negative representation is the default. {\tt [TRUE]}
      }
      \sstsubsection{
         ODEVICE = DEVICE (Read)
      }{
         Name of the output device.  The suggested default is the
         current graphics device and CANON\_L if there is no current
         device.  The device must be in the GNS category
         MATRIX\_PRINTER, and have at least 24 greyscale intensities.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Name given to the output NDF data structure used to store the
         contents of the image-display memory.  If it is null ({\tt !}) no
         NDF will be created. {\tt [!]}
      }
      \sstsubsection{
         SCALE = \_REAL (Read)
      }{
         Scale factor for output.  Unity gives the largest possible
         output, but it takes longest to compute and print (goes as the
         square of the scale factor). On the other hand unity does
         provide maximum resolution. SCALE must be between 0 and 1.
         {\tt [0.707]}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title of the plot and the output NDF.  There is only space on
         the plot for about 25 characters in the title.  If it is null
         ({\tt !}) no title will be plotted, and the title in the output NDF
         becomes {\tt 'KAPPA - Snapshot'}. {\tt [!]}
      }
      \sstsubsection{
         WHOLE = \_LOGICAL (Read)
      }{
         If true, the whole image-display memory is recorded, otherwise
         a selected region of what is visible on the screen is plotted.
         Dumping the whole memory can require considerable disk space
         for work arrays and the output NDF. {\tt [FALSE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SNAPSHOT WHOLE
      }{
         This will dump the whole of the current image display's memory
         to the CANON\_L device.
      }
      \sstexamplesubsection{
         SNAPSHOT SCALE=1.0
      }{
         This will capture a the whole or part of what is visible on
         the screen of the current image display and dump it to the
         CANON\_L device at the largest magnification.
      }
      \sstexamplesubsection{
         SNAPSHOT POSTSCRIPT VIEWS DEVICE=IKON WHOLE
      }{
         This dumps the whole of the Ikon's memory to the Postscript
         device, and also to a NDF called VIEWS.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The whole of the screen and the whole of the memory may be
         different, for example, the image may have been zoomed or panned.

         \sstitem
         Files are not spooled to laserprinters.  They must be printed
         outside this application.
      }
   }
   \sstimplementationstatus{
      No origin information is passed to the output NDF.
   }
}

\manroutine {{\manheadstyle{SQORST}}}{ Squashes or stretches a 2-d
  data array in either or both axes.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  The output data array, written to an {\mantt{IMAGE}} structure, is produced
  by either squashing or stretching the 2-d data array, in the input
  {\mantt{IMAGE}} structure, in either or both of the {$x$} and {$y$} axes.
  The dimensions of the output data array, are given by the user. The
  stretching is performed by keeping the edge pixels fixed and
  calculating the intervening pixels by bi-linear interpolation. The
  squashing is performed by calculating each pixel in the output
  array as the mean of the corresponding pixels in the input array.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  SQORST

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the 2-d data array to be squashed
  or stretched.
\manparameterentry {{\mantt{READ}} }{{\mantt{XDIM}}  }{{\mantt{\_INTEGER}}}
  First dimension for the output 2-d data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{YDIM}}  }{{\mantt{\_INTEGER}}}
  Second dimension for the output 2-d data array.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure to contain the 2-d data array after being
  squashed or stretched.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Will form the {\mantt{TITLE}} component for the output {\mantt{IMAGE}}
  structure. \mbox{{\mantt ['KAPPA - Sqorst']}}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
  Dave Baines ({\mantt{ROE}}::{\mantt{ASOC5}})
\end{manroutinedescription}

\sstroutine{
   STATS
}{
   Computes simple statistics for an NDF's pixels
}{
   \sstdescription{
      This application computes and displays simple statistics for the
      pixels in an NDF's data, quality or variance array. The
      statistics available are:
      \sstitemlist{

         \sstitem
         The pixel sum.

         \sstitem
         The pixel mean.

         \sstitem
         The pixel standard deviation.

         \sstitem
         The value and position of the minimum- and maximum-valued
         pixels.

         \sstitem
         The total number of pixels in the NDF.

         \sstitem
         The number of pixels used in the statistics.

         \sstitem
         The number of pixels omitted.

      }
      Iterative $\kappa$-sigma clipping may also be applied as an option.
   }
   \sstusage{
      STATS NDF [COMP] [CLIP] [LOGFILE]
   }
   \sstparameters{
      \sstsubsection{
         CLIP( ) = \_REAL (Read)
      }{
         An optional 1-dimensional array of clipping levels to be
         applied, expressed as standard deviations.  If a null value is
         supplied for this parameter (the default), then no iterative
         clipping will take place and the statistics computed will
         include all the valid NDF pixels.

         If an array of clipping levels is given, then the routine will
         first compute statistics using all the available pixels. It
         will then reject all those pixels whose values lie outside
         $\kappa$ standard deviations of the mean (where $\kappa$ is
         the first value
         supplied) and will then re-evaluate the statistics. This
         rejection iteration is repeated in turn for each value in the
         CLIP array.  A maximum of 5 values may be supplied, all of
         which must be positive. {\tt [!]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The name of the NDF array component for which statistics are
         required: {\tt "Data"}, {\tt "Error"}, {\tt "Quality"} or
         {\tt "Variance"} (note that {\tt "Error"} is the alternative
         to {\tt "Variance"} and causes the square root of the variance
         values to be taken before computing the statistics). If
         {\tt "Quality"} is specified, then the quality values are treated
         as numerical values (in the range 0 to 255). {\tt ["Data"]}
      }
      \sstsubsection{
         LOGFILE = FILE (Write)
      }{
         A text file into which the results should be logged. If a null
         value is supplied (the default), then no logging of results
         will take place. {\tt [!]}
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         The NDF data structure to be analysed.
      }
      \sstsubsection{
         NUMBAD = \_INTEGER (Write)
      }{
         The number of pixels which were either not valid or were
         rejected from the statistics during iterative K-sigma
         clipping.
      }
   }
   \newpage
   \sstresparameters{
      \sstsubsection{
         MAXCOORD( ) = \_DOUBLE (Write)
      }{
         A 1-dimensional array of values giving the user coordinates of
         the centre of the (first) maximum-valued pixel found in the
         NDF array. The number of coordinates is equal to the number of
         NDF dimensions.
      }
      \sstsubsection{
         MAXIMUM = \_DOUBLE (Write)
      }{
         The maximum pixel value found in the NDF array.
      }
      \sstsubsection{
         MAXPOS( ) = \_INTEGER (Write)
      }{
         A 1-dimensional array of pixel indices identifying the (first)
         maximum-valued pixel found in the NDF array. The number of
         indices is equal to the number of NDF dimensions.
      }
      \sstsubsection{
         MEAN = \_DOUBLE (Write)
      }{
         The mean value of all the valid pixels in the NDF array.
      }
      \sstsubsection{
         MINCOORD( ) = \_DOUBLE (Write)
      }{
         A 1-dimensional array of values giving the user coordinates of
         the centre of the (first) minimum-valued pixel found in the
         NDF array. The number of coordinates is equal to the number of
         NDF dimensions.
      }
      \sstsubsection{
         MINIMUM = \_DOUBLE (Write)
      }{
         The minimum pixel value found in the NDF array.
      }
      \sstsubsection{
         MINPOS( ) = \_INTEGER (Write)
      }{
         A 1-dimensional array of pixel indices identifying the (first)
         minimum-valued pixel found in the NDF array. The number of
         indices is equal to the number of NDF dimensions.
      }
      \sstsubsection{
         NUMGOOD = \_INTEGER (Write)
      }{
         The total number of pixels in the NDF (both good and bad).
      }
      \sstsubsection{
         NUMPIX = \_INTEGER (Write)
      }{
         The number of NDF pixels which actually contributed to the
         computed statistics.
      }
      \sstsubsection{
         SIGMA = \_DOUBLE (Write)
      }{
         The standard deviation of the pixel values in the NDF array.
      }
      \sstsubsection{
         TOTAL = \_DOUBLE (Write)
      }{
         The sum of the pixel values in the NDF array.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         STATS IMAGE
      }{
         Computes and displays simple statistics for the data array in
         the NDF called IMAGE.
      }
      \sstexamplesubsection{
         STATS NDF=SPECTRUM VARIANCE
      }{
         Computes and displays simple statistics for the variance array
         in the NDF called SPECTRUM.
      }
      \sstexamplesubsection{
         STATS SPECTRUM ERROR
      }{
         Computes and displays statistics for the variance array in the
         NDF called spectrum, but takes the square root of the variance
         values before doing so.
      }
      \sstexamplesubsection{
         STATS HALLEY LOGFILE=STATS.DAT
      }{
         Computes statistics for the data array in the NDF called
         HALLEY, and writes the results to a logfile called STATS.DAT.
      }
      \sstexamplesubsection{
         STATS NGC1333 CLIP=[3.0,2.8,2.5]
      }{
         Computes statistics for the data array in the NDF called
         NGC1333, applying three iterations of $\kappa$-sigma clipping. The
         statistics are first calculated for all the valid pixels in
         the data array.  Those pixels with values lying more than 3.0
         standard deviations from the mean are then rejected, and the
         statistics are re-computed. This process is then repeated
         twice more, rejecting pixel values lying more than 2.8 and 2.5
         standard deviations from the mean.  The final statistics are
         displayed.
      }
   }
   \sstimplementationstatus{
      The following NDF features are supported by this application:
      \sstitemlist{

         \sstitem
         The DATA, VARIANCE and QUALITY arrays (the TITLE and AXIS
         components are also used).

         \sstitem
         Bad-pixel handling, including automatic quality masking.

         \sstitem
         All non-complex numeric types.

         \sstitem
         Any number of NDF dimensions.
      }
   }
}

\manroutine {{\manheadstyle{STATS2D}}}{ Computes simple statistics for a 2-d data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine takes the 2-d data array in the input {\mantt{IMAGE}}
  structure, and outputs information about that array, including
  dimensions, total, mean, maximum, minimum, and standard
  deviation. The region analysed is a sub-array of specified size
  and position.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  STATS2D

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{LOGFILE}} }{{\mantt{FILENAME}}}
  Name of the ASCII file to record the statistics. If null,
  there will be no logging. {\mantt [!]}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the 2-d data array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{XSTART}} }{{\mantt{\_INTEGER}}}
  {$x$} start pixel index of the sub-array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{YSTART}} }{{\mantt{\_INTEGER}}}
  {$y$} start pixel index of the sub-array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{XSIZE}}  }{{\mantt{\_INTEGER}}}
  {$x$} size of the sub-array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{YSIZE}}  }{{\mantt{\_INTEGER}}}
  {$y$} size of the sub-array to be analysed.
\manparameterentry {{\mantt{READ}} }{{\mantt{AGAIN}}  }{{\mantt{\_LOGICAL}}}
  Whether or not another the sub-array is to be analysed.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{NUMPIX}} }{{\mantt{\_INTEGER}}}
  Number of pixels in the last-chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{NUMBAD}} }{{\mantt{\_INTEGER}}}
  Number of bad pixels in the last-chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MAXIMUM}} }{{\mantt{\_REAL}}}
  Maximum value in the last-chosen section.
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MAXPOS( 2 )}} }{{\mantt{\_INTEGER}}}
  {$x$},{$y$} indices of the pixel with the maximum value in the
  last-chosen section. 
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MINIMUM}} }{{\mantt{\_REAL}}}
  Minimum value in the last-chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MINPOS( 2 )}} }{{\mantt{\_INTEGER}}}
  {$x$},{$y$} indices of the pixel with the minimum value in the
  last-chosen section. 
\manparameterentry {{\mantt{WRITE}} }{{\mantt{TOTAL}} }{{\mantt{\_REAL}}}
  The total of pixel values in the last-chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{MEAN}} }{{\mantt{\_REAL}}}
  The mean of pixel values in the last-chosen section.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{SIGMA}} }{{\mantt{\_REAL}}}
  The standard deviation of pixel values in the last-chosen section.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

\sstroutine{
   SUB
}{
   Subtracts one NDF data structure from another
}{
   \sstdescription{
      The routine subtracts one NDF data structure from another
      pixel-by-pixel to produce a new NDF.
   }
   \sstusage{
      SUB IN1 IN2 OUT
   }
   \sstparameters{
      \sstsubsection{
         IN1 = NDF (Read)
      }{
         First NDF, from which the second NDF is to be subtracted.
      }
      \sstsubsection{
         IN2 = NDF (Read)
      }{
         Second NDF, to be subtracted from the first NDF.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Output NDF to contain the difference of the two input NDFs.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Value for the title of the output NDF. A null value will cause
         the title of the NDF supplied for parameter IN1 to be used
         instead. {\tt ['KAPPA - Sub']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SUB A B C
      }{
         This subtracts the NDF called B from the NDF called A, to make
         the NDF called C.  C has title {\tt "KAPPA - Sub"}.
      }
      \sstexamplesubsection{
         SUB OUT=C IN1=A IN2=B TITLE="Background subtracted"
      }{
         This subtracts the NDF called B from the NDF called A, to make
         the NDF called C.  C has the title {\tt "Background subtracted"}.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the two input NDFs have different pixel-index bounds, then
         they will be trimmed to match before being subtracted. An error
         will result if they have no pixels in common.

         \sstitem
         This routine correctly processes the AXIS, DATA, QUALITY,
         LABEL, TITLE and VARIANCE components of an NDF data structure and
         propagates all extensions. Bad pixels and all non-complex numeric
         data types can be handled.

         \sstitem
         The HISTORY component is simply propagated without change, if
         present.

         \sstitem
         Units processing is not supported at present and therefore the
         the UNITS component is not propagated.
      }
   }
}

\manroutine {{\manheadstyle{SURFIT}}}{ Fits a polynomial or spline surface to 2-d data %
array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  The background of a 2-d data array in the input {\mantt{IMAGE}}
  structure is estimated by condensing the array into equally-sized
  rectangular bins, fitting a spline or polynomial surface to the bin values,
  and finally evaluating the surface for each pixel in the data array.

  There is a selection of estimators by which representative
  values for each bin are determined. There are several options to
  make the fit more accurate.  Values beyond upper and lower
  thresholds may be excluded from the binning.  Bad pixels are also
  excluded, so prior masking may help to find the background more
  rapidly.  {$\kappa$}-{$\sigma$} clipping of the fitted bins is available
  so that the fit is not biased by anomolous bins, such as those
  entirely within an extended object.  If a given bin contains more
  than a prescribed fraction of bad pixels, it is excluded from the
  fit.

  The data array representing the background is evaluated at each
  pixel by one of two methods.  It is written to the output {\mantt{IMAGE}}
  structure.

  The raw binned data, the weights, the fitted binned data and the
  residuals to the fit may be written to a logfile.  This also
  keeps a record of the input parameters and the rms error of the
  fit.

  The magic-value method is used for processing bad data.

\manroutineitem {Invocation }{}
  SURFIT

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure containing the 2-d data array to be smoothed.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  {\mantt{IMAGE}} structure to contain the 2-d data array after smoothing.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Will be used as the {\mantt{TITLE}} component of the output
  {\mantt{IMAGE}} structure. \mbox{\mantt ['KAPPA - Surfit']}
\manparameterentry {{\mantt{READ}} }{{\mantt{LOGFILE}} }{{\mantt{FILENAME}}}
  Name of the file to log the binned array and errors before
  and after fitting.  If null, there will be no logging. {\mantt{[!]}}
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{ESTIMATOR}} }{{\mantt{\_CHAR}}}
  The estimator for the bin.  It must one of the following values:
  {\mantt{'MEAN'}} for the mean value, {\mantt{'KSIGMA'}} for the mean
  with {$\kappa$}-{$\sigma$} clipping; {\mantt{'MODE'}} for the mode, and
  {\mantt{'MEDIAN'}} for the median. If it is none of these, the mode is
  used. {\mantt ['Mode']}
\manparameterentry {{\mantt{READ}} }{{\mantt{CLIP}} }{{\mantt{\_REAL}}}
  Array of limits for progressive clipping of pixel values
  during the binning process in units of standard deviation.
  A null value means only unclipped statistics are computed
  and presented. Between 1 and 5 values may be supplied. {\mantt{[2,3]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{FITTYPE}} }{{\mantt{\_CHAR}}}
  The type of fit.  It must be either {\mantt{'POLYNOMIAL'}} for a
  polynomial or {\mantt{'SPLINE'}} for a bi-cubic spline. {\mantt ['Spline']}
\manparameterentry {{\mantt{READ}} }{{\mantt{NXPAR}} }{{\mantt{\_INTEGER}}}
  The number of fitting parameters to be used in the {$x$}
  direction.  It must be in the range 1 to 15 for a polynomial
  fit, and 4 to 15 for a bi-cubic-spline fit. Thus 1 gives
  a constant, 2 a linear fit, 3 a quadratic {\it etc.}\ Increasing this
  parameter increases the flexibility of the surface in the {$x$}
  direction. {\mantt{[4]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{NYPAR}} }{{\mantt{\_INTEGER}}}
  The number of fitting parameters to be used in the {$y$}
  direction.  It must be in the range 1 to 15 for a polynomial
  fit, and 4 to 15 for a bi-cubic-spline fit. Thus 1 gives
  a constant, 2 a linear fit, 3 a quadratic {\it etc.}\ Increasing this
  parameter increases the flexibility of the surface in the {$y$}
  direction. {\mantt{[4]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{IX}} }{{\mantt{\_INTEGER}}}
  The size in columns of a bin used to estimate the local background.
  {\mantt{[}}{$x$} dimension / 32 {\mantt{]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{IY}} }{{\mantt{\_INTEGER}}}
  The size in lines of a bin used to estimate the local background.
  {\mantt{[}}{$y$} dimension / 32 {\mantt{]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{WLIMIT}} }{{\mantt{\_REAL}} }
  The minimum fraction of good pixels in a bin that permits
  the bin to be included in the fit.  Here good pixels are
  ones that participated in the calculation of the bin's
  representative value. So they exclude both bad pixels and
  ones rejected during estimation ({\it e.g.}\ ones beyond the
  thresholds or were clipped). {\mantt{[0.3]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{THRLO}} }{{\mantt{\_REAL}}}
  Lower threshold below which values will be excluded from the
  analysis to derive representative values for the bins.  If
  it is {\mantt{!}} there will be no lower threshold. {\mantt{[!]}} 
\manparameterentry {{\mantt{READ}} }{{\mantt{THRHI}} }{{\mantt{\_REAL}}}
  Upper threshold above which values will be excluded from the
  analysis to derive representative values for the bins.  If
  it is {\mantt{!}} there will be no upper threshold. {\mantt{[!]}} 
\manparameterentry {{\mantt{READ}} }{{\mantt{FITCLIP}} }{{\mantt{\_REAL}}}
  Array of limits for progressive clipping of the binned array
  in units of the rms deviation of the fit.  A null value ({\mantt{!}})
  means no clipping of the binned array will take place.
  Between 1 and 5 values may be supplied. {\mantt{[!]}} 
\end{manparametertable}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{EVALUATE}} }{{\mantt{\_CHAR}}}
  The method by which the resulting data array is to be
  evaluated from the surface-fit.  It must be either
  {\mantt{'INTERPOLATE'}} where the values at the corners of the bins
  are derived first, and then the pixel values are found by
  linear interpolation within those bins; or {\mantt{'ALL'}} where the
  surface-fit is evaluated for every pixel.  The latter is
  slower, but can produce more-accurate results, unless the
  surface is not well behaved. {\mantt{['INTERPOLATE']}} 
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known

\manroutineitem {Authors }{}
  Malcolm J. Currie ~STARLINK ( {\mantt {RAL}}::{\mantt {CUR}} )

\end{manroutinedescription}

\manroutine {{\manheadstyle{THRESH}}}{ Creates a thresholded version of a
  data array (new values for pixels outside defined thresholds are specified).}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  A thresholded version of the data array, contained in the input
  {\mantt{IMAGE}} structure, is written to the new data array, stored in
  the output {\mantt{IMAGE}} structure. There are upper and lower limits
  for the thresholding. Any values in the input data array above
  the upper threshold will be set to one user-specified value, and
  anything below the lower threshold will be set set to another
  user-specified value, in the output data array.

\manroutineitem {Invocation }{}
  THRESH

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array to be
  thresholded.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the thresholded version of
  the data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure.
 \mbox{{\mantt ['KAPPA - Thresh']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{THRLO}}  }{{\mantt{\_REAL}}}
  This value defines the lower threshold.
\manparameterentry {{\mantt{READ}} }{{\mantt{THRHI}}  }{{\mantt{\_REAL}}}
  This value defines the upper threshold.
\manparameterentry {{\mantt{READ}} }{{\mantt{NEWLO}}  }{{\mantt{LITERAL}}}
  This defines the value to which all numbers below {\mantt{\%THRLO}} are
  set.  If this is set to {\mantt{'Bad'}} the magic-value is used.
\manparameterentry {{\mantt{READ}} }{{\mantt{NEWHI}}  }{{\mantt{LITERAL}}}
  This defines the value to which all numbers above {\mantt{\%THRHI}} are
  set.  If this is set to {\mantt{'Bad'}} the magic-value is used.
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
  D.W.T.Baines ({\mantt{ROE}}::{\mantt{ASOC5}})
\end{manroutinedescription}

\manroutine {{\manheadstyle{THRESH0}}}{ Creates a thresholded version
  of a data array (every value outside the defined thresholds is set to zero).}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  A thresholded version of the data array, contained in the input
  {\mantt{IMAGE}} structure, is written to the new data array, stored in
  the output {\mantt{IMAGE}} structure. There are upper and lower limits
  for the thresholding. Any values in the input data array above
  the upper threshold and anything below the lower threshold will
  be set set to zero, in the output data array.

\manroutineitem {Invocation }{}
  THRESH0

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}}  }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array to be
  thresholded.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}}  }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the thresholded version of
  the data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}}  }{{\mantt{\_CHAR}}}
  Title for the output {\mantt{IMAGE}} structure.
 \mbox{{\mantt ['KAPPA - Thresh0']}}
\manparameterentry {{\mantt{READ}} }{{\mantt{THRLO}}  }{{\mantt{\_REAL}}}
  This value defines the lower threshold.
\manparameterentry {{\mantt{READ}} }{{\mantt{THRHI}}  }{{\mantt{\_REAL}}}
  This value defines the upper threshold.
\manparameterentry {{\mantt{READ}} }{{\mantt{NEWLO}}  }{{\mantt{\_REAL}}}
  This defines the value to which all numbers below {\mantt{\%THRLO}} are
  set. \mbox{{\mantt [0.0]}}
\manparameterentry {{\mantt{READ}} }{{\mantt{NEWHI}}  }{{\mantt{\_REAL}}}
  This defines the value to which all numbers above {\mantt{\%THRHI}} are
  set. \mbox{{\mantt [0.0]}}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
  D.W.T.Baines ({\mantt{ROE}}::{\mantt{ASOC5}})
\end{manroutinedescription}

\sstroutine{
   TRANDAT
}{
   Converts free-format ASCII data into an NDF
}{
   \sstdescription{
      This application takes grid data contained in a free-format ASCII
      file and stores them in the data array of an NDF.  The data file
      could contain, for example, mapping data  or results from
      simulations which are to be converted into an image for analysis.

      There are two modes of operation which depend on whether the
      ASCII file contains co-ordinate information, or just solely data
      values.

      a)  If the file contains co-ordinate information the format
      of the data is tabular; the positions and values are arranged in
      columns and a record may contain information for only a single
      point.  Where data points are duplicated only the last value
      appears in the NDF.  Comment lines can be given, and are
      indicated by a hash or exclamation mark in the first column.
      Here is an example file (the vertical ellipses indicate missing
      lines in the file):
{\tt \begin{verse}
          \# Model 5, phi = 0.25,  eta = 1.7 \\
          1 -40.0   40.0   1121.9 \\
          2  0.0   30.0     56.3 \\
          3 100.0   20.0   2983.2 \\
          4 120.0   85.0    339.3 \\
          . ~. ~~. ~ .   \\
          . ~. ~~. ~ .   \\
          . ~. ~~. ~ .   \\
          <EOF>
\end{verse}}

      The records do not need to be ordered (but see the warning in the
      Notes), as the application searches for the maximum and minimum
      co-ordinates in each dimension so that it can define the size of
      the output image.  Also, each record may contain other data
      fields (separated by one or more spaces), which need not be all
      the same data type.  In the example above only columns 2, 3 and 4
      are required.  The distance between adjacent pixels is in the
      same units as the read-in co-ordinates.

      You are informed of the number of points found and the maximum
      and minimum co-ordinate values for each dimension.  There is no
      limit imposed by the application on the number of points or the
      maximum output array size, though there may be external
      constraints.  The derived array size is reported in case you have
      made a typing error in the ASCII file.  If you realise that this
      has indeed occurred just abort ({\tt !!}) when prompted for the output
      NDF.

      b) If the ASCII file contains no co-ordinates, the format is
      quite flexible, however, the data are read into the data array
      in Fortran order, {\it i.e.}\ the first dimension is the most rapidly
      varying, followed by the second dimension and so on.  The number
      of data values that may appear on a line is variable; data values
      are separated by at least a space, comma, tab or carriage return.
      A line can have up to 255 characters.  In addition a record may
      have trailing comments designated by a hash or exclamation mark.
      Here is an example file, though a more regular format would be
      clearer for the human reader.
{\tt \begin{verse}
          \# test for the new TRANDAT \\
          23 45.3 ! a comment \\
          50.7,47.5 120. 46.67  47.89 42.4567 \\
          .1 23.3 45.2 43.2  56.0 30.9 29. 27. 26. 22.4 20. 18. -12. 8. \\
           9.2 11. \\
          <EOF>
\end{verse}}

      Notice that the shape of the NDF is defined by a parameter rather
      than explicitly in the file.
   }
   \sstusage{
      TRANDAT FREENAME OUT [POSCOLS] [VALCOL] [PSCALE] [DTYPE] [TITLE]
   }
   \sstparameters{
      \sstsubsection{
         AUTO = \_LOGICAL (Read)
      }{
         If true the ASCII file does not contain co-ordinate
         information. {\tt [FALSE]}
      }
      \sstsubsection{
         BAD = \_LOGICAL (Read)
      }{
         If true the output NDF data array is initialised with the
         bad value, otherwise it is filled with zeroes. {\tt [TRUE]}
      }
      \sstsubsection{
         DTYPE = LITERAL (Read)
      }{
         The HDS type of the data values within the ASCII file, and
         the type of the data array in the output NDF. The options
         are: {\tt '\_REAL'}, {\tt '\_DOUBLE'}, {\tt '\_INTEGER'},
         {\tt '\_BYTE'}, {\tt '\_UBYTE'}, {\tt '\_WORD'}, {\tt '\_UWORD'}.
         (Note the leading underscore.) {\tt ['\_REAL']}
      }
      \sstsubsection{
         FREENAME = FILENAME (Read)
      }{
         Name of the ASCII file containing the free-format data.  It
         has a default extension of .DAT.
      }
      \sstsubsection{
         POSCOLS = \_INTEGER (Read)
      }{
         Column positions of the co-ordinates in an input record
         of the ASCII file, starting from $x$ to higher dimensions.  It
         is only used in co-ordinate mode.  The columns must be
         different amongst themselves and also different from the
         column containing the values.  If there is duplication
         new values for both POSCOLS and VALCOL will be requested.
         {\tt [1,2]}
      }
      \sstsubsection{
         PSCALE() = \_REAL (Read)
      }{
         Pixel-to-pixel distance in co-ordinate units for each
         dimension.  It is only used in co-ordinate mode.  Its purpose
         is to permit linear scaling from some arbitrary units to
         pixels. {\tt [}1.0 in each co-ordinate dimension{\tt ]}
      }
      \sstsubsection{
         QUANTUM = \_INTEGER (Read)
      }{
         You can safely ignore this parameter.  It is used for fine-
         tuning performance in the co-ordinate mode.

         The application obtains work space to store the position-value
         data before they can be copied into the output NDF so that the
         array bounds can be computed.  Since the number of lines in
         the ASCII file is unknown, the application obtains chunks of
         work space whose size is three times this parameter whenever
         it runs out of storage.  (Three because the parameter
         specifies the number of lines in the file rather than the
         number of data items.)  If you have a large number of points
         there are efficiency gains if you make this parameter either
         about 20--30 per cent or slightly greater than or equal to the
         number of lines your ASCII file.  A value slightly less than
         the number of lines is inefficient as it creates nearly 50 per
         cent unused space.  A value that is too small can cause
         unnecessary unmapping, expansion and re-mapping of the work
         space.  For most purposes the default should give acceptable
         performance. It must lie between 32 and 2097152. {\tt [2048]}
      }
      \sstsubsection{
         SHAPE = \_INTEGER (Read)
      }{
         The shape of the NDF to be created. For example, {\tt [50,30,20]}
         would create 50 columns by 30 lines by 10 bands.  It is only
         accessed in automatic mode.
      }
      \sstsubsection{
         NDF = NDF (Write)
      }{
         Output NDF for the generated data array.
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output NDF. {\tt ['KAPPA - Trandat']}
      }
      \sstsubsection{
         VALCOL = \_INTEGER (Read)
      }{
         Column position of the array values in an input record of
         the ASCII file.  It is only used in co-ordinate mode.  The
         column position must be different from those specified for
         the co-ordinate columns.  If there is duplication new values
         for both POSCOLS and VALCOL will be requested. {\tt [3]}
      }
   }
   \newpage
   \sstexamples{
      \sstexamplesubsection{
         TRANDAT SIMDATA MODEL
      }{
         Reads the ASCII file SIMDATA.DAT and stores the data into the
         data array of a two-dimensional, \_REAL NDF called MODEL.  The
         input file should have the co-ordinates and real values
         arranged in columns, with the $x$-$y$ positions in columns 1 and 2
         respectively, and the real data in column 3.
      }
      \sstexamplesubsection{
         TRANDAT FREENAME=SIMDATA OUT=MODEL AUTO SHAPE=[50,40,9]
      }{
         Reads the ASCII file SIMDATA.DAT and stores the data into the
         data array of a three-dimensional, \_REAL NDF called MODEL.
         It's $x$ dimension is 50, $y$ is 40 and $z$ is 9. The input file only
         contains real values and comments.
      }
      \sstexamplesubsection{
         TRANDAT FREENAME=SIMDATA OUT=MODEL AUTO SHAPE=[50,40,9] DTYPE=\_I
      }{
         As the previous example except an \_INTEGER NDF is created, and
         the ASCII file must contain integer data.
      }
      \sstexamplesubsection{
         TRANDAT SIMDATA MODEL [6,3,4] 2
      }{
         Reads the ASCII file SIMDATA.DAT and stores the data into the
         data array of a three-dimensional, \_REAL NDF called MODEL. The
         input file should have the co-ordinates and real values
         arranged in columns, with the $x$-$y$-$z$ positions in columns 6, 3
         and 4 respectively, and the real data in column 2.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         All non-complex numeric data types can be handled.  However,
         byte, unsigned byte, word and unsigned word require data
         conversion, and therefore involve additional processing.
         to a vector element (for $n$-d generality).

         \sstitem
         {\bf WARNING:} In non-automatic mode it is strongly advisable for
         large output NDFs to place the data in Fortran order, {\it i.e.}\ the
         first dimension is the most rapidly varying, followed by the
         second dimension and so on.  This gives optimum performance.  The
         meaning of `large' will depend on working-set quotas on your
         system, but a few megabytes gives an idea.  If you jump randomly
         backwards and forwards, or worse, have an ASCII file in
         reverse-Fortran order, this can have disastrous performance
         consequences for you and other users.

         \sstitem
         In non-automatic mode, the co-ordinates for each dimension are
         stored in the NDF axis structure.  The first centre is at the
         minimum value found in the list of positions for the dimension
         plus half of the scale factor.  Subsequent centres are
         incremented by the scale factor.

         \sstitem
         The output NDF may have between one and seven dimensions.

         \sstitem
         In automatic mode, an error is reported if the shape does not
         use all the data points in the file.
      }
   }
}

\manroutine {{\manheadstyle{TRIG}}}{ Performs a trigonometric
  transformation on a data array.}
\begin{manroutinedescription}
\manroutineitem {Description }{}
  This routine allows the user to select one of a set of several
  basic trigonometrical functions (sine, cosine, tangent, arcsine,
  {\it etc.}) and operate on each pixel of the data array, in the input
  {\mantt{IMAGE}} structure, with this function, and then to output a
  transformed version of the array. The trigonometric functions can
  be selected to act as if the input data are to be treated as
  radians or degrees. If a scalar value rather than a data array is
  input, the application acts purely on that scalar value.

  The magic-value method is used for processing bad data.  Undefined
  results are set to the magic value.

\manroutineitem {Invocation }{}
  TRIG

\manroutineitem {Parameters }{}
\begin{manparametertable}
\manparameterentry {{\mantt{READ}} }{{\mantt{INPIC}} }{{\mantt{IMAGE}}}
  Input {\mantt{IMAGE}} structure containing the data array to be
  transformed.
\manparameterentry {{\mantt{READ}} }{{\mantt{TRIGFUNC}} }{{\mantt{\_CHAR}}}
  Trigonometrical function to be applied.  The options are {\mantt {SIN}},
  {\mantt {COS}}, {\mantt {TAN}}, {\mantt {SIND}}, {\mantt {COSD}},
  {\mantt {TAND}}, {\mantt {ASIN}}, {\mantt {ACOS}}, {\mantt {ATAN}},
  {\mantt {ASIND}}, {\mantt {ACOSD}}, {\mantt {ATAND}}.
\manparameterentry {{\mantt{WRITE}} }{{\mantt{OUTPIC}} }{{\mantt{IMAGE}}}
  Output {\mantt{IMAGE}} structure containing the transformed data array.
\manparameterentry {{\mantt{READ}} }{{\mantt{OTITLE}} }{{\mantt{\_CHAR}}}
  Title string for the output {\mantt{IMAGE}} structure.
 \mbox{{\mantt ['KAPPA - Trig']}}
\end{manparametertable}
\manroutineitem {Bugs }{}
  None known.

\manroutineitem {Authors }{}
  Mark McCaughrean UoE ( {\mantt REVA}::{\mantt MJM} )
  Malcolm J. Currie ~STARLINK \mbox{( {\mantt RAL}::{\mantt CUR} )}
\end{manroutinedescription}

 
 
\sstroutine{
   TURBOCONT
}{
   Contours a 2-d NDF quickly
}{
   \sstdescription{
      This application draws a contour plot of a 2-d NDF on the current
      graphics device via an efficient algorithm.  The image may be
      part or whole of the data array, but also the variance or quality
      can be shown.  The plot is situated within the current
      graphics-database picture.

      The contour plot resides within optional, annotated and enumerated
      axes.  An optional, but recommended, key may be drawn to the
      right of the contour plot.  It reports the NDF's units if there
      are any, and only contour heights actually plotted are included.
      There are five methods for selecting contours.
   }
   \sstusage{
      TURBOCONT NDF [COMP] MODE NCONT [KEY] [DEVICE]
        $\left\{ {\begin{tabular}{l}
                    FIRSTCNT=? STEPCNT=? \\
                    HEIGHTS=?
                   \end{tabular} }
        \right.$
        \newline\hspace*{23.3em}
        \makebox[0mm][c]{\small mode}
   }
   \sstparameters{
      \sstsubsection{
         ANNOTA = \_LOGICAL (Read)
      }{
         If true the contour lines will be annotated with a contour
         number corresponding to the key entry.  It is ignored if there
         no key is selected. {\tt [FALSE]}
      }
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         True if the graphics device is to be cleared before display
         of the array. {\tt [TRUE]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be {\tt "Data"},
         {\tt "Quality"} or {\tt "Variance"}. {\tt ["Data"]}
      }
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either {\tt "WORLD"}
         or {\tt "DATA"}.  {\tt "WORLD"} makes pixel co-ordinates to appear on axes.
         If COSYS = {\tt "DATA"} the NDF's axis information is used to
         annotate axes.  {\tt [}Current co-ordinate system{\tt ]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device. {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         FIRSTCNT = \_REAL (Read)
      }{
         Height of the first contour (Linear and Magnitude modes).
      }
      \sstsubsection{
         HEIGHTS() = \_REAL (Read)
      }{
         Contour levels (Free mode).
      }
      \sstsubsection{
         KEY = \_LOGICAL (Read)
      }{
         A key of the contour level versus pixel value is to be
         produced. {\tt [TRUE]}
      }
      \sstsubsection{
         MAXRES = \_LOGICAL (Read)
      }{
         If true the contours are interpolated to the resolution of the
         plotting device, {\it i.e.}\ provides sub-pixel resolution, otherwise
         straight-line segments at pixel resolution are drawn. The
         latter does not give smooth contours, but this makes the
         processing much faster.  The former draws smoother contours to
         the resolution of the graphics workstation, but they still
         have vertices. If you require smooth well-rounded contours try
         the slower CONTOUR. {\tt [FALSE]}
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The type of method to selected contour levels.  The options
         are :
         \begin{description}
           \item [Free]      - The user defines a series of contour values.
           \item [Automatic] - The specified number of contours are equally
                         spaced between the maximum and minimum pixel
                         values in the sub-array.
           \item [Area]      - Contours enclose areas of the sub-array for
                         which the equivalent radius increases by equal
                         increments.
           \item [Linear]    - The user defines the number of contours, the
                         start contour level and linear step
                         between contours.
           \item [Magnitude] - The user defines the number of contours, the
                         start contour level and step between contours.
                         The step size is in magnitudes so the $n^{\rm th}$
                         contour is 10$^{-0.4*(n-1)*{\rm step}}$ times the
                         start contour level.
         \end{description}
      }
      \sstsubsection{
         NCONT = \_INTEGER (Read)
      }{
         The number of contours required (all modes except Free). Must
         be between 1 and 50.  If this is large, the plot may be
         cluttered and take longer to produce. 6, the suggested default,
         gives reasonable results.
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         NDF structure containing the 2-d image to be contoured.
      }
      \sstsubsection{
         PXSIZE = \_REAL (Read)
      }{
         The length ($x$ axis) of the plot in metres.  There is an upper
         limit given by the $x$ size of the current picture.
         {\tt [}Maximum that can fit in the current picture whilst
         preserving square pixels{\tt ]}
      }
      \sstsubsection{
         PYSIZE = \_REAL (Read)
      }{
         The length ($y$ axis) of the plot in metres.  There is an upper
         limit given by the $x$ size of the current picture.
         {\tt [}Maximum that can fit in the current picture whilst
         preserving square pixels{\tt ]}
      }
      \sstsubsection{
         RESOLUTION = \_REAL (Read)
      }{
         The resolution factor. The actual plotting resolution is this
         times the $x$ and $y$ theoretical resolutions in world
         co-ordinates. In GKS whether or not a given {\tt "}lamp{\tt "} is
         illuminated or pen quanta has ink within it cannot be
         determined, so a factor of unity is too small for the most
         efficient processing. It must lie between 2.0 and 10.0. {\tt [2.0]}
      }
      \sstsubsection{
         STEPCNT = \_REAL (Read)
      }{
         Separation between contour levels, linear for Linear mode
         and in magnitudes for Magnitude mode.
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB  =  LITERAL (Read)
      }{
         Label for the plot abscissa, in which NCAR fancy founts may be
         embedded when FONT = {\tt "NCAR"}.  If axis information is
         present the suggested default is the NDF's axis label
         followed by the units, in parentheses.  If an error occurs
         obtaining the label the suggested default is {\tt "X"}. {\tt []}
      }
      \sstsubsection{
         AXES = \_LOGICAL (Read)
      }{
         True if labelled and annotated axes are to be drawn around the
         contour plot.  The annotations are either the data
         co-ordinates from the NDF axis components, provided these are
         present and linear and COSYS = {\tt "DATA"}; otherwise pixel
         co-ordinates are used.  {\tt [TRUE]}
      }
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         {\tt "NCAR"} for the NCAR fancy characters and {\tt "GKS"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value. {\tt ["GKS"]}
      }
      \sstsubsection{
         LABELFREQ = \_INTEGER (Read)
      }{
         The frequency with which contour levels are annotated. 1 means
         every level will be labelled.  This may be excessive in
         plots where the contours are closely packed. This is ignored
         unless contour annotation has been selected. It must be between
         1 and the number of contour heights. {\tt [1]}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the numbers of major tick marks
         for the $x$ and $y$ axes.  (Number used is between MAJTIC$+$2 and
         5$*$MAJTIC/2$+$4.) {\tt [3.,3.]}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark
         for the $x$ and $y$ axes.  A negative value forces the graphics
         package to compute appropriate values. {\tt [-1.,-1.]}
      }
      \sstsubsection{
         NOISY = \_LOGICAL (Read)
      }{
         If true the contour lines will alternately be annotated with
         a contour number corresponding to the key entry, but at
         twice the frequency.  It is ignored unless annotated contours
         have been selected. {\tt [FALSE]}
      }
      \sstsubsection{
         ORDLAB  =  LITERAL (Read)
      }{
         Label for the plot ordinate, in which NCAR fancy founts may be
         embedded when FONT = {\tt "NCAR"}.  If axis information is
         present the suggested default is the NDF's axis label followed
         by the units, in parentheses.  If an error occurs obtaining
         the label the suggested default is {\tt "Y"}. {\tt []}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         True if the axis tick marks are to appear on the outside of
         the axes instead of inside. By default, the tick marks are
         drawn outside the contouring region to eliminate
         intersections of ticks with the contours. {\tt [TRUE]}
      }
      \sstsubsection{
         PENROT = \_LOGICAL (Read)
      }{
         If true the plotting pens are cycled through the contours to
         aid identification of the contour heights.  It is ignored
         when annotation is selected. {\tt [FALSE]}
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of the plot.  Up to about 40 characters can be
         accommodated, and NCAR fancy founts may be embedded when
         FONT = {\tt "NCAR"}. If an error occurs obtaining the title, it
         is defaulted to {\tt "Contour plot"}. {\tt [}The NDF title{\tt ]}
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the axes and annotations in the plot, where
         1.0 is the normal thickness. Currently, this is only available
         on a few devices.  It must take a value in the range 0.5--5.0.
         {\tt [1.0]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         TURBOCONT MYFILE D $\backslash$
      }{
         Contours the data array in the NDF called MYFILE on the current
         graphics device.  All other settings are defaulted, so for
         example the current method for determining heights is used, and
         a key is plotted.
      }
      \sstexamplesubsection{
         TURBOCONT TAURUS1(100:199,150:269,4) $\backslash$
      }{
         Contours a 2-dimensional portion of current array component in
         the NDF cube called TAURUS1 on the current graphics device.
         The portion extends from pixel (100,150,4) to pixel
         (199,269,4).  All other settings are defaulted, so for example
         coarse contours are drawn, using the current mode for
         determining heights, and a key is plotted.
      }
      \sstexamplesubsection{
         TURBOCONT IN=NGC6872 MODE=AU NCONT=5
      }{
         Contours the data array in the NDF called NGC6872 on the
         current graphics device. Five equally spaced contours between
         the maximum and minimum data values are drawn. The NDF's title
         adorns the plot. A key is plotted.
      }
      \sstexamplesubsection{
         TURBOCONT NGC6872 MODE=AU NCONT=5 ANNOTA LABELFREQ=2 COSYS=W
      }{
         As above. In addition the contours are annotated at
         alternate heights.  The axes are annotated with pixel
         co-ordinates.
      }
      \sstexamplesubsection{
         TURBOCONT NGC6872 MODE=LI FIRSTCNT=10 STEPCNT=2 NCONT=5 NOAXES
      }{
         Contours the data array in the NDF called NGC6872 on the
         current graphics device.  Four contours at heights 10, 12, 14,
         and 16 are drawn. A key is plotted, but no axes surround the
         contour plot.
      }
      \sstexamplesubsection{
         TURBOCONT COMP=D NOKEY $\backslash$
      }{
         Contours the portion of the data array in the current NDF on
         the current graphics device using the current method for height
         selection. The NDF's title adorns the plot.  No key is drawn.
      }
      \sstexamplesubsection{
         TURBOCONT COMP=V MODE=FR HEIGHTS=[10,20,40,80] TITLE=Variance
      }{
         Contours the variance array in the current NDF on the
         current graphics device.  Contours at 10, 20, 40 and 80 are
         drawn. {\tt "Variance"} is the title of the plot.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application stores a number of pictures in the graphics
         database in the following order: a FRAME of the specified size
         containing the title, annotated axes, contours and key; a DATA
         picture which is stored with world co-ordinates in units of data
         pixels; and a KEY picture to store the key if present.  The DATA
         picture also may have double-precision data co-ordinates derived
         from the NDF axis components provided these are linear and
         different from pixel co-ordinates; the data co-ordinates are
         stored via a linear transformation.  The NDF associated with the
         plot is stored by reference with the DATA picture.  On exit the
         current database picture for the chosen device reverts to the
         input picture.

         \sstitem
         There are some options for setting the characteristics of the
         contour lines.  By default, solid lines are drawn with the first
         (default) SGS pen, usually white or black depending on the
         graphics device selected.  There are alternatives to override
         this default behaviour. For each contour height actually used,
         the application can either:
        \begin{enumerate}
         \item cycle the pens (modulo 3), or
         \item annotate the contours using the number of the contour 
               height corresponding to the key entries rather than the
               values themselves.  The frequency of labelling may be defined.
               Clearly, the key option must be chosen in conjunction with
               annotated contours.
         \end{enumerate}
         Should both be selected, annotation takes precedence.  The
         characteristics of the second and third line styles in option 1
         will depend on the chosen graphics device. An image display or
         pen plotter will draw coloured lines, whereas a laser printer or
         monochrome terminal will draw a variety of dashed or thicker
         lines.  The second is not recommended should the data array have
         a large number of bad pixels, or if the contours are closely
         packed. There is an additional parameter to select double
         annotations for short or noisy contours in option 2.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Only real data can be processed directly.  Other data types
         will undergo a type conversion before the contour plot is drawn.

         \sstitem
         Bad pixels and QUALITY are supported.

         \sstitem
         The lower and upper-bound parameters are used to define a
         slice.  This is a temporary scheme until slices can be specified
         following the NDF's name.
      }
   }
}
 
\sstroutine{
   TWEAK
}{
   Interactively adjusts a colour table
}{
   \sstdescription{
      This application allows the colour table of an image display to
      be altered by means of the cursor and buttons on the trackerball
      or mouse.  The colour table is displayed at the top of the current
      picture spanning its width.  The cursor is used to adjust two
      properties of the colour table:
      \begin{enumerate}
      \item Motion in the $x$-direction adjusts the origin colour index.
           The lookup table is written into the image display's colour
           table from that origin.  The origin increases colour index
           as the cursor is moved to the right, and decreases as the
           cursor is moved to the left.
      \item Motion in the $y$-direction adjusts the range of colour indices
           into which the lookup table is to be mapped.  Motion upwards
           expands the range of colour indices, and motion downwards
           compresses it.  Initially, the lookup table fills the colour
           table.
      \end{enumerate}
      Colour indices smaller than the origin take the colour of the
      origin.  Colour indices beyond where the lookup table is mapped
      to the colour table, take the colour of the last colour index that
      is mapped by the lookup table.

      There are three predefined lookup tables stored in the following
      order: greyscale, eight coloured ramps, and eight coloured
      blocks.  A user-defined lookup table stored in an NDF may be used
      to supplement these; it becomes the initial lookup table,
      otherwise the greyscale is used first.

      If the trackerball or mouse has at least three options its buttons
      do the following:
      \begin{description}
      \item [1] - Resets the colour table to its initial state. This results
                  in the lookup table being mapped onto all the colour indices.
      \item [2] - Moves onto the next lookup table. When the last one has been
                  used, the first is used again, and so on.
      \item [3] - Reads the current cursor position.
      \item [Break] - Exits the interaction and fixes the colour table in
                  its current state.  Then the colour table can be saved
                  as an NDF lookup table.
      \end{description}

       If there are only two options, choice 2 is the same as number 3
       above, and pressing choice 1 will give a second menu comprising
       the above options 1 and 2. The position of the cursor is ignored
       for the second menu.

       This application only modifies the unreserved portion of the
       colour table.
   }
   \sstusage{
      TWEAK INLUT OUTLUT [DEVICE] [ODEVICE]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Image-display device to be used.  The device must be in one of
         the following GNS categories: IMAGE\_DISPLAY or WINDOW, and
         have at least 32 greyscale intensities or colour indices.  It
         must not reset when opened and must allow graphical input.
         {\tt [}Current image-display device{\tt ]}
      }
      \sstsubsection{
         INLUT = NDF (Read)
      }{
         The NDF containing the lookup table as its data array.  The
         LUT must be 2-dimensional, the first dimension being 3, and
         the second being arbitrary.
         Linear interpolation is used to compress or expand the lookup
         table if the second dimension is different from the number
         of unreserved colour indices.  Also the LUT's values must lie
         in the range 0.0--1.0.  The suggested default is the current
         lookup table.
      }
      \sstsubsection{
         ODEVICE = DEVICE (Read)
      }{
         Image-display overlay to be used.  The device must be in one of
         the following GNS categories: IMAGE\_OVERLAY or WINDOW, and
         have at least 4 colour indices.  It must not reset when opened
         and must allow graphical input.  {\tt [}Current image-display
         overlay{\tt ]}
      }
      \sstsubsection{
         OUTLUT = NDF (Write)
      }{
         The NDF to contain the saved lookup table.  The NDF is two
         dimensional, the first dimension being 3 for the RGB
         intensities, and the second is the number of colour indices,
         which is arbitrary.  Each element in the data array lies in the
         range 0.0 to 1.0.  The suggested default is {\tt "TWEAK\_LUT"}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output NDF. {\tt ['Kappa - Tweak']}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         TWEAK MYLUT NEWLUT
      }{
         This tweaks lookup table stored in the NDF called MYLUT, or
         one of the predefined lookup tables, and the resulting
         colour table is stored in NDF NEWLUT.
      }
      \sstexamplesubsection{
         TWEAK MYLUT !
      }{
         This tweaks lookup table stored in the NDF called MYLUT, or
         one of the predefined lookup tables.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The predefined colours are red, green, orange, blue, yellow, cyan,
         magenta and white in that order.

         \sstitem
         The display of the colour table persists after the application
         exits.
      }
   }
}

\sstroutine{
   ZAPLIN
}{
   Replaces regions in a 2-d NDF by bad values or by linear
   interpolation
}{
   \sstdescription{
      This routine allows the user to mask or clean whole columns or
      lines, or regions from a 2-d data and variance arrays in an NDF
      structure.  The cleaned arrays are written to an output NDF.
      At present the cleaning process is one of the following:
      \begin{enumerate}
      \item Flagging by substitution of the magic value.
      \item Bi-linear interpolation across a region, using the nearest
         non-bad pixels on each of the four sides.
      \item Linear interpolation across whole lines or columns, using
         the nearest non-bad pixels to either side.
      \end{enumerate}
      The magic value is also substituted in processes 2. and 3. where
      interpolation is not possible, such as at the edge of the array.

      Co-ordinates may either be in pixels or in data co-ordinates.
      Three methods are available for obtaining the lines or columns
      or the region:
      \begin{enumerate}
      \item From the parameter system, usually in response to prompting.
      \item By a placing a graphics cursor of a nominated device either
         side of the defect.  If columns are being zapped then the
         line position of the cursor is ignored, and vice versa.  To
         use this mode the data array must already be displayed as an
         image or contour plot and the picture stored in the graphics
         database.
      \item By reading a free-format ASCII file in which each record
         defines a zapping instruction.  Each record must contain
         either a) a pair of column or line positions followed by {\tt L} or
         {\tt C} to indicate whether it is lines or columns being specified
         respectively; or b) the lower followed by the upper bound of
         a region ({\it i.e.}\ a pair of $x$-$y$ positions.)  There may be
         commentary lines in the file beginning with {\tt \#} or {\tt !}.  For
         example,
      {\tt \begin{verse}
         \# University of Madrugada  CCD Mark III  defects \\
         23  23  L \\
         157 158 C \\
         40 23 45 25 \\
         <EOF>
      \end{verse}}

        would zap line 23, columns 157 and 158, and a region from
        (40,23) to (45,25).
      \end{enumerate}

      In the first two modes the application loops asking for new
      columns, lines or regions to zap, until told to quit or it
      encounters an error.  An output co-ordinate-list file may also be
      produced; it may be recycled in later processing as the input to
      the third mode.  In the last mode processing stops when the end
      of file is found.
   }
   \sstusage{
      ZAPLIN IN OUT [TITLE] COLIN=? LINCOL=? COLUMNS=? LINES=?
   }
   \sstparameters{
      \sstsubsection{
         COLIN =  FILENAME (Read)
      }{
         Name of the ASCII file containing the column and line bounds
         of areas to be cleaned. It is only used when MODE = {\tt "File"}.
      }
      \sstsubsection{
         COLOUT =  FILENAME (Read)
      }{
         Name of the file to store the areas cleaned.  It has the same
         format as an input ASCII file.  It may be used as input via
         parameter COLIN for processing of other NDFs in the same way,
         without the drudgery of repeating the commands by hand.
         It is not available if MODE = {\tt "File"}.  If COLOUT is null ({\tt !}),
         there will be no logging to an output ASCII file. {\tt [!]}
      }
      \sstsubsection{
         COLUMNS( 2 ) = \_DOUBLE (Read)
      }{
         Columns that define the inclusive bounds of the region to be
         zapped.  These are given either pixel indices if COSYS =
         {\tt "WORLD"} or the NDF has no axis information, or data
         co-ordinates if COSYS = {\tt "DATA"}.  The application constrains
         the column bounds to be within the bounds of the NDF.  This
         parameter is only required when MODE = {\tt "Interface"}.
      }
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either {\tt "WORLD"}
         or {\tt "DATA"}.  If COSYS = {\tt "DATA"} the input co-ordinates,
         either in the ASCII file (File mode) or parameter values (Interface
         mode) are to be expressed in data co-ordinates, otherwise
         pixel indices (the world co-ordinates) are used.  In all modes
         the results are written in data co-ordinates.  The data values
         are converted to and from pixel indices via the NDF's axis
         values; if there is no axis information within the NDF, world
         co-ordinates are then used, except in Cursor mode where the
         transformation, if present, is taken from the last DATA
         picture in the graphics database.  If COSYS = {\tt "WORLD"} pixel
         co-ordinates are used throughout.  {\tt [}Current co-ordinate
         system{\tt ]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics device whose the cursor is used to select the
         columns or lines that are to be zapped.  It is only used
         when MODE = "Cursor".  {\tt [}Current graphics device{\tt ]}
      }
      \sstsubsection{
         IN  =  NDF (Read)
      }{
         Input NDF structure containing the 2-d data array to be
         cleaned.
      }
      \sstsubsection{
         LINCOL  =  LITERAL (Read)
      }{
         The type of area is to be cleaned.  The options are {\tt "Lines"},
         {\tt "Columns"} or a {\tt "Region"}.   {\tt "Lines"} cleans all the columns
         between two line limits; likewise {\tt "Columns"} cleans all the
         lines between two column limits; {\tt "Region"} cleans an area
         given by pairs of column and line limits.  This parameter is
         not used if MODE = {\tt "File"}.  If it is specified on the command
         line in interface mode only one zap operation will be
         performed; otherwise a series of changes may be made until
         terminated by setting LINCOL to null ({\tt !}).
      }
      \sstsubsection{
         LINES( 2 ) =  \_DOUBLE (Read)
      }{
         Lines that define the inclusive bounds of the region to be
         zapped.  These are given either pixel indices if COSYS =
         {\tt "WORLD"} or the NDF has no axis information, or data
         co-ordinates if COSYS = {\tt "DATA"}.  The application constrains
         the line bounds to be within the bounds of the NDF.  This
         parameter is only required when MODE = {\tt "Interface"}.
      }
      \sstsubsection{
         MARK = \_LOGICAL (Read)
      }{
         If true each point selected by the cursor will be marked by a
         cross when MODE = {\tt "Cursor"}.  {\tt [FALSE]}
      }
      \sstsubsection{
         MODE  =  LITERAL (Read)
      }{
         The mode by which the bounds of the region to be cleaned
         are to be obtained.  The options are as follows: {\tt "Interface"}
         defines via the parameter system, {\tt "Cursor"} enables selection
         by graphics cursor, and {\tt "File"} reads them from an ASCII file.
         {\tt [}Current interaction mode{\tt ]}
      }
      \sstsubsection{
         NOISE  =  LOGICAL (Read)
      }{
         If NOISE is true random noise is added to each substituted
         pixel unless ZAPTYPE = {\tt "Bad"}.  The variance of the noise is
         equal to that of the data variance of the substituted data
         value.  If the data variance is bad for a pixel, no noise is
         added to that pixel.  This facility is provided for cosmetic
         use. {\tt [FALSE]}
      }
      \sstsubsection{
         OUT  =  NDF (Write)
      }{
         Output NDF structure containing cleaned version of the
         input data and variance arrays.
      }
      \sstsubsection{
         TITLE  =  LITERAL (Read)
      }{
         Title for the output NDF structure. {\tt ['KAPPA - Zaplin']}
      }
      \sstsubsection{
         ZAPTYPE  =  LITERAL (Read)
      }{
         The type of the cleaning.  The options are {\tt "Linear"} for linear
         interpolation across the line or column using the values that
         abut the pixels to be zapped, or {\tt "Bad"} for substitution by the
         bad-pixel value. {\tt ["Linear"]}
      }
   }
   \newpage
   \sstexamples{
      \sstexamplesubsection{
         ZAPLIN OUT=CLEANED COLOUT=FUDGE.DAT
      }{
         Assuming the current interaction mode is cursor this will copy
         the NDF associated with the last DATA picture to an NDF called
         CLEANED, ready to be zapped interactively using the current
         graphics device.  The cleaning is via linear interpolation.
         A record of the areas cleaned will be stored in the ASCII file
         named FUDGE.DAT.
      }
      \sstexamplesubsection{
         ZAPLIN GRUBBY CLEANED I COSYS=W LINCOL=R COLUMNS=[188,190] LINES=[15,16]
      }{
          This zaps a region from pixel (188,15) to (190,16) within the
          NDF called GRUBBY and stores the result in the NDF called
          CLEANED.  The zapping is via linear interpolation.
      }
      \sstexamplesubsection{
         ZAPLIN GRUBBY(6,,) CLEANED I COSYS=W LINCOL=R COLUMNS=[188,190]
      }{
         This zaps columns 188 to 190 in the sixth $y$-$z$ plane region
         within the NDF called GRUBBY and stores the result in the NDF
         called CLEANED.  The zapping is via linear interpolation.
      }
      \sstexamplesubsection{
         ZAPLIN M42 M42C F COLIN=AAOCCD1.DAT ZAPTYPE=B
      }{
         This flags with the bad pixel value the regions in the NDF
         called M42 defined in the ASCII file called AAOCCD1.DAT, and
         stores the result in an NDF called M42C.
      }
      \sstexamplesubsection{
         ZAPLIN M42 M42C F COLIN=AAOCCD1.DAT NOISE
      }{
         As above except that linear interpolation plus cosmetic noise
         are used to replace the areas to be cleaned rather than bad
         pixels.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If there is no variance array in the NDF, the absolute data
         value is used instead to apply noise.  This variance is not
         written to the output NDF.

         \sstitem
         When using input files care should be taken to ensure that
         the co-ordinate system used in the file matches that of the NDF
         in the current co-ordinate system.

         \sstitem
         Data co-ordinates are stored and output in single precision
         except when the axis array is type '\_DOUBLE' or '\_INTEGER', or
         in cursor mode when there is no axis information in the NDF.

         \sstitem
         For a user-defined section of the input NDF, lines and columns
         are with respect to the 2-d image, and do not necessarily refer to
         the first and second dimensions of the section.  See above for an
         example.
      }
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The routine correctly processes the AXIS, DATA, QUALITY, LABEL,
         TITLE, UNITS and VARIANCE components of an NDF, and propagates all
         extensions.  Bad pixels and all non-complex data types can be
         handled.

         \sstitem
         The HISTORY component, if present, is simply propagated without
         change.

         \sstitem
         There could be a false precision in the data co-ordinates
         when the transformation is obtained from the AGI database.  This
         only occurs when there is no axis information in the NDF.
      }
   }
}

\newpage
\section{Standard Named Colours}
\label{ap:colset}
The standard set of named colours recognised by {\small KAPPA} is
tabulated below together with their red, green, and blue relative
intensities.  It is the X-windows standard colour set so don't blame
{\small KAPPA} if you think some of them are anomolous.  In addition to
those tabulated, there grey levels at each percentage between ``Black''
and ``White''.  These are called ``Grey1'', ``Grey2'', \dots, ``Grey99''.
All the names containing ``Grey'' have synonyms spelt with ``Gray''. 
\medskip

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{8}{|c|}{{\large Standard Colour Set}} \\ \hline
\multicolumn{1}{|c|}{Name} & \multicolumn{1}{|c|}{R} & \multicolumn{1}{c|}{G} &
\multicolumn{1}{c|}{B} & \multicolumn{1}{|c|}{Name} & \multicolumn{1}{c|}{R} &
\multicolumn{1}{c|}{G} & \multicolumn{1}{c|}{B}  \\ \hline
AliceBlue           & 0.941 & 0.973 & 1.000 & AntiqueWhite        & 0.980 & 0.922 & 0.843 \\ 
AntiqueWhite1       & 1.000 & 0.937 & 0.859 & AntiqueWhite2       & 0.933 & 0.875 & 0.800 \\ 
AntiqueWhite3       & 0.804 & 0.753 & 0.690 & AntiqueWhite4       & 0.545 & 0.514 & 0.471 \\ 
Aquamarine          & 0.498 & 1.000 & 0.831 & Aquamarine1         & 0.498 & 1.000 & 0.831 \\ 
Aquamarine2         & 0.463 & 0.933 & 0.776 & Aquamarine3         & 0.400 & 0.804 & 0.667 \\ 
Aquamarine4         & 0.271 & 0.545 & 0.455 & Azure               & 0.941 & 1.000 & 1.000 \\ 
Azure1              & 0.941 & 1.000 & 1.000 & Azure2              & 0.878 & 0.933 & 0.933 \\ 
Azure3              & 0.757 & 0.804 & 0.804 & Azure4              & 0.514 & 0.545 & 0.545 \\ 
Beige               & 0.961 & 0.961 & 0.863 & Bisque              & 1.000 & 0.894 & 0.769 \\ 
Bisque1             & 1.000 & 0.894 & 0.769 & Bisque2             & 0.933 & 0.835 & 0.718 \\ 
Bisque3             & 0.804 & 0.718 & 0.620 & Bisque4             & 0.545 & 0.490 & 0.420 \\ 
Black               & 0.000 & 0.000 & 0.000 & BlanchedAlmond      & 1.000 & 0.922 & 0.804 \\ 
Blue                & 0.000 & 0.000 & 1.000 & Blue1               & 0.000 & 0.000 & 1.000 \\ 
Blue2               & 0.000 & 0.000 & 0.933 & Blue3               & 0.000 & 0.000 & 0.804 \\ 
Blue4               & 0.000 & 0.000 & 0.545 & BlueViolet          & 0.541 & 0.169 & 0.886 \\ 
Brown               & 0.647 & 0.165 & 0.165 & Brown1              & 1.000 & 0.251 & 0.251 \\ 
Brown2              & 0.933 & 0.231 & 0.231 & Brown3              & 0.804 & 0.200 & 0.200 \\ 
Brown4              & 0.545 & 0.137 & 0.137 & Burlywood           & 0.871 & 0.722 & 0.529 \\ 
Burlywood1          & 1.000 & 0.827 & 0.608 & Burlywood2          & 0.933 & 0.773 & 0.569 \\ 
Burlywood3          & 0.804 & 0.667 & 0.490 & Burlywood4          & 0.545 & 0.451 & 0.333 \\ 
CadetBlue           & 0.373 & 0.620 & 0.627 & CadetBlue1          & 0.596 & 0.961 & 1.000 \\ 
CadetBlue2          & 0.557 & 0.898 & 0.933 & CadetBlue3          & 0.478 & 0.773 & 0.804 \\ 
CadetBlue4          & 0.325 & 0.525 & 0.545 & Chartreuse          & 0.498 & 1.000 & 0.000 \\ 
Chartreuse1         & 0.498 & 1.000 & 0.000 & Chartreuse2         & 0.463 & 0.933 & 0.000 \\ 
Chartreuse3         & 0.400 & 0.804 & 0.000 & Chartreuse4         & 0.271 & 0.545 & 0.000 \\ 
Chocolate           & 0.824 & 0.412 & 0.118 & Chocolate1          & 1.000 & 0.498 & 0.141 \\ 
Chocolate2          & 0.933 & 0.463 & 0.129 & Chocolate3          & 0.804 & 0.400 & 0.114 \\ 
Chocolate4          & 0.545 & 0.271 & 0.075 & Coral               & 1.000 & 0.498 & 0.314 \\ 
Coral1              & 1.000 & 0.447 & 0.337 & Coral2              & 0.933 & 0.416 & 0.314 \\ 
Coral3              & 0.804 & 0.357 & 0.271 & Coral4              & 0.545 & 0.243 & 0.184 \\ 
CornflowerBlue      & 0.392 & 0.584 & 0.929 & Cornsilk            & 1.000 & 0.973 & 0.863 \\ 
Cornsilk1           & 1.000 & 0.973 & 0.863 & Cornsilk2           & 0.933 & 0.910 & 0.804 \\ 
Cornsilk3           & 0.804 & 0.784 & 0.694 & Cornsilk4           & 0.545 & 0.533 & 0.471 \\ 
Cyan                & 0.000 & 1.000 & 1.000 & Cyan1               & 0.000 & 1.000 & 1.000 \\ 
Cyan2               & 0.000 & 0.933 & 0.933 & Cyan3               & 0.000 & 0.804 & 0.804 \\ 
Cyan4               & 0.000 & 0.545 & 0.545 & DarkGoldenrod       & 0.722 & 0.525 & 0.043 \\ 
DarkGoldenrod1      & 1.000 & 0.725 & 0.059 & DarkGoldenrod2      & 0.933 & 0.678 & 0.055 \\ 
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{8}{|c|}{{\large Standard Colour Set}} \\ \hline
\multicolumn{1}{|c|}{Name} & \multicolumn{1}{|c|}{R} & \multicolumn{1}{c|}{G} &
\multicolumn{1}{c|}{B} & \multicolumn{1}{|c|}{Name} & \multicolumn{1}{c|}{R} &
\multicolumn{1}{c|}{G} & \multicolumn{1}{c|}{B}  \\ \hline
DarkGoldenrod3      & 0.804 & 0.584 & 0.047 & DarkGoldenrod4      & 0.545 & 0.396 & 0.031 \\ 
DarkGreen           & 0.000 & 0.392 & 0.000 & DarkKhaki           & 0.741 & 0.718 & 0.420 \\ 
DarkOliveGreen      & 0.333 & 0.420 & 0.184 & DarkOliveGreen1     & 0.792 & 1.000 & 0.439 \\ 
DarkOliveGreen2     & 0.737 & 0.933 & 0.408 & DarkOliveGreen3     & 0.635 & 0.804 & 0.353 \\ 
DarkOliveGreen4     & 0.431 & 0.545 & 0.239 & DarkOrange          & 1.000 & 0.549 & 0.000 \\ 
DarkOrange1         & 1.000 & 0.498 & 0.000 & DarkOrange2         & 0.933 & 0.463 & 0.000 \\ 
DarkOrange3         & 0.804 & 0.400 & 0.000 & DarkOrange4         & 0.545 & 0.271 & 0.000 \\ 
DarkOrchid          & 0.600 & 0.196 & 0.800 & DarkOrchid1         & 0.749 & 0.243 & 1.000 \\ 
DarkOrchid2         & 0.698 & 0.227 & 0.933 & DarkOrchid3         & 0.604 & 0.196 & 0.804 \\ 
DarkOrchid4         & 0.408 & 0.133 & 0.545 & DarkSalmon          & 0.914 & 0.588 & 0.478 \\ 
DarkSeaGreen        & 0.561 & 0.737 & 0.561 & DarkSeaGreen1       & 0.757 & 1.000 & 0.757 \\ 
DarkSeaGreen2       & 0.706 & 0.933 & 0.706 & DarkSeaGreen3       & 0.608 & 0.804 & 0.608 \\ 
DarkSeaGreen4       & 0.412 & 0.545 & 0.412 & DarkSlateBlue       & 0.282 & 0.239 & 0.545 \\ 
DarkSlateGrey       & 0.184 & 0.310 & 0.310 & DarkSlateGrey1      & 0.592 & 1.000 & 1.000 \\ 
DarkSlateGrey2      & 0.553 & 0.933 & 0.933 & DarkSlateGrey3      & 0.475 & 0.804 & 0.804 \\ 
DarkSlateGrey4      & 0.322 & 0.545 & 0.545 & DarkTurquoise       & 0.000 & 0.808 & 0.820 \\ 
DarkViolet          & 0.580 & 0.000 & 0.827 & DeepPink            & 1.000 & 0.078 & 0.576 \\ 
DeepPink1           & 1.000 & 0.078 & 0.576 & DeepPink2           & 0.933 & 0.071 & 0.537 \\ 
DeepPink3           & 0.804 & 0.063 & 0.463 & DeepPink4           & 0.545 & 0.039 & 0.314 \\ 
DeepSkyBlue         & 0.000 & 0.749 & 1.000 & DeepSkyBlue1        & 0.000 & 0.749 & 1.000 \\ 
DeepSkyBlue2        & 0.000 & 0.698 & 0.933 & DeepSkyBlue3        & 0.000 & 0.604 & 0.804 \\ 
DeepSkyBlue4        & 0.000 & 0.408 & 0.545 & DimGrey             & 0.412 & 0.412 & 0.412 \\ 
DodgerBlue          & 0.118 & 0.565 & 1.000 & DodgerBlue1         & 0.118 & 0.565 & 1.000 \\ 
DodgerBlue2         & 0.110 & 0.525 & 0.933 & DodgerBlue3         & 0.094 & 0.455 & 0.804 \\ 
DodgerBlue4         & 0.063 & 0.306 & 0.545 & Firebrick           & 0.698 & 0.133 & 0.133 \\ 
Firebrick1          & 1.000 & 0.188 & 0.188 & Firebrick2          & 0.933 & 0.173 & 0.173 \\ 
Firebrick3          & 0.804 & 0.149 & 0.149 & Firebrick4          & 0.545 & 0.102 & 0.102 \\ 
FloralWhite         & 1.000 & 0.980 & 0.941 & ForestGreen         & 0.133 & 0.545 & 0.133 \\ 
Gainsboro           & 0.863 & 0.863 & 0.863 & GhostWhite          & 0.973 & 0.973 & 1.000 \\ 
Gold                & 1.000 & 0.843 & 0.000 & Gold1               & 1.000 & 0.843 & 0.000 \\ 
Gold2               & 0.933 & 0.788 & 0.000 & Gold3               & 0.804 & 0.678 & 0.000 \\ 
Gold4               & 0.545 & 0.459 & 0.000 & Goldenrod           & 0.855 & 0.647 & 0.125 \\ 
Goldenrod1          & 1.000 & 0.757 & 0.145 & Goldenrod2          & 0.933 & 0.706 & 0.133 \\ 
Goldenrod3          & 0.804 & 0.608 & 0.114 & Goldenrod4          & 0.545 & 0.412 & 0.078 \\ 
Green               & 0.000 & 1.000 & 0.000 & Green1              & 0.000 & 1.000 & 0.000 \\ 
Green2              & 0.000 & 0.933 & 0.000 & Green3              & 0.000 & 0.804 & 0.000 \\ 
Green4              & 0.000 & 0.545 & 0.000 & GreenYellow         & 0.678 & 1.000 & 0.184 \\ 
Grey                & 0.753 & 0.753 & 0.753 & Honeydew            & 0.941 & 1.000 & 0.941 \\ 
Honeydew1           & 0.941 & 1.000 & 0.941 & Honeydew2           & 0.878 & 0.933 & 0.878 \\ 
Honeydew3           & 0.757 & 0.804 & 0.757 & Honeydew4           & 0.514 & 0.545 & 0.514 \\ 
HotPink             & 1.000 & 0.412 & 0.706 & HotPink1            & 1.000 & 0.431 & 0.706 \\ 
HotPink2            & 0.933 & 0.416 & 0.655 & HotPink3            & 0.804 & 0.376 & 0.565 \\ 
HotPink4            & 0.545 & 0.227 & 0.384 & IndianRed           & 0.804 & 0.361 & 0.361 \\ 
IndianRed1          & 1.000 & 0.416 & 0.416 & IndianRed2          & 0.933 & 0.388 & 0.388 \\ 
IndianRed3          & 0.804 & 0.333 & 0.333 & IndianRed4          & 0.545 & 0.227 & 0.227 \\ 
Ivory               & 1.000 & 1.000 & 0.941 & Ivory2              & 0.933 & 0.933 & 0.878 \\ 
Ivory3              & 0.804 & 0.804 & 0.757 & Ivory4              & 0.545 & 0.545 & 0.514 \\ 
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{8}{|c|}{{\large Standard Colour Set}} \\ \hline
\multicolumn{1}{|c|}{Name} & \multicolumn{1}{|c|}{R} & \multicolumn{1}{c|}{G} &
\multicolumn{1}{c|}{B} & \multicolumn{1}{|c|}{Name} & \multicolumn{1}{c|}{R} &
\multicolumn{1}{c|}{G} & \multicolumn{1}{c|}{B}  \\ \hline
Khaki               & 0.941 & 0.902 & 0.549 & Khaki1              & 1.000 & 0.965 & 0.561 \\ 
Khaki2              & 0.933 & 0.902 & 0.522 & Khaki3              & 0.804 & 0.776 & 0.451 \\ 
Khaki4              & 0.545 & 0.525 & 0.306 & Lavender            & 0.902 & 0.902 & 0.980 \\ 
LavenderBlush       & 1.000 & 0.941 & 0.961 & LavenderBlush1      & 1.000 & 0.941 & 0.961 \\ 
LavenderBlush2      & 0.933 & 0.878 & 0.898 & LavenderBlush3      & 0.804 & 0.757 & 0.773 \\ 
LavenderBlush4      & 0.545 & 0.514 & 0.525 & LawnGreen           & 0.486 & 0.988 & 0.000 \\ 
LemonChiffon        & 1.000 & 0.980 & 0.804 & LemonChiffon1       & 1.000 & 0.980 & 0.804 \\ 
LemonChiffon2       & 0.933 & 0.914 & 0.749 & LemonChiffon3       & 0.804 & 0.788 & 0.647 \\ 
LemonChiffon4       & 0.545 & 0.537 & 0.439 & LightBlue           & 0.678 & 0.847 & 0.902 \\ 
LightBlue1          & 0.749 & 0.937 & 1.000 & LightBlue2          & 0.698 & 0.875 & 0.933 \\ 
LightBlue3          & 0.604 & 0.753 & 0.804 & LightBlue4          & 0.408 & 0.514 & 0.545 \\ 
LightCoral          & 0.941 & 0.502 & 0.502 & LightCyan           & 0.878 & 1.000 & 1.000 \\ 
LightCyan1          & 0.878 & 1.000 & 1.000 & LightCyan2          & 0.820 & 0.933 & 0.933 \\ 
LightCyan3          & 0.706 & 0.804 & 0.804 & LightCyan4          & 0.478 & 0.545 & 0.545 \\ 
LightGoldenrod      & 0.933 & 0.867 & 0.510 & LightGoldenrod1     & 1.000 & 0.925 & 0.545 \\ 
LightGoldenrod2     & 0.933 & 0.863 & 0.510 & LightGoldenrod3     & 0.804 & 0.745 & 0.439 \\ 
LightGoldenrod4     & 0.545 & 0.506 & 0.298 & LightGoldenrodYellow& 0.980 & 0.980 & 0.824 \\ 
LightGrey           & 0.827 & 0.827 & 0.827 & LightPink           & 1.000 & 0.714 & 0.757 \\ 
LightPink1          & 1.000 & 0.682 & 0.725 & LightPink2          & 0.933 & 0.635 & 0.678 \\ 
LightPink3          & 0.804 & 0.549 & 0.584 & LightPink4          & 0.545 & 0.373 & 0.396 \\ 
LightSalmon         & 1.000 & 0.627 & 0.478 & LightSalmon1        & 1.000 & 0.627 & 0.478 \\ 
LightSalmon2        & 0.933 & 0.584 & 0.447 & LightSalmon3        & 0.804 & 0.506 & 0.384 \\ 
LightSalmon4        & 0.545 & 0.341 & 0.259 & LightSeaGreen       & 0.125 & 0.698 & 0.667 \\ 
LightSkyBlue        & 0.529 & 0.808 & 0.980 & LightSkyBlue1       & 0.690 & 0.886 & 1.000 \\ 
LightSkyBlue2       & 0.643 & 0.827 & 0.933 & LightSkyBlue3       & 0.553 & 0.714 & 0.804 \\ 
LightSkyBlue4       & 0.376 & 0.482 & 0.545 & LightSlateBlue      & 0.518 & 0.439 & 1.000 \\ 
LightSlateGrey      & 0.467 & 0.533 & 0.600 & LightSteelBlue      & 0.690 & 0.769 & 0.871 \\ 
LightSteelBlue1     & 0.792 & 0.882 & 1.000 & LightSteelBlue2     & 0.737 & 0.824 & 0.933 \\ 
LightSteelBlue3     & 0.635 & 0.710 & 0.804 & LightSteelBlue4     & 0.431 & 0.482 & 0.545 \\ 
LightYellow         & 1.000 & 1.000 & 0.878 & LightYellow1        & 1.000 & 1.000 & 0.878 \\ 
LightYellow2        & 0.933 & 0.933 & 0.820 & LightYellow3        & 0.804 & 0.804 & 0.706 \\ 
LightYellow4        & 0.545 & 0.545 & 0.478 & LimeGreen           & 0.196 & 0.804 & 0.196 \\ 
Linen               & 0.980 & 0.941 & 0.902 & Magenta             & 1.000 & 0.000 & 1.000 \\ 
Magenta1            & 1.000 & 0.000 & 1.000 & Magenta2            & 0.933 & 0.000 & 0.933 \\ 
Magenta3            & 0.804 & 0.000 & 0.804 & Magenta4            & 0.545 & 0.000 & 0.545 \\ 
Maroon              & 0.690 & 0.188 & 0.376 & Maroon1             & 1.000 & 0.204 & 0.702 \\ 
Maroon2             & 0.933 & 0.188 & 0.655 & Maroon3             & 0.804 & 0.161 & 0.565 \\ 
Maroon4             & 0.545 & 0.110 & 0.384 & MediumAquamarine    & 0.400 & 0.804 & 0.667 \\ 
MediumBlue          & 0.000 & 0.000 & 0.804 & MediumOrchid        & 0.729 & 0.333 & 0.827 \\ 
MediumOrchid1       & 0.878 & 0.400 & 1.000 & MediumOrchid2       & 0.820 & 0.373 & 0.933 \\ 
MediumOrchid3       & 0.706 & 0.322 & 0.804 & MediumOrchid4       & 0.478 & 0.216 & 0.545 \\ 
MediumPurple        & 0.576 & 0.439 & 0.859 & MediumPurple1       & 0.671 & 0.510 & 1.000 \\ 
MediumPurple2       & 0.624 & 0.475 & 0.933 & MediumPurple3       & 0.537 & 0.408 & 0.804 \\ 
MediumPurple4       & 0.365 & 0.278 & 0.545 & MediumSeaGreen      & 0.235 & 0.702 & 0.443 \\ 
MediumSlateBlue     & 0.482 & 0.408 & 0.933 & MediumSpringGreen   & 0.000 & 0.980 & 0.604 \\ 
MediumTurquoise     & 0.282 & 0.820 & 0.800 & MediumVioletRed     & 0.780 & 0.082 & 0.522 \\ 
MidnightBlue        & 0.098 & 0.098 & 0.439 & MintCream           & 0.961 & 1.000 & 0.980 \\ 
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{8}{|c|}{{\large Standard Colour Set}} \\ \hline
\multicolumn{1}{|c|}{Name} & \multicolumn{1}{|c|}{R} & \multicolumn{1}{c|}{G} &
\multicolumn{1}{c|}{B} & \multicolumn{1}{|c|}{Name} & \multicolumn{1}{c|}{R} &
\multicolumn{1}{c|}{G} & \multicolumn{1}{c|}{B}  \\ \hline
MistyRose           & 1.000 & 0.894 & 0.882 & MistyRose1          & 1.000 & 0.894 & 0.882 \\ 
MistyRose2          & 0.933 & 0.835 & 0.824 & MistyRose3          & 0.804 & 0.718 & 0.710 \\ 
MistyRose4          & 0.545 & 0.490 & 0.482 & Moccasin            & 1.000 & 0.894 & 0.710 \\ 
NavajoWhite         & 1.000 & 0.871 & 0.678 & NavajoWhite1        & 1.000 & 0.871 & 0.678 \\ 
NavajoWhite2        & 0.933 & 0.812 & 0.631 & NavajoWhite3        & 0.804 & 0.702 & 0.545 \\ 
NavajoWhite4        & 0.545 & 0.475 & 0.369 & Navy                & 0.000 & 0.000 & 0.502 \\ 
NavyBlue            & 0.000 & 0.000 & 0.502 & OldLace             & 0.992 & 0.961 & 0.902 \\ 
OliveDrab           & 0.420 & 0.557 & 0.137 & OliveDrab1          & 0.753 & 1.000 & 0.243 \\ 
OliveDrab2          & 0.702 & 0.933 & 0.227 & OliveDrab3          & 0.604 & 0.804 & 0.196 \\ 
OliveDrab4          & 0.412 & 0.545 & 0.133 & Orange              & 1.000 & 0.647 & 0.000 \\ 
Orange1             & 1.000 & 0.647 & 0.000 & Orange2             & 0.933 & 0.604 & 0.000 \\ 
Orange3             & 0.804 & 0.522 & 0.000 & Orange4             & 0.545 & 0.353 & 0.000 \\ 
OrangeRed           & 1.000 & 0.271 & 0.000 & OrangeRed1          & 1.000 & 0.271 & 0.000 \\ 
OrangeRed2          & 0.933 & 0.251 & 0.000 & OrangeRed3          & 0.804 & 0.216 & 0.000 \\ 
OrangeRed4          & 0.545 & 0.145 & 0.000 & Orchid              & 0.855 & 0.439 & 0.839 \\ 
Orchid1             & 1.000 & 0.514 & 0.980 & Orchid2             & 0.933 & 0.478 & 0.914 \\ 
Orchid3             & 0.804 & 0.412 & 0.788 & Orchid4             & 0.545 & 0.278 & 0.537 \\ 
PaleGoldenrod       & 0.933 & 0.910 & 0.667 & PaleGreen           & 0.596 & 0.984 & 0.596 \\ 
PaleGreen1          & 0.604 & 1.000 & 0.604 & PaleGreen2          & 0.565 & 0.933 & 0.565 \\ 
PaleGreen3          & 0.486 & 0.804 & 0.486 & PaleGreen4          & 0.329 & 0.545 & 0.329 \\ 
PaleTurquoise       & 0.686 & 0.933 & 0.933 & PaleTurquoise1      & 0.733 & 1.000 & 1.000 \\ 
PaleTurquoise2      & 0.682 & 0.933 & 0.933 & PaleTurquoise3      & 0.588 & 0.804 & 0.804 \\ 
PaleTurquoise4      & 0.400 & 0.545 & 0.545 & PaleVioletRed       & 0.859 & 0.439 & 0.576 \\ 
PaleVioletRed1      & 1.000 & 0.510 & 0.671 & PaleVioletRed2      & 0.933 & 0.475 & 0.624 \\ 
PaleVioletRed3      & 0.804 & 0.408 & 0.537 & PaleVioletRed4      & 0.545 & 0.278 & 0.365 \\ 
PapayaWhip          & 1.000 & 0.937 & 0.835 & PeachPuff           & 1.000 & 0.855 & 0.725 \\ 
PeachPuff1          & 1.000 & 0.855 & 0.725 & PeachPuff2          & 0.933 & 0.796 & 0.678 \\ 
PeachPuff3          & 0.804 & 0.686 & 0.584 & PeachPuff4          & 0.545 & 0.467 & 0.396 \\ 
Peru                & 0.804 & 0.522 & 0.247 & Pink                & 1.000 & 0.753 & 0.796 \\ 
Pink1               & 1.000 & 0.710 & 0.773 & Pink2               & 0.933 & 0.663 & 0.722 \\ 
Pink3               & 0.804 & 0.569 & 0.620 & Pink4               & 0.545 & 0.388 & 0.424 \\ 
Plum                & 0.867 & 0.627 & 0.867 & Plum1               & 1.000 & 0.733 & 1.000 \\ 
Plum2               & 0.933 & 0.682 & 0.933 & Plum3               & 0.804 & 0.588 & 0.804 \\ 
Plum4               & 0.545 & 0.400 & 0.545 & PowderBlue          & 0.690 & 0.878 & 0.902 \\ 
Purple              & 0.627 & 0.125 & 0.941 & Purple1             & 0.608 & 0.188 & 1.000 \\ 
Purple2             & 0.569 & 0.173 & 0.933 & Purple3             & 0.490 & 0.149 & 0.804 \\ 
Purple4             & 0.333 & 0.102 & 0.545 & Red                 & 1.000 & 0.000 & 0.000 \\ 
Red1                & 1.000 & 0.000 & 0.000 & Red2                & 0.933 & 0.000 & 0.000 \\ 
Red3                & 0.804 & 0.000 & 0.000 & Red4                & 0.545 & 0.000 & 0.000 \\ 
RosyBrown           & 0.737 & 0.561 & 0.561 & RosyBrown1          & 1.000 & 0.757 & 0.757 \\ 
RosyBrown2          & 0.933 & 0.706 & 0.706 & RosyBrown3          & 0.804 & 0.608 & 0.608 \\ 
RosyBrown4          & 0.545 & 0.412 & 0.412 & RoyalBlue           & 0.255 & 0.412 & 0.882 \\ 
RoyalBlue1          & 0.282 & 0.463 & 1.000 & RoyalBlue2          & 0.263 & 0.431 & 0.933 \\ 
RoyalBlue3          & 0.227 & 0.373 & 0.804 & RoyalBlue4          & 0.153 & 0.251 & 0.545 \\ 
SaddleBrown         & 0.545 & 0.271 & 0.075 & Salmon              & 0.980 & 0.502 & 0.447 \\ 
Salmon1             & 1.000 & 0.549 & 0.412 & Salmon2             & 0.933 & 0.510 & 0.384 \\ 
Salmon3             & 0.804 & 0.439 & 0.329 & Salmon4             & 0.545 & 0.298 & 0.224 \\ 
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{8}{|c|}{{\large Standard Colour Set}} \\ \hline
\multicolumn{1}{|c|}{Name} & \multicolumn{1}{|c|}{R} & \multicolumn{1}{c|}{G} &
\multicolumn{1}{c|}{B} & \multicolumn{1}{|c|}{Name} & \multicolumn{1}{c|}{R} &
\multicolumn{1}{c|}{G} & \multicolumn{1}{c|}{B}  \\ \hline
SandyBrown          & 0.957 & 0.643 & 0.376 & SeaGreen            & 0.180 & 0.545 & 0.341 \\ 
SeaGreen1           & 0.329 & 1.000 & 0.624 & SeaGreen2           & 0.306 & 0.933 & 0.580 \\ 
SeaGreen3           & 0.263 & 0.804 & 0.502 & SeaGreen4           & 0.180 & 0.545 & 0.341 \\ 
Seashell            & 1.000 & 0.961 & 0.933 & Seashell1           & 1.000 & 0.961 & 0.933 \\ 
Seashell2           & 0.933 & 0.898 & 0.871 & Seashell3           & 0.804 & 0.773 & 0.749 \\ 
Seashell4           & 0.545 & 0.525 & 0.510 & Sienna              & 0.627 & 0.322 & 0.176 \\ 
Sienna1             & 1.000 & 0.510 & 0.278 & Sienna2             & 0.933 & 0.475 & 0.259 \\ 
Sienna3             & 0.804 & 0.408 & 0.224 & Sienna4             & 0.545 & 0.278 & 0.149 \\ 
SkyBlue             & 0.529 & 0.808 & 0.922 & SkyBlue1            & 0.529 & 0.808 & 1.000 \\ 
SkyBlue2            & 0.494 & 0.753 & 0.933 & SkyBlue3            & 0.424 & 0.651 & 0.804 \\ 
SkyBlue4            & 0.290 & 0.439 & 0.545 & SlateBlue           & 0.416 & 0.353 & 0.804 \\ 
SlateBlue1          & 0.514 & 0.435 & 1.000 & SlateBlue2          & 0.478 & 0.404 & 0.933 \\ 
SlateBlue3          & 0.412 & 0.349 & 0.804 & SlateBlue4          & 0.278 & 0.235 & 0.545 \\ 
SlateGrey           & 0.439 & 0.502 & 0.565 & SlateGrey1          & 0.776 & 0.886 & 1.000 \\ 
SlateGrey2          & 0.725 & 0.827 & 0.933 & SlateGrey3          & 0.624 & 0.714 & 0.804 \\ 
SlateGrey4          & 0.424 & 0.482 & 0.545 & Snow                & 1.000 & 0.980 & 0.980 \\ 
Snow1               & 1.000 & 0.980 & 0.980 & Snow2               & 0.933 & 0.914 & 0.914 \\ 
Snow3               & 0.804 & 0.788 & 0.788 & Snow4               & 0.545 & 0.537 & 0.537 \\ 
SpringGreen         & 0.000 & 1.000 & 0.498 & SpringGreen1        & 0.000 & 1.000 & 0.498 \\ 
SpringGreen2        & 0.000 & 0.933 & 0.463 & SpringGreen3        & 0.000 & 0.804 & 0.400 \\ 
SpringGreen4        & 0.000 & 0.545 & 0.271 & SteelBlue           & 0.275 & 0.510 & 0.706 \\ 
SteelBlue1          & 0.388 & 0.722 & 1.000 & SteelBlue2          & 0.361 & 0.675 & 0.933 \\ 
SteelBlue3          & 0.310 & 0.580 & 0.804 & SteelBlue4          & 0.212 & 0.392 & 0.545 \\ 
Tan                 & 0.824 & 0.706 & 0.549 & Tan1                & 1.000 & 0.647 & 0.310 \\ 
Tan2                & 0.933 & 0.604 & 0.286 & Tan3                & 0.804 & 0.522 & 0.247 \\ 
Tan4                & 0.545 & 0.353 & 0.169 & Thistle             & 0.847 & 0.749 & 0.847 \\ 
Thistle1            & 1.000 & 0.882 & 1.000 & Thistle2            & 0.933 & 0.824 & 0.933 \\ 
Thistle3            & 0.804 & 0.710 & 0.804 & Thistle4            & 0.545 & 0.482 & 0.545 \\ 
Tomato              & 1.000 & 0.388 & 0.278 & Tomato1             & 1.000 & 0.388 & 0.278 \\ 
Tomato2             & 0.933 & 0.361 & 0.259 & Tomato3             & 0.804 & 0.310 & 0.224 \\ 
Tomato4             & 0.545 & 0.212 & 0.149 & Turquoise           & 0.251 & 0.878 & 0.816 \\ 
Turquoise1          & 0.000 & 0.961 & 1.000 & Turquoise2          & 0.000 & 0.898 & 0.933 \\ 
Turquoise3          & 0.000 & 0.773 & 0.804 & Turquoise4          & 0.000 & 0.525 & 0.545 \\ 
Violet              & 0.933 & 0.510 & 0.933 & VioletRed           & 0.816 & 0.125 & 0.565 \\ 
VioletRed1          & 1.000 & 0.243 & 0.588 & VioletRed2          & 0.933 & 0.227 & 0.549 \\ 
VioletRed3          & 0.804 & 0.196 & 0.471 & VioletRed4          & 0.545 & 0.133 & 0.322 \\ 
Vory1               & 1.000 & 1.000 & 0.941 & Wheat               & 0.961 & 0.871 & 0.702 \\ 
Wheat1              & 1.000 & 0.906 & 0.729 & Wheat2              & 0.933 & 0.847 & 0.682 \\ 
Wheat3              & 0.804 & 0.729 & 0.588 & Wheat4              & 0.545 & 0.494 & 0.400 \\ 
White               & 1.000 & 1.000 & 1.000 & WhiteSmoke          & 0.961 & 0.961 & 0.961 \\ 
Yellow              & 1.000 & 1.000 & 0.000 & Yellow1             & 1.000 & 1.000 & 0.000 \\ 
Yellow2             & 0.933 & 0.933 & 0.000 & Yellow3             & 0.804 & 0.804 & 0.000 \\ 
Yellow4             & 0.545 & 0.545 & 0.000 & YellowGreen         & 0.604 & 0.804 & 0.196 \\ 
\hline
\end{tabular}
\end{center}

\newpage
\section{Standard components in an NDF.}
\label{ap:NDFformat}

An NDF comprises a main data array plus a collection of objects drawn from 
a set of standard items and extensions (see SUN/33).
Only the main data array must be present; all the other items are optional.

ADAM\_EXAMPLES:EXAMPLE.SDF is an NDF which contains all the standard 
NDF components, except a FITS extension; it also has a Figaro extension.
The structure of the file 
(as revealed by {\tt \$ TRACE ADAM\_EXAMPLES:EXAMPLE}) is shown below.
The layout is
\begin{verbatim} 
     NAME(dimensions)    <TYPE>     VALUE(S)
\end{verbatim}
Note that scalar objects have no dimensions and that each level down the
hierarchy is indented.


\begin{verbatim}

   EXAMPLE  <NDF>

      DATA_ARRAY(856)  <_REAL>       *,0.2284551,-2.040089,45.84504,56.47374,
                                     ... 746.2602,820.8976,570.0729,*,449.574
      TITLE          <_CHAR*30>      'HR6259 - AAT fibre data'
      LABEL          <_CHAR*20>      'Flux'
      UNITS          <_CHAR*20>      'Counts/s'
      QUALITY        <QUALITY>       {structure}
         BADBITS        <_UBYTE>        1
         QUALITY(856)   <_UBYTE>        1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
                                     ... 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0

      VARIANCE(856)  <_REAL>         2.1,0.1713413,1.5301,34.38378,42.35531,
                                     ... 615.6732,427.5547,353.9127,337.1805
      AXIS(1)        <AXIS>          {structure}

      Contents of AXIS(1)
         DATA_ARRAY(856)  <_REAL>       3847.142,3847.672,3848.201,3848.731,
                                        ... 4298.309,4298.838,4299.368,4299.897
         LABEL          <_CHAR*20>      'Wavelength'
         UNITS          <_CHAR*20>      'Angstroms'

      HISTORY        <HISTORY>       {structure}
         CREATED        <_CHAR*30>      '1990-DEC-12 08:21:02.324'
         CURRENT_RECORD  <_INTEGER>     3
         RECORDS(10)    <HIST_REC>      {array of structures}

         Contents of RECORDS(1)
            TEXT           <_CHAR*40>      'Extracted spectrum from fibre data.'
            DATE           <_CHAR*25>      '1990-DEC-19 08:43:03.08'
            COMMAND        <_CHAR*30>      'FIGARO V2.4 FINDSP command'


      MORE           <EXT>           {structure}
         FIGARO         <EXT>           {structure}
            TIME           <_REAL>         1275
            SECZ           <_REAL>         2.13



   End of Trace.
\end{verbatim}

Of course, this is only an example format. There are various ways of
representing some of the components. These {\sl variants\/} are
described in SGP/38. 

The components are considered in detail below. The names (in bold
typeface) are significant as they are used by the NDF access routines to
identify the components. 

\begin{description}

\item[{\bf DATA}] -- the main data array is the only 
component which must be present in an NDF. 
In the case of EXAMPLE.SDF, the data component is a 1-d 
array of real type with 856 elements.  It can have up to seven 
dimensions.   It is particularly referenced via parameter names IN, OUT,
and NDF.

\item[{\bf TITLE}] -- the  character string {\tt 'HR6259 - AAT fibre 
data'} describes the contents of the NDF. The NDF's TITLE
might be used as the title of a graph {\it etc.}  It may be set
via the command SETTITLE.  Applications that create an NDF assign
a TITLE to the NDF via a parameter, called TITLE unless the application
generates several NDFs.

\item[{\bf LABEL}] -- the character string {\tt'Flux'} describes the
quantity represented in the NDF's main data array. The LABEL is
intended for use on the axis of graphs {\it etc.}  It may be set
via the command SETLABEL.  

\item[{\bf UNITS}] -- this character string
describes the physical units of the quantity stored in the main data 
array, in this case, {\tt'Counts/s'}.  It may be set
via the command SETUNITS.  

\item[{\bf QUALITY}] -- this component is used to indicate
the quality of each element in the main data array, for example
whether each pixel is vignetted or not.
The quality structure contains a 
quality array and a BADBITS value, both of which {\sl must\/} be of 
type \_UBYTE.  
The quality array has the same shape and size as
the main data array and is used in conjunction with the BADBITS value 
to decide the quality of a pixel in the main data array.
In EXAMPLE.SDF the BADBITS component has value 1.
This means that a value of 1 in the quality array indicates a bad pixel
in the main data array, whereas any other value indicates that 
the associated pixel is good.  (Note the pixel is bad
if the bit-wise comparison QUALITY {\tt "}AND{\tt "} BADBITS is non-zero).
The meanings of the QUALITY bits are arbitrary.  See the command SETBB.

\item[{\bf VARIANCE}] -- the variance array is the same shape and size
as the main data array and contains the errors 
associated with the individual data values. 
These are stored as {\sl variance\/} estimates for each
pixel.  VARIANCE may be set via the SETVAR command.

\item[{\bf AXIS}] -- the AXIS structure may contain axis information for
any dimension of the NDF's main array. In this case, the main data array
is only 1-d, therefore only the AXIS(1) structure is present. This
structure contains the actual axis data array, and also label and units
information.  {\small KAPPA} uses the label and units for axis
annotations.  All axes or none must be present. 

\item[{\bf HISTORY}] -- this component provides a record of the
processing history of the NDF. Only the first of three records is shown
for EXAMPLE.SDF. This indicates that the spectrum was extracted from
fibre data using the Figaro FINDSP command on 1990 December 19.  In
{\small KAPPA} HISTORY is propagated but not yet generated. 

\item[{EXTENSIONs}] -- the purpose of extensions is to store
non-standard items. These auxiliary data could be information about
the original observing setup, such as the airmass during the observation
or the temperature of the detector; they may be calibration data or
results produced during processing of the data array, {\it e.g.}\
spectral-line fits. EXAMPLE.SDF began life as a Figaro file\footnote{The
Figaro file was converted to an NDF using the command DST2NDF, see
SUN/55.} which contained values for the airmass and exposure time
associated with the observations. These are stored in the Figaro
extension, and the intention is that the Figaro applications which use
these values will know where to find them.

One extension that is used by {\small KAPPA} is the FITS extension.
This holds the FITS headers as an array of 80-character elements,
{\it i.e.}\ one FITS card image per array element.  You can extract
the values of ancillary items from the FITS extension to a
non-standard extension via FITSIMP.  The extension can be listed
via the command FITSLIST.
\end{description}

\newpage
\section{IMAGE data format}
\label{ap:IMAGEformat}
The IMAGE format as used by some of {\small KAPPA} is a simple
HDS structure, comprising a floating-point data array, a character title,
and the maximum and minimum data values.  It is variant of
the original Wright-Giddings IMAGE structure.  There are others is use
that contain more items.
An example structure is shown schematically below using the
TRACE (SUN/102) notation; see Appendix~\ref{ap:NDFformat}.
\begin{verbatim}
   HORSEHEAD  <IMAGE>

      DATA_ARRAY(384,512)  <_REAL>   100.5,102.6,110.1,109.8,105.3,107.6,
                                     ... 123.1,117.3,119,120.5,127.3,108.4
      TITLE          <_CHAR*72>      'KAPPA - Flip'
      DATA_MIN       <_REAL>         28.513
      DATA_MAX       <_REAL>         255.94

   End of Trace.
\end{verbatim}

Currently, the DATA\_ARRAY may have up to seven dimensions.
IMAGE structures are associated with parameters like INPIC and OUTPIC.
The TITLE object of new IMAGE structures takes the value of the
parameter OTITLE.  DATA\_MIN and DATA\_MAX are handled transparently. 

The IMAGE format is not too dissimilar from a {\em primitive\/} NDF with
no extensions.  Indeed if it did not have DATA\_MAX and DATA\_MIN it would
be a {\it bona fide}\ NDF.  Thus applications that handle the IMAGE 
format can follow the rules of SGP/38 and process it like an NDF.  In
effect this means that all extensions are propagated to output files,
and a quality array is propagated where the processing does not 
invalidate its values.  This similarity in formats enables NDF and
IMAGE applications to work in co-operation, and the conversion within
{\small KAPPA} can be undertaken piecemeal.  Note that in the long
term the primitive {\em variant\/} will not be the norm for NDFs, since,
for example, it does not support origin information.

\section{Supported HDS Data Types}
\label{ap:HDStypes}
{\small KAPPA} applications can process NDFs in one or more of
the following HDS data types.
The correspondence between Fortran types and HDS data types is as follows:

\begin{center}
\begin{tabular}{|l|c|l|} \hline
{\bf HDS Type} & {\bf Number of bytes} & {\bf VAX FORTRAN Type}\\ \hline
\_DOUBLE & 8 & DOUBLE PRECISION \\
\_INTEGER & 4 & INTEGER \\
\_REAL & 8 & REAL \\
\_UBYTE & 1 & BYTE \\
\_BYTE & 1 & BYTE \\
\_UWORD & 2 & INTEGER*2 \\
\_WORD & 2 & INTEGER*2\\
\hline
\end{tabular}
\end{center}

(\_UBYTE) and (\_UWORD) types are unsigned and so permit data ranges of
0--255 and 0--65535 respectively.

\newpage
\section{R\^{o}le of KAPPA}
\label{ap:role}
Until recently, most Starlink applications, {\it e.g.}\ {\small ASPIC},
used the Interim software environment, but now a far-more-powerful and
flexible set of tools and standards under the banner {\small ADAM} ({\it
c.f.}~SUN/94, SG/4) has superseded Interim. During the long period when
the Starlink software environment was under review Starlink applications
have diverged, using different environments, standards, conventions and
data formats.  As a consequence a rationalisation of Starlink
applications code is underway, with the goals of providing {\em
maintainable\/} and {\em portable\/} packages that work in harmony,
more-rapid extensibility, since individual packages are no longer
required to perform all functions and the additional functionality can
be added piecemeal.  New user interfaces, such as graphical, could be
layered within the tool kit for obtaining parameters and so make the
enhancement available to all applications that make use of those tools. 
To make this rationalisation viable, Starlink programmers utilise the
toolkits provided by {\small ADAM}. 

An important part of the rationalisation is that applications will be
unified by sharing the same basic data structure---the NDF (Extensible
$N$-dimensional Data Format). This contains an $n$-dimensional data
array that can store most astronomical data such as spectra, images and
spectral-line data cubes. The NDF may also contain information like a
title, axis labels and units, error and quality arrays.  There are also
places in the NDF, called {\em extensions}, to store any ancillary data
associated with the data array, even other NDFs.

The backbone of the software reorganisation is {\small KAPPA} ({\bf
K}ernel {\bf AP}plication {\bf PA}ckage). It aims to provide
general-purpose applications that have wide applicability. In order to
achieve generality {\small KAPPA} does not process non-standard
extensions; however, it does not lose non-standard ancillary data since
it copies extensions to any NDFs that it creates. {\em The functionality
of {\small KAPPA} should not be regarded in isolation.} It should be
considered in conjunction with the specialist {\small ADAM} applications
such as those for CCD reduction, stellar and galaxy photometry, and IRAS
analysis.  Some are are already available (PHOTOM, PISA, CCDPACK,
SPECDRE, ASTERIX) and others are well advanced (PONGO, IRAS90). {\small
KAPPA} should not be perceived as a rival to {\small FIGARO}. As {\small
FIGARO} {\em applications\/} become more integrated with {\small ADAM}
packages, for example by sharing the NDF format, they should be seen as
complementary, with {\small FIGARO} concentrating on spectroscopy and
{\small KAPPA} image processing.  Of course, there is some duplication
for historical and ease-of-use reasons. 

\newpage
\section{UNIX Differences}
\label{ap:unixdif}

Although the UNIX and VMS implementations of {\sc KAPPA} are similar,
there are differences, and these are described in the various
subsections below. 

\subsection{Running Applications}

To start you must issue the usual {\tt KAPPA} command, but note that
it must be in lowercase.

\begin{verbatim}
     kappa
\end{verbatim}

All commands must be given in full and in lowercase.  {\sc ICL} is
not available and hence there is no {\sc ADAM} monolith version of
{\sc KAPPA}.  One consequence is that {\sc ADAM} parameters cannot
be passed between applications.  Since commands are invoked from the
shell some command syntax is interpreted as shell metacharacters.  These
include parenthesis, bracket, quote, double quote and backslash.  A
backslash is needed before each metacharacter for these characters to be
taken literally.  Here are some examples

\begin{quote}
{\tt stats image$\backslash$(100:199,}$\sim${\tt 100$\backslash$)}
\end{quote}

obtains statistics of a section of an NDF; while

\begin{verbatim}
     display picture \\
\end{verbatim}

displays NDF picture, accepting the suggested defaults for other 
parameters; and

\begin{verbatim}
     contour psf mode=fr heights=\[10,20,40\] pltitl=\"Demo plot\"
\end{verbatim}

contours the NDF called psf at array values of 10, 20, and 40,
with a title of ``Demo plot''.

When responding to prompts neither the {\tt <TAB>} function for editing
the default nor command-line recall is available.

Parameter values are case insensitive except for graphics devices and
filenames.  No file extension is assumed for ASCII files. (On VMS {\tt
".DAT"} is assumed if no extension is given.) 

On UNIX, {\sc KAPPA} is a monolith, but not in the traditional
{\sc ADAM} sense. All the applications are soft links to this single
application, which itself finds the command you made, not {\sc ICL}.  This
scheme was chosen to make vast savings in disc space, particularly on
DECstations. One side effect is that given sufficient real memory the
monolith appears to give a quicker load time (after the first
invocation) than when there are individual applications. However, on a
machine with a small memory ($\sim$8Mb) the monolith will not be
retained in memory as you process your data, and so there can be some
pregnant pauses, just like from {\sc DCL}. 

\subsection{Help}

There is no {\bf help} command.  You must use {\bf kaphelp} to
obtain {\sc KAPPA} help.  For example, you should enter 

\begin{verbatim}
     kaphelp display
\end{verbatim}

to obtain help on the {\sc KAPPA} {\bf display} command.

\subsection{Missing Applications}

The following applications are not available on UNIX:

\begin{center}
\begin{tabular}{|p{18mm}|p{130mm}|}
\hline
Application & \multicolumn{1}{c|}{Reason} \\ \hline
FITSDIN  FITSIN &  These would need some major reworking.  Since
 much new functionality ({\it e.g.}\ binary table and image  extensions)
 is planned soon, not porting now will save programmer time in the long
 term.  Also the MAG library is not available.  The ASCII and HDS files
 output from the VMS version are portable and there is little performance
 gain on UNIX as most of the processing is input-output. \\ \hline

FOURIER &  Not available on the DECstation because there is
 no single-precision NAG library available for this machine. \\ \hline

IDPAN  IDRESET  & ARGS and Ikon image displays are not available
 on UNIX machines. \\ \hline

MEM2D & A UNIX version of the MEMSYS3 library is not available. \\ \hline
\end{tabular}
\end{center}

\subsection{Name Clashes}

Some {\sc KAPPA} applications clash with UNIX commands.  These
are {\bf compress} and {\bf look}.  There is also a {\bf glob} in
the C-shell which might confuse you should you forget that {\bf
globals} cannot be abbreviated. 

\subsection{HDS Files}

Although HDS files are portable you are recommended to copy them to the
host machine, and run application {\bf native} on them for significant
efficiency gains. 

\subsection{Graphics Database}

The location of the AGI database can be controlled by setting the
environment variable AGI\_USER to the desired location.  If AGI\_USER
is undefined, the database file is placed in your home directory.

\subsection{Mouse}

In some applications it is possible to press the left-hand and
right-hand mouse buttons of a workstation to perform interaction in
addition to hitting the 1 and . keyboard buttons respectively.  These
are {\bf centroid, cursor, lutview, picdef,} and {\bf zaplin}.  Note
that you should continue to use the keyboard for inspect. 

\newpage
\section{Release Notes---V0.8}
The main change is the introduction of a {\small DCL} version of {\small KAPPA}.
The release features more applications that use the NDF---including
both new and modified applications.  There are 18 new commands.

\subsection{Global changes}
\begin{itemize}
  \item Access to {\small KAPPA} commands from {\small DCL}.

  \item Supports the CENTRE arrays of the NDF's AXIS structure.

  \item Supports world and data co-ordinates (via the AXIS structures in
    the NDF).  These co-ordinates and AXIS structures not only control
    the appearance of axes, but enable the positions of features or a
    range of positions to to be specified either in pixels or data
    units.  There is a global parameter to control which system to use.

  \item It incorporates the latest version of the graphics database, AGI.
    This means that the data co-ordinate system may be stored with
    pictures and used later.  Also the name of the NDF creating the
    plot is recorded;  this can be used to advantage in interactive
    applications like CENTROID and INSPECT where you only need give
    the filename when DISPLAYing the image.  The new AGI also means
    there is no longer a superfluous almost-blank sheet of paper
    produced on hardcopy devices.  There are separate databases in
    separate files for each computer node in a cluster.

  \item There is a new global parameter to control the interaction mode
    for obtaining co-ordinates.  It can take three states: Cursor
    (for a graphics cursor), Interface (for prompting), and File
    (for an ASCII file).

   \item  Specification of a graphics device within an application
    now lasts for the duration of that application.  Formerly, the
    application would update the global parameters.  These must be set
    via the GDSET, IDSET and OVSET commands.

  \item All the applications that create, read, manipulate and use colour
    tables have been converted to ignore a set of reserved pens.  The
    reserved pens form a static palette for axes, text, borders,
    bad-pixel flagging {\it etc.}\  The palette is unaffected by changes to
    the colour table.  There are also applications for handling the
    palette.

  \item All the applications that require an image-display device have
    more-flexible criteria, and these are documented.  The error
    messages that result when an unsuitable graphics device is chosen
    give explicit reasons why that device cannot be used.

  \item There is a FONT parameter for controlling the graphics fount in
    line graphics (excluding COLUMNAR and HIDE).

  \item  In addition to describing new functionality the documentation
    has been expanded featuring more examples, {\small ICL} procedures,
    and tips; appendices describing the NDF and supported HDS data types. 
    There is structuring of the parameter lists, separating result, and
    graphics-style parameters from the primary parameters. 

  \item {\small KAPPA} V0.8 requires 1.5MB {\em less\/} virtual memory than V0.7.
\end{itemize}

\subsection{New applications}
\begin{description}
  \item [CLEANER]  Flags small defects in a substantially smooth 2-d NDF.

  \item [FITSDIN]  Reads a list of disc-FITS files including wildcards.
    It supports all standard FITS including floating-point data.
    Like FITSIN it can run in automatic mode, and will process files
    with block sizes other than a multiple of 2880 bytes.

  \item [FITSIMP]  Moves ancillary data from the FITS extension to other
    extensions within an NDF.

  \item [FITSLIST]  Lists the contents of the FITS extension in an NDF to
    the screen or a file.

  \item [IDCLEAR]  Clears an image-display device. (It is the equivalent of
    GDCLEAR and it is provided for ease of use.)

  \item [IDSTATE]  Shows the current status of of an image-display device.
    It is the equivalent of GDSTATE and it is provided for ease of
    use, but it also has additional information about the number of
    entries in the colour table and the palette colours. (See PAL$\lsk$)

  \item [LUTHILITE]  Interactively highlights an image-display's colour 
    table.  A variable-width band of a nominated colour may be moved
    along the colour table in real time to highlight image features.

  \item [LUTTWEAK]  Interactively modifies (squash/stretch and offset) an
    image-display's colour table.  It is the long-term replacement
    for TWEAK.  Since it uses IDI it changes the colour table in real 
    time.

  \item [MEM2D]  Maximum-entropy deconvolution of a 2-D NDF---an important
    application for those wishing to extract fine detail from their
    images.

  \item [MLINPLOT]  Draws a multiple line plot of a 2-D NDF's data values
    versus their axis co-ordinates.

  \item [PAL$\lsk$]  From this release {\small KAPPA} reserves a portion of
    an image display's colour table to hold a palette of 16 colours for
    annotations, axes, borders, marking bad pixels {\it etc.}  The palette
    is unaffected by changes to the colour table.  Four applications
    are provided to control this palette.  PALDEF loads a default
    palette. PALENTRY sets a palette to a named colour or RGB 
    intensities. PALSAVE saves the current palette in an NDF.  PALREAD
    restores a saved palette.

  \item [PICIN]  Reports the size, location, name, comment, label,
    associated NDF of a picture interior to the current one. The
    results are written to parameters.  It is provided to help
    construct composite plots within procedures.

  \item [PICLIST]  Lists the graphics-database pictures for a device from 
    which a new current picture may be chosen.

  \item [SETBB]  Sets the badbits mask of an NDF data structure in order to
    control the effect of data quality.
\end{description}

\subsection{New procedures}
\begin{description}
  \item [LUTFC]  Loads the standard false-colour lookup table.
\end{description}

\subsection{Withdrawn applications}
  SHSIZE has been withdrawn.  Use NDFTRACE instead.

\subsection{Deprecated features}
  All the application parameters specifying the bounds of an NDF will
  be withdrawn, except those in INSPECT, since the bounds can be
  supplied following the name of the NDF.  This will be done when
  only a few of the {\small KAPPA} applications that use the old IMAGE
  data format remain.

  The following applications will be withdrawn at V0.9:
  \begin{description}
  \item[STATS2D] STATS with NDF\_ sectioning (see SUN/33.3 Section 16
     or Section~\ref{se:ndfsect}) already duplicates STATS2D.
  \end{description}

\subsection{Extended applications}
  
  Here is a summary of the main modifications.
\begin{itemize}
  \item CDIV and CMULT have been converted to NDF\_ and include variance
    processing.  They can process any non-complex numeric data.

  \item CENTROID has been converted to NDF\_ and can process $n$-D data.
    It works in either world or data co-ordinates.  The input NDF
    name need not be supplied in cursor mode as it is obtained from
    the graphics database.  Errors in the centroid position may be
    estimated.  A co-ordinate file may be produced for use by other
    applications, such as PSF.  A single centroid may be obtained
    by giving the INIT parameter on the command line, {\it i.e.} it
    prevents looping.

  \item COLUMNAR and HIDE obtain their axis labels from the NDF axis
    component, by default.  The associated NDF is stored with the
    data picture in the graphics database.

  \item CONTOUR and TURBOCONT obtain their axis labels and annotations
    from the NDF axis structure, by default.  The graphics database
    records the NDF and the transformation from world-to-data
    co-ordinates, provided the latter is approximately linear.  The
    axes are now optional.

  \item CONTOVER has been converted to NDF\_.  In addition to the data
    array, the variance or quality can be contoured.

  \item CRELUT has been converted to NDF\_ and made more efficient. 
    There are double the number of user-definable entries in the
    palette, and the handling of the reserved pens is improved, {\it e.g.}
    no striping in the histogram.  The image NDF may be any of the
    non-complex numeric data types.  The input lookup table may be
    mapped to the device's colour table via a nearest-neighbour
    method. There is improved commentary.  New colours in the palette
    may be specified as either RGB relative intensities or a named
    colour.  Specifying the scaling limits on the command line
    prevents the calculation of the extreme values of the NDF used
    as suggested defaults.

  \item CURSOR reports either world or data co-ordinates, single or double
    precision.

  \item DISPLAY features several efficiency improvements, particularly
    for large arrays.  Byte and word arrays may be processed directly.
    The scaled image may be stored for quicker re-display via a
    no-scaling option.  The scaling limits may be written to output
    parameters.  Axes are labelled and annotated in data co-ordinates 
    obtained from the NDF axis structure.  The graphics database
    records the NDF and the transformation from world-to-data
    co-ordinates, provided the latter is approximately linear.  The
    restriction on suitable devices has been relaxed so support for
    colour is no longer a requirement.  Since such devices, such as
    inkjet and laser printers reset their colour tables each time they
    are opened, DISPLAY permits a lookup table to be read into the
    colour table.  As an alternative to axes a coloured border may be
    drawn about the image, using a colour selected from the palette.
    There is control of the appearance of bad pixels.

  \item FITSIN has been converted to NDF\_.  It can process block sizes
    other than 2880-byte multiples and floating-point data.  NDF
    axis-structure components are written.

  \item FLIP has been converted to NDF\_ and works in $n$-D.  It handles all
    non-complex data types.

  \item FOURIER provides easier control on the selection of the
    various input NDFs.

 \item GDSET, IDSET, and OVSET are no longer procedures.  They check that
    the chosen device is suitable.
    
  \item GDSTATE outputs the size, location, name, comment, label, and
    associated NDF name to parameters.  Also for procedures there is
    a switch to prevent reporting when just output parameters are
    needed. 
   
  \item GLOBALS is no longer a procedure and is much faster as a consequence.

  \item GREYPLOT has been converted to NDF\_.  It handles all
    non-complex data types, and has optional bad-pixel handling.  In
    addition to the data array, the variance or quality can be
    displayed.  There are more options for scaling the data,
    including percentiles.  The scaled image may be displayed for
    quicker re-display via a no-scaling option.  Other efficiency
    improvements have been made.  The scaling limits may be written
    to output parameters.  Axes can be drawn.  The axes are labelled
    and annotated in data co-ordinates obtained from the NDF axis
    structure or pixel co-ordinates.  The graphics database records
    the NDF and the transformation from world-to-data co-ordinates,
    provided the latter is approximately linear.  The reserved pens
    may be bypassed to improve the quality of the output on hardcopy
    devices.  There is control of the appearance of bad pixels.

  \item INSPECT has been partially converted to NDF\_.  The input NDF
    name need not be supplied in cursor mode as it is obtained from
    the graphics database.  It requires an OVERLAY class of device.
    The parameter names have been rationalised as an {\it aide-m\'{e}moire}.
    If the OPTION keyword is given on the command line it prevents 
    looping for further inspections.

  \item LUTABLE has been converted to NDF\_.  The input lookup table
    may be mapped to the device's colour table via a nearest-neighbour
    method.  This provides better colour tables for discontinuous
    lookup tables.  Some of the parameters have been
    renamed for clarity and consistency. If the COLTAB and MAPPING
    parameters are provided on the command line, there is no looping.

  \item LINPLOT has been converted to NDF\_.  It handles all non-complex
    numeric data types.  In addition to the data array, the variance
    or quality can be plotted.  The abscissa axis is labelled and
    annotated in data co-ordinates obtained from the NDF axis
    structure, and the ordinate uses the NDF label and units.  The
    graphics database records the NDF and the transformation from
    world-to-data co-ordinates, provided the latter is approximately
    linear, or logarithmic.

  \item NDFTRACE supports NDF axis components.

  \item PICSEL has no restriction on the maximum number of pictures that
    can be searched following AGI enhancements.

  \item PSF outputs the point-spread function to an NDF.  The dimensions
    of the NDF are given by the fitting area or such that a fraction
    of the peak amplitude is just included within the image.  The
    restriction that prevented a single object from being used to
    define the psf has been lifted.  The list of positions may be in
    world or data co-ordinates.

  \item SNAPSHOT has a rubber-band cursor to define the region to capture.

  \item STATS has been converted to NDF\_.  It works directly on all
    non-complex data types.

  \item TWEAK has been converted to NDF\_.

  \item ZAPLIN has been converted to NDF\_.  It works in either world or
    data co-ordinates.  The input NDF name need not be supplied in
    cursor mode as it is obtained from the graphics database.  All
    non-complex data types are processed directly.  Giving parameter
    LINCOL on the command line prevents looping, and so `zaps' a
    single region.

  \item The following applications, though not requiring conversion to the
    NDF\_ library, also had improved documentation including examples,
    usage, and multi-line parameter help:  BLINK, CURSOR, GDCLEAR,
    GDNAMES, GDSTATE, IDINVISIBLE, IDPAZO, IDRESET, IDUNZOOM,
    IDVISIBLE, LUTFLIP, LUTROT, LUTSAVE, PICDEF, PICLABEL, PICSEL.
    
  \item All the procedures have been converted to the new-style
    documentation.
\end{itemize}

\newpage
\section{Release Notes---V0.8-4}
Originally, the main purpose of this release was to fix bugs, however, 
due to various circumstances it is opportune to release some other
facilities.  Most notably are the first releases of KAPPA for
DECstation and SUN.  There are five new commands.

\subsection{Global changes}
\begin{itemize}
  \item  Where it is valid and straightforward, IMAGE-format applications
    now propagate the NDF components VARIANCE, AXIS, LABEL, UNITS,
    and HISTORY.  Previously, only QUALITY and extensions were copied.

  \item  Additional support for NDF sections is provided as follows:

     \begin{itemize}

     \item  There are new applications for copying sections to a new
       NDF or {\it in situ\/} (see below).

     \item  NDF applications with parameters for defining a section
       of an NDF, {\it e.g.}\ CONTOUR, LINPLOT, and HIDE, have had
       these parameters removed, since the section can be defined more
       flexibly following the input NDF's name.  The section may be
       arbitrary, for example, DISPLAY can plot a portion of any of
       the planes (XY, XZ, YZ) of a cube.

     \item  IMAGE-format applications can access the data array in a
       simple NDF, and in some cases can use the origin information.
       Besides NDF's with non-default origins, IMAGE-format applications
       can now process NDFs with a bad-pixel flag.

     \end{itemize}
     See Section~\ref{se:ndfsect} for details of NDF sections and how to
     specify them.

  \item  IDI applications operate on X-windows image displays in addition
    to Ikons. A window may be shared by GKS and IDI applications---for
    example, run DISPLAY to view an image then invoke LUTROT to rotate
    the colour table---as well as by non-KAPPA applications.  

  \item  X-window-overlay devices are supported.

  \item  The colour set has been expanded to over 550 colours and grey 
    levels.  This new set corrects the anomalous values.

  \item  In addition to describing new functionality the paper
    documentation has been expanded and reorganised to assist new users.
    Several typographical and editing errors have been corrected in
    the documentation.

  \item  KAPPA\_DIR:BAD.PAR has been withdrawn, since {\small KAPPA} no
    longer uses it.  Programmers should use PRIMDAT's PRM\_PAR instead.
\end{itemize}

\subsection{New applications}
Although only an incremental release, the following applications have
been pending release for over a year.  Now that simple NDFs are supported
to a limited degree, these applications can now be made available.
\begin{description}

  \item [NDFCOPY]  Copies an NDF (or NDF section) to a new location.

  \item [SETBAD]  Sets new bad-pixel flag values for an NDF.  This
     accelerates processing when the flag indicates that there are no
     bad data present.

  \item [SETBOUND]  Sets new bounds for an NDF.  The NDF may be trimmed
     or enlarged to a specific shape.

  \item [SETORIGIN]  Sets a new pixel origin for an NDF.

\end{description}

There is another new application that provides more-efficient
processing of an HDS file after its transfer between machines.
\begin{description}
  \item [NATIVE]  Converts an HDS object to native machine data
      representation
\end{description}

\subsection{Deprecated features}
  The following applications will be withdrawn at V0.9:
  \begin{description}
  \item[COMPRESS] The NDF\_ version of COMPAVE will provide COMPRESS's
     functionality.
  \item[NUMBA] The NDF\_ version of NUMB will provide NUMBA's
     functionality.
  \item[PICK2D] NDFCOPY or SETBOUND provides the functionality in $n$-d.
  \item[THRESH0] The THRESH0 operation can easily be performed
     by THRESH.
  \end{description}

  To prevent command-name clashes with {\small Figaro} two applications
  will be renamed at V0.9.  GAUSS becomes GAUSMOOTH, and CLEANER reverts
  to FFCLEAN.

\subsection{Extended applications}
  
Here is a summary of the main modifications.
\begin{itemize}
  \item DISPLAY and GREYPLOT parameters BADCOL and BCOLOUR default
    to their current values.  PERCENTILES accepts values from 0 to 100
    rather than fractionally within this range as occurred previously.
  \item KAPHELP uses portable help.
  \item LUTCOL (LUTABLE COLTAB=COLOUR) fills the available colour
    table, though this means that each coloured block will not
    necessarily occupy the same number of coloured indices.
  \item LUTHILITE, LUTROT, and LUTTWEAK permit fine-tune control.
    The rate of motion of the colour table or highlight is a
    function of the speed of cursor movement in addition to the cursor
    position.  For a given cursor displacement sluggish motion rotates
    the colour table more slowly than for faster motion.  LUTTWEAK has
    a larger dynamic range and smaller increments for squashing and
    stretching.
  \item PICDEF has a new parameter, FILL, for controlling the fractional
    size of array pictures within the grid.  Parameter CURPIC has
    been renamed CURRENT for consistency with other applications.

\end{itemize}

\end{document}
