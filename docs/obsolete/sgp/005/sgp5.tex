\documentstyle[11pt]{article} 
\pagestyle{myheadings}

%------------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink General Paper}
\newcommand{\stardocinitials}  {SGP}
\newcommand{\stardocnumber}    {5.1}
\newcommand{\stardocauthors}   {P.M.\ Allan}
\newcommand{\stardocdate}      {31 October 1991}
\newcommand{\stardoctitle}     {CNF and F77 \\ [1ex]
                                Mixed Language Programming -- FORTRAN and C}
\newcommand{\stardocversion}   {Version 1.0}
\newcommand{\stardocmanual}    {Programmer's Manual}
%------------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\renewcommand{\_}{{\tt\char'137}}     % re-centres the underscore
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

\renewcommand{\thepage}{\roman{page}}

%------------------------------------------------------------------------------
% Add any \newcommand or \newenvironment commands here
\newcounter{examples}


%+
%  Name:
%     LAYOUT.TEX

%  Purpose:
%     Define Latex commands for laying out documentation produced by PROLAT.

%  Language:
%     Latex

%  Type of Module:
%     Data file for use by the PROLAT application.

%  Description:
%     This file defines Latex commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by Latex. The
%     contents of this file should be included in the source presented to
%     Latex in front of any output from PROLAT. By default, this is done
%     automatically by PROLAT.

%  Notes:
%     The definitions in this file should be included explicitly in any file
%     which requires them. The \include directive should not be used, as it
%     may not then be possible to process the resulting document with Latex
%     at a later date if changes to this definitions file become necessary.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}

%  Define a \tt font of the required size.
\font\ssttt=cmtt10 scaled 1095

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.45pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{\item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[1]{\item[{\ssttt #1}] \mbox{} \\}

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

\newcommand{\sstbox}[1]{\item[] \makebox[8.5em][l]{#1}}

%  End of LAYOUT.TEX layout definitions.
%.

%+
% Extra sst definitions written by PMA.
%-

% Definition to give a banner that only has the name of the routine on the
% left, not on the left and right.

\newcommand{\sstmacro}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-1.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.45pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \begin{description}
      #3
   \end{description}
}

% Define layout of brief listing sections - Pinched from SUN/33

\newcommand{\noteroutine}[2]{{\small \bf #1} \nopagebreak \\
                             \hspace*{3em} {\em #2} \\[1.5ex]}

% End of extra sst definitions.
%.

%------------------------------------------------------------------------------

\begin{document}
\thispagestyle{empty}
SCIENCE \& ENGINEERING RESEARCH COUNCIL \hfill \stardocname\\
RUTHERFORD APPLETON LABORATORY\\
{\large\bf Starlink Project\\}
{\large\bf \stardoccategory\ \stardocnumber}
\begin{flushright}
\stardocauthors\\
\stardocdate
\end{flushright}
\vspace{-4mm}
\rule{\textwidth}{0.5mm}
\vspace{5mm}
\begin{center}
{\Huge\bf  \stardoctitle \\ [2.5ex]}
{\LARGE\bf \stardocversion \\ [4ex]}
{\Huge\bf  \stardocmanual}
\end{center}
\vspace{5mm}

%------------------------------------------------------------------------------
%  Package Description
\begin{center}
{\Large\bf Description}
\end{center}

This document describes how to write programs in a mixture of FORTRAN and C. It
will be of use to anyone who has a need to do this. Two sets of software are
described in this document. F77 is a set of C macros to handle the FORTRAN -- C
subroutine linkage and CNF is a set of C functions for handling the difference
between FORTRAN and C character strings.

The software is currently available on VAX/VMS systems, Sun Sparc systems and
DEC systems running Ultrix/RISC (typically, DECstations).

\markright{\stardocname}
\newpage
\markright{\stardocname}

%------------------------------------------------------------------------------
%  Add this part if you want a table of contents
\null\vspace {5mm}
\begin {center}
\rule{80mm}{0.5mm} \\ [1ex]
{\Large\bf \stardoctitle \\ [2.5ex]
           \stardocversion} \\ [2ex]
\rule{80mm}{0.5mm}
\end{center}
\vspace{30mm}

\setlength{\parskip}{0mm}
\tableofcontents
\setlength{\parskip}{\medskipamount}
\markright{\stardocname}
\newpage
%------------------------------------------------------------------------------
% Section 1 begins ...
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\null\vspace {5mm}
\begin {center}
\rule{80mm}{0.5mm} \\ [1ex]
{\Large\bf \stardoctitle \\ [2.5ex]
           \stardocversion} \\ [2ex]
\rule{80mm}{0.5mm}
\end{center}
\vspace{30mm}

\section{How to read this document}
\label{how-to}

This document tells a programmer how to mix program segments written in FORTRAN
and C. It provides information on several levels from a quick `how to get
started' cookbook, down to machine specific details. The minimum that you
should read is the introduction and the cookbook. This will tell you how to
write programs, but without much of the background information of what is
really going on. After you have tried a few programs, you will probably want to
read the rest of the document.

The C macros and functions are fully documented in appendices
\ref{f77:description} and \ref{cnf:description}. Section
\ref{compiling-and-linking} tells you how to compile and link the programs.

\section{Introduction}
\label{intro}

Starlink has historically been a `FORTRAN only' project. There are several
reasons for this. Primarily it is because scientists have been brought up with
FORTRAN and for most purposes it is perfectly adequate for our needs. However,
there are some tasks for which FORTRAN is not really suitable. In such
situations it may be better to write programs in a language other than FORTRAN,
rather than try to persuade FORTRAN to do something that it is not suited to.
Writing recursive procedures is the classic example, but there are many more.
Starlink has recognised the need for a language other than FORTRAN by providing
C compilers at all Starlink nodes. 

There are in fact good reasons to avoid diversifying into trendy new languages
unless it is absolutely necessary. Any substantial piece of software will
require someone to support it long after the original author has moved on to
other things and it is not reasonable to expect that person to have expertise
in a large number of programming languages. However, for some purposes, FORTRAN
77 is simply not adequate. In fact some major parts of Starlink software have
been written in other languages because of this. HDS is written in C (it was
originally written in Bliss, in the days when even C was impractical because of
restrictions in the early compilers) and ICL is written in Pascal (and this does
indeed cause problems with supporting it). In the future, FORTRAN 90 will
overcome many of the limitations that FORTRAN 77 has, but until that becomes
readily available (and even after), some things are simply better written in C.

It is often the case that most of a program can be written in FORTRAN, leaving
only a few tricky parts that cannot be written using standard (or even non
standard) FORTRAN. An example of a task that cannot be performed using standard
FORTRAN is getting some memory for use in your program. Admittedly, this can be
done on a VMS machine using system services, but these are VMS specific
features that are virtually guaranteed to be non portable to other computers.
Often a better approach is to write the tricky parts in C. This is exactly the
approach that has been adopted for HDS. The problem then is how to pass data
between FORTRAN routines and C functions. This document will describe  how to
do this. Clearly the details of passing information between program segments
written in different languages will be machine dependent; however, there are
also many important similarities. Despite any problems that may arise, it is
easier to port programs written in a mixture of FORTRAN and C to other computer
systems than to port programs written purely in FORTRAN that make use of
machine specific routines like VMS system services. Sections \ref{f77:c-from-f}
and \ref{calling-c} of this document describe how to mix FORTRAN and C in a way
that is portable to all current Starlink hardware.

It is quite likely that you will often want to use C to make use of something
that the C run time library provides, such as allocating memory. This
requirement is sufficiently common that a library of FORTRAN callable routines
has already been provided to do exactly that. It is called PSX and is described
in SUN/121. In many programs, use of the PSX library will remove the need to
write any C code at all.

You may think that if you want to use C for part of a program then you should
use C for all of the program. This may indeed be the best option; however, if
you also want to call subroutines that are written in FORTRAN (e.g.\ just about
any Starlink library), then you are going to be involved in mixed language
programming anyway. The correct choice will depend on the circumstances.

Writing mixed language programs is not something that should be embarked upon
lightly. There might be a better way of achieving the same result using just
FORTRAN. The source code may not look as pretty, but if it runs effectively and
efficiently then that is all that is required. If you can achieve what you want
using standard FORTRAN then you should do so. If you cannot, then this document
will tell you how to mix FORTRAN and C {\em in a portable way}. The programming
language manuals of the computer manufacturers tell you how to mix languages on
their own hardware, but achieving portability needs a little more thought.

Finally, if you are new to C, you should be aware that the way that things are
normally done in C can be rather different from the way that they are normally
done in FORTRAN. When I was new to C, I proudly showed someone one of my first
C programs. `That's not a C program,' they said,  `That's a FORTRAN program
that's written in C.' They were, of course, right. A useful book an C
programming is Banahan \cite{Banahan}. This describes how to write programs in
ANSI standard C and is written in an easy-going style. The author is not averse
to criticizing C when he thinks that a feature of the language is not
appropriate.

\section{Cookbook}

This section introduces mixed language programming. It skips over many of the
details and concentrates on how to get programs going. For a fuller explanation
of mixed language programming, you should read the rest of this document.

\subsection{Calling C from FORTRAN}

Why would you want to call a C function from a FORTRAN program? Typically this
will be to do something in the C function that cannot be done from FORTRAN, at
least not in the way that you would like. On account of this, realistic
examples of calling C from FORTRAN can be rather involved. After all, you can
do most simple things from FORTRAN itself. So as not to obscure how to go about
writing mixed language programs with complex C functions, the examples in this
section concentrate on what to do when mixing C and FORTRAN rather than on
providing realistic examples of this.

Here is an example of a FORTRAN program that calls a C function which sets
various arguments.

\refstepcounter{examples}
\label{ex:cook-ex1}
\begin{center}
Example \ref{ex:cook-ex1} -- Passing arguments between FORTRAN and C.
\end{center}
\nopagebreak[4]
FORTRAN program:
{\small \begin{verbatim}
      PROGRAM COOK1
      INTEGER I,J
      REAL A,B
      CHARACTER*(80) LINE
      LOGICAL X

      I = 1
      A = 5.0
      X = .FALSE.
      LINE = ' '
      CALL SILLY1( A, B, I, J, LINE, LEN(LINE), X )
      PRINT *, LINE

      END
\end{verbatim} }
C function:
\nopagebreak[4]
{\small \begin{verbatim}
      #include "cnf.h"
      #include "f77.h"

      F77_SUBROUTINE(silly1)( REAL(a), REAL(b), INTEGER(i), INTEGER(j),
         CHARACTER(line), INTEGER(line_l), LOGICAL(x) TRAIL(line) )
      {
         GENPTR_REAL(a)
         GENPTR_REAL(b)
         GENPTR_INTEGER(i)
         GENPTR_INTEGER(j)
         GENPTR_CHARACTER(line)
         GENPTR_INTEGER(line_l)
         GENPTR_LOGICAL(x)

         char str[] = "This is a string";

         if( F77_ISTRUE(*x) )
         {
            *b = *a;
            *j = *i;
         }
         else
         {
            cnf_exprt( str, line, *line_l );
         }
      }
\end{verbatim} }

This is a rather silly example, but it does illustrate all of the important
points of calling C from FORTRAN. The FORTRAN program is completely standard.
The name of the C function is declared using a macro {\bf F77\_\-SUBROUTINE}.
Do not leave any spaces around the name of the routine. This can cause problems
on some systems. The dummy arguments of the function are declared using macros
named after the FORTRAN type of the actual argument. The only odd thing is the
macro called {\bf TRAIL}. Each argument of type {\bf CHARACTER} should have a
corresponding {\bf TRAIL} added to the end of the argument list. N.B. {\bf
TRAIL} macros must not have a comma in front of them. All C functions that are
to be called from FORTRAN should be declared in a similar manner.

There then follows a set of {\bf GENPTR\_\-{\em type}} macros; one for each
argument of the function. {\bf TRAIL} arguments are not counted as being true
arguments and so there are no {\bf GENPTR} statements for them. Note that there
are no semicolons at the end of these lines.

The only other macro used is {\bf F77\_\-ISTRUE}. This should be used whenever
an argument is treated as a logical value, and takes into account the different
ways that FORTRAN and C may interpret bit patterns as logical values.

Note that all explicit function arguments are pointer arguments. This is
necessary if their value is to be modified in the function. The consequence of
this is that scalar arguments must be referred to by {\tt*}{\em arg} within
the function.

FORTRAN and C store character strings in different ways. FORTRAN stores them as
fixed length, blank filled strings while C stores them as variable length, null
terminated strings. If a C function needs to work with character strings that
have been passed from a calling FORTRAN routine, then the FORTRAN string must
be copied into an equivalent local copy. Similarly, a C function may need to
return a string to the calling FORTRAN routine. This is a very common
occurrence, so a set of C functions are provided to do this. They are called CNF
functions and are fully described in appendix \ref{cnf:description}.
Essentially they just copy a FORTRAN string to a C string and vice versa. In
the above example, the function {\bf cnf\_exprt} copies the C string {\bf str}
into the FORTRAN string {\bf line}.

The final step is compiling and linking the program.

On VMS, suppose the main FORTRAN program is in the file COOK1.FOR and the C
function is in the file SILLY1.C, then the commands are
\begin{quote}{\tt
CNF\_DEV\\
FORTRAN COOK1\\
CC SILLY1\\
LINK COOK1,SILLY1,CNF\_IMAGE/OPT
}
\end{quote}

On Unix, the files are taken to be cook1.f and silly1.c, so the commands are
\begin{quote}{\tt
cc -c -I/star/include silly1.c\\
f77 cook1.f silly1.o -L/star/lib `cnf\_link`
}
\end{quote}

In the Unix example, since the linking is done by the f77 command, the
C compilation must be done before the FORTRAN one. Note that compiling the
FORTRAN routine first and then trying to link the routine using the {\tt cc}
command generally does not work.

\subsection{Calling FORTRAN from C}

Why would you want to call a FORTRAN subprogram from a C routine? Typically
this would be because you want to use a precompiled library of routines that
were written in FORTRAN. The NAG library is a prime example. This can be bought
in a C callable version, but this is not yet available on Starlink machines.

To see how to call FORTRAN from C, let us consider the above example, but now
with the roles of FORTRAN and C exchanged.

\refstepcounter{examples}
\label{ex:cook-ex2}
\begin{center}
Example \ref{ex:cook-ex2} -- Passing arguments between C and FORTRAN.
\end{center}
\nopagebreak[4]
C program:
{\small \begin{verbatim}
      #include "cnf.h"
      #include "f77.h"

      #define FLINE_LENGTH 80
      
      extern F77_SUBROUTINE(silly2)( REAL(a), REAL(b), INTEGER(i), INTEGER(j),
         CHARACTER(line), INTEGER(line_l), LOGICAL(x) TRAIL(line) );

      main()
      {
         DECLARE_INTEGER(i);
         DECLARE_INTEGER(j);
         DECLARE_INTEGER(fline_l);
         DECLARE_REAL(a);
         DECLARE_REAL(b);
         DECLARE_LOGICAL(x);
         DECLARE_CHARACTER(fline,FLINE_LENGTH);

         char line[FLINE_LENGTH+1];

         fline_l = FLINE_LENGTH;

         i = 1;
         a = 5.0;
         x = F77_FALSE;

         F77_EXTERNAL_NAME(silly2)( REAL_ARG(&a), REAL_ARG(&b), INTEGER_ARG(&i),
           INTEGER_ARG(&j), CHARACTER_ARG(fline), INTEGER_ARG(&fline_l),
           LOGICAL_ARG(&x) TRAIL_ARG(fline) );

         cnf_imprt( fline, FLINE_LENGTH, line );

         printf( "%s\n", line );
      }
\end{verbatim} }
\pagebreak[3]
FORTRAN function:
\nopagebreak[4]
{\small \begin{verbatim}
      SUBROUTINE SILLY2( A, B, I, J, LINE, LINE_L, X )
      REAL A, B
      INTEGER I, J
      CHARACTER * ( * ) LINE
      INTEGER LINE_L
      LOGICAL X

      IF( X ) THEN
        B = A
        J = I
      ELSE
         LINE = 'This is a string'
      END IF

      END
\end{verbatim} }

In the above C main program, the variable {\tt fline\_l} is declared and set
equal to the constant {\tt FLINE\_LENGTH}. At first sight this is unnecessary.
However, this is not the case, as we need to pass the value of {\tt
FLINE\_LENGTH} to the subroutine and it is not possible to pass constants to
FORTRAN subroutines. Only variables can be passed.

Armed with the above examples, you should be in a position to start
experimenting with mixed language programming. For further information, read
on.

\section{Representation of data}

Different languages have differing fundamental data types on which they can
operate. FORTRAN has the types INTEGER, REAL, DOUBLE PRECISION, COMPLEX,
LOGICAL and CHARACTER. The only aggregate data type that it supports is the
array, although a character variable can store many characters. C supports the
fundamental types {\bf int}, {\bf float}, {\bf double}, {\bf char}, and {\bf
void}. It also allows {\bf int} to be modified by the type specifiers {\bf
short} or {\bf long}, {\bf signed} or {\bf unsigned}, {\bf char} to be modified
by {\bf signed} or {\bf unsigned} and {\bf double} to be modified by {\bf
long}. However, on any given machine, some of the {\bf short}, normal and {\bf
long} types may be represented in the same way. Note that, unlike FORTRAN, a C
character variable can only store a single character. Also unlike FORTRAN, a C
character variable is treated as a type of integer rather than as a separate
type. Finally, ANSI C has the type {\bf enum}, an enumerated list of values.
The aggregate data types are the array, structure and union. New types can be
defined in terms of the basic types by means of a {\bf typedef} statement.

When writing mixed language programs, it is clearly important to know which
FORTRAN types map on to which C types; in particular, which similar types use
the same amount of storage. This will be discussed more fully in the machine
dependent sections in appendix \ref{implement}; however, there are some general
points to be considered first.

\subsection{Numeric Types}

If data are to be passed between routines that have been written in different
languages, then it is important that those languages represent the data in the
same way. The FORTRAN standard makes no statements about how any of the data
types should be implemented and there is almost nothing in the C standard
either. For example, if a certain bit pattern was interpreted as the integer
$-2$ by FORTRAN, yet the same bit pattern was interpreted by C as $-1$, then
there are going to be serious problems trying to communicate between routines
written in different languages. Fortunately, the hardware on which the program
is running provides a constraint for those data types that are implemented
directly in the  hardware. For example, all reasonable computers have
instructions for operating on integers and it would be a particularly perverse
compiler writer who chose not to use the hardware representation. Something
that is slightly more likely to be a problem is the way that floating point
numbers are represented. If the hardware supports floating point arithmetic,
then you are in the same situation as for integers and all should be well.
However, if the hardware does not support floating point arithmetic, then there
could be problems. Some older PCs do not have floating point hardware, although
modern PCs either support floating point operations directly in hardware, or
there is a recognised way of representing floating point numbers that is
generally adhered to. The bottom line on numerical data types is that it is
most unlikely that different languages will represent the same number in a
different manner on the same hardware.

\subsection{Characters}

When considering character data, things are a bit more complicated in that the
hardware does not impose a meaning on a given bit pattern. It is the operating
system that does that. The character codes that are in common use are the ASCII
collating sequence and the EBCDIC collating sequence. EBCDIC is only used by
IBM mainframe and minicomputers (and their clones), but there are a lot of IBM
computers around. (The IBM PC does {\it not}\, use EBCDIC.) Again it would be
rather perverse if, on a given computer, FORTRAN and C used a different
representation of characters, so that is not really worth worrying about. What
certainly is worth paying attention to is the possibility that any given
program may be run on several different computers, some using ASCII characters
and some using EBCDIC. That is not a concern that is particular to mixed
language programming though.

An important point about character data is that they are stored differently in
FORTRAN and C. FORTRAN stores character data as a fixed length string padded
with trailing blanks whereas C stores character data as a variable length, null
terminated string. The difference is standardized, so it does not lead to
problems with portability, but it is something that will involve extra work
when passing character data between routines written in different languages.

\subsection{Logical Types}

So far all seems well. However, a place that can certainly cause problems is
the representation of logical values. In principle, it is completely up to the
compiler writer to chose how logical values are represented. What is even worse
as far as C is concerned is that there is no logical type at all! In C, a
numerical value of zero represents false and anything else represents true, but
these are numeric data types, not logical types. On a VAX/VMS system, FORTRAN
represents a logical value of false by an integer zero and true by an integer
minus one; however, only the bottom bit is tested, so if an integer value of 2
were to be treated as a logical value, then it would be taken as false. C, on
the other hand, would treat it as true.

\subsection{Arrays}

Although the representation of a single numerical value is unlikely to cause a
problem, the way that arrays of numbers are stored is different between
different languages. One dimensional arrays are the least problem, but even
then there are differences. In C, all arrays subscripts start at zero, and this
cannot be changed. In FORTRAN, subscripts start at one by default, but this can
be modified so that the lower bound of a dimension of an array can be any
integer. What must be remembered is that the array element with the lowest
subscript in a FORTRAN array will map on to the array element with a zero
subscript when treated as a C array. This is not a serious problem as long as
you remember it.

Multi-dimensional arrays are a well known problem since FORTRAN stores
consecutive array elements in column-major order (this {\em is}\, is specified
in the FORTRAN standard) whereas other languages store them in row-major order.
For example, in FORTRAN, the order of elements in a 2 x 2 array called A are
A(1,1), A(2,1), A(1,2), A(2,2), whereas in C this would be A[0,0], A[0,1],
A[1,0], A[1,1]. In practice this is rarely a serious problem as long as you
remember to take account of the reversed order when writing a program. However,
when coupled with the difference in default lower bounds (zero in C, one in
FORTRAN) it is a fruitful source of bugs.

\subsection{Same Language -- Different Compiler}

In the preceding sections, reference is often made to `the way that FORTRAN
does something' or `the way that C does something'. However, even different
compilers for the same language can do things in a different way if the
standard does not specify how that something should be done. A reasonable
example is that one FORTRAN compiler might represent a true logical value by
the integer 1, whereas another might just as reasonably use $-1$. This is not
just a hypothetical problem; the FORTRAN for RISC compiler from MIPS and the
DEC FORTRAN for RISC compiler both work on the DECstation and interpret the
same number as different logical values. I shall continue to refer to `the way
that FORTRAN does it', even though it is more correct to refer to `the way that
FORTRAN compiler XYZ implements it'. The distinction is rarely important, but
should be borne in mind.

\section{Communication between routines}

There are three ways of passing data between a program and a subprogram:
(i)~the argument list of the subprogram, (ii)~the return value of the
subprogram if it is a function and (iii)~global variables. The concept of
arguments and return values of subprograms are common to many programming
languages including FORTRAN and C. The ways in which global variables are
handled are rather different. In FORTRAN there are common blocks whereas in C
there are external variables or structures. Each of these will be considered in
turn.

\subsection{Arguments}
\label{arg}

This is the main method for passing data between a calling program and the
called subprogram. The calling program takes the actual arguments of the call
to the  subprogram, constructs an argument list and then passes execution to
that routine. The subprogram then uses the values in the argument list to
access the actual arguments. It may pass data back to the calling program by
modifying the data in some or all of the arguments. As far as passing arguments
between a program and a subprogram is concerned, the principal difference
between FORTRAN and C is the method used for passing the arguments.

Note that the above paragraph refers to modifying arguments. On a VMS, SunOS or
Ultrix machine, the actual contents of the argument list is never modified.
What may be modified is the contents of the location pointed to by an element
of the argument list. This is not to say that other computers would not modify
the argument list itself.

There are three commonly used methods for passing subprogram arguments: call by
value, call by reference and call by descriptor. Call by value passes the
actual value of the argument to the called routine, call by reference passes a
pointer to the value of the argument (i.e.\ the address of the argument) and
call by descriptor passes a pointer to a structure describing the argument.
Although these are the basic methods of passing arguments, a particular type of
argument may be passed by a combination of these. As is described in
section~\ref{sun:arg}, the FORTRAN compiler on a Sun workstation uses a
combination of call by reference and call by value to pass character arguments.
What is common is that all arguments are passed by exchanging data values. It
is how those values are to be interpreted that gives rise to the different
mechanisms.

The FORTRAN standard does not specify how arguments should be passed to
subprograms and indeed different compilers for different machines do use
different methods. It is most usual for numeric data types to be passed by
reference since the subprogram may modify the value of the argument. This is
most easily achieved by passing a pointer to the storage location containing
the data value, rather than a copy of the value itself. On the other hand, the
C standard explicitly states that values cannot be returned to the calling
routine directly through arguments and so call by value is most commonly used.
It is worth recalling that the argument list of a routine is simply a sequence
of computer words. If these are a list of addresses of data values then
everything is simple. However, suppose that an array was passed by value. This
would mean that the compiler would have to arrange for a copy of the entire
array to be placed in the argument list that was passed to the called
subprogram. Consequently, arrays are invariably passed by reference or by
descriptor, never by value.

It may seem tedious to have to think about the actual mechanisms that a
compiler uses to pass data between routines when all you want to do is to get
on with your programming. However, understanding this is the key to mixed
language programming. Fortunately the facilities described in
section~\ref{f77:c-from-f} hide much of this from the programmer. 

\subsection{Function Values}

The second mechanism for passing data between routines is the return value of a
function. FORTRAN makes a distinction between subprograms that return a value
(functions) and those that do not (subroutines), whereas C does not. All C
subprograms are functions that return a value (even the main program), although
that value may be {\bf void}. Since it is simply a value that is being
returned, the mechanisms for returning scalar numeric values tend to be just
that -- a value is returned. However, things get more complicated in the case of
functions returning things like character variables. This will be discussed
further in appendix \ref{implement} on machine dependencies.

\subsection{Global Data}

Different languages can have very different ways of dealing with variables that
are not local to a particular routine, but have a more global scope. FORTRAN
has common blocks for global data that are accessed by particular routines. The
data values in a common block can be accessed by different names in different
routines, although this is generally considered bad practice. C functions can
access global data by using variables that are not declared in a particular
routine, but have a scope of all the routines contained in the source file in
which the global variables are defined. If the same variable is needed across
several source files, then it can be declared as {\bf extern}.

Although these two mechanisms are very different in principle, in practice,
computer manufacturers tend to implement them in a way such that it is possible
to share global data between routines that have been written in different
languages. The details of how this is done are given in the appendix about
specific machines. However, there is an indirect way of accessing FORTRAN
common blocks from C that is also worth considering. The FORTRAN routine that
calls the C function can pass as an argument, the first element of the common
block. As long as FORTRAN passes this argument by reference, then the C
function can use this address to access all of the other elements of the common
block. The elements of the common block must be stored contiguously. Whether
this method, or the use of the macros described in section~\ref{f77:c-from-f},
achieve a greater degree of portability in this respect is not known at
present. On account of these potential portability problems, you should avoid
passing global data between routines written in different languages, whenever
possible.

\section{Calling C routines from FORTRAN}
\label{f77:c-from-f}

As the examples in the appendix on machine specific details show, different
computers handle subroutine interfaces in different ways. This apparently makes
it difficult to write portable programs that are a mixture of FORTRAN and C.
However, it is only the C code that differs and fortunately the differences can
be hidden by suitable C macros so that the same code can be compiled on all
types of hardware mentioned in this document. The macros have been constructed
in such a way that they can accommodate other subroutine passing mechanisms;
however, it is not possible to guess all the types of mechanisms that we might
come across.

The macros can be used in a C function by including the file {\bf f77.h}. This
file will naturally be stored in different places on different types of system,
even if it is only the syntax of the file name that is different. It would be a
pity if all of the implementation specific details were hidden away in these
macros, only to have to have an implementation specific {\bf \#include}
statement in each C source file. Fortunately there is a way around this
problem that is described in the section on compiling and linking
(section~\ref{compiling-and-linking}).

Let us now consider an example of using the F77 macros to illustrate
their use.

\refstepcounter{examples}
\label{ex:f77-ex1}
\begin{center}
Example \ref{ex:f77-ex1} -- Passing arguments between FORTRAN and C.
\end{center}
\nopagebreak[4]
FORTRAN program:
{\small \begin{verbatim}
      PROGRAM F1
      INTEGER FIRST, MIDDLE, GAP
      CHARACTER*(80) LINE

      FIRST = 5
      MIDDLE = 10
      GAP = 3
      CALL BANNER( LINE, FIRST, MIDDLE, GAP )
      PRINT *, LINE

      END
\end{verbatim} }
\pagebreak[3]
C function:
\nopagebreak[4]
{\small \begin{verbatim}
      #include "f77.h"

      F77_SUBROUTINE(banner)( CHARACTER(line), INTEGER(first), INTEGER(middle), 
                              INTEGER(gap) TRAIL(line) )
      {
         GENPTR_CHARACTER(line)
         GENPTR_INTEGER(first)
         GENPTR_INTEGER(middle)
         GENPTR_INTEGER(gap)

         int i, j;       /* Loop counters.  */
         char *cp;       /* Pointer to a character.  */

      /* Make cp point to the beginning of the string line.  */
         cp = line;

      /* First blanks.  */
         for( i = 0, j = 0 ; (j < line_length) && (i < *gap) ; i++, j++ )
            *cp++ = ' ';

      /* First hyphens.  */
         for( i = 0 ; (j < line_length) && (i < *first) ; i++, j++ )
            *cp++ = '-';

      /* More blanks.  */
         for( i = 0 ; (j < line_length) && (i < *gap) ; i++, j++ )
            *cp++ = ' ';

      /* Middle stars.  */
         for( i = 0 ; (j < line_length) && (i < *middle) ; i++, j++ )
            *cp++ = '*';

      /* More blanks.  */
         for( i = 0 ; (j < line_length) && (i < *gap) ; i++, j++ )
            *cp++ = ' ';

      /* Last hyphens.  */
         for( i = 0 ; (j < line_length) && (i < *first) ; i++, j++ )
            *cp++ = '-';
      }
\end{verbatim} }

This program generates a banner to separate sections of output. The banner
consists of some hyphens, followed by some stars and finally the same number
of hyphens again. There are also some blanks between the beginning of the line
and between the hyphens and stars. The work is done in the subroutine BANNER
and the form of the output is governed by the three arguments FIRST, MIDDLE and
GAP. For example, CALL BANNER( LINE, 5, 10, 3 ) would return with LINE set to
the following character string.

\begin{verbatim}
   -----   **********   -----
\end{verbatim}

The FORTRAN part of this example is completely standard; it is the C code that
need further explanation. Firstly there is the declaration of the subroutine
with the macro F77\_SUBROUTINE. This handles the fact that some computer
systems require a trailing underscore to be added to the name of the C function
if it is to be called from FORTRAN. In the same statement there are the
function's dummy arguments, declared using the macros CHARACTER, INTEGER and
TRAIL. The INTEGER macro declares the appropriate dummy argument to handle an
incoming argument passed from FORTRAN. This will usually be declared to be
`pointer to {\bf int}'. The CHARACTER and TRAIL macros come in pairs. The
CHARACTER macro declares the appropriate argument to handle the incoming
character variable and TRAIL may declare an extra argument to handle those
cases where an extra hidden argument is added to specify the length of a
character argument. On some machines, TRAIL will be null and on account of this
{\em there should not be a comma before any TRAIL macros}. When TRAIL is not
null, then it will add the comma itself. If there are several TRAIL macros then
there must not be a comma directly in front of any of them.

The next set of macros are the GENPTR\_{\it type}\/ macros, one for each
argument of the FORTRAN subroutine (TRAIL arguments are not counted as separate
arguments for this purpose). These handle the ways that subprogram arguments
may be passed on different machines. They ensure that a pointer to the argument
exists. On most systems, this is exactly what is passed from the FORTRAN
program and so the macros for numeric arguments are null. If a particular
system passed the value of an argument, rather than its address, then these
macros would generate the appropriate pointers.

The CHARACTER, TRAIL and GENPTR\_CHARACTER macros have to cope with the
different ways that systems deal with passing character variables. Although the
way that these macros are implemented can be a bit complex, what the programmer
sees is essentially simple. For each character argument, the macros generate a
pointer to a character variable and an integer holding the length of that
character variable. The above example will create the variable {\bf line} of
type {\bf char \tt*} and variable {\bf line\_length} of type {\bf int}. If
these are available directly as function arguments, then the macro
GENPTR\_CHARACTER will be null, otherwise it will generate these two variables
from the arguments. The best way of seeing what is going on is to compile a
function with macro expansion turned on and list the output.

There is an important difference between this example and the one in the
cookbook. In this case, an {\bf int} variable containing the length of the
character argument is generated automatically whereas in the example in the
cookbook the length was passed explicitly. In fact, the {\bf int} variable was
also generated in the example in the cookbook, but it was not used. It is more
portable to explicitly pass the length of CHARACTER variables and to ignore
the automatically generated length as this will cope with the situation where
the length cannot be generated automatically. No such machines are known to the
author at present, but Murphy's Law would indicate that the next machine that
we desperately need to use will have this problem.

Although the use of these macros does seems a bit strange at first, once any
pointers have been generated, the rest of the code is standard C.

Something that has not yet been considered is whether to write the code in
upper or lower case. All of the examples in this document have the FORTRAN code
in upper case and the C code in lower case, thereby following common practice.
Normally it makes no difference whether code is written in upper case or lower
case. Where is does matter is in declaring external symbols. External symbols
are names of routines and names of common blocks (FORTRAN) or variables
declared {\bf extern} (C). The linker must be able to recognise that the
external symbols in the FORTRAN routines are the same external symbols in the C
functions. On a VMS system, the VAX~C compiler will fold all external symbols
to upper case by default, although there is a compiler option to fold them all
to lower case or leave them as written in the source code. The VAX FORTRAN
compiler will generate all external symbols in upper case. On Unix systems, the
FORTRAN compiler will typically fold external names to lower case (and add a
trailing underscore), whereas the C compiler will leave the case unchanged.
Consequently, all external symbols in C functions that might be referenced from
FORTRAN should be coded in lower case.

\subsection{General Description}

Having considered an example of using the macros to write a C function that is
to be called from FORTRAN, let us look at all of the macros in more details.
You will notice that some of the macros are prefixed by F77 while others are
not. Those that do not have the F77 prefix are those that occur in standard
places in the source code and so are unlikely to be confused with other macros.
The macros that do have the F77 prefix are those that declare a C function and
others that are less commonly used, and when they are, they can occur anywhere
within the body of the C routine. A full description of each macro is given in
appendix~\ref{f77:description}.

The whole ethos of the F77 macros is to try to isolate the FORTRAN -- C
interface to the beginning of the C function. Within the body of the C
function, the programmer should not need to be aware of the fact the this
function is designed to be called from FORTRAN. It is not possible to achieve
this completely and at the same time retain portability of code, but the 
intention is there none the less.

\subsection{Declaration of a Function}

There are two types of macros involved in declaring a C function that is to be
called from FORTRAN; the function name and the function arguments. If the C
function is to be treated as a FORTRAN subroutine, then it should be declared
with the macro {\bf F77\_SUBROUTINE}. This will declare the C function to be of
type {\bf void} and will generate the correct form of the of the routine name,
handling such things as appending a trailing underscore where required.

If the C function is to be treated as a FORTRAN function, then it should be
declared with one of the macros {\bf F77\_INTEGER\_FUNCTION}, {\bf
F77\_REAL\_FUNCTION}, {\bf F77\_DOUBLE\_FUNCTION}, {\bf
F77\_LOGICAL\_FUNCTION}, {\bf F77\_CHARACTER\_FUNCTION}, {\bf
F77\_BYTE\_FUNCTION} or {\bf F77\_WORD\_FUNCTION}. These macros will declare
the function to be of the appropriate type, e.g.\ a function declared with {\bf
F77\_INTEGER\_FUNCTION} is likely to be of type {\bf int}.

The declaration of a C function that is to be treated as a FORTRAN character
function is more complex than one that returns a scalar numeric or logical
value. The first argument of the function should be {\bf
CHARACTER\_RETURN\_VALUE(return\_value)}, where {\bf return\_value} is a
variable of type `pointer to {\bf char}'. Although character functions work
perfectly well on all current Starlink hardware, it is one of the more
difficult things to guess how other manufacturer might implement them.
Consequently, it is recommended that character functions be avoided where
possible and that a subroutine that returns a character argument be used
instead.

\subsection{Declaration of Arguments}

Scalar arguments are declared with the macros {\bf INTEGER}, {\bf REAL}, {\bf
DOUBLE}, {\bf LOGICAL}, {\bf BYTE}, {\bf WORD}, {\bf CHARACTER} and {\bf TRAIL}.
The macros that declare numeric and logical arguments take account of the fact
that a FORTRAN integer variable may correspond to a C type of {\bf int} on one
machine, but to {\bf long int} on another. They also handle the mechanism that
is used to pass the arguments.

Character arguments are more complex as different computers use differing
mechanisms for passing the arguments. To take account of this, for every
argument that is declared using the {\bf CHARACTER} macro, there should be a
corresponding {\bf TRAIL} macro at the end of the list of dummy arguments. As
mentioned in a preceding example, {\em there should not be a comma before any
TRAIL macros}.

C differs from FORTRAN in that it has pointer variables. These are often used to
manipulate arrays, rather than by using array subscripts. The macros that are
used to declared array arguments do in fact declare them to be arrays. If the
programmer wishes to manipulate these arrays by means of pointer arithmetic,
then for maximum portability they should declare separate pointers within the C
function that point to the array argument.

Array arguments are declared by one of the macros 
{\bf INTEGER\_ARRAY}, {\bf REAL\_ARRAY}, {\bf DOUBLE\_ARRAY}, {\bf
LOGICAL\_ARRAY}, {\bf BYTE\_ARRAY}, {\bf WORD\_ARRAY}, {\bf CHARACTER\_ARRAY}.
The macros {\em type}{\bf\_ARRAY} that declare numeric or
logical array arguments declare the arrays to be of unspecified size, e.g.\
{\bf int vector[\,]}. To enable the C function to process the array correctly,
the dimensions of the array should be passed as additional arguments.

The macro {\bf CHARACTER\_ARRAY} has a second argument to specify the number of
individual characters in each FORTRAN array element. This is required as C
handles a one dimensional FORTRAN character array as a two dimensional array of
type {\bf char}, i.e.\ the FORTRAN statement:

\begin{quote}{\tt
CHARACTER * ( NCHAR ) NAMES(DIM)
}
\end{quote}

is equivalent to the C statement:

\begin{quote}{\tt
character names[dim][nchar]
}
\end{quote}

The CNF macros do not allow you to declare fixed sized dimensions for an array
that is a dummy argument. Normally, it is necessary to pass the dimensions as
arguments of the routine anyway, but there are circumstances where the
dimensions of the array will be fixed, e.g.\ an array might specify a rotation
in space and hence is always 3 {\tt x} 3. What is gained by declaring the
fixed dimensions of the array is that subscript calculations can be done on
arrays of more than one dimension. Unfortunately, such declarations cannot be
made portable as some FORTRAN systems pass arrays by descriptor. If you really
must declare arrays with fixed dimensions, you can do so as follows:

{\small \begin{verbatim}
      F77_SUBROUTINE(subname)( F77_INTEGER_TYPE array[3][3] )
      {
         ...
         elem = array[i][j]
         ...
      }
\end{verbatim} }

This example declares the dummy argument to be an INTEGER array of fixed size. 
Although the subscript calculation can be performed as the routine knows the
size of the array, the {\bf sizeof} operator does not return the full size of
the array as the complier casts {\bf array[3][3]} to {\tt *}{\bf array}. All
things considered, it is better to have the dimensions of array passed as
separate argument and to do the subscript arithmetic yourself with pointers.
Here is an example of initializing an array of arbitrary size and arbitrary
number of dimensions.

\refstepcounter{examples}
\label{ex:f77-arbary}
\begin{center}
Example \ref{ex:f77-arbary} -- Passing an array of arbitrary size from FORTRAN
to C.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
{\small \begin{verbatim}
      PROGRAM ARY

      INTEGER NDIMS, DIM1, DIM2, DIM3
      PARAMETER( NDIMS = 3, DIM1 = 5, DIM2 = 10, DIM3 = 2 )

      INTEGER DIMS( NDIMS )
      INTEGER A( DIM1, DIM2, DIM3 )

      DIMS( 1 ) = DIM1
      DIMS( 2 ) = DIM2
      DIMS( 3 ) = DIM3
      CALL INIT( A, NDIMS, DIMS )

      END
\end{verbatim} }
\pagebreak[1]
C function:
\nopagebreak[4]
{\small \begin{verbatim}
      #include "f77.h"

      F77_SUBROUTINE(init)( INTEGER_ARRAY(a), INTEGER(ndims), INTEGER_ARRAY(dims) )
      {
         GENPTR_INTEGER_ARRAY(a)
         GENPTR_INTEGER(ndims)
         GENPTR_INTEGER_ARRAY(dims)

         int *ptr = &a[0];  /* ptr now points to the first element of a.  */
         int size = 1;      /* Declare and initialize size.  */
         int i;             /* A loop counter.  */

         /* Find the number of elements in a.  */

         for( i = 0; i < *ndims ; i++ )
            size = size * dims[i];

         /* Set each element of a to zero.  */

         for( i = 0 ; i < size ; i++ )
            *ptr++ = 0;
      }
\end{verbatim} }

In this example, each element of the array {\bf a} is accessed via the pointer
{\bf ptr}, which is incremented each time around the last loop.

\subsection{Arguments -- and pointers to them}

When a FORTRAN program calls a subprogram, it is possible for the value of any
of its arguments to be altered by that subprogram. In the case of C, a function
cannot return modified values of arguments to the calling routine if what is
passed is the value of the argument. If a C function is to modify one of its
argument, then the address must be a pointer to the value to be modified rather
than the actual value. Consequently in C functions that are designed to be
called from FORTRAN, all function arguments should be treated as though the
address of the actual argument had been passed, not its value. This means that
the arguments should be referenced as {\tt *}{\em arg} from within the C
function and not directly as {\em arg}. This may seem odd to a FORTRAN
programmer, but is natural to a C programmer. 

To ensure that there always exists a pointer to each dummy argument,
the first lines of code in the body of any C function that is to be called from
FORTRAN should be {\bf GENPTR} macros for each of the function arguments. The
macros {\bf GENPTR\_INTEGER}, {\bf GENPTR\_REAL}, {\bf GENPTR\_DOUBLE}, {\bf
GENPTR\_LOGICAL}, {\bf GENPTR\_BYTE} and {\bf GENPTR\_WORD} always result in
there being a C variable of type `pointer to variable' for all non character
variables. For example, {\bf GENPTR\_INTEGER(first)} ensures that there will be
a variable declared as {\bf int {\tt *}first}. On all current types of system,
this macro will actually be null since the pointer is available directly as an
argument. However, the macro should be present to guard against future
computers working in a different way. For example, if a particular system
passed FORTRAN variables by value rather than by reference, then this macro
would construct the appropriate pointer.

Character arguments are different in that the {\bf GENPTR} macro ensures that
there are two variables available, one of type `pointer to char' that points to
the actual character data, and one of type {\bf int} that is the length of the
character variable. The name of the variable that holds the length of the
character string is constructed by appending {\bf `\_length'} to the name of
the character variable. For example, if a function is declared to have a dummy
argument with the macro {\bf CHARACTER(ch)} and a corresponding {\bf
TRAIL(ch)}, then after the execution of whatever the macro {\bf
GENPTR\_CHARACTER(ch)} expands into, there will be a `pointer to character'
variable called {\bf ch} and an integer variable called {\bf ch\_length}.
Although the length of a character variable is directly accessible through the
{\bf int} variable {\bf ch\_length}, it is better to pass the length of the
character variable explicitly if maximum portability is sought. This is
because, although it works on all currently supported platforms, it may not be
possible to gain access to the length on some machines.

It is important to remember that what is available after the execution of what
a {\bf GENPTR} macro expands into will be a pointer to the dummy argument, not a
variable of numeric or character type. Consequently the body of the code should
refer to it as {\tt *}{\em arg} and not as {\em arg}. In a long C function, it
may be worth copying scalar arguments into local variables to avoid having to
remember to put the {\tt *} on each reference to an argument. If the variable
is changed in the function, then it should of course be copied back into the
argument at the end of the function. Alternatively you could define C macros to
refer to the pointers, such as

\begin{quote}{\tt
\#define STATUS *status
}
\end{quote}

Note that although ANSI C will allow the above as {\bf status} and {\bf STATUS}
are distinct names, you should beware of the possibility of a computer that
does not have lower case characters. Such machines used to exist in abundance,
but at present, this does seem a remote possibility.

Array arguments should have pointers generated (if necessary) by using the {\bf
GENPTR\_{\em type}\_ARRAY} macros. All arrays are handled by these macros.

\subsection{Type Specifiers}

There are macros {\bf F77\_\-INTEGER\_\-TYPE}, {\bf F77\_\-REAL\_\-TYPE}, {\bf
F77\_\-DOUBLE\_\-TYPE}, {\bf F77\_\-LOGICAL\_\-TYPE}, {\bf
F77\_\-CHARACTER\_\-TYPE}, {\bf F77\_\-BYTE\_\-TYPE}, {\bf F77\_\-WORD\_\-TYPE}
which expand to the C data type that corresponds to the FORTRAN data type of
the macro name, e.g.\ on a particular computer {\bf F77\_\-INTEGER\_\-TYPE} may
expand to {\bf int}. These are usually not needed explicitly within user
written code, but can be required when declaring common blocks, casting values
from a variable of one type to one of a different type and when using the {\bf
sizeof} operator.

\subsection{Logical Values}

The macros {\bf F77\_\-FALSE} and {\bf F77\_\-TRUE} expand to the numerical
values that FORTRAN treats as false and true (e.g. 0 and 1). They should be used
when setting logical values to be returned to the calling FORTRAN routine.
There are also macros {\bf F77\_\-ISFALSE} and {\bf F77\_\-ISTRUE} that should
be used when testing a function argument for truth or falsehood.

\subsection{External Names}

The macro {\bf F77\_\-EXTERNAL\_\-NAME} handles the difference between the
actual external name of a function called from FORTRAN and a function that
apparently has the same name when called from C. Typically this involves
appending an underscore character to a name. This macro is not normally needed
directly by the programmer, but is called by other macros.

\subsection{Common Blocks}

There are two macros that deal with common blocks, {\bf F77\_\-NAMED\_\-COMMON}
and {\bf F77\_\-BLANK\_\-COMMON}. They are used when declaring external
structures that corresponds to FORTRAN common blocks and when referring to
components of those structures in the C code. The following declares a common
block named `block' that contains three INTEGER variables and three REAL
variables.

{\small \begin{verbatim}
      extern struct
      {
        F77_INTEGER_TYPE i,j,k;
        F77_REAL_TYPE a,b,c;
      } F77_NAMED_COMMON(block);
\end{verbatim} }

The corresponding FORTRAN statements are

{\small \begin{verbatim}
      INTEGER I,J,K
      REAL A,B,C
      COMMON /BLOCK/ I,J,K,A,B,C
\end{verbatim} }

Within the C function the variables would be referred to as {\bf
F77\_\-NAMED\_\-COMMON(block).i}, {\bf F77\_\-NAMED\_\-COMMON(block).j}, etc. 

Note that all that these macros do is to hide the actual name of the external
structure from the programmer. If a computer implemented the correspondence
between FORTRAN common blocks and C global data in a completely different way,
then these macros would not provide portability to such an environment.

On account of this, it is best to avoid using common blocks where possible, but
of course, if you need to interface to existing FORTRAN programs, this may not
be practical.

\subsection{Pointers}

FORTRAN 77 does not provide a concept such as a pointer. However, it is widely
used in Starlink software for passing an address from one subroutine to
another. Typically a FORTRAN program calls a subroutine that returns a value to
an integer variable that is actually an address of an array. The value of this
variable (as opposed to its address) is then passed on to a piece of user
written code (using {\tt \%}VAL), where it is treated as an array.

C, of course, does provide pointers; in fact you can hardly avoid using them.
To take some account of this, a macro {\bf POINTER} is defined to declare C
function arguments that the calling FORTRAN program will treat as a pointer.
The FORTRAN routine should not process a {\bf POINTER} variable in any way. The
only valid operations on a {\bf POINTER} variable are to pass it to a
subprogram using the normal parameter passing mechanism or to pass its value to
a subprogram using the {\tt \%}VAL function.

\section{Converting between FORTRAN and C strings}
\label{cnf}

As has been mentioned several times already, FORTRAN and C store character
strings differently. FORTRAN stores them as a fixed length string that is filled
with trailing blanks, whereas C stores then as a variable length string that is
terminated by the null character. Although C strings are of variable length,
there must of course be enough space reserved to store the maximum length that
the string ever reaches {\em plus one more character for the trailing null}.

To aid the programmer in converting between the two forms of character strings,
a package of C functions, called CNF routines, have been written. These
handle all aspects of converting between the two types of string and provide
options such as including the trailing blanks in the C version of a string and
only copying a maximum number of characters. None of the functions are very
complicated and some of them are just a tidier way of achieving what could be
done with a few lines of C in the calling program. Consequently in a time
critical application it may be appropriate to include the source of a CNF
function in your code, rather than incur the overheads of a making a function
call.

The functions are fully described in appendix~\ref{cnf:description}. Here is an
example of how to use them. This is the same as an example from the machine
specific section of this document. The use of the F77 macros and the CNF
functions have made the C code easier to write and completely portable to all
Starlink systems.

\refstepcounter{examples}
\label{ex:f77-char}
\begin{center}
Example \ref{ex:f77-char} -- Passing character arguments from FORTRAN to C.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
{\small \begin{verbatim}
      PROGRAM STRING
      CHARACTER STR*20

      CALL GETSTR( STR )
      PRINT *,STR

      END
\end{verbatim} }
\pagebreak[1]
C function:
\nopagebreak[4]
{\small \begin{verbatim}
      #include "f77.h"
      #include "cnf.h"

      F77_SUBROUTINE(getstr)( CHARACTER(fortchar) TRAIL(fortchar) )
      {
         GENPTR_CHARACTER(fortchar)           /* Generate pointer to fortchar */

         char  *string = "This is a string";  /* A string to be printed */

      /* Copy the string to the function argument */
         cnf_exprt( string, fortchar, fortchar_length );
      }
\end{verbatim} }


\section{Calling FORTRAN routines from C}
\label{calling-c}

The operations needed to write a C routine that can call a FORTRAN subroutine
or function are fairly similar to those needed when calling C from FORTRAN.
Many of the macros that are used are the same, so you should read
section~\ref{f77:c-from-f} before reading this one. A typical reason to call
FORTRAN from C is to use a pre-existing subroutine library. Here is an example
of calling PGPLOT from a C main program.

\refstepcounter{examples}
\label{ex:ccallsf}
\begin{center}
Example \ref{ex:ccallsf} -- Passing character arguments from FORTRAN to C.
\end{center}
\nopagebreak[4]
C main program:
{\small \begin{verbatim}
      #include "cnf.h"
      #include "f77.h"

      extern void F77_EXTERNAL_NAME(pgbegin)
         ( INTEGER(unit), CHARACTER(file), INTEGER(nxsub), INTEGER(nysub)
           TRAIL(file) );
     
      extern void F77_EXTERNAL_NAME(pgenv)
         ( REAL(xmin), REAL(xmax), REAL(ymin), REAL(ymax), INTEGER(just),
           INTEGER(axis) );

      extern void F77_EXTERNAL_NAME(pglabel)
         ( CHARACTER(xlab), CHARACTER(ylab), CHARACTER(toplab)
           TRAIL(xlab) TRAIL(ylab) TRAIL(toplab) );

      extern void F77_EXTERNAL_NAME(pgpoint)
         ( INTEGER(n), REAL_ARRAY(xs), REAL_ARRAY(ys), INTEGER(symbol) );

      extern void F77_EXTERNAL_NAME(pgend) ( );

      extern void F77_EXTERNAL_NAME(pgline)
         ( INTEGER(n), REAL_ARRAY(xpnts), REAL_ARRAY(ypnts) );

      main()
      {
         int i;
         float xs[] = {1.,2.,3.,4.,5.};
         float ys[] = {1.,4.,9.,16.,25.};

         DECLARE_INTEGER(unit);
         DECLARE_CHARACTER(file,10);
         DECLARE_INTEGER(nxsub);
         DECLARE_INTEGER(nysub);
         DECLARE_REAL(xmin);
         DECLARE_REAL(xmax);
         DECLARE_REAL(ymin);
         DECLARE_REAL(ymax);
         DECLARE_INTEGER(just);
         DECLARE_INTEGER(axis);
         DECLARE_CHARACTER(xlab,50);
         DECLARE_CHARACTER(ylab,50);
         DECLARE_CHARACTER(toplab,50);
         DECLARE_INTEGER(n);
         DECLARE_REAL_ARRAY(xpnts,60);
         DECLARE_REAL_ARRAY(ypnts,60);
         DECLARE_INTEGER(symbol);


         unit = 0; cnf_exprt( "?", file, file_length); nxsub = 1; nysub = 1;
         F77_CALL(pgbegin) ( INTEGER_ARG(&unit), CHARACTER_ARG(file), 
                             INTEGER_ARG(&nxsub), INTEGER_ARG(&nysub)
                             TRAIL_ARG(file) );

         xmin = 0.0; xmax = 10.0; ymin = 0.0; ymax = 20.0; just = 0; axis = 1;
         F77_CALL(pgenv) ( REAL_ARG(&xmin), REAL_ARG(&xmax), REAL_ARG(&ymin),
                           REAL_ARG(&ymax), INTEGER_ARG(&just), INTEGER_ARG(&axis) );

         cnf_exprt( "(x)", xlab, xlab_length );
         cnf_exprt( "(y)", ylab, ylab_length );
         cnf_exprt( "PGPLOT Example 1 - y = x\\u2", toplab, toplab_length );
         F77_CALL(pglabel) ( CHARACTER_ARG(xlab), CHARACTER_ARG(ylab),
                             CHARACTER_ARG(toplab)
                             TRAIL_ARG(xlab) TRAIL_ARG(ylab) TRAIL_ARG(toplab) );

         n = 5;
         for( i=0 ; i<n ; i++ )
         {
            xpnts[i] = xs[i];
            ypnts[i] = ys[i];
         }
         symbol = 9;
         F77_CALL(pgpoint) ( INTEGER_ARG(&n), REAL_ARRAY_ARG(xpnts),
                             REAL_ARRAY_ARG(ypnts), INTEGER_ARG(&symbol) );

         n = 60;
         for( i=0 ; i<n ; i++ )
         {
            xpnts[i] = 0.1 * i;
            ypnts[i] = xpnts[i]*xpnts[i];
         }
         F77_CALL(pgline) ( INTEGER_ARG(&n), REAL_ARRAY_ARG(xpnts),
                            REAL_ARRAY_ARG(ypnts) );

         F77_CALL(pgend)();

      }
\end{verbatim} }

This is a realistic example of calling PGPLOT routines form C. The module
begins with a set of function prototypes for the FORTRAN routines that will be
called in the C main program. All variables that need to be passed to FORTRAN
subroutines are declared using {\bf DECLARE\_\-{\em type}} macros. These macros
ensure that the variables are declared to be of the correct type and storage
size expected by the FORTRAN subroutine. There then follow the calls to the
subroutines that do the actual plotting. The most notable things about these
calls is that the actual arguments are explicitly passed by address. This seems
strange to a FORTRAN programmer, but is natural to a C programmer. Arguments
that may be modified must always have their addresses passed, not their values.
It may be thought that the {\bf{\em type}\_ARG} macros should add the {\tt\&}
character where it is needed. However, this gives rise to problems when calling
FORTRAN from C from FORTRAN, as well as being rather misleading. Note that
scalar arguments need the ampersand character adding, whereas array arguments
do not. This is exactly what would be typed if the called routine were a C
function.

What is clear from this example is that the inability to put arguments that are
constant expressions directly in the call to the routine makes the program a
lot more verbose than the equivalent FORTRAN program. Unfortunately, the
obvious solution of writing an actual argument as something like {\bf
INTEGER\_ARG(\&5)} does not work as you cannot take the address of a constant.
This is not a failing of the F77 macros, but is inherent in the C language. For
routines that are called in many places, it will be more convenient to write a
wrap up function in C that is to be called from the C main program and to put
all of the F77 macros required into that function. This produces less efficient
code, since there is an extra level of subroutine call. However, in many
situations, the extra cost will be outweighed by the benefits of more
transparent code.

The macro {\bf F77\_CALL} actually expands to the same thing as the macro {\bf
F77\_\-EXTERNAL\_\-NAME}, but is included as it is more descriptive of what is
being done when calling a FORTRAN routine from C.

\section{Other Approaches to Mixed Language Programming}

The F77 macros and CNF functions described in this document provide a
complete way of writing portable programs written in a mixture of FORTRAN and
C. All of the work necessary to provide the correct interface goes into writing
the C routines. It is relatively painless to call C from FORTRAN, since the
work of writing the interface need only be done once, but it can be annoying to
have to write a lot of extra code every time that a FORTRAN routine is called
from a C one. As mentioned in section~\ref{calling-c}, it may be appropriate to
write wrap around routines when calling FORTRAN from C.

Another package that tackles the problem of mixing C and FORTRAN is one called
CFORTRAN, written by Burkhard Burow of the University of Toronto. This will be
available as part of the CERN library and could be provided on Starlink if
required. This package allows you to write an interface layer between a user's
code and a subroutine package such that neither side need be aware that the
other is written in a foreign language. This is a crucial difference from the
F77 macros, where the C code is written in the full knowledge that the function
is being called from, or is to call, a FORTRAN routine. It is certainly
possible to write a package that can be called either from FORTRAN or C using
the F77 macros, but this does not occur automatically.

When using CFORTRAN, an extra level of subroutine call is always involved over
what is strictly necessary using the macros described in this document. This
results in less efficient code. However, when this is not a serious problem,
there may be situations in which it is more appropriate to use the CFORTRAN
system in preference to F77.

\section{Compiling and Linking}
\label{compiling-and-linking}

\subsection{General}

FORTRAN programs do not need to be compiled in any special way when employing
mixed language programming since they are not aware that the subprogram that
they are calling is not written in FORTRAN. When compiling a C function that is
to be called from FORTRAN, it should contain the line:

\begin{quote}{\tt
\#include "f77.h"
}
\end{quote}

to define the F77 macros and possibly:

\begin{quote}{\tt
\#include "cnf.h"
}
\end{quote}

if the CNF functions are used as well.

\subsubsection{Use on VMS}

Before compiling or linking a program that uses the F77 macros or CNF
functions, you should type the command

\begin{quote}{\tt
\$ CNF\_DEV
}
\end{quote}

to define some logical names. One of these logical names is {\bf C\$INCLUDE}
which tells the C compiler where to look for include files. Consequently, it is
not normally necessary to give the {\bf /INCLUDE} qualifier to the {\bf CC}
command. To compile a C function that uses the F77 macros or the CNF functions,
all that is necessary is to type

\begin{quote}{\tt
\$ CC FUNC
}
\end{quote}

All references to the F77 macros are of course resolved at compile time, so the
only question about linking is how to link with the CNF library for those
functions that call them.

In common with other Starlink packages, the CNF routines are provided as a
shareable image and as an object library. The preferred method is to use the
shareable image and to link as follows:

\begin{quote}{\tt
\$ LINK program,STAR\_LINK/OPT
}
\end{quote}

If you do not wish to use the standard Starlink options file, but still wish to
use the shareable image, then the command is:

\begin{quote}{\tt
\$ LINK program,CNF\_LINK/OPT
}
\end{quote}

If you wish to use the object library instead of the shareable image, then the
command is:

\begin{quote}{\tt
\$ LINK program,CNF\_DIR:CNF/LIB,SYS\$LIBRARY:VAXCRTL/LIB
}
\end{quote}

The use of shareable images rather than object libraries will lead to smaller
executable files. However, in the case of the CNF library, the amount of code
is so small that the difference is not important.

\subsubsection{Use on Unix}

On a Unix system, you can tell the compiler where to look for {\bf \#include}
files with the {\bf -I} qualifier to the cc command, e.g.

\begin{quote}{\tt
> cc -I/star/include -c func.c
}
\end{quote}

The include files for all Starlink software are stored in the
directory {\bf /star/include}.

The object files for all Starlink libraries reside in /star/lib. To link a
FORTRAN program prog.f and a C function sub.c with the CNF library, first
compile the C function and then compile and link the FORTRAN program:

\begin{quote}{\tt
> cc -c -I/star/include sub.c \\
> f77 prog.f sub.o -L/star/lib `cnf\_link` -o prog
}
\end{quote}



\appendix
\newpage

\section{Implementation Specific Details}
\label{implement}

As indicated several times earlier, many of the details of mixed language
programming are implementation dependent. This section will deal in turn with
each type of hardware that Starlink possesses. Given that programs can be
written in a portable way, you may wonder if you need to know about the
implementation specific details at all. This is in fact necessary when
debugging programs, since the debugger will be working on the output of any
macros that hide the implementation specific details from the programmer.

There is some duplication between the following subsections, one for each type
of operating system, particularly in the examples. This has been done so that
each section can be read separately from any other.

\subsection{VAX/VMS}

\subsubsection{General}

A VAX computer is based on a 32 bit architecture. Data can be addressed as
bytes (8 bits), words (16 bits), longwords (32 bits), quadwords (64 bits) or
octawords (128 bits). The terminology is a hangover from the PDP-11 series of
computers and the basic unit of storage on a VAX is the longword. References to
FORTRAN and C in this subsection refer to the VAX~FORTRAN and VAX~C compilers
produced by DEC.

\subsubsection{Data Types}

There is a simple correspondence between VAX~FORTRAN and VAX~C numeric variable
types. The standard types are given in the upper part of
table~\ref{vms:data-types} and VAX~FORTRAN extensions in the lower part. These
should generally be avoided for reasons of portability. However, they are
provided since HDS (SUN/92) has corresponding data types.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|} \hline
\multicolumn{1}{|c|}{VAX FORTRAN} & \multicolumn{1}{c|}{VAX~C} \\ \hline
INTEGER & int \\
REAL & float \\
DOUBLE PRECISION & double \\
LOGICAL & int \\
CHARACTER*1 & char \\
CHARACTER*n & char[n] \\ \hline
BYTE & char \\
INTEGER*2 & short \\ \hline
\end{tabular}
\end{center}
\caption{Corresponding data types for VAX/VMS}
\label{vms:data-types}
\end{table}

Although VAX~C defines unsigned data types of {\bf unsigned char} (range 0 to
255),  {\bf unsigned short} (range 0 to 32767) and {\bf unsigned int} (range 0
to $2^{32}-1$), there are no corresponding unsigned data types in FORTRAN.
There is also a C type called {\bf long int}; however in VAX~C, this is the
same as an {\bf int}.

The C language does not specify whether variables of type {\bf char} should be
stored as signed or unsigned values. On VMS, they are stored as signed
values in the range -128 to 127.

Similarly there is no C data type that corresponds to the FORTRAN data type of
COMPLEX. However, since VAX~FORTRAN passes all numeric variable by reference, a
COMPLEX variable could be passed to a VAX~C subprogram where it might be
handled as a structure consisting of two variables of type {\bf float}.

A VAX~FORTRAN LOGICAL value can be passed to a VAX~C {\bf int}, but care must
be taken over the interpretation of the value since VAX~FORTRAN only considers
the lower bit of the longword to be significant (0 is false, 1 is true) whereas
VAX~C treats any numerical value other than 0 as true. When VAX~FORTRAN sets a
logical value to true, it sets all the bits. This corresponds to a numerical
value of minus one.

\subsubsection{Arguments}
\label{vms:arg}

To understand how to pass arguments between VAX~FORTRAN and VAX~C programs, it
is necessary to understand the possible methods that VMS can use for passing
arguments and how each language makes use of them. VMS defines a procedure
calling standard that is used by all compilers written by DEC for the VMS
operating system. This is described in the `Introduction to the VMS Run-Time
Library' manual with additional information in the `Introduction to VMS System
Services' manual. If you have a third party compiler that does not conform to
this standard then you will not be able to mix the object code that it produces
with that from DEC compilers. There are three ways that an actual argument may
be passed to a subroutine. What is actually passed as an argument should always
be a longword. It is the interpretation of that longword that is where the
differences arise. Note the word {\em should}\, in the last but one sentence.
VAX~C will occasionally generate an argument that is longer than one longword.
This is a violation of the VAX procedure calling standard. It causes no
problems for pure VAX~C programs, but is a potential source of problems for
mixed language programs.

VAX~FORTRAN passes all data types other than CHARACTER by reference, i.e.\ the
address of the variable or array is put in the argument list. CHARACTER
variables are passed by descriptor. The descriptor contains the type and class
of descriptor, the length of the string and the address where the characters
are actually stored.

VAX~C uses call by value to pass all variables, constants (except string
constants), expressions, array elements, structures and unions that are actual
arguments of functions. It uses call by reference to pass whole arrays, string
constants and functions. VAX~C never uses call by descriptor as a default
method of passing arguments.

To pass a VAX~C variable of type {\bf double} by value requires the use of two
longwords in the argument list and so is a violation of the VAX procedure
calling standard. The passing of a VAX~C structure that is bigger that one
longword is a similar violation. It is always better to pass C structures by
reference, although this should not be a problem in practice since in the case
of a pure VAX~C program, everything is handled consistently and in the case of
a mixture of FORTRAN and C, you would not normally pass variables by value
anyway.

In VAX~FORTRAN, the default argument passing mechanism can be overridden by use
of the {\tt \%}VAL, {\tt \%}REF and {\tt \%}DESCR functions. These functions
are not portable and should be avoided whenever possible. The only exception is
that {\tt \%}VAL is used in Starlink software for passing pointer variables. In
VAX~C there is no similar way of `cheating' as there is in VAX~FORTRAN;
however, this is not necessary as the language allows more flexibility itself.
For example, if you wish to pass a variable named {\bf x} by reference rather
than by value, you simply put {\bf \&x} as the actual argument instead of {\bf
x}. To pass something by descriptor, you need to construct the appropriate
structure and pass the address of that. See the DEC manual `Guide to VAX~C' for
further details.

Since C provides more flexibility in the mechanism of passing arguments than
does FORTRAN, it is C that ought to shoulder the burden of handling the
different mechanisms. All numeric variables and constants, array elements,
whole arrays and function names should be passed into and out of C functions by
reference. Numeric expressions will be passed from VAX~FORTRAN to VAX~C by
reference and so the corresponding dummy argument in the C function should be
declared to be of type `pointer to type'. When C has a constant or an
expression as an actual argument in a function call, it can only pass it by
value. VAX~FORTRAN cannot cope with this and so in a VAX~C program, all
expressions should be assigned to variables before being passed to a FORTRAN
routine.

Here are some examples to illustrate these points. 

\refstepcounter{examples}
\label{ex:vms-f2c}
\begin{center}
Example \ref{ex:vms-f2c} -- Passing arguments from VAX~FORTRAN to VAX~C.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
{\small \begin{verbatim}
      PROGRAM FORT1
      INTEGER A
      REAL B
      A = 1
      B = 2.0
      CALL C1( A, B )
      END
\end{verbatim} }
\pagebreak[1]
C function:
\nopagebreak[4]
{\small \begin{verbatim}
      void c1( int *a, float *b )
      {
         int x;
         float y;

         x = *a;    /* x is now equal to 1 */
         y = *b;    /* y is now equal to 2.0 */

         printf( "x = %d\n", x );
         printf( "y = %f\n", y );
      }
\end{verbatim} }

In this first example, a FORTRAN program passes an INTEGER and REAL variable to
a C function. The values of these arguments are then assigned to two local
variables. They could just as well have been used directly in the function by
referring to the variables  {\tt *}{\bf a} and {\tt *}{\bf b} instead of
assigning their values to the local variables {\bf x} and {\bf y}. Since the
VAX~FORTRAN program passes the actual arguments by reference, the dummy arguments
used in the declaration of the VAX~C function should be a pointer to the variable
that is being passed.

Now an example of calling a VAX~FORTRAN subroutine from VAX~C.

\pagebreak[3]
\refstepcounter{examples}
\label{ex:vms-c2f}
\begin{center}
Example \ref{ex:vms-c2f} -- Passing arguments from VAX~C to VAX~FORTRAN.
\end{center}
\nopagebreak[4]
C main program:
\nopagebreak[4]
{\small \begin{verbatim}
      main()
      {
        int  i = 2;            /* Declare i and initialize it.  */
        void fort2( int *i );  /* Declare function fort2. */

        fort2( &i );           /* Call fort2.  */
      }
\end{verbatim} }
\pagebreak[1]
FORTRAN subroutine:
\nopagebreak[4]
{\small \begin{verbatim}
      SUBROUTINE FORT2( I )
      INTEGER I

      PRINT *,I

      END
\end{verbatim} }

The VAX~C main function declares and initializes a variable, {\bf i}, and declares
a function {\bf fort2}. It calls {\bf fort2}, passing the address of the
variable {\bf i} rather than its value, as this is what the VAX~FORTRAN subroutine
will be expecting.

As we have seen, the case of scalar numeric arguments is fairly
straightforward. However, the passing of character variables between VAX~FORTRAN
and VAX~C is more complicated. VAX~FORTRAN passes character variables by descriptor and
VAX~C must handle these descriptors. Furthermore, there is the point that FORTRAN
deals with fixed length, blank padded strings, whereas C deals with variable
length, null terminated strings. It is also worth noting that Unix machines
tend to handle character arguments in a manner which is different from the VMS
way. The simplest possible example of a character argument is given here in all
of its gory detail. You will be pleased to discover that this example is purely
for illustration. The macros described in section~\ref{f77:c-from-f} hide all
of these details from the programmer, and in a portable manner as well! 

\refstepcounter{examples}
\label{ex:vms-char}
\begin{center}
Example \ref{ex:vms-char} -- Passing character arguments from VAX~FORTRAN to VAX~C.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
{\small \begin{verbatim}
      PROGRAM FORT3
      CHARACTER STR*20

      CALL C3( STR )
      PRINT *,STR

      END
\end{verbatim} }
\pagebreak[1]
C function:
\nopagebreak[4]
{\small \begin{verbatim}
      #include <descrip.h>                    /* VMS Descriptors */
      #include <stdio.h>                      /* Standard I/O functions */

      void c3( struct dsc$descriptor_s  *fortchar )
      {
         int  i;                              /* A loop counter */
         char  *string = "This is a string";  /* A string to be printed */

      /* Copy the string to the function argument */
         strncpy( fortchar->dsc$a_pointer, string, fortchar->dsc$w_length );

      /* Pad the character argument with trailing blanks */
         for( i = strlen( string ) ; i < fortchar->dsc$w_length ; i++ )
            fortchar->dsc$a_pointer[i] = ' ';
      }
\end{verbatim} }

The second variable declaration in the C subprogram declares a local variable
to be a string and initializes it. This string is then copied to the storage
area that the subprogram argument points to, taking care not to copy more
characters than the argument has room for. Finally any remaining space in the
argument is filled with blanks, the null character being overwritten. You
should always fill any trailing space with blanks in this way. What should
definitely not be done is to modify the descriptor to indicate the number of
non blank characters that it now holds. The VAX~FORTRAN compiler will not
expect this to happen and it is likely to cause run-time errors. See the DEC
manual `Guide to VAX~C' for more details of handling descriptors in VAX~C.

If an actual argument in a VAX~FORTRAN routine is an array of characters, rather
than just a single character variable, the descriptor that describes the data
is different. It is defined by the macro {\bf dsc\$descriptor\_a} instead of
{\bf dsc\$descriptor\_s}. This contains extra information about the number of
dimensions and their bounds; however, this can generally be ignored since the
first part of the {\bf dsc\$descriptor\_a} descriptor is the same as the {\bf
dsc\$descriptor\_s} descriptor. This extra information can be unpacked from the
descriptor, however, to do so would lead to non portable code. It is generally
better to use the address of the array that is passed in the descriptor and to
pass any array dimensions as separate arguments. The C subroutine then has all
of the information that it requires and can handle the data as an array or by
using pointers, as the programmer sees fit. See example~\ref{ex:f77-arbary} for
an illustration of this.

\subsubsection{Function Values}

The way that the return value of a function is handled is very much like a
simple assignment statement. In practice, the value is actually returned in one
or two of the registers of the CPU, depending on the size of the data type.
Consequently there is no problem in handling the value of any function that
returns a numerical value as long as the storage used by the value being
returned and the value expected correspond (see table~\ref{vms:data-types} on
page~\pageref{vms:data-types}). If a VAX~C function is treated as a LOGICAL
function by VAX~FORTRAN, there is no problem as long as the VAX~C function
ensures that it returns a value that will be interpreted correctly. The best
thing to do is to make sure that the C function can only return zero (for
false) or minus one (for true).

The case of a function that returns a character string is more complex. The way
that VAX~FORTRAN returns a character variable as a function value is to add a
hidden extra entry to the beginning of the argument list. This is a pointer to
a character descriptor. If a VAX~C function wishes to return a function value
that VAX~FORTRAN will interpret as a character string, then you must explicitly
add an extra argument to the VAX~C function and build the appropriate structure
in your C function. This may seem rather complicated, but what it boils down to
is that the following two segments of VAX~FORTRAN are equivalent (but only in
VAX~FORTRAN).

\pagebreak[3]
\refstepcounter{examples}
\label{ex:vms-charfn}
\begin{center}
Example \ref{ex:vms-charfn} -- Equivalence of a VMS character function and a
VMS subroutine.
\end{center}
\nopagebreak[4]
{\small \begin{verbatim}
      CHARACTER*(10) RETURN
      CALL CHARFN( RETURN, A, B )

   or

      CHARACTER*(10) RETURN, CHARFN
      RETURN = CHARFN( A, B )
\end{verbatim} }
If written as a function, CHARFN returns a value of type CHARACTER. It is left
as an exercise for the reader to demonstrate that the above assertion is true
using just FORTRAN.

\subsubsection{Global Data}

Although FORTRAN and C use different methods for representing global data, it is
actually very easy to mix them. If a VAX~FORTRAN common block contains a single
variable or array, then the corresponding VAX~C variable simply needs to be
declared as {\bf extern} and the two variables will use the same storage. 

\refstepcounter{examples}
\label{ex:vms-common}
\begin{center}
Example \ref{ex:vms-common} -- A VAX~FORTRAN labelled common block containing a
single variable
\end{center}
\nopagebreak[4]
FORTRAN common block:
{\small \begin{verbatim}
      CHARACTER*(10) STRING
      COMMON /BLOCK/ STRING
\end{verbatim} }

C external variable:
{\small \begin{verbatim}
      extern char block[10];
\end{verbatim} }

Note that the name of the C variable corresponds to the name of the FORTRAN
common block, not the name of the FORTRAN variable. This example shows that you
can use the same storage area for both VAX~FORTRAN and VAX~C strings. However, you must
still beware of the different way in which FORTRAN and C handle the end of
a string.

If the FORTRAN common block contains more than one variable or array, then the 
C variables must be contained in a structure.

If you wish to access the VAX~FORTRAN blank common block, then the
corresponding VAX~C structure should be called \$BLANK.

\refstepcounter{examples}
\label{ex:vms-common2}
\begin{center}
Example \ref{ex:vms-common2} -- A VAX~FORTRAN labelled common block containing
several variables.
\end{center}
\nopagebreak[4]
FORTRAN common block:
{\small \begin{verbatim}
      INTEGER I,J,K
      COMMON /NUMS/ I,J,K
\end{verbatim} }

C external variable:
{\small \begin{verbatim}
      extern struct { int i,j,k; } nums;
\end{verbatim} }

\subsection{SunOS}

\subsubsection{General}

A Sun computer is based on a 32 bit architecture. Data can be addressed in
multiples of 1, 2, 4, 8 or 16 bytes, a byte being 8 bits. References to FORTRAN
and C in this subsection refer to the Sun~FORTRAN and GNU~C compilers. At
present, the Sun~C compiler does not accept ANSI C programs. It is expected
that a future version of the Sun~C compiler will be ANSI compliant, but until
then, it should not be used for writing Starlink programs.

\subsubsection{Data Types}

There is a simple correspondence between Sun~FORTRAN and GNU~C numeric variable types.
The standard types are given in the upper part of table~\ref{sun:data-types}
and Sun~FORTRAN extensions in the lower part. These should generally be avoided
for reasons of portability, however, they are provided since HDS (SUN/92) has
corresponding data types.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|} \hline
\multicolumn{1}{|c|}{Sun~FORTRAN} & \multicolumn{1}{c|}{GNU~C} \\ \hline
INTEGER & int \\
REAL & float \\
DOUBLE PRECISION & double \\
LOGICAL & int \\
CHARACTER*1 & char \\
CHARACTER*n & char[n] \\ \hline
BYTE & char \\
INTEGER*2 & short \\ \hline
\end{tabular}
\end{center}
\caption{Corresponding data types for SunOS}
\label{sun:data-types}
\end{table}

Although GNU~C defines unsigned data types of {\bf unsigned char} (range 0 to 255), 
{\bf unsigned short} (range 0 to 32767) and {\bf unsigned int} (range 0 to
$2^{32}-1$), there are no corresponding unsigned data types in FORTRAN. There
is also a C type called {\bf long int}, however in GNU~C, this is the same as
an {\bf int}.

The C language does not specify whether variables of type {\bf char} should be
stored as signed or unsigned values. On SunOS, they are stored as signed
values in the range -128 to 127.

Similarly there is no C data type that corresponds to the FORTRAN data type of
COMPLEX. However, since Sun~FORTRAN passes all numeric variable by reference, a
COMPLEX variable could be passed to a C subprogram where it might be handled as
a structure consisting of two variables of type {\bf float}.

A Sun~FORTRAN LOGICAL value can be passed to a C {\bf int}. Sun~FORTRAN and C both use
zero to represent a false value and anything else to represent a true value, so
there is no problem with converting the data values.

\subsubsection{External Names}

The Sun~FORTRAN compiler appends an underscore character to all external names that 
it generates. This applies to the names of subroutines, functions, labelled
common blocks and block data subprograms.

\subsubsection{Arguments}
\label{sun:arg}

To understand how to pass arguments between Sun~FORTRAN and C programs, it is
necessary to understand the possible methods that the operating system can use
for passing arguments and how each language makes use of them. There are three
ways that an actual argument may be passed to a subroutine. What is actually
passed as an argument should always be a four byte word. It is the
interpretation of that word that is where the differences arise. 

Sun~FORTRAN passes all data types other than CHARACTER by reference, i.e.\ the
address of the variable or array is put in the argument list. CHARACTER
variables are passed by  a mixture of reference and value. The argument list
contains the address of the character variable being passed, but there is also 
an extra argument added at the end of the argument list for each character
variable. This gives the actual length of the FORTRAN CHARACTER variable and so
this datum is being passed by value. These extra arguments are hidden from the
FORTRAN programmer, but must be explicitly included in any C routines.

C uses call by value to pass all variables, constants (except string
constants), expressions, array elements, structures and unions that are actual
arguments of functions. It uses call by reference to pass whole arrays, string
constants and functions. C never uses call by descriptor as a default.

To pass a C variable of type {\bf double} by value requires the use of two
longwords in the argument list. Similarly, if a C structure is passed by value,
then the number of bytes that it takes up in the argument list can be large.
This is a dangerous practice and all structures should be passed by reference.
Since, by default, Sun~FORTRAN does not pass variables by value anyway, this should
not give rise to any problems.

In Sun~FORTRAN, the default argument passing mechanism can be overridden by use
of the {\tt \%}VAL and {\tt \%}REF functions. These functions are not portable
and should be avoided whenever possible. The {\tt \%}DESCR function provided in
VAX~FORTRAN is {\em not}\, provided on a Sun. In C there is no similar way of
`cheating' as there is in FORTRAN; however, this is not necessary as the
language allows more flexibility itself. For example, if you wish to pass a
variable named {\bf x} by reference rather than by value, you simply put {\bf
\&x} as the actual argument instead of {\bf x}. 

Since C provides more flexibility in the mechanism of passing arguments than
does FORTRAN, it is C that ought to shoulder the burden of handling the
different mechanisms. All numeric variables and constants, array elements,
whole arrays and function names should be passed into and out of C functions by
reference. Numeric expressions will be passed from FORTRAN to C by reference
and so the corresponding dummy argument in the C function should be declared to
be of type `pointer to type'. When C has a constant or an expression as an
actual argument in a function call, it can only pass it by value. Sun~FORTRAN
cannot cope with this and so in a C program, all expressions should be assigned
to variables before being passed to a FORTRAN routine.

Here are some examples to illustrate these points. 

\refstepcounter{examples}
\label{ex:sun-f2c}
\begin{center}
Example \ref{ex:sun-f2c} -- Passing arguments from Sun~FORTRAN to GNU C.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
{\small \begin{verbatim}
      PROGRAM FORT1
      INTEGER A
      REAL B
      A = 1
      B = 2.0
      CALL C1( A, B )
      END
\end{verbatim} }
\pagebreak[1]
C function:
\nopagebreak[4]
{\small \begin{verbatim}
      void c1_( int *a, float *b)
      {
         int x;
         float y;

         x = *a;    /* x is now equal to 1 */
         y = *b;    /* y is now equal to 2.0 */

         printf( "x = %d\n", x );
         printf( "y = %f\n", y );
      }
\end{verbatim} }

The C function name requires the underscore as the FORTRAN compiler generates
this automatically. 

In this first example, a Sun~FORTRAN program passes an INTEGER and REAL
variable to a C function. The values of these arguments are then assigned to
two local variables. They could just as well have been used directly in the
function by referring to the variables {\tt *}{\bf a} and {\tt *}{\bf b}
instead of assigning their values to the local variables {\bf x} and {\bf y}. 
Since the FORTRAN program passes the actual arguments by reference, the dummy
arguments used in the declaration of the C function should be a pointer to the
variable that is being passed.

Now an example of calling a Sun~FORTRAN subroutine from C.

\refstepcounter{examples}
\label{ex:sun-c2f}
\begin{center}
Example \ref{ex:sun-c2f} -- Passing arguments from C to Sun~FORTRAN.
\end{center}
\nopagebreak[4]
C main program:
\nopagebreak[4]
{\small \begin{verbatim}
      main()
      {
        int  i = 2;             /* Declare i and initialize it.  */
        void fort2_( int *i );  /* Declare function fort2_. */

        fort2_( &i );           /* Call fort2.  */
      }
\end{verbatim} }
\pagebreak[1]
FORTRAN subroutine:
\nopagebreak[4]
{\small \begin{verbatim}
      SUBROUTINE FORT2( I )
      INTEGER I

      PRINT *,I

      END
\end{verbatim} }

The C main function declares and initializes a variable, {\bf i}, and declares
a function {\bf fort2\_} (note the underscore). It calls {\bf fort2\_}, passing
the address of the variable {\bf i} rather than its value, as this is what the
FORTRAN subroutine will be expecting.

As we have seen, the case of scalar numeric arguments is fairly
straightforward, however, the passing of character variables between Sun~FORTRAN
and C is more complicated. Sun~FORTRAN passes character variables by passing the
address of the character variable and then adding an extra value to the
argument list that is the size of the character variable.  Furthermore, there
is the point that FORTRAN deals with fixed length, blank padded strings,
whereas C deals with variable length, null terminated strings. The simplest
possible example of a character argument is given here as an illustration.
Although it looks simpler than the corresponding example under VMS, it is not
really any better. The important point is that it is different from the VMS
example. The macros described in section~\ref{f77:c-from-f} hide all of these
differences from the programmer, thereby making the code portable.

\refstepcounter{examples}
\label{ex:sun-char}
\begin{center}
Example \ref{ex:sun-char} -- Passing character arguments from Sun~FORTRAN to C.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
{\small \begin{verbatim}
      PROGRAM FORT3
      CHARACTER STR*20

      CALL C3( STR )
      PRINT *,STR

      END
\end{verbatim} }
\pagebreak[1]
C function:
\nopagebreak[4]
{\small \begin{verbatim}
      #include <stdio.h>                      /* Standard I/O functions */

      void c3_( char *fortchar, int length )
      {
         int  i;                              /* A loop counter */
         char  *string = "This is a string";  /* A string to be printed */

      /* Copy the string to the function argument */
         strncpy( fortchar, string, length );

      /* Pad the character argument with trailing blanks */
         for( i = strlen( string ) ; i < length ; i++ )
            fortchar[i] = ' ';
      }
\end{verbatim} }

The second variable declaration in the C subprogram declares a local variable
to be a string and initializes it. This string is then copied to the storage
area that the subprogram argument points to, taking care not to copy more
characters than the argument has room for. Finally any remaining space in the
argument is filled with blanks, the null character being overwritten. You
should always fill any trailing space with blanks in this way. 

\subsubsection{Function Values}

The way that the return value of a function is handled is very much like a
simple assignment statement. The value is actually returned in one or two of
the registers of the CPU, depending on the size of the data type. Consequently
there is no problem in handling the value of any function that returns a
numerical value as long as the storage used by the value being returned and the
value expected correspond (see table~\ref{sun:data-types} on
page~\pageref{sun:data-types}). 

The case of a function that returns a character string is more complex. The way
that Sun~FORTRAN returns a character variable as a function value is to add two
hidden extra entries to the beginning of the argument list. These are a pointer
to a character variable and the value of the length of this variable. If a C
function wishes to emulate a FORTRAN CHARACTER function, then you must
explicitly add these two extra arguments to the C function. Any value that the
C function returns will be ignored. Here is an example to illustrate this.

\refstepcounter{examples}
\label{ex:sun-charfn}
\begin{center}
Example \ref{ex:sun-charfn} -- Use of a Sun~FORTRAN character function.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
{\small \begin{verbatim}
      PROGRAM CFUNC
      CHARACTER*(10) VAR, FUNC

      VAR = FUNC( 6 )
      PRINT *, VAR

      END
\end{verbatim} }
\pagebreak[1]
C function:
\nopagebreak[4]
{\small \begin{verbatim}
      void func_( char *retval, int length, int *n )
      {
         char *cp;
         int i, max;

      /* Find the number of characters to be copied.  */
         if( *n < length )
            max = *n;
         else
            max = length;

      /* Set a local character pointer equal to the return address.  */
         cp = retval;

      /* Copy some asterisks to the "return value".  */
         for( i = 0 ; i < max ; i++ )
            *cp++ = '*';

      /* Fill the rest of the string with blanks.  */
         for( ; i < length ; i++ )
            *cp++ = ' ';
      }
\end{verbatim} }

The C function copies some asterisks into the location that Sun~FORTRAN will
interpret as the return value of the FORTRAN CHARACTER function. The number of
such asterisks is specified by the single argument of the FORTRAN function and
the rest of the string is filled with blanks.

\subsubsection{Global Data}

Although FORTRAN and C use different method for representing global data, it is
actually very easy to mix them. If a Sun~FORTRAN common block contains a single
variable or array, then the corresponding C variable simply needs to be
declared as {\bf extern} and the two variables will use the same storage.

\refstepcounter{examples}
\label{ex:sun-common}
\begin{center}
Example \ref{ex:sun-common} -- A labelled Sun~FORTRAN common block containing a
single variable.
\end{center}
\nopagebreak[4]
FORTRAN common block:
{\small \begin{verbatim}
      CHARACTER*(10) STRING
      COMMON /BLOCK/ STRING
\end{verbatim} }

C external variable:
\nopagebreak[4]
{\small \begin{verbatim}
      extern char block_[10];
\end{verbatim} }

Note that the name of the C variable corresponds to the name of the FORTRAN
common block, not the name of the FORTRAN variable. This example shows that you
can use the same storage area for both Sun~FORTRAN and C strings, however, you must
still beware of the different way in which FORTRAN and C handle the end of
a string.

If the FORTRAN common block contains more than one variable or array, then the 
C variables must be contained in a structure.

If you wish to access the Sun~FORTRAN blank common block, then the corresponding C
structure should be called {\bf \_BLNK\_\_}.

\refstepcounter{examples}
\label{ex:sun-common2}
\begin{center}
Example \ref{ex:sun-common2} -- A labelled Sun~FORTRAN common block containing
several variables.
\end{center}
\nopagebreak[4]
FORTRAN common block:
\nopagebreak[4]
{\small \begin{verbatim}
      INTEGER I,J,K
      COMMON /NUMS/ I,J,K
\end{verbatim} }

C external variable:
\nopagebreak[4]
{\small \begin{verbatim}
      extern struct { int i,j,k; } nums_;
\end{verbatim} }

\subsection{Ultrix/RISC (DECstation)}

\subsubsection{General}

A DECstation computer is based on a 32 bit architecture. Data can be addressed
in multiples of 1, 2, 4, 8 or 16 bytes, a byte being 8 bits. The FORTRAN
compiler used on the DECstation is the DEC FORTRAN for RISC compiler and the
C compiler is the MIPS C compiler.

The machine specific details relating to mixed language programming are
almost identical to those for the Sun and so the previous subsection should be
consulted for more details. This is not to say that there are no differences
between the DECstation and Sun compilers, merely that they do not generally
impinge on the question of mixed language programming.

The one place where the DECstation may differ from the Sun is in how logical
values are handled. The original FORTRAN compiler for the DECstation, FORTRAN
for RISC used the Sun interpretation of logical values, i.e.\ zero is false,
non zero is true. The more recent DEC FORTRAN for RISC compiler uses the VMS
convention that only checks the lowest bit of a value, so 0 is false, 1 is
true, 2 is false, 3 is true, etc. When DEC~FORTRAN sets a LOGICAL variable to
TRUE, all the bits in the data are set to 1, resulting in a numerical
equivalent value of -1. Unfortunately this means that the correct value of the
macros {\bf F77\_ISFALSE} and {\bf F77\_ISTRUE} used in a C function, depend on
which FORTRAN compiler you are using. It is not possible to handle this
automatically, so you must be sure to use the right values for the macros. The
default assumption is that you are using the DEC FORTRAN for RISC compiler,
i.e.\ the newer one. Fortunately this is unlikely to be a problem in practice,
since a TRUE value will normally be 1 or -1, and these values will be handled
correctly by either compiler.

\subsection{Other Operating Systems}

The F77 macros have been designed to cope with other systems as far as is
possible. It should be possible to modify the file {\bf f77.h} to cope with
most computers. The places where this may prove difficult, or even impossible,
are likely to be due to arguments being passed in an unforeseen way.

The include file {\bf cnf.h} declares the functions used for handling character
strings. The declarations are written as function prototypes and assume that
the C compiler will handle this feature of ANSI C. If a particular C compiler
does not support this feature, then the header file could easily be modified to
take this into account.

\newpage

\section{F77 macros}
\label{f77:description}

This appendix contains a list of the F77 macros, arranged by functionality, and
a full description of each macro. The effect of each macro is described and the
expansion of the macro on each of the supported systems is given. If a macro is
too long to be shown on a single line, then the continuation on the next line
is indented to distinguish a continuation from a further level of macro
expansion.

{\bf N.B.} It is important not to leave spaces around arguments in macros calls
as these spaces are then included in the macro expansion on some systems, i.e.\
write {\bf F77\_\-SUBROUTINE(fred)}, not {\bf F77\_\-SUBROUTINE( fred )}. This
seems to be a bug in the offending compilers, but the problem is there none the
less.

Many macros currently expand to an empty string on all currently supported
systems. Nevertheless, the macros should still be used to guard against them
being necessary on future systems.

\subsection{Alphabetical List of F77 Macros}

\noteroutine{
   BYTE
}{
   Declare a BYTE argument
}
\noteroutine{
   BYTE\_ARG
}{
   Pass a BYTE argument to a FORTRAN routine
}
\noteroutine{
   BYTE\_ARRAY
}{
   Declare a BYTE array argument
}
\noteroutine{
   BYTE\_ARRAY\_ARG
}{
   Pass a BYTE array argument to a FORTRAN routine
}
\noteroutine{
   CHARACTER
}{
   Declare a CHARACTER argument
}
\noteroutine{
   CHARACTER\_ARG
}{
   Pass a CHARACTER argument to a FORTRAN routine
}
\noteroutine{
   CHARACTER\_ARRAY
}{
   Declare a CHARACTER array argument
}
\noteroutine{
   CHARACTER\_ARRAY\_ARG
}{
   Pass a CHARACTER array argument to a FORTRAN routine
}
\noteroutine{
   CHARACTER\_RETURN\_VALUE
}{
   Declare an argument that will be the return value of a CHARACTER
   function
}
\noteroutine{
   DECLARE\_BYTE
}{
   Declare a BYTE variable
}
\noteroutine{
   DECLARE\_BYTE\_ARRAY
}{
   Declare a BYTE array
}
\noteroutine{
   DECLARE\_CHARACTER
}{
   Declare a CHARACTER variable
}
\noteroutine{
   DECLARE\_CHARACTER\_ARRAY
}{
   Declare a CHARACTER array
}
\noteroutine{
   DECLARE\_DOUBLE
}{
   Declare a DOUBLE variable
}
\noteroutine{
   DECLARE\_DOUBLE\_ARRAY
}{
   Declare a DOUBLE array
}
\noteroutine{
   DECLARE\_INTEGER
}{
   Declare an INTEGER variable
}
\noteroutine{
   DECLARE\_INTEGER\_ARRAY
}{
   Declare an INTEGER array
}
\noteroutine{
   DECLARE\_LOGICAL
}{
   Declare a LOGICAL variable
}
\noteroutine{
   DECLARE\_LOGICAL\_ARRAY
}{
   Declare a LOGICAL array
}
\noteroutine{
   DECLARE\_REAL
}{
   Declare a REAL variable
}
\noteroutine{
   DECLARE\_REAL\_ARRAY
}{
   Declare a REAL array
}
\noteroutine{
   DECLARE\_WORD
}{
   Declare a WORD variable
}
\noteroutine{
   DECLARE\_WORD\_ARRAY
}{
   Declare a WORD array
}
\noteroutine{
   DOUBLE
}{
   Declare a DOUBLE PRECISION argument
}
\noteroutine{
   DOUBLE\_ARG
}{
   Pass a DOUBLE argument to a FORTRAN routine
}
\noteroutine{
   DOUBLE\_ARRAY
}{
   Declare a DOUBLE PRECISION array argument
}
\noteroutine{
   DOUBLE\_ARRAY\_ARG
}{
   Pass an actual DOUBLE array argument to a FORTRAN routine
}
\noteroutine{
   F77\_BLANK\_COMMON
}{
   Refer to blank common
}
\noteroutine{
   F77\_BYTE\_FUNCTION
}{
   Declare a function that returns a BYTE value
}
\noteroutine{
   F77\_BYTE\_TYPE
}{
   Define the type BYTE
}
\noteroutine{
   F77\_CALL
}{
   Call a FORTRAN routine from C
}
\noteroutine{
   F77\_CHARACTER\_FUNCTION
}{
   Declare a function that returns a CHARACTER value
}
\noteroutine{
   F77\_CHARACTER\_TYPE
}{
   Define the type CHARACTER
}
\noteroutine{
   F77\_DOUBLE\_FUNCTION
}{
   Declare a function that returns a DOUBLE PRECISION value
}
\noteroutine{
   F77\_DOUBLE\_TYPE
}{
   Define the type DOUBLE PRECISION
}
\noteroutine{
   F77\_EXTERNAL\_NAME
}{
   The external name of a function
}
\noteroutine{
   F77\_FALSE
}{
   The logical value FALSE
}
\noteroutine{
   F77\_INTEGER\_FUNCTION
}{
   Declare a function that returns an INTEGER value
}
\noteroutine{
   F77\_INTEGER\_TYPE
}{
   Define the type INTEGER
}
\noteroutine{
   F77\_ISFALSE
}{
   Is this the FORTRAN logical value false?
}
\noteroutine{
   F77\_ISTRUE
}{
   Is this the FORTRAN logical value true?
}
\noteroutine{
   F77\_LOGICAL\_FUNCTION
}{
   Declare a function that returns a LOGICAL value
}
\noteroutine{
   F77\_LOGICAL\_TYPE
}{
   Define the type LOGICAL
}
\noteroutine{
   F77\_NAMED\_COMMON
}{
   Refer to a named common block
}
\noteroutine{
   F77\_REAL\_FUNCTION
}{
   Declare a function that returns a REAL value
}
\noteroutine{
   F77\_REAL\_TYPE
}{
   Define the type REAL
}
\noteroutine{
   F77\_SUBROUTINE
}{
   Declare a SUBROUTINE
}
\noteroutine{
   F77\_TRUE
}{
   The logical value TRUE
}
\noteroutine{
   F77\_WORD\_FUNCTION
}{
   Declare a function that returns a WORD value
}
\noteroutine{
   F77\_WORD\_TYPE
}{
   Define the type WORD
}
\noteroutine{
   GENPTR\_BYTE
}{
   Generate a pointer to a BYTE argument
}
\noteroutine{
   GENPTR\_BYTE\_ARRAY
}{
   Generate a pointer to a BYTE array argument
}
\noteroutine{
   GENPTR\_CHARACTER
}{
   Generate a pointer to a CHARACTER argument
}
\noteroutine{
   GENPTR\_CHARACTER\_ARRAY
}{
   Generate a pointer to a CHARACTER array argument
}
\noteroutine{
   GENPTR\_DOUBLE
}{
   Generate a pointer to a DOUBLE PRECISION argument
}
\noteroutine{
   GENPTR\_DOUBLE\_ARRAY
}{
   Generate a pointer to a DOUBLE PRECISION array argument
}
\noteroutine{
   GENPTR\_INTEGER
}{
   Generate a pointer to an INTEGER argument
}
\noteroutine{
   GENPTR\_INTEGER\_ARRAY
}{
   Generate a pointer to an INTEGER array argument
}
\noteroutine{
   GENPTR\_LOGICAL
}{
   Generate a pointer to a LOGICAL argument
}
\noteroutine{
   GENPTR\_LOGICAL\_ARRAY
}{
   Generate a pointer to a LOGICAL array argument
}
\noteroutine{
   GENPTR\_POINTER
}{
   Generate a pointer to a POINTER argument
}
\noteroutine{
   GENPTR\_REAL
}{
   Generate a pointer to a REAL argument
}
\noteroutine{
   GENPTR\_REAL\_ARRAY
}{
   Generate a pointer to a REAL array argument
}
\noteroutine{
   GENPTR\_WORD
}{
   Generate a pointer to a WORD argument
}
\noteroutine{
   GENPTR\_WORD\_ARRAY
}{
   Generate a pointer to a WORD array argument
}
\noteroutine{
   INTEGER
}{
   Declare an INTEGER argument
}
\noteroutine{
   INTEGER\_ARG
}{
   Pass an INTEGER argument to a FORTRAN routine
}
\noteroutine{
   INTEGER\_ARRAY
}{
   Declare an INTEGER array argument
}
\noteroutine{
   INTEGER\_ARRAY\_ARG
}{
   Pass an INTEGER array argument to a FORTRAN routine
}
\noteroutine{
   LOGICAL
}{
   Declare a LOGICAL argument
}
\noteroutine{
   LOGICAL\_ARG
}{
   Pass a LOGICAL argument to a FORTRAN routine
}
\noteroutine{
   LOGICAL\_ARRAY
}{
   Declare a LOGICAL array argument
}
\noteroutine{
   LOGICAL\_ARRAY\_ARG
}{
   Pass a LOGICAL array argument to a FORTRAN routine
}
\noteroutine{
   POINTER
}{
   Declare a POINTER argument
}
\noteroutine{
   REAL
}{
   Declare a REAL argument
}
\noteroutine{
   REAL\_ARG
}{
   Pass a REAL argument to a FORTRAN routine
}
\noteroutine{
   REAL\_ARRAY
}{
   Declare a REAL array argument
}
\noteroutine{
   REAL\_ARRAY\_ARG
}{
   Pass a REAL array argument to a FORTRAN routine
}
\noteroutine{
   TRAIL
}{
   Declare hidden trailing arguments
}
\noteroutine{
   TRAIL\_ARG
}{
   Pass the length of a CHARACTER argument to a FORTRAN routine
}
\noteroutine{
   WORD
}{
   Declare a WORD argument
}
\noteroutine{
   WORD\_ARG
}{
   Pass a WORD argument to a FORTRAN routine
}
\noteroutine{
   WORD\_ARRAY
}{
   Declare a WORD array argument
}
\noteroutine{
   WORD\_ARRAY\_ARG
}{
   Pass a WORD array argument to a FORTRAN routine
}


\subsection{Classified List of F77 Macros}

\subsubsection{Declaration of a C function}

\noteroutine{
   F77\_BYTE\_FUNCTION
}{
   Declare a function that returns a BYTE value
}
\noteroutine{
   F77\_CHARACTER\_FUNCTION
}{
   Declare a function that returns a CHARACTER value
}
\noteroutine{
   F77\_DOUBLE\_FUNCTION
}{
   Declare a function that returns a DOUBLE PRECISION value
}
\noteroutine{
   F77\_INTEGER\_FUNCTION
}{
   Declare a function that returns an INTEGER value
}
\noteroutine{
   F77\_LOGICAL\_FUNCTION
}{
   Declare a function that returns a LOGICAL value
}
\noteroutine{
   F77\_REAL\_FUNCTION
}{
   Declare a function that returns a REAL value
}
\noteroutine{
   F77\_SUBROUTINE
}{
   Declare a SUBROUTINE
}
\noteroutine{
   F77\_WORD\_FUNCTION
}{
   Declare a function that returns a WORD value
}

\subsubsection{Arguments of a C function}

\noteroutine{
   BYTE
}{
   Declare a BYTE argument
}
\noteroutine{
   BYTE\_ARRAY
}{
   Declare a BYTE array argument
}
\noteroutine{
   CHARACTER
}{
   Declare a CHARACTER argument
}
\noteroutine{
   CHARACTER\_ARRAY
}{
   Declare a CHARACTER array argument
}
\noteroutine{
   CHARACTER\_RETURN\_VALUE
}{
   Declare an argument that will be the return value of a CHARACTER
   function
}
\noteroutine{
   DOUBLE
}{
   Declare a DOUBLE PRECISION argument
}
\noteroutine{
   DOUBLE\_ARRAY
}{
   Declare a DOUBLE PRECISION array argument
}
\noteroutine{
   INTEGER
}{
   Declare an INTEGER argument
}
\noteroutine{
   INTEGER\_ARRAY
}{
   Declare an INTEGER array argument
}
\noteroutine{
   LOGICAL
}{
   Declare a LOGICAL argument
}
\noteroutine{
   LOGICAL\_ARRAY
}{
   Declare a LOGICAL array argument
}
\noteroutine{
   POINTER
}{
   Declare a POINTER argument
}
\noteroutine{
   REAL
}{
   Declare a REAL argument
}
\noteroutine{
   REAL\_ARRAY
}{
   Declare a REAL array argument
}
\noteroutine{
   TRAIL
}{
   Declare hidden trailing arguments
}
\noteroutine{
   TRAIL\_ARG
}{
   Pass the length of a CHARACTER argument to a FORTRAN routine
}
\noteroutine{
   WORD
}{
   Declare a WORD argument
}
\noteroutine{
   WORD\_ARRAY
}{
   Declare a WORD array argument
}

\subsubsection{Generate Pointers to Arguments}

\noteroutine{
   GENPTR\_BYTE
}{
   Generate a pointer to a BYTE argument
}
\noteroutine{
   GENPTR\_BYTE\_ARRAY
}{
   Generate a pointer to a BYTE array argument
}
\noteroutine{
   GENPTR\_CHARACTER
}{
   Generate a pointer to a CHARACTER argument
}
\noteroutine{
   GENPTR\_CHARACTER\_ARRAY
}{
   Generate a pointer to a CHARACTER array argument
}
\noteroutine{
   GENPTR\_DOUBLE
}{
   Generate a pointer to a DOUBLE PRECISION argument
}
\noteroutine{
   GENPTR\_DOUBLE\_ARRAY
}{
   Generate a pointer to a DOUBLE PRECISION array argument
}
\noteroutine{
   GENPTR\_INTEGER
}{
   Generate a pointer to an INTEGER argument
}
\noteroutine{
   GENPTR\_INTEGER\_ARRAY
}{
   Generate a pointer to an INTEGER array argument
}
\noteroutine{
   GENPTR\_LOGICAL
}{
   Generate a pointer to a LOGICAL argument
}
\noteroutine{
   GENPTR\_LOGICAL\_ARRAY
}{
   Generate a pointer to a LOGICAL array argument
}
\noteroutine{
   GENPTR\_POINTER
}{
   Generate a pointer to a POINTER argument
}
\noteroutine{
   GENPTR\_REAL
}{
   Generate a pointer to a REAL argument
}
\noteroutine{
   GENPTR\_REAL\_ARRAY
}{
   Generate a pointer to a REAL array argument
}
\noteroutine{
   GENPTR\_WORD
}{
   Generate a pointer to a WORD argument
}
\noteroutine{
   GENPTR\_WORD\_ARRAY
}{
   Generate a pointer to a WORD array argument
}

\subsubsection{Data Types}

\noteroutine{
   F77\_BYTE\_TYPE
}{
   Define the type BYTE
}
\noteroutine{
   F77\_CHARACTER\_TYPE
}{
   Define the type CHARACTER
}
\noteroutine{
   F77\_DOUBLE\_TYPE
}{
   Define the type DOUBLE PRECISION
}
\noteroutine{
   F77\_INTEGER\_TYPE
}{
   Define the type INTEGER
}
\noteroutine{
   F77\_LOGICAL\_TYPE
}{
   Define the type LOGICAL
}
\noteroutine{
   F77\_REAL\_TYPE
}{
   Define the type REAL
}
\noteroutine{
   F77\_WORD\_TYPE
}{
   Define the type WORD
}

\subsubsection{Logical Values}

\noteroutine{
   F77\_FALSE
}{
   The logical value FALSE
}
\noteroutine{
   F77\_ISFALSE
}{
   Is this the FORTRAN logical value false?
}
\noteroutine{
   F77\_ISTRUE
}{
   Is this the FORTRAN logical value true?
}
\noteroutine{
   F77\_TRUE
}{
   The logical value TRUE
}

\subsubsection{External Names}

\noteroutine{
   F77\_EXTERNAL\_NAME
}{
   The external name of a function
}

\subsubsection{Common Blocks}

\noteroutine{
   F77\_BLANK\_COMMON
}{
   Refer to blank common
}
\noteroutine{
   F77\_NAMED\_COMMON
}{
   Refer to a named common block
}

\subsubsection{Declaring variables for passing to a FORTRAN routine}

\noteroutine{
   DECLARE\_BYTE
}{
   Declare a BYTE variable
}
\noteroutine{
   DECLARE\_BYTE\_ARRAY
}{
   Declare a BYTE array
}
\noteroutine{
   DECLARE\_CHARACTER
}{
   Declare a CHARACTER variable
}
\noteroutine{
   DECLARE\_CHARACTER\_ARRAY
}{
   Declare a CHARACTER array
}
\noteroutine{
   DECLARE\_DOUBLE
}{
   Declare a DOUBLE variable
}
\noteroutine{
   DECLARE\_DOUBLE\_ARRAY
}{
   Declare a DOUBLE array
}
\noteroutine{
   DECLARE\_INTEGER
}{
   Declare an INTEGER variable
}
\noteroutine{
   DECLARE\_INTEGER\_ARRAY
}{
   Declare an INTEGER array
}
\noteroutine{
   DECLARE\_LOGICAL
}{
   Declare a LOGICAL variable
}
\noteroutine{
   DECLARE\_LOGICAL\_ARRAY
}{
   Declare a LOGICAL array
}
\noteroutine{
   DECLARE\_REAL
}{
   Declare a REAL variable
}
\noteroutine{
   DECLARE\_REAL\_ARRAY
}{
   Declare a REAL array
}
\noteroutine{
   DECLARE\_WORD
}{
   Declare a WORD variable
}
\noteroutine{
   DECLARE\_WORD\_ARRAY
}{
   Declare a WORD array
}

\subsubsection{Passing arguments to a FORTRAN routine}

\noteroutine{
   BYTE\_ARG
}{
   Pass a BYTE argument to a FORTRAN routine
}
\noteroutine{
   BYTE\_ARRAY\_ARG
}{
   Pass a BYTE array argument to a FORTRAN routine
}
\noteroutine{
   CHARACTER\_ARG
}{
   Pass a CHARACTER argument to a FORTRAN routine
}
\noteroutine{
   CHARACTER\_ARRAY\_ARG
}{
   Pass a CHARACTER array argument to a FORTRAN routine
}
\noteroutine{
   DOUBLE\_ARG
}{
   Pass a DOUBLE argument to a FORTRAN routine
}
\noteroutine{
   DOUBLE\_ARRAY\_ARG
}{
   Pass an actual DOUBLE array argument to a FORTRAN routine
}
\noteroutine{
   F77\_CALL
}{
   Call a FORTRAN routine from C
}
\noteroutine{
   INTEGER\_ARG
}{
   Pass an INTEGER argument to a FORTRAN routine
}
\noteroutine{
   INTEGER\_ARRAY\_ARG
}{
   Pass an INTEGER array argument to a FORTRAN routine
}
\noteroutine{
   LOGICAL\_ARG
}{
   Pass a LOGICAL argument to a FORTRAN routine
}
\noteroutine{
   LOGICAL\_ARRAY\_ARG
}{
   Pass a LOGICAL array argument to a FORTRAN routine
}
\noteroutine{
   REAL\_ARG
}{
   Pass a REAL argument to a FORTRAN routine
}
\noteroutine{
   REAL\_ARRAY\_ARG
}{
   Pass a REAL array argument to a FORTRAN routine
}
\noteroutine{
   WORD\_ARG
}{
   Pass a WORD argument to a FORTRAN routine
}
\noteroutine{
   WORD\_ARRAY\_ARG
}{
   Pass a WORD array argument to a FORTRAN routine
}


% Full Description of F77 macros.

\newpage
\subsection{F77 Macro Descriptions}

\sstmacro{
   BYTE
}{
   Declare a BYTE argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a BYTE variable passed from a FORTRAN program.
   }
   \sstinvocation{
      BYTE(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         BYTE(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char $*$arg
            \sstbox{SunOS:}    char $*$arg
            \sstbox{Ultrix:}   char $*$arg
\end{itemize}
      }
   }
}
\sstmacro{
   BYTE\_ARG
}{
   Pass a BYTE argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a BYTE argument to a FORTRAN routine. The argument should be
      the address of a BYTE variable.
   }
   \sstinvocation{
      BYTE\_ARG(p\_arg)
   }
   \sstarguments{
      \sstsubsection{
         p\_arg
      }{
         A pointer to the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         BYTE\_ARG(\&arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:} \&arg
            \sstbox{SunOS:}   \&arg
            \sstbox{Ultrix:}  \&arg
\end{itemize}
      }
   }
}
\sstmacro{
   BYTE\_ARRAY
}{
   Declare a BYTE array argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a BYTE array passed from a FORTRAN program.
   }
   \sstinvocation{
      BYTE\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         BYTE\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char arg[\,]
            \sstbox{SunOS:}    char arg[\,]
            \sstbox{Ultrix:}   char arg[\,]
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The C compiler will cast char arg[\,] to char $*$arg.
      }
   }
}
\sstmacro{
   BYTE\_ARRAY\_ARG
}{
   Pass a BYTE array argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a BYTE array argument to a FORTRAN routine. The argument
      should be the address of a BYTE array.
   }
   \sstinvocation{
      BYTE\_ARRAY\_ARG(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The name of the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         BYTE\_ARRAY\_ARG(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  arg
            \sstbox{SunOS:}    arg
            \sstbox{Ultrix:}   arg
\end{itemize}
      }
   }
}
\sstmacro{
   CHARACTER
}{
   Declare a CHARACTER argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a CHARACTER variable passed from a FORTRAN program.
   }
   \sstinvocation{
      CHARACTER(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CHARACTER(x)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  struct dsc\$descriptor\_s $*$x\_arg
            \sstbox{SunOS:}    char x[\,]
            \sstbox{Ultrix:}   char x[\,]
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         On a VAX/VMS system, the macro expands to a pointer to a
            descriptor whereas on other systems it expands to an array
            declarator.
      }
   }
}
\sstmacro{
   CHARACTER\_ARG
}{
   Pass a CHARACTER argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a CHARACTER argument to a FORTRAN routine. The argument
      should be the address of a CHARACTER variable.
   }
   \sstinvocation{
      CHARACTER\_ARG(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The name of the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CHARACTER\_ARG(charg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  charg\_arg
            \sstbox{SunOS:}    charg
            \sstbox{Ultrix:}   charg
\end{itemize}
      }
   }
}
\sstmacro{
   CHARACTER\_ARRAY
}{
   Declare a CHARACTER array argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a CHARACTER array passed from a FORTRAN program.
   }
   \sstinvocation{
      CHARACTER\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CHARACTER\_ARRAY(x)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  struct dsc\$descriptor\_a $*$x\_arg
            \sstbox{SunOS:}    char x[\,]
            \sstbox{Ultrix:}   char x[\,]
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The C compiler will cast char x[\,] to char $*$x.
      }
   }
}
\sstmacro{
   CHARACTER\_ARRAY\_ARG
}{
   Pass a CHARACTER array argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a CHARACTER array argument to a FORTRAN routine. The
      argument should be the address of a CHARACTER array.
   }
   \sstinvocation{
      CHARACTER\_ARRAY\_ARG(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The name of the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CHARACTER\_ARRAY\_ARG(charg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  charg\_arg
            \sstbox{SunOS:}    charg
            \sstbox{Ultrix:}   charg
\end{itemize}
      }
   }
}
\sstmacro{
   CHARACTER\_RETURN\_VALUE
}{
   Declare an argument that will be the return value of a CHARACTER
   function
}{
   \sstdescription{
      Declare a C function argument to return the value of a CHARACTER
      function. There is no corresponding actual argument in the FORTRAN
      call, but the compiler generates this extra argument and possibly
      another one, specifying the length of the value to be returned.
   }
   \sstinvocation{
      CHARACER\_RETURN\_VALUE(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The hidden dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CHARACTER\_RETURN\_VALUE(x)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  struct dsc\$descriptor\_s $*$x\_arg
            \sstbox{SunOS:}    char x[\,] ,int x\_length
            \sstbox{Ultrix:}   char x[\,] ,int x\_length
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The C compiler will cast char x[\,] to char $*$x.
      }
   }
}
\sstmacro{
   DECLARE\_BYTE
}{
   Declare a BYTE variable
}{
   \sstdescription{
      Declare a BYTE variable that will be passed to a FORTRAN routine.
      This variable will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_BYTE(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_BYTE(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char arg
            \sstbox{SunOS:}    char arg
            \sstbox{Ultrix:}   char arg
\end{itemize}
      }
   }
}
\sstmacro{
   DECLARE\_BYTE\_ARRAY
}{
   Declare a BYTE array
}{
   \sstdescription{
      Declare a BYTE array that will be passed to a FORTRAN routine.
      This array will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_BYTE\_ARRAY(arg,dims)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The array being declared.
      }
      \sstsubsection{
         dims
      }{
         The dimensions of the array.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_BYTE\_ARRAY(arg,10)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char arg[10]
            \sstbox{SunOS:}    char arg[10]
            \sstbox{Ultrix:}   char arg[10]
\end{itemize}
      }
      \sstexamplesubsection{
         DECLARE\_BYTE\_ARRAY(arg,2][3][4)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char arg[2][3][4]
            \sstbox{SunOS:}    char arg[2][3][4]
            \sstbox{Ultrix:}   char arg[2][3][4]
\end{itemize}
      }
   }
}
\sstmacro{
   DECLARE\_CHARACTER
}{
   Declare a CHARACTER variable
}{
   \sstdescription{
      Declare a CHARACTER variable that will be passed to a FORTRAN routine.
      This variable will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_CHARACTER(arg,length)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being declared.
      }
      \sstsubsection{
         length
      }{
         The length of the character string.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_CHARACTER(C,50)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char C[50]; const int C\_length = 50;
            \sstbox{}          struct dsc\$descriptor\_s C\_descr =
            \sstbox{}          \{ 50, DSC\$K\_DTYPE\_T, DSC\$K\_CLASS\_S, C \};
            \sstbox{}          struct dsc\$descriptor\_s $*$C\_arg =\&C\_descr
            \sstbox{SunOS:}    char C[50]; const int C\_length = 50
            \sstbox{Ultrix:}   char C[50]; const int C\_length = 50
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         On VMS, the expansion of the macro is quite complex. A char
            array is declared as well as an int variable to store the
            length of the array. There is also a descriptor and a pointer
            to that descriptor. The address of the descriptor is what is
            actually passed to the called FORTRAN routine.
      }
   }
}
\sstmacro{
   DECLARE\_CHARACTER\_ARRAY
}{
   Declare a CHARACTER array
}{
   \sstdescription{
      Declare a CHARACTER array that will be passed to a FORTRAN routine.
      This array will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_CHARACTER\_ARRAY(arg,length,dims)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The array being declared.
      }
      \sstsubsection{
         length
      }{
         The length of the character string.
      }
      \sstsubsection{
         dims
      }{
         The dimensions of the array.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_CHARACTER\_ARRAY(C,50,10)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char C[10][50]; const int C\_length = 50;
            \sstbox{}          struct dsc\$descriptor\_s C\_descr =
            \sstbox{}          \{ 50, DSC\$K\_DTYPE\_T, DSC\$K\_CLASS\_S, C \};
            \sstbox{}          struct dsc\$descriptor\_s $*$C\_arg =\&C\_descr
            \sstbox{SunOS:}    char C[10][50]; const int C\_length
            \sstbox{Ultrix:}   char C[10][50]; const int C\_length
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         On VMS, the expansion of the macro is quite complex. A char
            array is declared as well as an int variable to store the
            length of the array. There is also a descriptor and a pointer
            to that descriptor. The address of the descriptor is what is
            actually passed to the called FORTRAN routine.
      }
   }
}
\sstmacro{
   DECLARE\_DOUBLE
}{
   Declare a DOUBLE PRECISION variable
}{
   \sstdescription{
      Declare a DOUBLE variable that will be passed to a FORTRAN routine.
      This variable will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_DOUBLE(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_DOUBLE(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  double arg
            \sstbox{SunOS:}    double arg
            \sstbox{Ultrix:}   double arg
\end{itemize}
      }
   }
}
\sstmacro{
   DECLARE\_DOUBLE\_ARRAY
}{
   Declare a DOUBLE PRECISION array
}{
   \sstdescription{
      Declare a DOUBLE array that will be passed to a FORTRAN routine.
      This array will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_DOUBLE\_ARRAY(arg,dims)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The array being declared.
      }
      \sstsubsection{
         dims
      }{
         The dimensions of the array.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_DOUBLE\_ARRAY(arg,10)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  double arg[10]
            \sstbox{SunOS:}    double arg[10]
            \sstbox{Ultrix:}   double arg[10]
\end{itemize}
      }
      \sstexamplesubsection{
         DECLARE\_DOUBLE\_ARRAY(arg,2][3][4)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  double arg[2][3][4]
            \sstbox{SunOS:}    double arg[2][3][4]
            \sstbox{Ultrix:}   double arg[2][3][4]
\end{itemize}
      }
   }
}
\sstmacro{
   DECLARE\_INTEGER
}{
   Declare an INTEGER variable
}{
   \sstdescription{
      Declare an INTEGER variable that will be passed to a FORTRAN routine.
      This variable will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_INTEGER(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_INTEGER(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int arg
            \sstbox{SunOS:}    int arg
            \sstbox{Ultrix:}   int arg
\end{itemize}
      }
   }
}
\sstmacro{
   DECLARE\_INTEGER\_ARRAY
}{
   Declare an INTEGER array
}{
   \sstdescription{
      Declare an INTEGER array that will be passed to a FORTRAN routine.
      This array will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_INTEGER\_ARRAY(arg,dims)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The array being declared.
      }
      \sstsubsection{
         dims
      }{
         The dimensions of the array.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_INTEGER\_ARRAY(arg,10)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int arg[10]
            \sstbox{SunOS:}    int arg[10]
            \sstbox{Ultrix:}   int arg[10]
\end{itemize}
      }
      \sstexamplesubsection{
         DECLARE\_INTEGER\_ARRAY(arg,2][3][4)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int arg[2][3][4]
            \sstbox{SunOS:}    int arg[2][3][4]
            \sstbox{Ultrix:}   int arg[2][3][4]
\end{itemize}
      }
   }
}
\sstmacro{
   DECLARE\_LOGICAL
}{
   Declare a LOGICAL variable
}{
   \sstdescription{
      Declare a LOGICAL variable that will be passed to a FORTRAN routine.
      This variable will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_LOGICAL(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_LOGICAL(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int arg
            \sstbox{SunOS:}    int arg
            \sstbox{Ultrix:}   int arg
\end{itemize}
      }
   }
}
\sstmacro{
   DECLARE\_LOGICAL\_ARRAY
}{
   Declare a LOGICAL array
}{
   \sstdescription{
      Declare a LOGICAL array that will be passed to a FORTRAN routine.
      This array will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_LOGICAL\_ARRAY(arg,dims)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The array being declared.
      }
      \sstsubsection{
         dims
      }{
         The dimensions of the array.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_LOGICAL\_ARRAY(arg,10)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int arg[10]
            \sstbox{SunOS:}    int arg[10]
            \sstbox{Ultrix:}   int arg[10]
\end{itemize}
      }
      \sstexamplesubsection{
         DECLARE\_LOGICAL\_ARRAY(arg,2][3][4)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int arg[2][3][4]
            \sstbox{SunOS:}    int arg[2][3][4]
            \sstbox{Ultrix:}   int arg[2][3][4]
\end{itemize}
      }
   }
}
\sstmacro{
   DECLARE\_REAL
}{
   Declare a REAL variable
}{
   \sstdescription{
      Declare a REAL variable that will be passed to a FORTRAN routine.
      This variable will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_REAL(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_REAL(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  float arg
            \sstbox{SunOS:}    float arg
            \sstbox{Ultrix:}   float arg
\end{itemize}
      }
   }
}
\sstmacro{
   DECLARE\_REAL\_ARRAY
}{
   Declare a REAL array
}{
   \sstdescription{
      Declare a REAL array that will be passed to a FORTRAN routine.
      This array will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_REAL\_ARRAY(arg,dims)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The array being declared.
      }
      \sstsubsection{
         dims
      }{
         The dimensions of the array.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_REAL\_ARRAY(arg,10)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  float arg[10]
            \sstbox{SunOS:}    float arg[10]
            \sstbox{Ultrix:}   float arg[10]
\end{itemize}
      }
      \sstexamplesubsection{
         DECLARE\_REAL\_ARRAY(arg,2][3][4)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  float arg[2][3][4]
            \sstbox{SunOS:}    float arg[2][3][4]
            \sstbox{Ultrix:}   float arg[2][3][4]
\end{itemize}
      }
   }
}
\sstmacro{
   DECLARE\_WORD
}{
   Declare a WORD variable
}{
   \sstdescription{
      Declare a WORD variable that will be passed to a FORTRAN routine.
      This variable will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_WORD(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_WORD(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  short int arg
            \sstbox{SunOS:}    short int arg
            \sstbox{Ultrix:}   short int arg
\end{itemize}
      }
   }
}
\sstmacro{
   DECLARE\_WORD\_ARRAY
}{
   Declare a WORD array
}{
   \sstdescription{
      Declare a WORD array that will be passed to a FORTRAN routine.
      This array will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_WORD\_ARRAY(arg,dims)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The array being declared.
      }
      \sstsubsection{
         dims
      }{
         The dimensions of the array.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_WORD\_ARRAY(arg,10)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  short int arg[10]
            \sstbox{SunOS:}    short int arg[10]
            \sstbox{Ultrix:}   short int arg[10]
\end{itemize}
      }
      \sstexamplesubsection{
         DECLARE\_WORD\_ARRAY(arg,2][3][4)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  short int arg[2][3][4]
            \sstbox{SunOS:}    short int arg[2][3][4]
            \sstbox{Ultrix:}   short int arg[2][3][4]
\end{itemize}
      }
   }
}
\sstmacro{
   DOUBLE
}{
   Declare a DOUBLE PRECISION argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a DOUBLE PRECISION variable passed from a FORTRAN program.
   }
   \sstinvocation{
      DOUBLE(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DOUBLE(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  double $*$arg
            \sstbox{SunOS:}    double $*$arg
            \sstbox{Ultrix:}   double $*$arg
\end{itemize}
      }
   }
}
\sstmacro{
   DOUBLE\_ARG
}{
   Pass a DOUBLE argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a DOUBLE argument to a FORTRAN routine. The argument should be
      the address of a DOUBLE variable.
   }
   \sstinvocation{
      DOUBLE\_ARG(p\_arg)
   }
   \sstarguments{
      \sstsubsection{
         p\_arg
      }{
         A pointer to the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DOUBLE\_ARG(\&arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:} \&arg
            \sstbox{SunOS:}   \&arg
            \sstbox{Ultrix:}  \&arg
\end{itemize}
      }
   }
}
\sstmacro{
   DOUBLE\_ARRAY
}{
   Declare a DOUBLE PRECISION array argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a DOUBLE PRECISION array passed from a FORTRAN program.
   }
   \sstinvocation{
      DOUBLE\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DOUBLE\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  double arg[\,]
            \sstbox{SunOS:}    double arg[\,]
            \sstbox{Ultrix:}   double arg[\,]
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The C compiler will cast double arg [\,] to double $*$arg.
      }
   }
}
\sstmacro{
   DOUBLE\_ARRAY\_ARG
}{
   Pass a DOUBLE array argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a DOUBLE array argument to a FORTRAN routine. The argument
      should be the address of a DOUBLE array.
   }
   \sstinvocation{
      DOUBLE\_ARRAY\_ARG(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The name of the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DOUBLE\_ARRAY\_ARG(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  arg
            \sstbox{SunOS:}    arg
            \sstbox{Ultrix:}   arg
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_BLANK\_COMMON
}{
   Refer to blank common
}{
   \sstdescription{
      Expands to the external name of blank common on the computer in
      use. This is used in declaring an external structure in C that
      overlays the FORTRAN blank common block.
   }
   \sstinvocation{
      F77\_BLANK\_COMMON
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_BLANK\_COMMON
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  \$BLANK
            \sstbox{SunOS:}    \_BLNK\_\_
            \sstbox{Ultrix:}   \_BLNK\_\_
\end{itemize}
      }
      \sstexamplesubsection{
         extern struct \{int i,j,k;\} F77\_BLANK\_COMMON;
      }{
         declares an external structure to use the same storage as the
         FORTRAN blank common.
      }
      \sstexamplesubsection{
         F77\_BLANK\_COMMON.i
      }{
         refers to component i of the above structure.
      }
   }
}
\sstmacro{
   F77\_BYTE\_FUNCTION
}{
   Declare a function that returns a BYTE value
}{
   \sstdescription{
      Declare a C function that will be called from FORTRAN as though it
      were a FORTRAN BYTE function.
   }
   \sstinvocation{
      F77\_BYTE\_FUNCTION(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the function to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_BYTE\_FUNCTION(name)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char name
            \sstbox{SunOS:}    char name\_
            \sstbox{Ultrix:}   char name\_
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_BYTE\_TYPE
}{
   Define the type BYTE
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type BYTE.
   }
   \sstinvocation{
      F77\_BYTE\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_BYTE\_TYPE
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char
            \sstbox{SunOS:}    char
            \sstbox{Ultrix:}   char
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_CALL
}{
   Call a FORTRAN routine from C
}{
   \sstdescription{
      Call a FORTRAN subroutine or function from a C routine.
   }
   \sstinvocation{
      F77\_CALL(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the FORTRAN routine being called.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CALL(suba)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  suba
            \sstbox{SunOS:}    suba\_
            \sstbox{Ultrix:}   suba\_
\end{itemize}
      }
   }
   \sstnotes{
      This macro is just a shorthand for F77\_EXTERNAL\_NAME. It is more
      expressive to use F77\_CALL rather than F77\_EXTERNAL\_NAME when
      calling a routine.
   }
}
\sstmacro{
   F77\_CHARACTER\_FUNCTION
}{
   Declare a function that returns a CHARACTER value
}{
   \sstdescription{
      Declare a C function that will be called from FORTRAN as though it
      were a FORTRAN CHARACTER function.
   }
   \sstinvocation{
      F77\_CHARACTER\_FUNCTION(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the function to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CHARACTER\_FUNCTION(name)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  void name
            \sstbox{SunOS:}    void name\_
            \sstbox{Ultrix:}   void name\_
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_CHARACTER\_TYPE
}{
   Define the type CHARACTER
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type CHARACTER.
   }
   \sstinvocation{
      F77\_CHARACTER\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CHARACTER\_TYPE
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char
            \sstbox{SunOS:}    char
            \sstbox{Ultrix:}   char
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_DOUBLE\_FUNCTION
}{
   Declare a function that returns a DOUBLE PRECISION value
}{
   \sstdescription{
      Declare a C function that will be called from FORTRAN as though it
      were a FORTRAN DOUBLE PRECISION function.
   }
   \sstinvocation{
      F77\_DOUBLE\_FUNCTION(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the function to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_DOUBLE\_FUNCTION(name)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  double name
            \sstbox{SunOS:}    double name\_
            \sstbox{Ultrix:}   double name\_
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_DOUBLE\_TYPE
}{
   Define the type DOUBLE PRECISION
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type DOUBLE
      PRECISION.
   }
   \sstinvocation{
      F77\_DOUBLE\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_DOUBLE\_TYPE
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  double
            \sstbox{SunOS:}    double
            \sstbox{Ultrix:}   double
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_EXTERNAL\_NAME
}{
   The external name of a function
}{
   \sstdescription{
      Define the external name of a C function. This may have such
      things as trailing underscores.
   }
   \sstinvocation{
      F77\_EXTERNAL\_NAME
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_EXTERNAL\_NAME(name)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  name
            \sstbox{SunOS:}    name\_
            \sstbox{Ultrix:}   name\_
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_FALSE
}{
   The logical value FALSE
}{
   \sstdescription{
      Expand to the number that FORTRAN treats as a logical value of
      FALSE.
   }
   \sstinvocation{
      F77\_FALSE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_FALSE
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  0
            \sstbox{SunOS:}    0
            \sstbox{Ultrix:}   0
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         FORTRAN and C might not interpret the same numerical value as
            the same logical value.
      }
   }
}
\sstmacro{
   F77\_INTEGER\_FUNCTION
}{
   Declare a function that returns an INTEGER value
}{
   \sstdescription{
      Declare a C function that will be called from FORTRAN as though it
      were a FORTRAN INTEGER function.
   }
   \sstinvocation{
      F77\_INTEGER\_FUNCTION(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the function to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_INTEGER\_FUNCTION(name)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int name
            \sstbox{SunOS:}    int name\_
            \sstbox{Ultrix:}   int name\_
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_INTEGER\_TYPE
}{
   Define the type INTEGER
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type INTEGER.
   }
   \sstinvocation{
      F77\_INTEGER\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_INTEGER\_TYPE
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int
            \sstbox{SunOS:}    int
            \sstbox{Ultrix:}   int
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_ISFALSE
}{
   Is this the FORTRAN logical value false?
}{
   \sstdescription{
      Does the argument of the macro evaluate to a value that FORTRAN
      would treat as a LOGICAL false?
   }
   \sstinvocation{
      if( F77\_ISFALSE(var) ) ...
   }
   \sstarguments{
      \sstsubsection{
         var
      }{
         The name of the value to be tested.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_ISFALSE(var)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  ( ! ( (var)\&1 ) )
            \sstbox{SunOS:}    ( ! ( var ) )
            \sstbox{Ultrix:}   ( ! ( (var)\&1 ) )
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The VAX FORTRAN and DEC FORTRAN for RISC compilers only use the
            lowest bit for the logical flag.
            Hence 0 = false, 1 = true, 2 = false, 3 = true, etc.

         \sstitem
         The Sun FORTRAN compiler uses zero = false, non zero = true.

         \sstitem
         The FORTRAN for RISC compiler (from MIPS) on the DECstation
            uses zero = false, non zero = true. This means that the correct
            value of this C macro depends on which FORTRAN compiler is
            being used.
      }
   }
}
\sstmacro{
   F77\_ISTRUE
}{
   Is this the FORTRAN logical value true?
}{
   \sstdescription{
      Does the argument of the macro evaluate to a value that FORTRAN
      would treat as a LOGICAL true?
   }
   \sstinvocation{
      if( F77\_ISTRUE(var) ) ...
   }
   \sstarguments{
      \sstsubsection{
         var
      }{
         The name of the value to be tested.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_ISTRUE(var)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  ( (var)\&1 )
            \sstbox{SunOS:}    ( var )
            \sstbox{Ultrix:}   ( (var)\&1 )
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The VAX FORTRAN and DEC FORTRAN for RISC compilers only use the
            lowest bit for the logical flag.
            Hence 0 = false, 1 = true, 2 = false, 3 = true, etc.

         \sstitem
         The Sun FORTRAN compiler uses zero = false, non zero = true.

         \sstitem
         The FORTRAN for RISC compiler (from MIPS) on the DECstation
            uses zero = false, non zero = true. This means that the correct
            value of this C macro depends on which FORTRAN compiler is
            being used.
      }
   }
}
\sstmacro{
   F77\_LOGICAL\_FUNCTION
}{
   Declare a function that returns a LOGICAL value
}{
   \sstdescription{
      Declare a C function that will be called from FORTRAN as though it
      were a FORTRAN LOGICAL function.
   }
   \sstinvocation{
      F77\_LOGICAL\_FUNCTION(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the function to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_LOGICAL\_FUNCTION(name)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int name
            \sstbox{SunOS:}    int name\_
            \sstbox{Ultrix:}   int name\_
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_LOGICAL\_TYPE
}{
   Define the type LOGICAL
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type LOGICAL.
   }
   \sstinvocation{
      F77\_LOGICAL\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_LOGICAL\_TYPE
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int
            \sstbox{SunOS:}    int
            \sstbox{Ultrix:}   int
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_NAMED\_COMMON
}{
   Refer to a named common block
}{
   \sstdescription{
      Expand to the external name of a named common block on the
      computer in use. This is used in declaring an external structure
      in C that overlays a FORTRAN named common block.
   }
   \sstinvocation{
      F77\_NAMED\_COMMON(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the common block.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_NAMED\_COMMON(name)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  name
            \sstbox{SunOS:}    name\_
            \sstbox{Ultrix:}   name\_
\end{itemize}
      }
      \sstexamplesubsection{
         extern struct \{int i,j,k;\} F77\_NAMED\_COMMON(block);
      }{
         declares an external structure to use the same storage as the
         FORTRAN named common block.
      }
      \sstexamplesubsection{
         F77\_NAMED\_COMMON(block).i
      }{
         refers to component i of the above structure.
      }
   }
}
\sstmacro{
   F77\_REAL\_FUNCTION
}{
   Declare a function that returns a REAL value
}{
   \sstdescription{
      Declare a C function that will be called from FORTRAN as though it
      were a FORTRAN REAL function.
   }
   \sstinvocation{
      F77\_REAL\_FUNCTION(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the function to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_REAL\_FUNCTION(name)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  float name
            \sstbox{SunOS:}    float name\_
            \sstbox{Ultrix:}   float name\_
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_REAL\_TYPE
}{
   Define the type REAL
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type REAL.
   }
   \sstinvocation{
      F77\_REAL\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_REAL\_TYPE
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  float
            \sstbox{SunOS:}    float
            \sstbox{Ultrix:}   float
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_SUBROUTINE
}{
   Declare a SUBROUTINE
}{
   \sstdescription{
      Declare a C function that will be called from FORTRAN as though it
      were a subroutine.
   }
   \sstinvocation{
      F77\_SUBROUTINE(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the function to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_REAL\_FUNCTION(name)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  void name
            \sstbox{SunOS:}    void name\_
            \sstbox{Ultrix:}   void name\_
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_TRUE
}{
   The logical value TRUE
}{
   \sstdescription{
      Expand to the number that FORTRAN treats as a logical value of
      TRUE.
   }
   \sstinvocation{
      F77\_TRUE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_TRUE
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  -1
            \sstbox{SunOS:}    1
            \sstbox{Ultrix:}   -1
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         FORTRAN and C might not interpret the same numerical value as
            the same logical value.
      }
   }
}
\sstmacro{
   F77\_WORD\_FUNCTION
}{
   Declare a function that returns a WORD value
}{
   \sstdescription{
      Declare a C function that will be called from FORTRAN as though it
      were a FORTRAN WORD function.
   }
   \sstinvocation{
      F77\_WORD\_FUNCTION(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the function to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_WORD\_FUNCTION(name)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  short int name
            \sstbox{SunOS:}    short int name\_
            \sstbox{Ultrix:}   short int name\_
\end{itemize}
      }
   }
}
\sstmacro{
   F77\_WORD\_TYPE
}{
   Define the type WORD
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type WORD.
   }
   \sstinvocation{
      F77\_WORD\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_WORD\_TYPE
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  short int
            \sstbox{SunOS:}    short int
            \sstbox{Ultrix:}   short int
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_BYTE
}{
   Generate a pointer to a BYTE argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the variable that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_BYTE(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_BYTE(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_BYTE\_ARRAY
}{
   Generate a pointer to a BYTE array argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the array that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_BYTE\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_BYTE\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_CHARACTER
}{
   Generate a pointer to a CHARACTER argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the character variable that
      has been passed as an actual argument to the C routine. Also
      generate a variable that contains the length of the actual
      character argument and call it arg\_length.
   }
   \sstinvocation{
      GENPTR\_CHARACTER(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_CHARACTER(x)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char $*$x = x\_arg-$>$dsc\$a\_pointer;
            \sstbox{}          int x\_length = x\_arg-$>$dsc\$w\_length;
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         On Unix systems, this macro is null, but on a VAX/VMS system,
            this macro actually declares the variables that are the pointer
            to the character string and the integer that contains its
            length.
      }
   }
}
\sstmacro{
   GENPTR\_CHARACTER\_ARRAY
}{
   Generate a pointer to a CHARACTER array argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the character array that
      has been passed as an actual argument to the C routine. Also
      generate a variable that contains the length of the actual
      character argument and call it arg\_length.
   }
   \sstinvocation{
      GENPTR\_CHARACTER\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_CHARACTER\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  char $*$x = x\_arg-$>$dsc\$a\_pointer;
            \sstbox{}          int x\_length = x\_arg-$>$dsc\$w\_length;
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         On Unix systems, this macro is null, but on a VAX/VMS system,
            this macro actually declares the variables that are the pointer
            to the character string and the integer that contains its
            length.
      }
   }
}
\sstmacro{
   GENPTR\_DOUBLE
}{
   Generate a pointer to a DOUBLE PRECISION argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the variable that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_DOUBLE(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_DOUBLE(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_DOUBLE\_ARRAY
}{
   Generate a pointer to a DOUBLE PRECISION array argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the array that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_DOUBLE\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_DOUBLE\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_INTEGER
}{
   Generate a pointer to an INTEGER argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the variable that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_INTEGER(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_INTEGER(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_INTEGER\_ARRAY
}{
   Generate a pointer to an INTEGER array argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the array that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_INTEGER\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_INTEGER\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_LOGICAL
}{
   Generate a pointer to a LOGICAL argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the variable that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_LOGICAL(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_LOGICAL(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_LOGICAL\_ARRAY
}{
   Generate a pointer to a LOGICAL array argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the array that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_LOGICAL\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_LOGICAL\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_POINTER
}{
   Generate a pointer to a POINTER argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the variable that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_POINTER(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_POINTER(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_REAL
}{
   Generate a pointer to a REAL argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the variable that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_REAL(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_REAL(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_REAL\_ARRAY
}{
   Generate a pointer to a REAL array argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the array that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_REAL\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_REAL\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_WORD
}{
   Generate a pointer to a WORD argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the variable that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_WORD(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_WORD(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   GENPTR\_WORD\_ARRAY
}{
   Generate a pointer to a WORD array argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the array that has been
      passed as an actual argument to the C routine. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly
      available directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_WORD\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_WORD\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}
            \sstbox{Ultrix:}
\end{itemize}
      }
   }
}
\sstmacro{
   INTEGER
}{
   Declare an INTEGER argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be an INTEGER variable passed from a FORTRAN program.
   }
   \sstinvocation{
      INTEGER(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         INTEGER(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int $*$arg
            \sstbox{SunOS:}    int $*$arg
            \sstbox{Ultrix:}   int $*$arg
\end{itemize}
      }
   }
}
\sstmacro{
   INTEGER\_ARG
}{
   Pass an INTEGER argument to a FORTRAN routine
}{
   \sstdescription{
      Pass an INTEGER argument to a FORTRAN routine. The argument
      should be the address of an INTEGER variable.
   }
   \sstinvocation{
      INTEGER\_ARG(p\_arg)
   }
   \sstarguments{
      \sstsubsection{
         p\_arg
      }{
         A pointer to the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         INTEGER\_ARG(\&arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:} \&arg
            \sstbox{SunOS:}   \&arg
            \sstbox{Ultrix:}  \&arg
\end{itemize}
      }
   }
}
\sstmacro{
   INTEGER\_ARRAY
}{
   Declare an INTEGER array argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be an INTEGER array passed from a FORTRAN program.
   }
   \sstinvocation{
      INTEGER\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         INTEGER\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int arg[\,]
            \sstbox{SunOS:}    int arg[\,]
            \sstbox{Ultrix:}   int arg[\,]
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The C compiler will cast int arg [\,] to int $*$arg.
      }
   }
}
\sstmacro{
   INTEGER\_ARRAY\_ARG
}{
   Pass an INTEGER array argument to a FORTRAN routine
}{
   \sstdescription{
      Pass an INTEGER array argument to a FORTRAN routine. The argument
      should be the address of an INTEGER array.
   }
   \sstinvocation{
      INTEGER\_ARRAY\_ARG(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The name of the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         INTEGER\_ARRAY\_ARG(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  arg
            \sstbox{SunOS:}    arg
            \sstbox{Ultrix:}   arg
\end{itemize}
      }
   }
}
\sstmacro{
   LOGICAL
}{
   Declare a LOGICAL argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a LOGICAL variable passed from a FORTRAN program.
   }
   \sstinvocation{
      LOGICAL(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LOGICAL(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int $*$arg
            \sstbox{SunOS:}    int $*$arg
            \sstbox{Ultrix:}   int $*$arg
\end{itemize}
      }
   }
}
\sstmacro{
   LOGICAL\_ARG
}{
   Pass a LOGICAL argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a LOGICAL argument to a FORTRAN routine. The argument should
      be the address of a LOGICAL variable.
   }
   \sstinvocation{
      LOGICAL\_ARG(p\_arg)
   }
   \sstarguments{
      \sstsubsection{
         p\_arg
      }{
         A pointer to the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LOGICAL\_ARG(\&arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:} \&arg
            \sstbox{SunOS:}   \&arg
            \sstbox{Ultrix:}  \&arg
\end{itemize}
      }
   }
}
\sstmacro{
   LOGICAL\_ARRAY
}{
   Declare a LOGICAL array argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a LOGICAL array passed from a FORTRAN program.
   }
   \sstinvocation{
      LOGICAL\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LOGICAL\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  int arg[\,]
            \sstbox{SunOS:}    int arg[\,]
            \sstbox{Ultrix:}   int arg[\,]
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The C compiler will cast int arg [\,] to int $*$arg.
      }
   }
}
\sstmacro{
   LOGICAL\_ARRAY\_ARG
}{
   Pass a LOGICAL array argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a LOGICAL array argument to a FORTRAN routine. The argument
      should be the address of a LOGICAL array.
   }
   \sstinvocation{
      LOGICAL\_ARRAY\_ARG(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The name of the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         LOGICAL\_ARRAY\_ARG(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  arg
            \sstbox{SunOS:}    arg
            \sstbox{Ultrix:}   arg
\end{itemize}
      }
   }
}
\sstmacro{
   POINTER
}{
   Declare a POINTER argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a FORTRAN variable whose value is to be treated as an address.
   }
   \sstinvocation{
      POINTER(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         POINTER(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  void $*$$*$arg
            \sstbox{SunOS:}    void $*$$*$arg
            \sstbox{Ultrix:}   void $*$$*$arg
\end{itemize}
      }
   }
}
\sstmacro{
   REAL
}{
   Declare a REAL argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a REAL variable passed from a FORTRAN program.
   }
   \sstinvocation{
      REAL(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         REAL(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  float  $*$arg
            \sstbox{SunOS:}    float  $*$arg
            \sstbox{Ultrix:}   float  $*$arg
\end{itemize}
      }
   }
}
\sstmacro{
   REAL\_ARG
}{
   Pass a REAL argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a REAL argument to a FORTRAN routine. The argument should be
      the address of a REAL variable.
   }
   \sstinvocation{
      REAL\_ARG(p\_arg)
   }
   \sstarguments{
      \sstsubsection{
         p\_arg
      }{
         A pointer to the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         REAL\_ARG(\&arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:} \&arg
            \sstbox{SunOS:}   \&arg
            \sstbox{Ultrix:}  \&arg
\end{itemize}
      }
   }
}
\sstmacro{
   REAL\_ARRAY
}{
   Declare a REAL array argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a REAL array passed from a FORTRAN program.
   }
   \sstinvocation{
      REAL\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         REAL\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  float arg[\,]
            \sstbox{SunOS:}    float arg[\,]
            \sstbox{Ultrix:}   float arg[\,]
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The C compiler will cast float arg [\,] to float $*$arg.
      }
   }
}
\sstmacro{
   REAL\_ARRAY\_ARG
}{
   Pass a REAL array argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a REAL array argument to a FORTRAN routine. The argument
      should be the address of a REAL array.
   }
   \sstinvocation{
      REAL\_ARRAY\_ARG(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The name of the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         REAL\_ARRAY\_ARG(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  arg
            \sstbox{SunOS:}    arg
            \sstbox{Ultrix:}   arg
\end{itemize}
      }
   }
}
\sstmacro{
   TRAIL
}{
   Declare hidden trailing arguments
}{
   \sstdescription{
      Declare an argument on those machines that put an extra value at
      the end of the argument list to specify the length of a CHARACTER
      variable.
   }
   \sstinvocation{
      TRAIL(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The extra dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         TRAIL(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}    ,int arg\_length
            \sstbox{Ultrix:}   ,int arg\_length
\end{itemize}
      }
   }
}
\sstmacro{
   TRAIL\_ARG
}{
   Pass the length of a CHARACTER argument to a FORTRAN routine
}{
   \sstdescription{
      Pass the length of a CHARACTER argument to a FORTRAN routine if
      the FORTRAN routine expects to receive it as a separate argument.
      The argument should be a character variable. The corresponding
      integer variable is handled automatically where it is needed.
   }
   \sstinvocation{
      TRAIL\_ARG(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The name of the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         TRAIL\_ARG(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}
            \sstbox{SunOS:}    ,arg\_length
            \sstbox{Ultrix:}   ,arg\_length
\end{itemize}
      }
   }
}
\sstmacro{
   WORD
}{
   Declare a WORD argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a WORD variable passed from a FORTRAN program.
   }
   \sstinvocation{
      WORD(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         WORD(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  short int $*$arg
            \sstbox{SunOS:}    short int $*$arg
            \sstbox{Ultrix:}   short int $*$arg
\end{itemize}
      }
   }
}
\sstmacro{
   WORD\_ARG
}{
   Pass a WORD argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a WORD argument to a FORTRAN routine. The argument should be
      the address of a WORD variable.
   }
   \sstinvocation{
      WORD\_ARG(p\_arg)
   }
   \sstarguments{
      \sstsubsection{
         p\_arg
      }{
         A pointer to the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         WORD\_ARG(\&arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:} \&arg
            \sstbox{SunOS:}   \&arg
            \sstbox{Ultrix:}  \&arg
\end{itemize}
      }
   }
}
\sstmacro{
   WORD\_ARRAY
}{
   Declare a WORD array argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a WORD array passed from a FORTRAN program.
   }
   \sstinvocation{
      WORD\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         WORD\_ARRAY(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  short int arg[\,]
            \sstbox{SunOS:}    short int arg[\,]
            \sstbox{Ultrix:}   short int arg[\,]
\end{itemize}
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The C compiler will cast short int arg [\,] to short int $*$arg.
      }
   }
}
\sstmacro{
   WORD\_ARRAY\_ARG
}{
   Pass a WORD array argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a WORD array argument to a FORTRAN routine. The argument
      should be the address of a WORD array.
   }
   \sstinvocation{
      WORD\_ARRAY\_ARG(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The name of the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         WORD\_ARRAY\_ARG(arg)
      }{
         will expand as follows:
\begin{itemize}
            \sstbox{VAX/VMS:}  arg
            \sstbox{SunOS:}    arg
            \sstbox{Ultrix:}   arg
\end{itemize}
      }
   }
}

% CNF functions

\newpage

\section{CNF functions}
\label{cnf:description}

This is a description of the CNF functions. They are first classified by
function, and then the full description of each function is given.

\subsection{Classified List of CNF Functions}
\subsubsection{Import a FORTRAN string to C}

\noteroutine{
   cnf\_creib
}{
   Create a temporary C string and import a blank filled FORTRAN
   string into it
}
\noteroutine{
   cnf\_creim
}{
   Create a temporary C string and import a FORTRAN string into it
}
\noteroutine{
   cnf\_impb
}{
   Import a FORTRAN string into a C string, retaining trailing blanks
}
\noteroutine{
   cnf\_impbn
}{
   Import no more than max characters from a FORTRAN string into a C
   string, \\ \hspace*{3em} retaining trailing blanks
}
\noteroutine{
   cnf\_impn
}{
   Import no more than max characters from a FORTRAN string into a C
   string
}
\noteroutine{
   cnf\_imprt
}{
   Import a FORTRAN string into a C string
}

\subsubsection{Export a C string to FORTRAN}

\noteroutine{
   cnf\_expn
}{
   Export a C string to a FORTRAN string, copying given a maximum
   number of \\ \hspace*{3em} characters
}
\noteroutine{
   cnf\_exprt
}{
   Export a C string to a FORTRAN string
}

\subsubsection{String Lengths}

\noteroutine{
   cnf\_lenc
}{
   Find the length of a C string
}
\noteroutine{
   cnf\_lenf
}{
   Find the length of a FORTRAN string
}

\subsubsection{Miscellaneous}

\noteroutine{
   cnf\_copyf
}{
   Copy one FORTRAN string to another FORTRAN string
}
\noteroutine{
   cnf\_creat
}{
   Create a temporary C string and return a pointer to it
}
\noteroutine{
   cnf\_free
}{
   Return temporary space
}

%\newpage
\subsection{CNF Routine Descriptions}

\sstroutine{
   cnf\_copyf
}{
   Copy one FORTRAN string to another FORTRAN string
}{
   \sstdescription{
      The FORTRAN string in source\_f is copied to dest\_f.
      The destination string is filled with trailing blanks or
      truncated as necessary.
   }
   \sstinvocation{
      cnf\_copyf( source\_f, source\_len, dest\_f, dest\_len )
   }
   \sstarguments{
      \sstsubsection{
         char  $*$source\_f  (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int  source\_len  (Given)
      }{
         The length of the input FORTRAN string
      }
      \sstsubsection{
         char  $*$dest\_f  (Returned via pointer)
      }{
         A pointer to the output FORTRAN string
      }
      \sstsubsection{
         int  dest\_len  (Given)
      }{
         The length of the output FORTRAN string
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_creat
}{
   Create a temporary C string and return a pointer to it
}{
   \sstdescription{
      Create a temporary C string and return a pointer to it.
      The space allocated to the C string is `length{\tt '} characters and is
      initialized to the null string.
   }
   \sstinvocation{
      pointer = cnf\_creat( length )
   }
   \sstarguments{
      \sstsubsection{
         int length (Given)
      }{
         The length of the space to be allocated in characters.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         char $*$cnf\_creat
      }{
         A pointer to the storage that has been allocated by this routine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the argument is given as N then there is room to store N-1
            characters plus a trailing null character in a C string.

         \sstitem
         If the routine could not create the space, then it returns a
            null pointer.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_creib
}{
   Create a temporary C string and import a blank filled FORTRAN
   string into it
}{
   \sstdescription{
      Create a temporary C string, import a FORTRAN string into it,
      retaining trailing blanks and return a pointer to this C string.
      The length of the C string that is created is just long enough to
      hold the FORTRAN string (including any trailing blanks), plus the
      null terminator.
   }
   \sstinvocation{
      pointer = cnf\_creib( source\_f, source\_len )
   }
   \sstarguments{
      \sstsubsection{
         char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         char $*$cnf\_creib
      }{
         A pointer to the temporary storage location
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the routine could not create the space, then it returns a
            null pointer.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_creim
}{
   Create a temporary C string and import a FORTRAN string into it
}{
   \sstdescription{
      Create a temporary C string, import a FORTRAN string into it and
      return a pointer to this C string.
      Any trailing blanks in the FORTRAN string are discarded.
      The length of the C string that is created is just long enough to
      hold the FORTRAN string (less trailing blanks), plus the null
      terminator.
   }
   \sstinvocation{
      pointer = cnf\_creim( source\_f, source\_len )
   }
   \sstarguments{
      \sstsubsection{
         char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         char $*$cnf\_creim
      }{
         A pointer to the storage space allocated by this function.
      }
   }
   \sstnotes{
      If the routine could not create the space, then it returns a null
      pointer.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_expn
}{
   Export a C string to a FORTRAN string, copying given a maximum
   number of characters
}{
   \sstdescription{
      Export a C string to a FORTRAN string, copying a maximum of `max{\tt '}
      characters. If the C string is shorter than the space allocated
      to the FORTRAN string, then pad it with blanks, even if the
      whole source string was not copied as it had more than `max{\tt '}
      characters. If the C string is longer than the space allocated
      to the FORTRAN string, then truncate the string.
   }
   \sstinvocation{
      cnf\_expn( source\_c, max, dest\_f, dest\_len )
   }
   \sstarguments{
      \sstsubsection{
         char $*$source\_c (Given)
      }{
         A pointer to the input C string
      }
      \sstsubsection{
         int max (Given)
      }{
         The maximum number of character to be copied from source\_c to
         dest\_f
      }
      \sstsubsection{
         char $*$dest\_f (Returned via pointer)
      }{
         A pointer to the FORTRAN output string
      }
      \sstsubsection{
         int dest\_len (Given)
      }{
         The length of the FORTRAN output string
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_exprt
}{
   Export a C string to a FORTRAN string
}{
   \sstdescription{
      Export a C string to a FORTRAN string. If the C string is
      shorter than the space allocated to the FORTRAN string, then pad
      it with blanks. If the C string is longer than the space
      allocated to the FORTRAN string, then truncate the string.
   }
   \sstinvocation{
      cnf\_exprt( source\_c, dest\_f, dest\_len )
   }
   \sstarguments{
      \sstsubsection{
         char $*$source\_c (Given)
      }{
         A pointer to the input C string
      }
      \sstsubsection{
         char $*$dest\_f (Returned via pointer)
      }{
         A pointer to the output FORTRAN string
      }
      \sstsubsection{
         int dest\_len (Given)
      }{
         The length of the output FORTRAN string
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_free
}{
   Return temporary space
}{
   \sstdescription{
      Return temporary storage space that was allocated by a previous
      call to cnf\_creat, cnf\_creib or cnf\_creim.
   }
   \sstinvocation{
      cnf\_free( temp )
   }
   \sstarguments{
      \sstsubsection{
         char $*$temp (Given)
      }{
         A pointer to the storage to be deallocated.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The source code for this function is trivial, being merely a
            call to the C run-time library routine, free(). However, it is
            included for completeness.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_impb
}{
   Import a FORTRAN string into a C string, retaining trailing blanks
}{
   \sstdescription{
      Import a FORTRAN string into a C string retaining trailing blanks.
      The null character is appended to the C string after all of the
      blanks in the input string.
   }
   \sstinvocation{
      cnf\_impb( source\_f, source\_len, dest\_c )
   }
   \sstarguments{
      \sstsubsection{
         char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
      \sstsubsection{
         char $*$dest\_c (Returned via pointer)
      }{
         A pointer to the output C string
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         No check is made that there is sufficient space allocated to
            the C string to hold the FORTRAN string. It is the
            responsibility of the programmer to check this.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_impbn
}{
   Import no more than max characters from a FORTRAN string into a C
   string, retaining trailing blanks
}{
   \sstdescription{
      Import a FORTRAN string into a C string, up to a maximum of `max{\tt '}
      characters, retaining trailing blanks. The null character is
      appended to the C string after all of the blanks in the input
      string.
   }
   \sstinvocation{
      cnf\_impbn( source\_f, source\_len, max, dest\_c )
   }
   \sstarguments{
      \sstsubsection{
         char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
      \sstsubsection{
         int max (Given)
      }{
         The maximum number of characters to be copied from the input
         FORTRAN string to the output C string
      }
      \sstsubsection{
         char $*$dest\_c (Returned via pointer)
      }{
         A pointer to the output C string
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         No check is made that there is sufficient space allocated to
            the C string to hold the FORTRAN string. It is the
            responsibility of the programmer to check this.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_impn
}{
   Import no more than max characters from a FORTRAN string into a C
   string
}{
   \sstdescription{
      Import a FORTRAN string into a C string, up to a maximum of `max{\tt '}
      characters. The null character is appended to the C string after
      all of the blanks in the input string.
   }
   \sstinvocation{
      cnf\_impn( source\_f, source\_len, max, dest\_c )
   }
   \sstarguments{
      \sstsubsection{
         char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
      \sstsubsection{
         int max (Given)
      }{
         The maximum number of characters to be copied from the input
         FORTRAN string to the output C string
      }
      \sstsubsection{
         char $*$dest\_c (Returned via pointer)
      }{
         A pointer to the output C string
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         No check is made that there is sufficient space allocated to
            the C string to hold the FORTRAN string. It is the
            responsibility of the programmer to check this.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_imprt
}{
   Import a FORTRAN string into a C string
}{
   \sstdescription{
      Import a FORTRAN string into a C string, discarding trailing
      blanks. The null character is appended to the C string after all
      of the blanks in the input string.
   }
   \sstinvocation{
      cnf\_imprt( source\_f, source\_len, dest\_c )
   }
   \sstarguments{
      \sstsubsection{
         char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
      \sstsubsection{
         char $*$dest\_c (Returned via pointer)
      }{
         A pointer to the output C string
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         No check is made that there is sufficient space allocated to
            the C string to hold the FORTRAN string. It is the
            responsibility of the programmer to check this.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_lenc
}{
   Find the length of a C string
}{
   \sstdescription{
      Find the length (i.e. position of the last non blank character)
      in a C string.
   }
   \sstinvocation{
      result = cnf\_lenc( source\_c )
   }
   \sstarguments{
      \sstsubsection{
         char $*$source\_c (Given)
      }{
         A pointer to the input C string
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int cnf\_lenc
      }{
         The length of the input C string
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine follows the FORTRAN convention of counting
            positions from one, so with an input string of {\tt "}ABCD{\tt "} the
            value returned would be 4.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   cnf\_lenf
}{
   Find the length of a FORTRAN string
}{
   \sstdescription{
      Find the length (i.e. position of the last non blank character)
      in a FORTRAN string. This is not necessarily the same as the value
      of source\_len as trailing blanks are not counted.
   }
   \sstinvocation{
      result = cnf\_lenf( source\_f, source\_len )
   }
   \sstarguments{
      \sstsubsection{
         char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length (including trailing blanks) of the input FORTRAN
         string
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int cnf\_lenf
      }{
         The length (excluding trailing blanks) of the input FORTRAN
         string.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine follows the FORTRAN convention of counting
            positions from one, so with an input string of {\tt "}ABCD{\tt "} the
            value returned would be 4.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}

\newpage
\section{References}

\begin{thebibliography}{9}
\bibitem{fortran:std}American National Standard -- Programming Language --
FORTRAN (ANSI X3.9-1978, ISO 1539-1980(E)). Publ, American National Standards
Institute.
\bibitem{c:std}American National Standard for Information Systems --
Programming Language -- C (ANSI X3.159-1989). Publ, American National Standards
Institute.
%\bibitem{psx:std}IEEE Standard Portable Operating System Interface for Computer
%Environments (IEEE Std 1003.1-1988). Publ, Institute of Electrical and
%Electronic Engineers, Inc.
\bibitem{Banahan}Banahan, M.F., 1988. The C Book: featuring the draft ANSI C
standard. Publ, Addison-Wesley.
\end{thebibliography}

\end{document}
